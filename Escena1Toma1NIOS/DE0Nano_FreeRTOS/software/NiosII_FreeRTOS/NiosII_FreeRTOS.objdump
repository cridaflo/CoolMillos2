
NiosII_FreeRTOS.elf:     file format elf32-littlenios2
NiosII_FreeRTOS.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x02000250

Program Header:
    LOAD off    0x00001020 vaddr 0x02000020 paddr 0x02000020 align 2**12
         filesz 0x00014300 memsz 0x008147c4 flags rwx
    LOAD off    0x00016000 vaddr 0x04001000 paddr 0x04001000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  04001000  04001000  00016000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000230  02000020  02000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00011f6c  02000250  02000250  00001250  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000350  020121bc  020121bc  000131bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001e14  0201250c  0201250c  0001350c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0080056e  02014320  02014320  00015320  2**2
                  ALLOC, SMALL_DATA
  6 .sdram        00000000  028147e4  028147e4  00016000  2**0
                  CONTENTS
  7 .epcs         00000000  04001020  04001020  00016000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00016000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000e98  00000000  00000000  00016028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0001f5ec  00000000  00000000  00016ec0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000899e  00000000  00000000  000364ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000b63c  00000000  00000000  0003ee4a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000038f4  00000000  00000000  0004a488  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000057eb  00000000  00000000  0004dd7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    000079db  00000000  00000000  00053567  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0005af44  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000af0  00000000  00000000  0005af88  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  00061616  2**0
                  CONTENTS, READONLY
 19 .cpu          00000003  00000000  00000000  00061619  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0006161c  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0006161d  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0006161e  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00061622  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00061626  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   00000004  00000000  00000000  0006162a  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    00000004  00000000  00000000  0006162e  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   00000004  00000000  00000000  00061632  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000006  00000000  00000000  00061636  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000032  00000000  00000000  0006163c  2**0
                  CONTENTS, READONLY
 30 .jdi          0000363b  00000000  00000000  0006166e  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     000848c0  00000000  00000000  00064ca9  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04001000 l    d  .entry	00000000 .entry
02000020 l    d  .exceptions	00000000 .exceptions
02000250 l    d  .text	00000000 .text
020121bc l    d  .rodata	00000000 .rodata
0201250c l    d  .rwdata	00000000 .rwdata
02014320 l    d  .bss	00000000 .bss
028147e4 l    d  .sdram	00000000 .sdram
04001020 l    d  .epcs	00000000 .epcs
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../NiosII_FreeRTOS_bsp//obj/HAL/src/crt0.o
02000284 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 obj/default/FreeRTOS/Source/portable/GCC/NiosII/port_asm.o
02000020 l       .exceptions	00000000 save_context
0200009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
020000ac l       .exceptions	00000000 hw_irq_test
02000150 l       .exceptions	00000000 soft_exceptions
020000c0 l       .exceptions	00000000 hw_irq_handler
020000d4 l       .exceptions	00000000 restore_context
0200016c l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 BlockQ.c
02014320 l     O .bss	00000006 sBlockingConsumerCount
02014326 l     O .bss	00000006 sBlockingProducerCount
02000598 l     F .text	000000a4 vBlockingQueueConsumer
0200050c l     F .text	0000008c vBlockingQueueProducer
0201432c l     O .bss	00000006 sLastBlockingConsumerCount.2714
02014332 l     O .bss	00000006 sLastBlockingProducerCount.2715
00000000 l    df *ABS*	00000000 GenQTest.c
02014338 l     O .bss	00000004 xErrorDetected
0201433c l     O .bss	00000004 ulLoopCounter
02014340 l     O .bss	00000004 ulLoopCounter2
02014344 l     O .bss	00000004 ulGuardedVariable
02014348 l     O .bss	00000004 xHighPriorityMutexTask
0201434c l     O .bss	00000004 xMediumPriorityMutexTask
02000864 l     F .text	00000464 prvSendFrontAndBackTest
02000fcc l     F .text	0000005c prvLowPriorityMutexTask
02001028 l     F .text	0000002c prvMediumPriorityMutexTask
02001054 l     F .text	00000070 prvHighPriorityMutexTask
02000cc8 l     F .text	0000019c prvTakeTwoMutexesReturnInDifferentOrder
02000e64 l     F .text	00000168 prvTakeTwoMutexesReturnInSameOrder
02014350 l     O .bss	00000004 ulLastLoopCounter.2739
02014354 l     O .bss	00000004 ulLastLoopCounter2.2740
00000000 l    df *ABS*	00000000 PollQ.c
02014358 l     O .bss	00000004 xPollingConsumerCount
0201435c l     O .bss	00000004 xPollingProducerCount
02014360 l     O .bss	00000004 xPolledQueue.2681
02001260 l     F .text	000000b4 vPolledQueueConsumer
020011bc l     F .text	000000a4 vPolledQueueProducer
00000000 l    df *ABS*	00000000 QPeek.c
02014364 l     O .bss	00000004 xErrorDetected
02014368 l     O .bss	00000004 ulLoopCounter
02001700 l     F .text	0000016c prvLowPriorityPeekTask
02001674 l     F .text	0000008c prvMediumPriorityPeekTask
020015ac l     F .text	000000c8 prvHighPriorityPeekTask
02001448 l     F .text	00000164 prvHighestPriorityPeekTask
0201436c l     O .bss	00000004 ulLastLoopCounter.2717
00000000 l    df *ABS*	00000000 blocktim.c
0201437c l     O .bss	00000004 xTestQueue
02014380 l     O .bss	00000004 xSecondary
02014384 l     O .bss	00000004 xPrimaryCycles
02014388 l     O .bss	00000004 xSecondaryCycles
0201438c l     O .bss	00000004 xErrorOccurred
02014390 l     O .bss	00000004 xRunIndicator
02001948 l     F .text	00000428 vPrimaryBlockTimeTestTask
02001d70 l     F .text	00000130 vSecondaryBlockTimeTestTask
02001ea0 l     F .text	0000011c prvBasicDelayTests
02014394 l     O .bss	00000004 xLastPrimaryCycleCount.2330
02014398 l     O .bss	00000004 xLastSecondaryCycleCount.2331
00000000 l    df *ABS*	00000000 comtest.c
0201439c l     O .bss	00000004 xPort
020143a0 l     O .bss	00000004 uxBaseLED
020143a4 l     O .bss	00000004 uxRxLoops
020020c0 l     F .text	000000b4 vComTxTask
02002174 l     F .text	00000118 vComRxTask
00000000 l    df *ABS*	00000000 countsem.c
020143a8 l     O .bss	00000004 xErrorDetected
020144f4 l     O .bss	00000018 xParameters
0200256c l     F .text	000000b0 prvCountingSemaphoreTask
020023cc l     F .text	000000d0 prvDecrementSemaphoreCount
0200249c l     F .text	000000d0 prvIncrementSemaphoreCount
020143ac l     O .bss	00000004 uxLastCount0.2295
020143b0 l     O .bss	00000004 uxLastCount1.2296
00000000 l    df *ABS*	00000000 death.c
020143b4 l     O .bss	00000002 usCreationCount
020143b8 l     O .bss	00000004 uxTasksRunningAtStart
0201429c l     O .rwdata	00000004 uxMaxNumberOfExtraTasksRunning
0200279c l     F .text	00000098 vCreateTasks
02002710 l     F .text	0000008c vSuicidalTask
020142a0 l     O .rwdata	00000002 usLastCreationCount.2594
020143bc l     O .bss	00000004 uxTasksRunningNow.2596
00000000 l    df *ABS*	00000000 dynamic.c
020143c4 l     O .bss	00000004 xContinuousIncrementHandle
020143c8 l     O .bss	00000004 xLimitedIncrementHandle
020143cc l     O .bss	00000004 ulCounter
020143d0 l     O .bss	00000002 usCheckVariable
020143d4 l     O .bss	00000004 xSuspendedQueueSendError
020143d8 l     O .bss	00000004 xSuspendedQueueReceiveError
020143dc l     O .bss	00000004 ulExpectedValue
02002a14 l     F .text	00000060 vContinuousIncrementTask
020029c0 l     F .text	00000054 vLimitedIncrementTask
02002a74 l     F .text	000000dc vCounterControlTask
02002b50 l     F .text	0000005c vQueueSendWhenSuspendedTask
02002bac l     F .text	00000088 vQueueReceiveWhenSuspendedTask
020143e0 l     O .bss	00000004 ulValueToSend.2718
020143e4 l     O .bss	00000002 usLastTaskCheck.2731
020143e8 l     O .bss	00000004 ulLastExpectedValue.2732
00000000 l    df *ABS*	00000000 flash.c
020143f0 l     O .bss	00000004 uxFlashTaskNumber
02002d28 l     F .text	00000090 vLEDFlashTask
00000000 l    df *ABS*	00000000 integer.c
020143f4 l     O .bss	00000004 xTaskCheck
02002e3c l     F .text	0000009c vCompeteingIntMathTask
00000000 l    df *ABS*	00000000 recmutex.c
020143f8 l     O .bss	00000004 xMutex
020143fc l     O .bss	00000004 xErrorOccurred
02014400 l     O .bss	00000004 xControllingIsSuspended
02014404 l     O .bss	00000004 xBlockingIsSuspended
02014408 l     O .bss	00000004 uxControllingCycles
0201440c l     O .bss	00000004 uxBlockingCycles
02014410 l     O .bss	00000004 uxPollingCycles
02014414 l     O .bss	00000004 xControllingTaskHandle
02014418 l     O .bss	00000004 xBlockingTaskHandle
0200300c l     F .text	000000fc prvRecursiveMutexControllingTask
02003108 l     F .text	000000a8 prvRecursiveMutexBlockingTask
020031b0 l     F .text	000000b4 prvRecursiveMutexPollingTask
0201441c l     O .bss	00000004 uxLastControllingCycles.2294
02014420 l     O .bss	00000004 uxLastBlockingCycles.2295
02014424 l     O .bss	00000004 uxLastPollingCycles.2296
00000000 l    df *ABS*	00000000 semtest.c
02014428 l     O .bss	00000008 sCheckVariables
02014430 l     O .bss	00000002 sNextCheckVariable
020034d8 l     F .text	0000018c prvSemaphoreTest
02014432 l     O .bss	00000008 sLastCheckVariables.2704
00000000 l    df *ABS*	00000000 ParTest.c
0201443c l     O .bss	00000004 ulLedStates
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
02003c4c l     F .text	000000a4 prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_2.c
0201450c l     O .bss	00800000 ucHeap
020142a4 l     O .rwdata	00000002 heapSTRUCT_SIZE
02014440 l     O .bss	00000008 xStart
02014448 l     O .bss	00000008 xEnd
020142a8 l     O .rwdata	00000004 xFreeBytesRemaining
02014450 l     O .bss	00000004 xHeapHasBeenInitialised.2579
02004264 l     F .text	00000074 prvHeapInit
00000000 l    df *ABS*	00000000 queue.c
020044a4 l     F .text	00000084 prvInitialiseNewQueue
02004528 l     F .text	00000060 prvInitialiseMutex
02004f7c l     F .text	0000018c prvCopyDataToQueue
02005328 l     F .text	00000058 prvIsQueueFull
020051a4 l     F .text	000000f4 prvUnlockQueue
02005108 l     F .text	0000009c prvCopyDataFromQueue
02005298 l     F .text	00000050 prvIsQueueEmpty
00000000 l    df *ABS*	00000000 tasks.c
0281450c l     O .bss	00000064 pxReadyTasksLists
02814570 l     O .bss	00000014 xDelayedTaskList1
02814584 l     O .bss	00000014 xDelayedTaskList2
02014458 l     O .bss	00000004 pxDelayedTaskList
0201445c l     O .bss	00000004 pxOverflowDelayedTaskList
02814598 l     O .bss	00000014 xPendingReadyList
028145ac l     O .bss	00000014 xTasksWaitingTermination
02014460 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
028145c0 l     O .bss	00000014 xSuspendedTaskList
02014464 l     O .bss	00000004 uxCurrentNumberOfTasks
02014468 l     O .bss	00000004 xTickCount
0201446c l     O .bss	00000004 uxTopReadyPriority
02014470 l     O .bss	00000004 xSchedulerRunning
02014474 l     O .bss	00000004 uxPendedTicks
02014478 l     O .bss	00000004 xYieldPending
0201447c l     O .bss	00000004 xNumOfOverflows
02014480 l     O .bss	00000004 uxTaskNumber
02014484 l     O .bss	00000004 xNextTaskUnblockTime
02014488 l     O .bss	00000004 xIdleTaskHandle
0201448c l     O .bss	00000004 uxSchedulerSuspended
020054b0 l     F .text	000001d0 prvInitialiseNewTask
02005680 l     F .text	00000108 prvAddNewTaskToReadyList
02006954 l     F .text	000000c0 prvInitialiseTaskLists
02006b80 l     F .text	00000044 prvDeleteTCB
02006bc4 l     F .text	00000068 prvResetNextTaskUnblockTime
020076bc l     F .text	000000e8 prvAddCurrentTaskToDelayedList
02005d14 l     F .text	00000094 prvTaskIsTaskSuspended
02006938 l     F .text	0000001c prvIdleTask
02006a14 l     F .text	000000a8 prvCheckTasksWaitingTermination
02006abc l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 max7219.c
00000000 l    df *ABS*	00000000 serial.c
02014490 l     O .bss	00000004 xRxedChars
02014494 l     O .bss	00000004 xCharsForTx
02007d74 l     F .text	00000074 vUARTInterruptHandler
02007de8 l     F .text	000000a4 vUARTReceiveHandler
02007e8c l     F .text	000000a0 vUARTTransmitHandler
00000000 l    df *ABS*	00000000 hello_world.c
020144b4 l     O .bss	00000004 xRxedChars
02008174 l     F .text	000004bc TaskRegleta
02008630 l     F .text	00000104 TaskSensoresLinea
02008734 l     F .text	00000338 TaskActualizarMatriz
02008a6c l     F .text	00000080 TaskParada
02008aec l     F .text	0000008c TaskRESET
02008b78 l     F .text	00000198 TaskLEDS
0200989c l     F .text	00000060 vUARTInterruptHandler
020098fc l     F .text	000000a4 vUARTReceiveHandler
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 itoa.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strcat.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 utoa.c
00000000 l    df *ABS*	00000000 findfp.c
0200b584 l     F .text	00000008 __fp_unlock
0200b598 l     F .text	0000019c __sinit.part.1
0200b734 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
0201250c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 alt_close.c
0200ddd8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
0200deec l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0200df18 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
0200e1bc l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
0200e2a4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
0200e480 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0201430c l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0200e724 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0200e860 l     F .text	00000034 alt_dev_reg
02012ee0 l     O .rwdata	000000cc epcs
02012fac l     O .rwdata	00001060 jtag
0201400c l     O .rwdata	000000c4 uart
020140d0 l     O .rwdata	000000c4 uart_2
02014194 l     O .rwdata	0000002c IO_Pio
020141c0 l     O .rwdata	0000002c IO_Pio1
020141ec l     O .rwdata	0000002c KEYS
02014218 l     O .rwdata	0000002c LED_Pio
02014244 l     O .rwdata	0000002c parallel_port_0
02014270 l     O .rwdata	0000002c parallel_port_1
00000000 l    df *ABS*	00000000 altera_avalon_epcs_flash_controller.c
0200e9d8 l     F .text	00000034 alt_flash_device_register
0200ea60 l     F .text	000003f8 alt_epcs_flash_query
0200ee58 l     F .text	000000ec alt_epcs_flash_memcmp
0200f230 l     F .text	00000094 alt_epcs_test_address
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0200f6f8 l     F .text	0000020c altera_avalon_jtag_uart_irq
0200f904 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0200ff3c l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_vars.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
020101ec l     F .text	0000009c altera_avalon_uart_irq
02010288 l     F .text	000000e4 altera_avalon_uart_rxirq
0201036c l     F .text	00000148 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
02010508 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
02010720 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 epcs_commands.c
02010964 l     F .text	00000038 epcs_test_wip
0201099c l     F .text	0000003c epcs_await_wip_released
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
020111c8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
02011424 l     F .text	000000e4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
02011584 l     F .text	0000003c alt_get_errno
020115c0 l     F .text	000000ec alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
0200f1a4 g     F .text	0000008c alt_epcs_flash_get_info
02000288 g     F .text	00000284 vStartBlockingQueueTasks
0200dd84 g     F .text	00000054 _isatty_r
0200e3bc g     F .text	0000007c alt_main
0200b300 g     F .text	00000090 strcpy
0200b1a8 g     F .text	000000c0 _puts_r
028146e4 g     O .bss	00000100 alt_irq
020142c8 g     O .rwdata	00000001 dobleA
0200daac g     F .text	00000060 _lseek_r
020000c4 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
020065b0 g     F .text	00000064 vTaskPlaceOnUnorderedEventList
02004224 g     F .text	00000020 xPortGetFreeHeapSize
028147e4 g       *ABS*	00000000 __alt_heap_start
020059bc g     F .text	00000058 uxTaskPriorityGet
0200186c g     F .text	00000044 xAreQueuePeekTasksStillRunning
028145fc g     O .bss	00000020 sensor_values
0200d060 g     F .text	0000005c __sseek
0200b8e4 g     F .text	00000010 __sinit
0200b73c g     F .text	00000078 __sfmoreglue
0200e45c g     F .text	00000024 __malloc_unlock
020010c4 g     F .text	00000060 xAreGenericQueueTasksStillRunning
020144e8 g     O .bss	00000004 altera_avalon_timer_ts_freq
0200c874 g     F .text	0000015c memmove
02001fbc g     F .text	00000068 xAreBlockTimeTestTasksStillRunning
02006ea4 g     F .text	00000054 vTaskEnterCritical
0200b8cc g     F .text	00000018 _cleanup
02004924 g     F .text	000000e8 xQueueGenericSendFromISR
02006248 g     F .text	00000040 pcTaskGetName
02007828 g     F .text	00000044 Outputlow_clk
020142c0 g     O .rwdata	00000004 velocidadMaxima
020119ac g     F .text	00000024 altera_nios2_gen2_irq_init
020109d8 g     F .text	000000fc epcs_sector_erase
04001000 g     F .entry	00000000 __reset
020045e4 g     F .text	00000090 xQueueGiveMutexRecursive
02002f54 g     F .text	000000b8 vStartRecursiveMutexTasks
02014454 g     O .bss	00000004 pxCurrentTCB
020078f0 g     F .text	00000040 OutputHigh_cs
0200dd28 g     F .text	0000005c _fstat_r
020144d0 g     O .bss	00000004 errno
0200cfdc g     F .text	00000008 __seofread
02008d10 g     F .text	00000288 calcularError
020144dc g     O .bss	00000004 alt_argv
0201c29c g       *ABS*	00000000 _gp
0200e6f4 g     F .text	00000030 usleep
02005a60 g     F .text	000001d4 vTaskPrioritySet
020077e4 g     F .text	00000044 Outputlow_Din
02012d60 g     O .rwdata	00000180 alt_fd_list
0200228c g     F .text	0000003c xAreComTestTasksStillRunning
02003bf4 g     F .text	00000038 xPortStartScheduler
02010c1c g     F .text	0000006c epcs_write_status_register
02005ffc g     F .text	00000048 vTaskEndScheduler
02011bcc g     F .text	00000090 alt_find_dev
0281461c g     O .bss	000000c8 ColoresEncontrados
020144a4 g     O .bss	00000004 errorPasado
0200af38 g     F .text	00000148 memcpy
02006560 g     F .text	00000050 vTaskPlaceOnEventList
02003264 g     F .text	0000009c xAreRecursiveMutexTasksStillRunning
0200b58c g     F .text	0000000c _cleanup_r
0200ad8c g     F .text	000000dc .hidden __floatsidf
02007930 g     F .text	00000050 max7219_int
02014370 g     O .bss	00000004 xHighPriorityTask
020077a4 g     F .text	00000040 OutputHigh_Din
02011508 g     F .text	0000007c alt_io_redirect
02004e00 g     F .text	0000007c xQueuePeekFromISR
020144ba g     O .bss	00000001 izq
020121bc g       *ABS*	00000000 __DTOR_END__
0200b268 g     F .text	00000014 puts
02004158 g     F .text	000000cc vPortFree
0200f33c g     F .text	00000100 alt_epcs_flash_write_block
0200fafc g     F .text	0000021c altera_avalon_jtag_uart_read
02009b10 g     F .text	00000064 .hidden __udivsi3
02002cb4 g     F .text	00000074 vStartLEDFlashTasks
0200e1f8 g     F .text	000000ac isatty
020078ac g     F .text	00000044 Outputlow_cs
02014374 g     O .bss	00000004 xMediumPriorityTask
020144b0 g     O .bss	00000004 xSemaphore
02006b20 g     F .text	00000060 uxTaskGetStackHighWaterMark
0201449c g     O .bss	00000004 portlog
020038f0 g     F .text	0000008c vListInsertEnd
020142d4 g     O .rwdata	00000004 PWM_izq
020144cc g     O .bss	00000004 __malloc_top_pad
020144a8 g     O .bss	00000004 vecesLineaNegra
0200af34 g     F .text	00000004 itoa
020028bc g     F .text	00000104 vStartDynamicPriorityTasks
0200b934 g     F .text	000004c8 __sfvwrite_r
02007bb8 g     F .text	00000024 vSerialClose
0200cf34 g     F .text	00000054 _sbrk_r
02005e80 g     F .text	000000ec xTaskResumeFromISR
020142ad g     O .rwdata	00000001 FALSO
0200dcc8 g     F .text	00000060 _read_r
020038c4 g     F .text	0000002c vListInitialiseItem
020037f0 g     F .text	0000006c vParTestToggleLED
02014300 g     O .rwdata	00000004 alt_max_fd
02003cf0 g     F .text	00000044 vPortSysTickHandler
0200d2cc g     F .text	000000f0 _fclose_r
0200d648 g     F .text	00000030 fflush
020144c8 g     O .bss	00000004 __malloc_max_sbrked_mem
020142c9 g     O .rwdata	00000001 doble5
02005a14 g     F .text	0000004c uxTaskPriorityGetFromISR
02003d34 g     F .text	00000170 alt_irq_register
02003750 g     F .text	000000a0 vParTestSetLED
02009bf4 g     F .text	000008ac .hidden __adddf3
0200f2c4 g     F .text	00000078 alt_epcs_flash_erase_block
0200e2e0 g     F .text	000000dc lseek
020144b9 g     O .bss	00000001 lecturaPixyFinalizada
020142e0 g     O .rwdata	00000004 _global_impure_ptr
02010ee8 g     F .text	0000005c epcs_exit_4_bytes_mode
020142d0 g     O .rwdata	00000004 lineasDerecha
0200c9d0 g     F .text	00000564 _realloc_r
028147e4 g       *ABS*	00000000 __bss_end
02003ea4 g     F .text	000000e0 alt_iic_isr_register
0200063c g     F .text	00000128 xAreBlockingQueuesStillRunning
020118a4 g     F .text	00000108 alt_tick
02003f84 g     F .text	000001d4 pvPortMalloc
02010140 g     F .text	000000ac altera_avalon_uart_init
02001314 g     F .text	00000048 xArePollingQueuesStillRunning
0200b904 g     F .text	00000018 __fp_lock_all
0200e170 g     F .text	0000004c alt_ic_irq_enabled
02004f40 g     F .text	0000003c vQueueDelete
02003c2c g     F .text	00000020 vPortEndScheduler
0200385c g     F .text	00000068 vListInitialise
02011808 g     F .text	0000009c alt_alarm_stop
020144d4 g     O .bss	00000004 alt_irq_active
0200017c g     F .exceptions	000000d4 alt_irq_handler
02012d38 g     O .rwdata	00000028 alt_dev_null
020061d4 g     F .text	00000028 xTaskGetTickCount
02004770 g     F .text	000001b4 xQueueGenericSend
02000764 g     F .text	00000100 vStartGenericQueueTasks
0200b580 g     F .text	00000004 utoa
0200ad0c g     F .text	00000080 .hidden __fixdfsi
0200261c g     F .text	0000008c xAreCountingSemaphoreTasksStillRunning
02006d9c g     F .text	00000108 xTaskPriorityDisinherit
020142f8 g     O .rwdata	00000008 alt_dev_list
0200e760 g     F .text	00000100 write
02006614 g     F .text	00000100 xTaskRemoveFromEventList
0200df54 g     F .text	000000b8 fstat
0200b27c g     F .text	00000084 strcat
02007ce8 g     F .text	0000008c vSerialPutString
02009550 g     F .text	0000034c analizarPixy
02007c54 g     F .text	00000094 xSerialPutChar
02009b74 g     F .text	00000058 .hidden __umodsi3
02010da4 g     F .text	00000068 epcs_read_electronic_signature
028147e4 g       *ABS*	00000000 end
02005788 g     F .text	000000e8 vTaskDelete
02002834 g     F .text	00000088 xIsCreateTaskStillRunning
0200aecc g     F .text	00000068 __itoa
0201075c g     F .text	000001ac altera_avalon_uart_write
0200f638 g     F .text	000000c0 altera_avalon_jtag_uart_init
02006f9c g     F .text	00000038 pvTaskIncrementMutexHeldCount
020121bc g       *ABS*	00000000 __CTOR_LIST__
020142d8 g     O .rwdata	00000004 PWM_der
04000000 g       *ABS*	00000000 __alt_stack_pointer
0200ffb4 g     F .text	0000007c alt_avalon_timer_sc_init
02010090 g     F .text	00000060 altera_avalon_uart_write_fd
0200ae68 g     F .text	00000064 .hidden __clzsi2
020100f0 g     F .text	00000050 altera_avalon_uart_close_fd
0200fd18 g     F .text	00000224 altera_avalon_jtag_uart_write
0200b8f4 g     F .text	00000004 __sfp_lock_acquire
0200c790 g     F .text	000000e4 memchr
02006834 g     F .text	000000dc xTaskCheckForTimeOut
0200d79c g     F .text	00000310 _free_r
02012008 g     F .text	00000180 __call_exitprocs
02002024 g     F .text	0000009c vAltStartComTestTasks
02006fd4 g     F .text	000000b0 ulTaskNotifyTake
020144ad g     O .bss	00000001 detenerse
020142e8 g     O .rwdata	00000004 __malloc_sbrk_base
02000250 g     F .text	00000038 _start
020144ec g     O .bss	00000004 _alt_tick_rate
02006044 g     F .text	0000002c vTaskSuspendAll
020061fc g     F .text	0000002c xTaskGetTickCountFromISR
020119d0 g     F .text	000001fc alt_avalon_spi_command
020144f0 g     O .bss	00000004 _alt_nticks
0200e4bc g     F .text	00000104 read
0200e8cc g     F .text	0000010c alt_sys_init
02003a54 g     F .text	00000098 uxListRemove
02011ef0 g     F .text	00000118 __register_exitproc
020142cc g     O .rwdata	00000004 lineasIzquierda
0200f9a4 g     F .text	00000068 altera_avalon_jtag_uart_close
02006c54 g     F .text	00000148 vTaskPriorityInherit
02009bcc g     F .text	00000028 .hidden __mulsi3
028145d4 g     O .bss	00000028 __malloc_current_mallinfo
02007644 g     F .text	00000078 xTaskNotifyStateClear
02005da8 g     F .text	000000d8 vTaskResume
02006468 g     F .text	000000f8 vTaskSwitchContext
02010908 g     F .text	0000005c epcs_read_status_register
0200f4d4 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
02011d64 g     F .text	000000c4 alt_get_fd
02011070 g     F .text	00000158 alt_busy_sleep
0200d278 g     F .text	00000054 _close_r
02008f98 g     F .text	000005b8 escribirXBee
020099a0 g     F .text	00000078 obtenerChar
02007084 g     F .text	000000f4 xTaskNotifyWait
020079fc g     F .text	00000104 sen_2_byte_info
02010e0c g     F .text	00000080 epcs_read_device_id
02011e74 g     F .text	0000007c memcmp
0200f594 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
028147e4 g       *ABS*	00000000 __alt_stack_base
0200f5e4 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
020144a1 g     O .bss	00000001 dobleLineaRegleta
0200d124 g     F .text	00000154 __swsetup_r
02005c34 g     F .text	000000e0 vTaskSuspend
0200b7b4 g     F .text	00000118 __sfp
02006228 g     F .text	00000020 uxTaskGetNumberOfTasks
02012930 g     O .rwdata	00000408 __malloc_av_
0200b900 g     F .text	00000004 __sinit_lock_release
020122fc g     O .rodata	00000009 numeros
0200a4a0 g     F .text	0000086c .hidden __muldf3
0200cf88 g     F .text	00000054 __sread
02011c5c g     F .text	00000108 alt_find_file
02011204 g     F .text	000000a4 alt_dev_llist_insert
0200e438 g     F .text	00000024 __malloc_lock
0200e644 g     F .text	000000b0 sbrk
02004674 g     F .text	000000a4 xQueueTakeMutexRecursive
0200d5ec g     F .text	0000005c _fflush_r
02014378 g     O .bss	00000004 xHighestPriorityTask
02014310 g     O .rwdata	00000008 alt_flash_dev_list
0200b428 g     F .text	00000158 __utoa
02007178 g     F .text	000001b0 xTaskGenericNotify
02014320 g       *ABS*	00000000 __bss_start
0200b080 g     F .text	00000128 memset
02007f2c g     F .text	00000248 main
020144e0 g     O .bss	00000004 alt_envp
020018b0 g     F .text	00000098 vCreateBlockTimeTasks
020144c4 g     O .bss	00000004 __malloc_max_total_mem
0200f534 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0200786c g     F .text	00000040 OutputHigh_clk
0200397c g     F .text	000000d8 vListInsert
0200d0bc g     F .text	00000008 __sclose
04000000 g       *ABS*	00000000 __alt_heap_limit
0200d3bc g     F .text	00000014 fclose
0200bf84 g     F .text	0000080c _malloc_r
02014304 g     O .rwdata	00000004 alt_errno
02005870 g     F .text	000000f0 vTaskDelayUntil
020144b8 g     O .bss	00000001 envioXbeeFinalizado
02003664 g     F .text	000000b8 xAreSemaphoreTasksStillRunning
0200bdfc g     F .text	000000c4 _fwalk
02004d1c g     F .text	000000e4 xQueueReceiveFromISR
020142b8 g     O .rwdata	00000008 Kd
02006c2c g     F .text	00000028 xTaskGetCurrentTaskHandle
02009a18 g     F .text	00000084 .hidden __divsi3
02004404 g     F .text	000000a0 xQueueGenericCreate
0200d678 g     F .text	00000124 _malloc_trim_r
020121bc g       *ABS*	00000000 __CTOR_END__
0200ef44 g     F .text	00000260 alt_epcs_flash_write
020142ac g     O .rwdata	00000001 VERDADERO
02004718 g     F .text	00000058 xQueueCreateCountingSemaphore
020121bc g       *ABS*	00000000 __DTOR_LIST__
020143c0 g     O .bss	00000004 xCreatedTask
02007328 g     F .text	000001ec xTaskGenericNotifyFromISR
0200e894 g     F .text	00000038 alt_irq_init
02002db8 g     F .text	00000084 vStartIntegerMathTasks
02006714 g     F .text	000000e4 xTaskRemoveFromUnorderedEventList
0200e5c0 g     F .text	00000084 alt_release_fd
02006070 g     F .text	00000164 xTaskResumeAll
02004ebc g     F .text	00000054 uxQueueSpacesAvailable
02012352 g     O .rodata	00000100 .hidden __clz_tab
02005f6c g     F .text	00000090 vTaskStartScheduler
02011e28 g     F .text	00000014 atexit
0200d0c4 g     F .text	00000060 _write_r
02003aec g     F .text	00000028 prvReadGp
020144ac g     O .bss	00000001 desactivarMotores
02005380 g     F .text	00000048 xQueueIsQueueFullFromISR
0200135c g     F .text	000000ec vStartQueuePeekTasks
020142e4 g     O .rwdata	00000004 _impure_ptr
020144d8 g     O .bss	00000004 alt_argc
0200d3d0 g     F .text	0000021c __sflush_r
02007bdc g     F .text	00000078 xSerialGetChar
020144e4 g     O .bss	00000004 altera_avalon_timer_ts_base
02011308 g     F .text	00000060 _do_dtors
02002ed8 g     F .text	0000007c xAreIntegerMathsTaskStillRunning
02001124 g     F .text	00000098 vStartPolledQueueTasks
020022c8 g     F .text	00000104 vStartCountingSemaphoreTasks
0200371c g     F .text	00000034 vParTestInitialise
0200b91c g     F .text	00000018 __fp_unlock_all
02006910 g     F .text	00000028 vTaskMissedYield
020142f0 g     O .rwdata	00000008 alt_fs_list
020144bb g     O .bss	00000001 der
020142c4 g     O .rwdata	00000004 velocidadBase
02004e7c g     F .text	00000040 uxQueueMessagesWaiting
02004ae8 g     F .text	00000234 xQueueGenericReceive
02006288 g     F .text	000001e0 xTaskIncrementTick
02010ad4 g     F .text	000000f4 epcs_read_buffer
0200ea0c g     F .text	00000054 alt_epcs_flash_init
0200e00c g     F .text	00000050 alt_ic_isr_register
020142b0 g     O .rwdata	00000008 Kp
020042d8 g     F .text	0000012c xQueueGenericReset
02014320 g       *ABS*	00000000 _edata
020026a8 g     F .text	00000068 vCreateSuicidalTasks
02010030 g     F .text	00000060 altera_avalon_uart_read_fd
028147e4 g       *ABS*	00000000 _end
02011368 g     F .text	00000068 alt_flash_open_dev
0200fa0c g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
020053c8 g     F .text	000000e8 xTaskCreate
02014498 g     O .bss	00000004 uartControl
02004244 g     F .text	00000020 vPortInitialiseBlocks
0200e0e4 g     F .text	0000008c alt_ic_irq_disable
02010e8c g     F .text	0000005c epcs_enter_4_bytes_mode
0200cfe4 g     F .text	0000007c __swrite
020142ec g     O .rwdata	00000004 __malloc_trim_threshold
02011e3c g     F .text	00000038 exit
0200bec0 g     F .text	000000c4 _fwalk_reent
020113d0 g     F .text	00000054 alt_flash_close_dev
02009a9c g     F .text	00000074 .hidden __modsi3
02005960 g     F .text	0000005c vTaskDelay
04000000 g       *ABS*	00000000 __alt_data_end
0200b8f8 g     F .text	00000004 __sfp_lock_release
02000000 g       *ABS*	00000000 __alt_mem_sdram
020143ec g     O .bss	00000004 xSuspendedTestQueue
020104b4 g     F .text	00000054 altera_avalon_uart_close
02007980 g     F .text	0000007c max7219_senbit
02012188 g     F .text	00000034 _exit
02010f44 g     F .text	0000012c alt_alarm_start
0200db0c g     F .text	000001bc __smakebuf_r
02006ef8 g     F .text	00000060 vTaskExitCritical
020144a0 g     O .bss	00000001 dobleLinea
02002c34 g     F .text	00000080 xAreDynamicPriorityTasksStillRunning
0200b390 g     F .text	00000098 strlen
02010bc8 g     F .text	00000054 epcs_write_enable
02003b14 g     F .text	000000e0 pxPortInitialiseStack
020116ac g     F .text	0000015c open
020142dc g     O .rwdata	00000004 uxQueueLength
020067f8 g     F .text	0000003c vTaskSetTimeOutState
02014308 g     O .rwdata	00000004 alt_priority_mask
0200e05c g     F .text	00000088 alt_ic_irq_enable
04001000 g       *ABS*	00000000 __alt_mem_epcs
02010544 g     F .text	000001dc altera_avalon_uart_read
02004f10 g     F .text	00000030 uxQueueMessagesWaitingFromISR
020052e8 g     F .text	00000040 xQueueIsQueueEmptyFromISR
02003300 g     F .text	000001d8 vStartSemaphoreTasks
0200f43c g     F .text	00000098 alt_epcs_flash_read
02014318 g     O .rwdata	00000008 alt_alarm_list
020112a8 g     F .text	00000060 _do_ctors
02006f58 g     F .text	00000044 uxTaskResetEventItemValue
02004588 g     F .text	0000005c xQueueCreateMutex
0200de14 g     F .text	000000d8 close
02007b00 g     F .text	000000b8 xSerialPortInitMinimal
02007514 g     F .text	00000130 vTaskNotifyGiveFromISR
020144bc g     O .bss	00000007 matriz
02004a0c g     F .text	000000dc xQueueGiveFromISR
0200b8fc g     F .text	00000004 __sinit_lock_acquire
02010c88 g     F .text	0000011c epcs_write_buffer



Disassembly of section .exceptions:

02000020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"		

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
 2000020:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -116		# Create space on the stack.
 2000024:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
 2000028:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
 200002c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
 2000030:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
 2000034:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
 2000038:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
 200003c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
 2000040:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
 2000044:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
 2000048:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
 200004c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
 2000050:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
 2000054:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
 2000058:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
 200005c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
 2000060:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
 2000064:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
 2000068:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
 200006c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
 2000070:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
 2000074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
 2000078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
 200007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
 2000080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
 2000084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
 2000088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
 200008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
 2000090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
 2000094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
 2000098:	df001c15 	stw	fp,112(sp)

0200009c <save_sp_to_pxCurrentTCB>:
 200009c:	06008074 	movhi	et,513

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
 20000a0:	c6111504 	addi	et,et,17492
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
 20000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
 20000a8:	c6c00015 	stw	sp,0(et)

020000ac <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending		# Load the Pending Interrupts indication
 20000ac:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 		# Load the eStatus (enabled interrupts).
 20000b0:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1			# Are interrupts enabled globally.
 20000b4:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
 20000b8:	10002526 	beq	r2,zero,2000150 <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
 20000bc:	20002426 	beq	r4,zero,2000150 <soft_exceptions>

020000c0 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
 20000c0:	200017c0 	call	200017c <alt_irq_handler>

020000c4 <restore_sp_from_pxCurrentTCB>:
 20000c4:	06008074 	movhi	et,513

    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
 20000c8:	c6111504 	addi	et,et,17492
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
 20000cc:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
 20000d0:	c6c00017 	ldw	sp,0(et)

020000d4 <restore_context>:

restore_context:
	ldw		ra, 0(sp)		# Restore the registers.
 20000d4:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
 20000d8:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
 20000dc:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 20000e0:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 20000e4:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
 20000e8:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
 20000ec:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
 20000f0:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
 20000f4:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
 20000f8:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 20000fc:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 2000100:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 2000104:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 2000108:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 200010c:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 2000110:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 2000114:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 2000118:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 200011c:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 2000120:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 2000124:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 2000128:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 200012c:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 2000130:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 2000134:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 2000138:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 200013c:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 2000140:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 2000144:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
 2000148:	dec01d04 	addi	sp,sp,116

    eret					# Return to address ea, loading eStatus into Status.
 200014c:	ef80083a 	eret

02000150 <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
 2000150:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
 2000154:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
 2000158:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
 200015c:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
 2000160:	c0000226 	beq	et,zero,200016c <call_scheduler>
  	break							# This is an un-implemented instruction or muldiv problem.
 2000164:	003da03a 	break	0
  	br		restore_context			# its something else
 2000168:	003fda06 	br	20000d4 <__reset+0xfdfff0d4>

0200016c <call_scheduler>:

call_scheduler:
	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
 200016c:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
 2000170:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
 2000174:	20064680 	call	2006468 <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore. 
 2000178:	003fd206 	br	20000c4 <__reset+0xfdfff0c4>

0200017c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 200017c:	defff904 	addi	sp,sp,-28
 2000180:	dfc00615 	stw	ra,24(sp)
 2000184:	df000515 	stw	fp,20(sp)
 2000188:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 200018c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 2000190:	0005313a 	rdctl	r2,ipending
 2000194:	e0bffe15 	stw	r2,-8(fp)

  return active;
 2000198:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 200019c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 20001a0:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 20001a4:	00800044 	movi	r2,1
 20001a8:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 20001ac:	e0fffb17 	ldw	r3,-20(fp)
 20001b0:	e0bffc17 	ldw	r2,-16(fp)
 20001b4:	1884703a 	and	r2,r3,r2
 20001b8:	10001426 	beq	r2,zero,200020c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 20001bc:	0080a074 	movhi	r2,641
 20001c0:	1091b904 	addi	r2,r2,18148
 20001c4:	e0fffd17 	ldw	r3,-12(fp)
 20001c8:	180690fa 	slli	r3,r3,3
 20001cc:	10c5883a 	add	r2,r2,r3
 20001d0:	10c00017 	ldw	r3,0(r2)
 20001d4:	0080a074 	movhi	r2,641
 20001d8:	1091b904 	addi	r2,r2,18148
 20001dc:	e13ffd17 	ldw	r4,-12(fp)
 20001e0:	200890fa 	slli	r4,r4,3
 20001e4:	1105883a 	add	r2,r2,r4
 20001e8:	10800104 	addi	r2,r2,4
 20001ec:	10800017 	ldw	r2,0(r2)
 20001f0:	1009883a 	mov	r4,r2
 20001f4:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 20001f8:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 20001fc:	0005313a 	rdctl	r2,ipending
 2000200:	e0bfff15 	stw	r2,-4(fp)

  return active;
 2000204:	e0bfff17 	ldw	r2,-4(fp)
 2000208:	00000706 	br	2000228 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 200020c:	e0bffc17 	ldw	r2,-16(fp)
 2000210:	1085883a 	add	r2,r2,r2
 2000214:	e0bffc15 	stw	r2,-16(fp)
      i++;
 2000218:	e0bffd17 	ldw	r2,-12(fp)
 200021c:	10800044 	addi	r2,r2,1
 2000220:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 2000224:	003fe106 	br	20001ac <__reset+0xfdfff1ac>

    active = alt_irq_pending ();
 2000228:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 200022c:	e0bffb17 	ldw	r2,-20(fp)
 2000230:	103fdb1e 	bne	r2,zero,20001a0 <__reset+0xfdfff1a0>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 2000234:	0001883a 	nop
}
 2000238:	0001883a 	nop
 200023c:	e037883a 	mov	sp,fp
 2000240:	dfc00117 	ldw	ra,4(sp)
 2000244:	df000017 	ldw	fp,0(sp)
 2000248:	dec00204 	addi	sp,sp,8
 200024c:	f800283a 	ret

Disassembly of section .text:

02000250 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 2000250:	06c10034 	movhi	sp,1024
    ori sp, sp, %lo(__alt_stack_pointer)
 2000254:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 2000258:	06808074 	movhi	gp,513
    ori gp, gp, %lo(_gp)
 200025c:	d6b0a714 	ori	gp,gp,49820
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 2000260:	00808074 	movhi	r2,513
    ori r2, r2, %lo(__bss_start)
 2000264:	1090c814 	ori	r2,r2,17184

    movhi r3, %hi(__bss_end)
 2000268:	00c0a074 	movhi	r3,641
    ori r3, r3, %lo(__bss_end)
 200026c:	18d1f914 	ori	r3,r3,18404

    beq r2, r3, 1f
 2000270:	10c00326 	beq	r2,r3,2000280 <_start+0x30>

0:
    stw zero, (r2)
 2000274:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 2000278:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 200027c:	10fffd36 	bltu	r2,r3,2000274 <__reset+0xfdfff274>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 2000280:	200e3bc0 	call	200e3bc <alt_main>

02000284 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 2000284:	003fff06 	br	2000284 <__reset+0xfdfff284>

02000288 <vStartBlockingQueueTasks>:
static volatile short sBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };

/*-----------------------------------------------------------*/

void vStartBlockingQueueTasks( UBaseType_t uxPriority )
{
 2000288:	defff104 	addi	sp,sp,-60
 200028c:	dfc00e15 	stw	ra,56(sp)
 2000290:	df000d15 	stw	fp,52(sp)
 2000294:	df000d04 	addi	fp,sp,52
 2000298:	e13fff15 	stw	r4,-4(fp)
xBlockingQueueParameters *pxQueueParameters1, *pxQueueParameters2;
xBlockingQueueParameters *pxQueueParameters3, *pxQueueParameters4;
xBlockingQueueParameters *pxQueueParameters5, *pxQueueParameters6;
const UBaseType_t uxQueueSize1 = 1, uxQueueSize5 = 5;
 200029c:	00800044 	movi	r2,1
 20002a0:	e0bff515 	stw	r2,-44(fp)
 20002a4:	00800144 	movi	r2,5
 20002a8:	e0bff615 	stw	r2,-40(fp)
const TickType_t xBlockTime = pdMS_TO_TICKS( ( TickType_t ) 1000 );
 20002ac:	0080fa04 	movi	r2,1000
 20002b0:	e0bff715 	stw	r2,-36(fp)
const TickType_t xDontBlock = ( TickType_t ) 0;
 20002b4:	e03ff815 	stw	zero,-32(fp)

	/* Create the first two tasks as described at the top of the file. */

	/* First create the structure used to pass parameters to the consumer tasks. */
	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
 20002b8:	01000304 	movi	r4,12
 20002bc:	2003f840 	call	2003f84 <pvPortMalloc>
 20002c0:	e0bff915 	stw	r2,-28(fp)

	/* Create the queue used by the first two tasks to pass the incrementing number.
	Pass a pointer to the queue in the parameter structure. */
	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( UBaseType_t ) sizeof( uint16_t ) );
 20002c4:	000d883a 	mov	r6,zero
 20002c8:	01400084 	movi	r5,2
 20002cc:	e13ff517 	ldw	r4,-44(fp)
 20002d0:	20044040 	call	2004404 <xQueueGenericCreate>
 20002d4:	1007883a 	mov	r3,r2
 20002d8:	e0bff917 	ldw	r2,-28(fp)
 20002dc:	10c00015 	stw	r3,0(r2)

	/* The consumer is created first so gets a block time as described above. */
	pxQueueParameters1->xBlockTime = xBlockTime;
 20002e0:	e0bff917 	ldw	r2,-28(fp)
 20002e4:	e0fff717 	ldw	r3,-36(fp)
 20002e8:	10c00115 	stw	r3,4(r2)

	/* Pass in the variable that this task is going to increment so we can check it
	is still running. */
	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
 20002ec:	e0bff917 	ldw	r2,-28(fp)
 20002f0:	d0e02104 	addi	r3,gp,-32636
 20002f4:	10c00215 	stw	r3,8(r2)

	/* Create the structure used to pass parameters to the producer task. */
	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
 20002f8:	01000304 	movi	r4,12
 20002fc:	2003f840 	call	2003f84 <pvPortMalloc>
 2000300:	e0bffa15 	stw	r2,-24(fp)

	/* Pass the queue to this task also, using the parameter structure. */
	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;
 2000304:	e0bff917 	ldw	r2,-28(fp)
 2000308:	10c00017 	ldw	r3,0(r2)
 200030c:	e0bffa17 	ldw	r2,-24(fp)
 2000310:	10c00015 	stw	r3,0(r2)

	/* The producer is not going to block - as soon as it posts the consumer will
	wake and remove the item so the producer should always have room to post. */
	pxQueueParameters2->xBlockTime = xDontBlock;
 2000314:	e0bffa17 	ldw	r2,-24(fp)
 2000318:	e0fff817 	ldw	r3,-32(fp)
 200031c:	10c00115 	stw	r3,4(r2)

	/* Pass in the variable that this task is going to increment so we can check
	it is still running. */
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );
 2000320:	e0bffa17 	ldw	r2,-24(fp)
 2000324:	d0e02284 	addi	r3,gp,-32630
 2000328:	10c00215 	stw	r3,8(r2)


	/* Note the producer has a lower priority than the consumer when the tasks are
	spawned. */
	xTaskCreate( vBlockingQueueConsumer, "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
 200032c:	d8000115 	stw	zero,4(sp)
 2000330:	e0bfff17 	ldw	r2,-4(fp)
 2000334:	d8800015 	stw	r2,0(sp)
 2000338:	e1fff917 	ldw	r7,-28(fp)
 200033c:	01810004 	movi	r6,1024
 2000340:	01408074 	movhi	r5,513
 2000344:	29486f04 	addi	r5,r5,8636
 2000348:	01008034 	movhi	r4,512
 200034c:	21016604 	addi	r4,r4,1432
 2000350:	20053c80 	call	20053c8 <xTaskCreate>
	xTaskCreate( vBlockingQueueProducer, "QProdB2", blckqSTACK_SIZE, ( void * ) pxQueueParameters2, tskIDLE_PRIORITY, NULL );
 2000354:	d8000115 	stw	zero,4(sp)
 2000358:	d8000015 	stw	zero,0(sp)
 200035c:	e1fffa17 	ldw	r7,-24(fp)
 2000360:	01810004 	movi	r6,1024
 2000364:	01408074 	movhi	r5,513
 2000368:	29487104 	addi	r5,r5,8644
 200036c:	01008034 	movhi	r4,512
 2000370:	21014304 	addi	r4,r4,1292
 2000374:	20053c80 	call	20053c8 <xTaskCreate>


	/* Create the second two tasks as described at the top of the file.   This uses
	the same mechanism but reverses the task priorities. */

	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
 2000378:	01000304 	movi	r4,12
 200037c:	2003f840 	call	2003f84 <pvPortMalloc>
 2000380:	e0bffb15 	stw	r2,-20(fp)
	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( UBaseType_t ) sizeof( uint16_t ) );
 2000384:	000d883a 	mov	r6,zero
 2000388:	01400084 	movi	r5,2
 200038c:	e13ff517 	ldw	r4,-44(fp)
 2000390:	20044040 	call	2004404 <xQueueGenericCreate>
 2000394:	1007883a 	mov	r3,r2
 2000398:	e0bffb17 	ldw	r2,-20(fp)
 200039c:	10c00015 	stw	r3,0(r2)
	pxQueueParameters3->xBlockTime = xDontBlock;
 20003a0:	e0bffb17 	ldw	r2,-20(fp)
 20003a4:	e0fff817 	ldw	r3,-32(fp)
 20003a8:	10c00115 	stw	r3,4(r2)
	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );
 20003ac:	e0bffb17 	ldw	r2,-20(fp)
 20003b0:	d0e02304 	addi	r3,gp,-32628
 20003b4:	10c00215 	stw	r3,8(r2)

	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
 20003b8:	01000304 	movi	r4,12
 20003bc:	2003f840 	call	2003f84 <pvPortMalloc>
 20003c0:	e0bffc15 	stw	r2,-16(fp)
	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
 20003c4:	e0bffb17 	ldw	r2,-20(fp)
 20003c8:	10c00017 	ldw	r3,0(r2)
 20003cc:	e0bffc17 	ldw	r2,-16(fp)
 20003d0:	10c00015 	stw	r3,0(r2)
	pxQueueParameters4->xBlockTime = xBlockTime;
 20003d4:	e0bffc17 	ldw	r2,-16(fp)
 20003d8:	e0fff717 	ldw	r3,-36(fp)
 20003dc:	10c00115 	stw	r3,4(r2)
	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );
 20003e0:	e0bffc17 	ldw	r2,-16(fp)
 20003e4:	d0e02184 	addi	r3,gp,-32634
 20003e8:	10c00215 	stw	r3,8(r2)

	xTaskCreate( vBlockingQueueConsumer, "QConsB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
 20003ec:	d8000115 	stw	zero,4(sp)
 20003f0:	d8000015 	stw	zero,0(sp)
 20003f4:	e1fffb17 	ldw	r7,-20(fp)
 20003f8:	01810004 	movi	r6,1024
 20003fc:	01408074 	movhi	r5,513
 2000400:	29487304 	addi	r5,r5,8652
 2000404:	01008034 	movhi	r4,512
 2000408:	21016604 	addi	r4,r4,1432
 200040c:	20053c80 	call	20053c8 <xTaskCreate>
	xTaskCreate( vBlockingQueueProducer, "QProdB4", blckqSTACK_SIZE, ( void * ) pxQueueParameters4, uxPriority, NULL );
 2000410:	d8000115 	stw	zero,4(sp)
 2000414:	e0bfff17 	ldw	r2,-4(fp)
 2000418:	d8800015 	stw	r2,0(sp)
 200041c:	e1fffc17 	ldw	r7,-16(fp)
 2000420:	01810004 	movi	r6,1024
 2000424:	01408074 	movhi	r5,513
 2000428:	29487504 	addi	r5,r5,8660
 200042c:	01008034 	movhi	r4,512
 2000430:	21014304 	addi	r4,r4,1292
 2000434:	20053c80 	call	20053c8 <xTaskCreate>



	/* Create the last two tasks as described above.  The mechanism is again just
	the same.  This time both parameter structures are given a block time. */
	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
 2000438:	01000304 	movi	r4,12
 200043c:	2003f840 	call	2003f84 <pvPortMalloc>
 2000440:	e0bffd15 	stw	r2,-12(fp)
	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( UBaseType_t ) sizeof( uint16_t ) );
 2000444:	000d883a 	mov	r6,zero
 2000448:	01400084 	movi	r5,2
 200044c:	e13ff617 	ldw	r4,-40(fp)
 2000450:	20044040 	call	2004404 <xQueueGenericCreate>
 2000454:	1007883a 	mov	r3,r2
 2000458:	e0bffd17 	ldw	r2,-12(fp)
 200045c:	10c00015 	stw	r3,0(r2)
	pxQueueParameters5->xBlockTime = xBlockTime;
 2000460:	e0bffd17 	ldw	r2,-12(fp)
 2000464:	e0fff717 	ldw	r3,-36(fp)
 2000468:	10c00115 	stw	r3,4(r2)
	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );
 200046c:	e0bffd17 	ldw	r2,-12(fp)
 2000470:	d0e02384 	addi	r3,gp,-32626
 2000474:	10c00215 	stw	r3,8(r2)

	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
 2000478:	01000304 	movi	r4,12
 200047c:	2003f840 	call	2003f84 <pvPortMalloc>
 2000480:	e0bffe15 	stw	r2,-8(fp)
	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
 2000484:	e0bffd17 	ldw	r2,-12(fp)
 2000488:	10c00017 	ldw	r3,0(r2)
 200048c:	e0bffe17 	ldw	r2,-8(fp)
 2000490:	10c00015 	stw	r3,0(r2)
	pxQueueParameters6->xBlockTime = xBlockTime;
 2000494:	e0bffe17 	ldw	r2,-8(fp)
 2000498:	e0fff717 	ldw	r3,-36(fp)
 200049c:	10c00115 	stw	r3,4(r2)
	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );
 20004a0:	e0bffe17 	ldw	r2,-8(fp)
 20004a4:	d0e02204 	addi	r3,gp,-32632
 20004a8:	10c00215 	stw	r3,8(r2)

	xTaskCreate( vBlockingQueueProducer, "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
 20004ac:	d8000115 	stw	zero,4(sp)
 20004b0:	d8000015 	stw	zero,0(sp)
 20004b4:	e1fffd17 	ldw	r7,-12(fp)
 20004b8:	01810004 	movi	r6,1024
 20004bc:	01408074 	movhi	r5,513
 20004c0:	29487704 	addi	r5,r5,8668
 20004c4:	01008034 	movhi	r4,512
 20004c8:	21014304 	addi	r4,r4,1292
 20004cc:	20053c80 	call	20053c8 <xTaskCreate>
	xTaskCreate( vBlockingQueueConsumer, "QConsB6", blckqSTACK_SIZE, ( void * ) pxQueueParameters6, tskIDLE_PRIORITY, NULL );
 20004d0:	d8000115 	stw	zero,4(sp)
 20004d4:	d8000015 	stw	zero,0(sp)
 20004d8:	e1fffe17 	ldw	r7,-8(fp)
 20004dc:	01810004 	movi	r6,1024
 20004e0:	01408074 	movhi	r5,513
 20004e4:	29487904 	addi	r5,r5,8676
 20004e8:	01008034 	movhi	r4,512
 20004ec:	21016604 	addi	r4,r4,1432
 20004f0:	20053c80 	call	20053c8 <xTaskCreate>
}
 20004f4:	0001883a 	nop
 20004f8:	e037883a 	mov	sp,fp
 20004fc:	dfc00117 	ldw	ra,4(sp)
 2000500:	df000017 	ldw	fp,0(sp)
 2000504:	dec00204 	addi	sp,sp,8
 2000508:	f800283a 	ret

0200050c <vBlockingQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueProducer, pvParameters )
{
 200050c:	defffa04 	addi	sp,sp,-24
 2000510:	dfc00515 	stw	ra,20(sp)
 2000514:	df000415 	stw	fp,16(sp)
 2000518:	df000404 	addi	fp,sp,16
 200051c:	e13fff15 	stw	r4,-4(fp)
uint16_t usValue = 0;
 2000520:	e03ffe0d 	sth	zero,-8(fp)
xBlockingQueueParameters *pxQueueParameters;
short sErrorEverOccurred = pdFALSE;
 2000524:	e03ffc0d 	sth	zero,-16(fp)

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
 2000528:	e0bfff17 	ldw	r2,-4(fp)
 200052c:	e0bffd15 	stw	r2,-12(fp)

	for( ;; )
	{
		if( xQueueSend( pxQueueParameters->xQueue, ( void * ) &usValue, pxQueueParameters->xBlockTime ) != pdPASS )
 2000530:	e0bffd17 	ldw	r2,-12(fp)
 2000534:	10c00017 	ldw	r3,0(r2)
 2000538:	e0bffd17 	ldw	r2,-12(fp)
 200053c:	11000117 	ldw	r4,4(r2)
 2000540:	e0bffe04 	addi	r2,fp,-8
 2000544:	000f883a 	mov	r7,zero
 2000548:	200d883a 	mov	r6,r4
 200054c:	100b883a 	mov	r5,r2
 2000550:	1809883a 	mov	r4,r3
 2000554:	20047700 	call	2004770 <xQueueGenericSend>
 2000558:	10800060 	cmpeqi	r2,r2,1
 200055c:	1000031e 	bne	r2,zero,200056c <vBlockingQueueProducer+0x60>
		{
			sErrorEverOccurred = pdTRUE;
 2000560:	00800044 	movi	r2,1
 2000564:	e0bffc0d 	sth	r2,-16(fp)
 2000568:	003ff106 	br	2000530 <__reset+0xfdfff530>
		}
		else
		{
			/* We have successfully posted a message, so increment the variable
			used to check we are still running. */
			if( sErrorEverOccurred == pdFALSE )
 200056c:	e0bffc0f 	ldh	r2,-16(fp)
 2000570:	1000051e 	bne	r2,zero,2000588 <vBlockingQueueProducer+0x7c>
			{
				( *pxQueueParameters->psCheckVariable )++;
 2000574:	e0bffd17 	ldw	r2,-12(fp)
 2000578:	10800217 	ldw	r2,8(r2)
 200057c:	10c0000b 	ldhu	r3,0(r2)
 2000580:	18c00044 	addi	r3,r3,1
 2000584:	10c0000d 	sth	r3,0(r2)
			}

			/* Increment the variable we are going to post next time round.  The
			consumer will expect the numbers to	follow in numerical order. */
			++usValue;
 2000588:	e0bffe0b 	ldhu	r2,-8(fp)
 200058c:	10800044 	addi	r2,r2,1
 2000590:	e0bffe0d 	sth	r2,-8(fp)

			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}
	}
 2000594:	003fe606 	br	2000530 <__reset+0xfdfff530>

02000598 <vBlockingQueueConsumer>:
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueConsumer, pvParameters )
{
 2000598:	defffa04 	addi	sp,sp,-24
 200059c:	dfc00515 	stw	ra,20(sp)
 20005a0:	df000415 	stw	fp,16(sp)
 20005a4:	df000404 	addi	fp,sp,16
 20005a8:	e13fff15 	stw	r4,-4(fp)
uint16_t usData, usExpectedValue = 0;
 20005ac:	e03ffc0d 	sth	zero,-16(fp)
xBlockingQueueParameters *pxQueueParameters;
short sErrorEverOccurred = pdFALSE;
 20005b0:	e03ffc8d 	sth	zero,-14(fp)

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
 20005b4:	e0bfff17 	ldw	r2,-4(fp)
 20005b8:	e0bffd15 	stw	r2,-12(fp)

	for( ;; )
	{
		if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS )
 20005bc:	e0bffd17 	ldw	r2,-12(fp)
 20005c0:	10c00017 	ldw	r3,0(r2)
 20005c4:	e0bffd17 	ldw	r2,-12(fp)
 20005c8:	11000117 	ldw	r4,4(r2)
 20005cc:	e0bffe04 	addi	r2,fp,-8
 20005d0:	000f883a 	mov	r7,zero
 20005d4:	200d883a 	mov	r6,r4
 20005d8:	100b883a 	mov	r5,r2
 20005dc:	1809883a 	mov	r4,r3
 20005e0:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 20005e4:	10800058 	cmpnei	r2,r2,1
 20005e8:	103ff41e 	bne	r2,zero,20005bc <__reset+0xfdfff5bc>
		{
			if( usData != usExpectedValue )
 20005ec:	e0bffe0b 	ldhu	r2,-8(fp)
 20005f0:	10ffffcc 	andi	r3,r2,65535
 20005f4:	e0bffc0b 	ldhu	r2,-16(fp)
 20005f8:	18800526 	beq	r3,r2,2000610 <vBlockingQueueConsumer+0x78>
			{
				/* Catch-up. */
				usExpectedValue = usData;
 20005fc:	e0bffe0b 	ldhu	r2,-8(fp)
 2000600:	e0bffc0d 	sth	r2,-16(fp)

				sErrorEverOccurred = pdTRUE;
 2000604:	00800044 	movi	r2,1
 2000608:	e0bffc8d 	sth	r2,-14(fp)
 200060c:	003feb06 	br	20005bc <__reset+0xfdfff5bc>
			}
			else
			{
				/* We have successfully received a message, so increment the
				variable used to check we are still running. */
				if( sErrorEverOccurred == pdFALSE )
 2000610:	e0bffc8f 	ldh	r2,-14(fp)
 2000614:	1000051e 	bne	r2,zero,200062c <vBlockingQueueConsumer+0x94>
				{
					( *pxQueueParameters->psCheckVariable )++;
 2000618:	e0bffd17 	ldw	r2,-12(fp)
 200061c:	10800217 	ldw	r2,8(r2)
 2000620:	10c0000b 	ldhu	r3,0(r2)
 2000624:	18c00044 	addi	r3,r3,1
 2000628:	10c0000d 	sth	r3,0(r2)
				}

				/* Increment the value we expect to remove from the queue next time
				round. */
				++usExpectedValue;
 200062c:	e0bffc0b 	ldhu	r2,-16(fp)
 2000630:	10800044 	addi	r2,r2,1
 2000634:	e0bffc0d 	sth	r2,-16(fp)
					taskYIELD();
				}
			}
			#endif
		}
	}
 2000638:	003fe006 	br	20005bc <__reset+0xfdfff5bc>

0200063c <xAreBlockingQueuesStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreBlockingQueuesStillRunning( void )
{
 200063c:	defffd04 	addi	sp,sp,-12
 2000640:	df000215 	stw	fp,8(sp)
 2000644:	df000204 	addi	fp,sp,8
static short sLastBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
static short sLastBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
BaseType_t xReturn = pdPASS, xTasks;
 2000648:	00800044 	movi	r2,1
 200064c:	e0bffe15 	stw	r2,-8(fp)
	changed or not.

	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
 2000650:	e03fff15 	stw	zero,-4(fp)
 2000654:	00003b06 	br	2000744 <xAreBlockingQueuesStillRunning+0x108>
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
 2000658:	e0bfff17 	ldw	r2,-4(fp)
 200065c:	1087883a 	add	r3,r2,r2
 2000660:	d0a02104 	addi	r2,gp,-32636
 2000664:	1885883a 	add	r2,r3,r2
 2000668:	1100000b 	ldhu	r4,0(r2)
 200066c:	e0bfff17 	ldw	r2,-4(fp)
 2000670:	1087883a 	add	r3,r2,r2
 2000674:	d0a02404 	addi	r2,gp,-32624
 2000678:	1885883a 	add	r2,r3,r2
 200067c:	1080000b 	ldhu	r2,0(r2)
 2000680:	20ffffcc 	andi	r3,r4,65535
 2000684:	18e0001c 	xori	r3,r3,32768
 2000688:	18e00004 	addi	r3,r3,-32768
 200068c:	10bfffcc 	andi	r2,r2,65535
 2000690:	10a0001c 	xori	r2,r2,32768
 2000694:	10a00004 	addi	r2,r2,-32768
 2000698:	1880011e 	bne	r3,r2,20006a0 <xAreBlockingQueuesStillRunning+0x64>
		{
			xReturn = pdFALSE;
 200069c:	e03ffe15 	stw	zero,-8(fp)
		}
		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
 20006a0:	e0bfff17 	ldw	r2,-4(fp)
 20006a4:	1087883a 	add	r3,r2,r2
 20006a8:	d0a02104 	addi	r2,gp,-32636
 20006ac:	1885883a 	add	r2,r3,r2
 20006b0:	10c0000b 	ldhu	r3,0(r2)
 20006b4:	e0bfff17 	ldw	r2,-4(fp)
 20006b8:	1089883a 	add	r4,r2,r2
 20006bc:	d0a02404 	addi	r2,gp,-32624
 20006c0:	2085883a 	add	r2,r4,r2
 20006c4:	10c0000d 	sth	r3,0(r2)


		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
 20006c8:	e0bfff17 	ldw	r2,-4(fp)
 20006cc:	1087883a 	add	r3,r2,r2
 20006d0:	d0a02284 	addi	r2,gp,-32630
 20006d4:	1885883a 	add	r2,r3,r2
 20006d8:	1100000b 	ldhu	r4,0(r2)
 20006dc:	e0bfff17 	ldw	r2,-4(fp)
 20006e0:	1087883a 	add	r3,r2,r2
 20006e4:	d0a02584 	addi	r2,gp,-32618
 20006e8:	1885883a 	add	r2,r3,r2
 20006ec:	1080000b 	ldhu	r2,0(r2)
 20006f0:	20ffffcc 	andi	r3,r4,65535
 20006f4:	18e0001c 	xori	r3,r3,32768
 20006f8:	18e00004 	addi	r3,r3,-32768
 20006fc:	10bfffcc 	andi	r2,r2,65535
 2000700:	10a0001c 	xori	r2,r2,32768
 2000704:	10a00004 	addi	r2,r2,-32768
 2000708:	1880011e 	bne	r3,r2,2000710 <xAreBlockingQueuesStillRunning+0xd4>
		{
			xReturn = pdFALSE;
 200070c:	e03ffe15 	stw	zero,-8(fp)
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
 2000710:	e0bfff17 	ldw	r2,-4(fp)
 2000714:	1087883a 	add	r3,r2,r2
 2000718:	d0a02284 	addi	r2,gp,-32630
 200071c:	1885883a 	add	r2,r3,r2
 2000720:	10c0000b 	ldhu	r3,0(r2)
 2000724:	e0bfff17 	ldw	r2,-4(fp)
 2000728:	1089883a 	add	r4,r2,r2
 200072c:	d0a02584 	addi	r2,gp,-32618
 2000730:	2085883a 	add	r2,r4,r2
 2000734:	10c0000d 	sth	r3,0(r2)
	changed or not.

	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
 2000738:	e0bfff17 	ldw	r2,-4(fp)
 200073c:	10800044 	addi	r2,r2,1
 2000740:	e0bfff15 	stw	r2,-4(fp)
 2000744:	e0bfff17 	ldw	r2,-4(fp)
 2000748:	108000d0 	cmplti	r2,r2,3
 200074c:	103fc21e 	bne	r2,zero,2000658 <__reset+0xfdfff658>
			xReturn = pdFALSE;
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
	}

	return xReturn;
 2000750:	e0bffe17 	ldw	r2,-8(fp)
}
 2000754:	e037883a 	mov	sp,fp
 2000758:	df000017 	ldw	fp,0(sp)
 200075c:	dec00104 	addi	sp,sp,4
 2000760:	f800283a 	ret

02000764 <vStartGenericQueueTasks>:
static TaskHandle_t xHighPriorityMutexTask, xMediumPriorityMutexTask;

/*-----------------------------------------------------------*/

void vStartGenericQueueTasks( UBaseType_t uxPriority )
{
 2000764:	defff904 	addi	sp,sp,-28
 2000768:	dfc00615 	stw	ra,24(sp)
 200076c:	df000515 	stw	fp,20(sp)
 2000770:	df000504 	addi	fp,sp,20
 2000774:	e13fff15 	stw	r4,-4(fp)
QueueHandle_t xQueue;
SemaphoreHandle_t xMutex;

	/* Create the queue that we are going to use for the
	prvSendFrontAndBackTest demo. */
	xQueue = xQueueCreate( genqQUEUE_LENGTH, sizeof( uint32_t ) );
 2000778:	000d883a 	mov	r6,zero
 200077c:	01400104 	movi	r5,4
 2000780:	01000144 	movi	r4,5
 2000784:	20044040 	call	2004404 <xQueueGenericCreate>
 2000788:	e0bffd15 	stw	r2,-12(fp)

	if( xQueue != NULL )
 200078c:	e0bffd17 	ldw	r2,-12(fp)
 2000790:	10000a26 	beq	r2,zero,20007bc <vStartGenericQueueTasks+0x58>
		vQueueAddToRegistry( xQueue, "Gen_Queue_Test" );

		/* Create the demo task and pass it the queue just created.  We are
		passing the queue handle by value so it does not matter that it is
		declared on the stack here. */
		xTaskCreate( prvSendFrontAndBackTest, "GenQ", configMINIMAL_STACK_SIZE, ( void * ) xQueue, uxPriority, NULL );
 2000794:	d8000115 	stw	zero,4(sp)
 2000798:	e0bfff17 	ldw	r2,-4(fp)
 200079c:	d8800015 	stw	r2,0(sp)
 20007a0:	e1fffd17 	ldw	r7,-12(fp)
 20007a4:	01810004 	movi	r6,1024
 20007a8:	01408074 	movhi	r5,513
 20007ac:	29487b04 	addi	r5,r5,8684
 20007b0:	01008034 	movhi	r4,512
 20007b4:	21021904 	addi	r4,r4,2148
 20007b8:	20053c80 	call	20053c8 <xTaskCreate>
	}

	/* Create the mutex used by the prvMutexTest task. */
	xMutex = xSemaphoreCreateMutex();
 20007bc:	01000044 	movi	r4,1
 20007c0:	20045880 	call	2004588 <xQueueCreateMutex>
 20007c4:	e0bffe15 	stw	r2,-8(fp)

	if( xMutex != NULL )
 20007c8:	e0bffe17 	ldw	r2,-8(fp)
 20007cc:	10001f26 	beq	r2,zero,200084c <vStartGenericQueueTasks+0xe8>
		vQueueAddToRegistry( ( QueueHandle_t ) xMutex, "Gen_Queue_Mutex" );

		/* Create the mutex demo tasks and pass it the mutex just created.  We
		are passing the mutex handle by value so it does not matter that it is
		declared on the stack here. */
		xTaskCreate( prvLowPriorityMutexTask, "MuLow", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_LOW_PRIORITY, NULL );
 20007d0:	d8000115 	stw	zero,4(sp)
 20007d4:	d8000015 	stw	zero,0(sp)
 20007d8:	e1fffe17 	ldw	r7,-8(fp)
 20007dc:	01810004 	movi	r6,1024
 20007e0:	01408074 	movhi	r5,513
 20007e4:	29487d04 	addi	r5,r5,8692
 20007e8:	01008034 	movhi	r4,512
 20007ec:	2103f304 	addi	r4,r4,4044
 20007f0:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( prvMediumPriorityMutexTask, "MuMed", configMINIMAL_STACK_SIZE, NULL, genqMUTEX_MEDIUM_PRIORITY, &xMediumPriorityMutexTask );
 20007f4:	d0a02c04 	addi	r2,gp,-32592
 20007f8:	d8800115 	stw	r2,4(sp)
 20007fc:	00800084 	movi	r2,2
 2000800:	d8800015 	stw	r2,0(sp)
 2000804:	000f883a 	mov	r7,zero
 2000808:	01810004 	movi	r6,1024
 200080c:	01408074 	movhi	r5,513
 2000810:	29487f04 	addi	r5,r5,8700
 2000814:	01008034 	movhi	r4,512
 2000818:	21040a04 	addi	r4,r4,4136
 200081c:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( prvHighPriorityMutexTask, "MuHigh", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_HIGH_PRIORITY, &xHighPriorityMutexTask );
 2000820:	d0a02b04 	addi	r2,gp,-32596
 2000824:	d8800115 	stw	r2,4(sp)
 2000828:	008000c4 	movi	r2,3
 200082c:	d8800015 	stw	r2,0(sp)
 2000830:	e1fffe17 	ldw	r7,-8(fp)
 2000834:	01810004 	movi	r6,1024
 2000838:	01408074 	movhi	r5,513
 200083c:	29488104 	addi	r5,r5,8708
 2000840:	01008034 	movhi	r4,512
 2000844:	21041504 	addi	r4,r4,4180
 2000848:	20053c80 	call	20053c8 <xTaskCreate>
	}
}
 200084c:	0001883a 	nop
 2000850:	e037883a 	mov	sp,fp
 2000854:	dfc00117 	ldw	ra,4(sp)
 2000858:	df000017 	ldw	fp,0(sp)
 200085c:	dec00204 	addi	sp,sp,8
 2000860:	f800283a 	ret

02000864 <prvSendFrontAndBackTest>:
/*-----------------------------------------------------------*/

static void prvSendFrontAndBackTest( void *pvParameters )
{
 2000864:	defffa04 	addi	sp,sp,-24
 2000868:	dfc00515 	stw	ra,20(sp)
 200086c:	df000415 	stw	fp,16(sp)
 2000870:	df000404 	addi	fp,sp,16
 2000874:	e13fff15 	stw	r4,-4(fp)

		/* Queue a message for printing to say the task has started. */
		vPrintDisplayMessage( &pcTaskStartMsg );
	#endif

	xQueue = ( QueueHandle_t ) pvParameters;
 2000878:	e0bfff17 	ldw	r2,-4(fp)
 200087c:	e0bffc15 	stw	r2,-16(fp)
	{
		/* The queue is empty, so sending an item to the back of the queue
		should have the same efect as sending it to the front of the queue.

		First send to the front and check everything is as expected. */
		xQueueSendToFront( xQueue, ( void * ) &ulLoopCounter, intsemNO_BLOCK );
 2000880:	01c00044 	movi	r7,1
 2000884:	000d883a 	mov	r6,zero
 2000888:	d1602804 	addi	r5,gp,-32608
 200088c:	e13ffc17 	ldw	r4,-16(fp)
 2000890:	20047700 	call	2004770 <xQueueGenericSend>

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
 2000894:	e13ffc17 	ldw	r4,-16(fp)
 2000898:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 200089c:	10800060 	cmpeqi	r2,r2,1
 20008a0:	1000021e 	bne	r2,zero,20008ac <prvSendFrontAndBackTest+0x48>
		{
			xErrorDetected = pdTRUE;
 20008a4:	00800044 	movi	r2,1
 20008a8:	d0a02715 	stw	r2,-32612(gp)
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != pdPASS )
 20008ac:	e0bffd04 	addi	r2,fp,-12
 20008b0:	000f883a 	mov	r7,zero
 20008b4:	000d883a 	mov	r6,zero
 20008b8:	100b883a 	mov	r5,r2
 20008bc:	e13ffc17 	ldw	r4,-16(fp)
 20008c0:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 20008c4:	10800060 	cmpeqi	r2,r2,1
 20008c8:	1000021e 	bne	r2,zero,20008d4 <prvSendFrontAndBackTest+0x70>
		{
			xErrorDetected = pdTRUE;
 20008cc:	00800044 	movi	r2,1
 20008d0:	d0a02715 	stw	r2,-32612(gp)
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
 20008d4:	d0e02817 	ldw	r3,-32608(gp)
 20008d8:	e0bffd17 	ldw	r2,-12(fp)
 20008dc:	18800226 	beq	r3,r2,20008e8 <prvSendFrontAndBackTest+0x84>
		{
			xErrorDetected = pdTRUE;
 20008e0:	00800044 	movi	r2,1
 20008e4:	d0a02715 	stw	r2,-32612(gp)
		}

		/* Then do the same, sending the data to the back, checking everything
		is as expected. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
 20008e8:	e13ffc17 	ldw	r4,-16(fp)
 20008ec:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 20008f0:	10000226 	beq	r2,zero,20008fc <prvSendFrontAndBackTest+0x98>
		{
			xErrorDetected = pdTRUE;
 20008f4:	00800044 	movi	r2,1
 20008f8:	d0a02715 	stw	r2,-32612(gp)
		}

		xQueueSendToBack( xQueue, ( void * ) &ulLoopCounter, intsemNO_BLOCK );
 20008fc:	000f883a 	mov	r7,zero
 2000900:	000d883a 	mov	r6,zero
 2000904:	d1602804 	addi	r5,gp,-32608
 2000908:	e13ffc17 	ldw	r4,-16(fp)
 200090c:	20047700 	call	2004770 <xQueueGenericSend>

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
 2000910:	e13ffc17 	ldw	r4,-16(fp)
 2000914:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 2000918:	10800060 	cmpeqi	r2,r2,1
 200091c:	1000021e 	bne	r2,zero,2000928 <prvSendFrontAndBackTest+0xc4>
		{
			xErrorDetected = pdTRUE;
 2000920:	00800044 	movi	r2,1
 2000924:	d0a02715 	stw	r2,-32612(gp)
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != pdPASS )
 2000928:	e0bffd04 	addi	r2,fp,-12
 200092c:	000f883a 	mov	r7,zero
 2000930:	000d883a 	mov	r6,zero
 2000934:	100b883a 	mov	r5,r2
 2000938:	e13ffc17 	ldw	r4,-16(fp)
 200093c:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2000940:	10800060 	cmpeqi	r2,r2,1
 2000944:	1000021e 	bne	r2,zero,2000950 <prvSendFrontAndBackTest+0xec>
		{
			xErrorDetected = pdTRUE;
 2000948:	00800044 	movi	r2,1
 200094c:	d0a02715 	stw	r2,-32612(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
 2000950:	e13ffc17 	ldw	r4,-16(fp)
 2000954:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 2000958:	10000226 	beq	r2,zero,2000964 <prvSendFrontAndBackTest+0x100>
		{
			xErrorDetected = pdTRUE;
 200095c:	00800044 	movi	r2,1
 2000960:	d0a02715 	stw	r2,-32612(gp)
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
 2000964:	d0e02817 	ldw	r3,-32608(gp)
 2000968:	e0bffd17 	ldw	r2,-12(fp)
 200096c:	18800226 	beq	r3,r2,2000978 <prvSendFrontAndBackTest+0x114>
		{
			xErrorDetected = pdTRUE;
 2000970:	00800044 	movi	r2,1
 2000974:	d0a02715 	stw	r2,-32612(gp)
		#endif



		/* Place 2, 3, 4 into the queue, adding items to the back of the queue. */
		for( ulData = 2; ulData < 5; ulData++ )
 2000978:	00800084 	movi	r2,2
 200097c:	e0bffd15 	stw	r2,-12(fp)
 2000980:	00000906 	br	20009a8 <prvSendFrontAndBackTest+0x144>
		{
			xQueueSendToBack( xQueue, ( void * ) &ulData, intsemNO_BLOCK );
 2000984:	e0bffd04 	addi	r2,fp,-12
 2000988:	000f883a 	mov	r7,zero
 200098c:	000d883a 	mov	r6,zero
 2000990:	100b883a 	mov	r5,r2
 2000994:	e13ffc17 	ldw	r4,-16(fp)
 2000998:	20047700 	call	2004770 <xQueueGenericSend>
		#endif



		/* Place 2, 3, 4 into the queue, adding items to the back of the queue. */
		for( ulData = 2; ulData < 5; ulData++ )
 200099c:	e0bffd17 	ldw	r2,-12(fp)
 20009a0:	10800044 	addi	r2,r2,1
 20009a4:	e0bffd15 	stw	r2,-12(fp)
 20009a8:	e0bffd17 	ldw	r2,-12(fp)
 20009ac:	10800170 	cmpltui	r2,r2,5
 20009b0:	103ff41e 	bne	r2,zero,2000984 <__reset+0xfdfff984>
			xQueueSendToBack( xQueue, ( void * ) &ulData, intsemNO_BLOCK );
		}

		/* Now the order in the queue should be 2, 3, 4, with 2 being the first
		thing to be read out.  Now add 1 then 0 to the front of the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 3 )
 20009b4:	e13ffc17 	ldw	r4,-16(fp)
 20009b8:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 20009bc:	108000e0 	cmpeqi	r2,r2,3
 20009c0:	1000021e 	bne	r2,zero,20009cc <prvSendFrontAndBackTest+0x168>
		{
			xErrorDetected = pdTRUE;
 20009c4:	00800044 	movi	r2,1
 20009c8:	d0a02715 	stw	r2,-32612(gp)
		}
		ulData = 1;
 20009cc:	00800044 	movi	r2,1
 20009d0:	e0bffd15 	stw	r2,-12(fp)
		xQueueSendToFront( xQueue, ( void * ) &ulData, intsemNO_BLOCK );
 20009d4:	e0bffd04 	addi	r2,fp,-12
 20009d8:	01c00044 	movi	r7,1
 20009dc:	000d883a 	mov	r6,zero
 20009e0:	100b883a 	mov	r5,r2
 20009e4:	e13ffc17 	ldw	r4,-16(fp)
 20009e8:	20047700 	call	2004770 <xQueueGenericSend>
		ulData = 0;
 20009ec:	e03ffd15 	stw	zero,-12(fp)
		xQueueSendToFront( xQueue, ( void * ) &ulData, intsemNO_BLOCK );
 20009f0:	e0bffd04 	addi	r2,fp,-12
 20009f4:	01c00044 	movi	r7,1
 20009f8:	000d883a 	mov	r6,zero
 20009fc:	100b883a 	mov	r5,r2
 2000a00:	e13ffc17 	ldw	r4,-16(fp)
 2000a04:	20047700 	call	2004770 <xQueueGenericSend>

		/* Now the queue should be full, and when we read the data out we
		should receive 0, 1, 2, 3, 4. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
 2000a08:	e13ffc17 	ldw	r4,-16(fp)
 2000a0c:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 2000a10:	10800160 	cmpeqi	r2,r2,5
 2000a14:	1000021e 	bne	r2,zero,2000a20 <prvSendFrontAndBackTest+0x1bc>
		{
			xErrorDetected = pdTRUE;
 2000a18:	00800044 	movi	r2,1
 2000a1c:	d0a02715 	stw	r2,-32612(gp)
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != errQUEUE_FULL )
 2000a20:	e0bffd04 	addi	r2,fp,-12
 2000a24:	01c00044 	movi	r7,1
 2000a28:	000d883a 	mov	r6,zero
 2000a2c:	100b883a 	mov	r5,r2
 2000a30:	e13ffc17 	ldw	r4,-16(fp)
 2000a34:	20047700 	call	2004770 <xQueueGenericSend>
 2000a38:	10000226 	beq	r2,zero,2000a44 <prvSendFrontAndBackTest+0x1e0>
		{
			xErrorDetected = pdTRUE;
 2000a3c:	00800044 	movi	r2,1
 2000a40:	d0a02715 	stw	r2,-32612(gp)
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != errQUEUE_FULL )
 2000a44:	e0bffd04 	addi	r2,fp,-12
 2000a48:	000f883a 	mov	r7,zero
 2000a4c:	000d883a 	mov	r6,zero
 2000a50:	100b883a 	mov	r5,r2
 2000a54:	e13ffc17 	ldw	r4,-16(fp)
 2000a58:	20047700 	call	2004770 <xQueueGenericSend>
 2000a5c:	10000226 	beq	r2,zero,2000a68 <prvSendFrontAndBackTest+0x204>
		{
			xErrorDetected = pdTRUE;
 2000a60:	00800044 	movi	r2,1
 2000a64:	d0a02715 	stw	r2,-32612(gp)
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
 2000a68:	e03ffd15 	stw	zero,-12(fp)
 2000a6c:	00002406 	br	2000b00 <prvSendFrontAndBackTest+0x29c>
		{
			/* Try peeking the data first. */
			if( xQueuePeek( xQueue, &ulData2, intsemNO_BLOCK ) != pdPASS )
 2000a70:	e0bffe04 	addi	r2,fp,-8
 2000a74:	01c00044 	movi	r7,1
 2000a78:	000d883a 	mov	r6,zero
 2000a7c:	100b883a 	mov	r5,r2
 2000a80:	e13ffc17 	ldw	r4,-16(fp)
 2000a84:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2000a88:	10800060 	cmpeqi	r2,r2,1
 2000a8c:	1000021e 	bne	r2,zero,2000a98 <prvSendFrontAndBackTest+0x234>
			{
				xErrorDetected = pdTRUE;
 2000a90:	00800044 	movi	r2,1
 2000a94:	d0a02715 	stw	r2,-32612(gp)
			}

			if( ulData != ulData2 )
 2000a98:	e0fffd17 	ldw	r3,-12(fp)
 2000a9c:	e0bffe17 	ldw	r2,-8(fp)
 2000aa0:	18800226 	beq	r3,r2,2000aac <prvSendFrontAndBackTest+0x248>
			{
				xErrorDetected = pdTRUE;
 2000aa4:	00800044 	movi	r2,1
 2000aa8:	d0a02715 	stw	r2,-32612(gp)
			}


			/* Now try receiving the data for real.  The value should be the
			same.  Clobber the value first so we know we really received it. */
			ulData2 = ~ulData2;
 2000aac:	e0bffe17 	ldw	r2,-8(fp)
 2000ab0:	0084303a 	nor	r2,zero,r2
 2000ab4:	e0bffe15 	stw	r2,-8(fp)
			if( xQueueReceive( xQueue, &ulData2, intsemNO_BLOCK ) != pdPASS )
 2000ab8:	e0bffe04 	addi	r2,fp,-8
 2000abc:	000f883a 	mov	r7,zero
 2000ac0:	000d883a 	mov	r6,zero
 2000ac4:	100b883a 	mov	r5,r2
 2000ac8:	e13ffc17 	ldw	r4,-16(fp)
 2000acc:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2000ad0:	10800060 	cmpeqi	r2,r2,1
 2000ad4:	1000021e 	bne	r2,zero,2000ae0 <prvSendFrontAndBackTest+0x27c>
			{
				xErrorDetected = pdTRUE;
 2000ad8:	00800044 	movi	r2,1
 2000adc:	d0a02715 	stw	r2,-32612(gp)
			}

			if( ulData != ulData2 )
 2000ae0:	e0fffd17 	ldw	r3,-12(fp)
 2000ae4:	e0bffe17 	ldw	r2,-8(fp)
 2000ae8:	18800226 	beq	r3,r2,2000af4 <prvSendFrontAndBackTest+0x290>
			{
				xErrorDetected = pdTRUE;
 2000aec:	00800044 	movi	r2,1
 2000af0:	d0a02715 	stw	r2,-32612(gp)
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
 2000af4:	e0bffd17 	ldw	r2,-12(fp)
 2000af8:	10800044 	addi	r2,r2,1
 2000afc:	e0bffd15 	stw	r2,-12(fp)
 2000b00:	e0bffd17 	ldw	r2,-12(fp)
 2000b04:	10800170 	cmpltui	r2,r2,5
 2000b08:	103fd91e 	bne	r2,zero,2000a70 <__reset+0xfdfffa70>
				xErrorDetected = pdTRUE;
			}
		}

		/* The queue should now be empty again. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
 2000b0c:	e13ffc17 	ldw	r4,-16(fp)
 2000b10:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 2000b14:	10000226 	beq	r2,zero,2000b20 <prvSendFrontAndBackTest+0x2bc>
		{
			xErrorDetected = pdTRUE;
 2000b18:	00800044 	movi	r2,1
 2000b1c:	d0a02715 	stw	r2,-32612(gp)
			taskYIELD();
		#endif


		/* Our queue is empty once more, add 10, 11 to the back. */
		ulData = 10;
 2000b20:	00800284 	movi	r2,10
 2000b24:	e0bffd15 	stw	r2,-12(fp)
		if( xQueueSend( xQueue, &ulData, intsemNO_BLOCK ) != pdPASS )
 2000b28:	e0bffd04 	addi	r2,fp,-12
 2000b2c:	000f883a 	mov	r7,zero
 2000b30:	000d883a 	mov	r6,zero
 2000b34:	100b883a 	mov	r5,r2
 2000b38:	e13ffc17 	ldw	r4,-16(fp)
 2000b3c:	20047700 	call	2004770 <xQueueGenericSend>
 2000b40:	10800060 	cmpeqi	r2,r2,1
 2000b44:	1000021e 	bne	r2,zero,2000b50 <prvSendFrontAndBackTest+0x2ec>
		{
			xErrorDetected = pdTRUE;
 2000b48:	00800044 	movi	r2,1
 2000b4c:	d0a02715 	stw	r2,-32612(gp)
		}
		ulData = 11;
 2000b50:	008002c4 	movi	r2,11
 2000b54:	e0bffd15 	stw	r2,-12(fp)
		if( xQueueSend( xQueue, &ulData, intsemNO_BLOCK ) != pdPASS )
 2000b58:	e0bffd04 	addi	r2,fp,-12
 2000b5c:	000f883a 	mov	r7,zero
 2000b60:	000d883a 	mov	r6,zero
 2000b64:	100b883a 	mov	r5,r2
 2000b68:	e13ffc17 	ldw	r4,-16(fp)
 2000b6c:	20047700 	call	2004770 <xQueueGenericSend>
 2000b70:	10800060 	cmpeqi	r2,r2,1
 2000b74:	1000021e 	bne	r2,zero,2000b80 <prvSendFrontAndBackTest+0x31c>
		{
			xErrorDetected = pdTRUE;
 2000b78:	00800044 	movi	r2,1
 2000b7c:	d0a02715 	stw	r2,-32612(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 2 )
 2000b80:	e13ffc17 	ldw	r4,-16(fp)
 2000b84:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 2000b88:	108000a0 	cmpeqi	r2,r2,2
 2000b8c:	1000021e 	bne	r2,zero,2000b98 <prvSendFrontAndBackTest+0x334>
		{
			xErrorDetected = pdTRUE;
 2000b90:	00800044 	movi	r2,1
 2000b94:	d0a02715 	stw	r2,-32612(gp)
		}

		/* Now we should have 10, 11 in the queue.  Add 7, 8, 9 to the
		front. */
		for( ulData = 9; ulData >= 7; ulData-- )
 2000b98:	00800244 	movi	r2,9
 2000b9c:	e0bffd15 	stw	r2,-12(fp)
 2000ba0:	00000d06 	br	2000bd8 <prvSendFrontAndBackTest+0x374>
		{
			if( xQueueSendToFront( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != pdPASS )
 2000ba4:	e0bffd04 	addi	r2,fp,-12
 2000ba8:	01c00044 	movi	r7,1
 2000bac:	000d883a 	mov	r6,zero
 2000bb0:	100b883a 	mov	r5,r2
 2000bb4:	e13ffc17 	ldw	r4,-16(fp)
 2000bb8:	20047700 	call	2004770 <xQueueGenericSend>
 2000bbc:	10800060 	cmpeqi	r2,r2,1
 2000bc0:	1000021e 	bne	r2,zero,2000bcc <prvSendFrontAndBackTest+0x368>
			{
				xErrorDetected = pdTRUE;
 2000bc4:	00800044 	movi	r2,1
 2000bc8:	d0a02715 	stw	r2,-32612(gp)
			xErrorDetected = pdTRUE;
		}

		/* Now we should have 10, 11 in the queue.  Add 7, 8, 9 to the
		front. */
		for( ulData = 9; ulData >= 7; ulData-- )
 2000bcc:	e0bffd17 	ldw	r2,-12(fp)
 2000bd0:	10bfffc4 	addi	r2,r2,-1
 2000bd4:	e0bffd15 	stw	r2,-12(fp)
 2000bd8:	e0bffd17 	ldw	r2,-12(fp)
 2000bdc:	108001e8 	cmpgeui	r2,r2,7
 2000be0:	103ff01e 	bne	r2,zero,2000ba4 <__reset+0xfdfffba4>
			}
		}

		/* Now check that the queue is full, and that receiving data provides
		the expected sequence of 7, 8, 9, 10, 11. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
 2000be4:	e13ffc17 	ldw	r4,-16(fp)
 2000be8:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 2000bec:	10800160 	cmpeqi	r2,r2,5
 2000bf0:	1000021e 	bne	r2,zero,2000bfc <prvSendFrontAndBackTest+0x398>
		{
			xErrorDetected = pdTRUE;
 2000bf4:	00800044 	movi	r2,1
 2000bf8:	d0a02715 	stw	r2,-32612(gp)
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != errQUEUE_FULL )
 2000bfc:	e0bffd04 	addi	r2,fp,-12
 2000c00:	01c00044 	movi	r7,1
 2000c04:	000d883a 	mov	r6,zero
 2000c08:	100b883a 	mov	r5,r2
 2000c0c:	e13ffc17 	ldw	r4,-16(fp)
 2000c10:	20047700 	call	2004770 <xQueueGenericSend>
 2000c14:	10000226 	beq	r2,zero,2000c20 <prvSendFrontAndBackTest+0x3bc>
		{
			xErrorDetected = pdTRUE;
 2000c18:	00800044 	movi	r2,1
 2000c1c:	d0a02715 	stw	r2,-32612(gp)
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != errQUEUE_FULL )
 2000c20:	e0bffd04 	addi	r2,fp,-12
 2000c24:	000f883a 	mov	r7,zero
 2000c28:	000d883a 	mov	r6,zero
 2000c2c:	100b883a 	mov	r5,r2
 2000c30:	e13ffc17 	ldw	r4,-16(fp)
 2000c34:	20047700 	call	2004770 <xQueueGenericSend>
 2000c38:	10000226 	beq	r2,zero,2000c44 <prvSendFrontAndBackTest+0x3e0>
		{
			xErrorDetected = pdTRUE;
 2000c3c:	00800044 	movi	r2,1
 2000c40:	d0a02715 	stw	r2,-32612(gp)
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
 2000c44:	008001c4 	movi	r2,7
 2000c48:	e0bffd15 	stw	r2,-12(fp)
 2000c4c:	00001206 	br	2000c98 <prvSendFrontAndBackTest+0x434>
		{
			if( xQueueReceive( xQueue, &ulData2, intsemNO_BLOCK ) != pdPASS )
 2000c50:	e0bffe04 	addi	r2,fp,-8
 2000c54:	000f883a 	mov	r7,zero
 2000c58:	000d883a 	mov	r6,zero
 2000c5c:	100b883a 	mov	r5,r2
 2000c60:	e13ffc17 	ldw	r4,-16(fp)
 2000c64:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2000c68:	10800060 	cmpeqi	r2,r2,1
 2000c6c:	1000021e 	bne	r2,zero,2000c78 <prvSendFrontAndBackTest+0x414>
			{
				xErrorDetected = pdTRUE;
 2000c70:	00800044 	movi	r2,1
 2000c74:	d0a02715 	stw	r2,-32612(gp)
			}

			if( ulData != ulData2 )
 2000c78:	e0fffd17 	ldw	r3,-12(fp)
 2000c7c:	e0bffe17 	ldw	r2,-8(fp)
 2000c80:	18800226 	beq	r3,r2,2000c8c <prvSendFrontAndBackTest+0x428>
			{
				xErrorDetected = pdTRUE;
 2000c84:	00800044 	movi	r2,1
 2000c88:	d0a02715 	stw	r2,-32612(gp)
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
 2000c8c:	e0bffd17 	ldw	r2,-12(fp)
 2000c90:	10800044 	addi	r2,r2,1
 2000c94:	e0bffd15 	stw	r2,-12(fp)
 2000c98:	e0bffd17 	ldw	r2,-12(fp)
 2000c9c:	10800330 	cmpltui	r2,r2,12
 2000ca0:	103feb1e 	bne	r2,zero,2000c50 <__reset+0xfdfffc50>
			{
				xErrorDetected = pdTRUE;
			}
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
 2000ca4:	e13ffc17 	ldw	r4,-16(fp)
 2000ca8:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 2000cac:	10000226 	beq	r2,zero,2000cb8 <prvSendFrontAndBackTest+0x454>
		{
			xErrorDetected = pdTRUE;
 2000cb0:	00800044 	movi	r2,1
 2000cb4:	d0a02715 	stw	r2,-32612(gp)
		}

		ulLoopCounter++;
 2000cb8:	d0a02817 	ldw	r2,-32608(gp)
 2000cbc:	10800044 	addi	r2,r2,1
 2000cc0:	d0a02815 	stw	r2,-32608(gp)
	}
 2000cc4:	003eee06 	br	2000880 <__reset+0xfdfff880>

02000cc8 <prvTakeTwoMutexesReturnInDifferentOrder>:
}
/*-----------------------------------------------------------*/

static void prvTakeTwoMutexesReturnInDifferentOrder( SemaphoreHandle_t xMutex, SemaphoreHandle_t xLocalMutex )
{
 2000cc8:	defffc04 	addi	sp,sp,-16
 2000ccc:	dfc00315 	stw	ra,12(sp)
 2000cd0:	df000215 	stw	fp,8(sp)
 2000cd4:	df000204 	addi	fp,sp,8
 2000cd8:	e13ffe15 	stw	r4,-8(fp)
 2000cdc:	e17fff15 	stw	r5,-4(fp)
	/* Take the mutex.  It should be available now. */
	if( xSemaphoreTake( xMutex, intsemNO_BLOCK ) != pdPASS )
 2000ce0:	000f883a 	mov	r7,zero
 2000ce4:	000d883a 	mov	r6,zero
 2000ce8:	000b883a 	mov	r5,zero
 2000cec:	e13ffe17 	ldw	r4,-8(fp)
 2000cf0:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2000cf4:	10800060 	cmpeqi	r2,r2,1
 2000cf8:	1000021e 	bne	r2,zero,2000d04 <prvTakeTwoMutexesReturnInDifferentOrder+0x3c>
	{
		xErrorDetected = pdTRUE;
 2000cfc:	00800044 	movi	r2,1
 2000d00:	d0a02715 	stw	r2,-32612(gp)
	}

	/* Set the guarded variable to a known start value. */
	ulGuardedVariable = 0;
 2000d04:	d0202a15 	stw	zero,-32600(gp)

	/* This task's priority should be as per that assigned when the task was
	created. */
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_LOW_PRIORITY )
 2000d08:	0009883a 	mov	r4,zero
 2000d0c:	20059bc0 	call	20059bc <uxTaskPriorityGet>
 2000d10:	10000226 	beq	r2,zero,2000d1c <prvTakeTwoMutexesReturnInDifferentOrder+0x54>
	{
		xErrorDetected = pdTRUE;
 2000d14:	00800044 	movi	r2,1
 2000d18:	d0a02715 	stw	r2,-32612(gp)
	}

	/* Now unsuspend the high priority task.  This will attempt to take the
	mutex, and block when it finds it cannot obtain it. */
	vTaskResume( xHighPriorityMutexTask );
 2000d1c:	d0a02b17 	ldw	r2,-32596(gp)
 2000d20:	1009883a 	mov	r4,r2
 2000d24:	2005da80 	call	2005da8 <vTaskResume>
	}
	#endif /* INCLUDE_eTaskGetState */

	/* The priority of the high priority task should now have been inherited
	as by now it will have attempted to get the mutex. */
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
 2000d28:	0009883a 	mov	r4,zero
 2000d2c:	20059bc0 	call	20059bc <uxTaskPriorityGet>
 2000d30:	108000e0 	cmpeqi	r2,r2,3
 2000d34:	1000021e 	bne	r2,zero,2000d40 <prvTakeTwoMutexesReturnInDifferentOrder+0x78>
	{
		xErrorDetected = pdTRUE;
 2000d38:	00800044 	movi	r2,1
 2000d3c:	d0a02715 	stw	r2,-32612(gp)
	}

	/* Attempt to set the priority of this task to the test priority -
	between the	idle priority and the medium/high test priorities, but the
	actual priority should remain at the high priority. */
	vTaskPrioritySet( NULL, genqMUTEX_TEST_PRIORITY );
 2000d40:	01400044 	movi	r5,1
 2000d44:	0009883a 	mov	r4,zero
 2000d48:	2005a600 	call	2005a60 <vTaskPrioritySet>
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
 2000d4c:	0009883a 	mov	r4,zero
 2000d50:	20059bc0 	call	20059bc <uxTaskPriorityGet>
 2000d54:	108000e0 	cmpeqi	r2,r2,3
 2000d58:	1000021e 	bne	r2,zero,2000d64 <prvTakeTwoMutexesReturnInDifferentOrder+0x9c>
	{
		xErrorDetected = pdTRUE;
 2000d5c:	00800044 	movi	r2,1
 2000d60:	d0a02715 	stw	r2,-32612(gp)
	}

	/* Now unsuspend the medium priority task.  This should not run as the
	inherited priority of this task is above that of the medium priority
	task. */
	vTaskResume( xMediumPriorityMutexTask );
 2000d64:	d0a02c17 	ldw	r2,-32592(gp)
 2000d68:	1009883a 	mov	r4,r2
 2000d6c:	2005da80 	call	2005da8 <vTaskResume>

	/* If the medium priority task did run then it will have incremented the
	guarded variable. */
	if( ulGuardedVariable != 0 )
 2000d70:	d0a02a17 	ldw	r2,-32600(gp)
 2000d74:	10000226 	beq	r2,zero,2000d80 <prvTakeTwoMutexesReturnInDifferentOrder+0xb8>
	{
		xErrorDetected = pdTRUE;
 2000d78:	00800044 	movi	r2,1
 2000d7c:	d0a02715 	stw	r2,-32612(gp)
	}

	/* Take the local mutex too, so two mutexes are now held. */
	if( xSemaphoreTake( xLocalMutex, intsemNO_BLOCK ) != pdPASS )
 2000d80:	000f883a 	mov	r7,zero
 2000d84:	000d883a 	mov	r6,zero
 2000d88:	000b883a 	mov	r5,zero
 2000d8c:	e13fff17 	ldw	r4,-4(fp)
 2000d90:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2000d94:	10800060 	cmpeqi	r2,r2,1
 2000d98:	1000021e 	bne	r2,zero,2000da4 <prvTakeTwoMutexesReturnInDifferentOrder+0xdc>
	{
		xErrorDetected = pdTRUE;
 2000d9c:	00800044 	movi	r2,1
 2000da0:	d0a02715 	stw	r2,-32612(gp)
	yet be disinherited because the local mutex is still held.  This is a
	simplification to allow FreeRTOS to be integrated with middleware that
	attempts to hold multiple mutexes without bloating the code with complex
	algorithms.  It is possible that the high priority mutex task will
	execute as it shares a priority with this task. */
	if( xSemaphoreGive( xMutex ) != pdPASS )
 2000da4:	000f883a 	mov	r7,zero
 2000da8:	000d883a 	mov	r6,zero
 2000dac:	000b883a 	mov	r5,zero
 2000db0:	e13ffe17 	ldw	r4,-8(fp)
 2000db4:	20047700 	call	2004770 <xQueueGenericSend>
 2000db8:	10800060 	cmpeqi	r2,r2,1
 2000dbc:	1000021e 	bne	r2,zero,2000dc8 <prvTakeTwoMutexesReturnInDifferentOrder+0x100>
	{
		xErrorDetected = pdTRUE;
 2000dc0:	00800044 	movi	r2,1
 2000dc4:	d0a02715 	stw	r2,-32612(gp)
	#endif

	/* The guarded variable is only incremented by the medium priority task,
	which still should not have executed as this task should remain at the
	higher priority, ensure this is the case. */
	if( ulGuardedVariable != 0 )
 2000dc8:	d0a02a17 	ldw	r2,-32600(gp)
 2000dcc:	10000226 	beq	r2,zero,2000dd8 <prvTakeTwoMutexesReturnInDifferentOrder+0x110>
	{
		xErrorDetected = pdTRUE;
 2000dd0:	00800044 	movi	r2,1
 2000dd4:	d0a02715 	stw	r2,-32612(gp)
	}

	if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
 2000dd8:	0009883a 	mov	r4,zero
 2000ddc:	20059bc0 	call	20059bc <uxTaskPriorityGet>
 2000de0:	108000e0 	cmpeqi	r2,r2,3
 2000de4:	1000021e 	bne	r2,zero,2000df0 <prvTakeTwoMutexesReturnInDifferentOrder+0x128>
	{
		xErrorDetected = pdTRUE;
 2000de8:	00800044 	movi	r2,1
 2000dec:	d0a02715 	stw	r2,-32612(gp)
	This time the priority of this task should be disinherited back to the
	priority to which it was set while the mutex was held.  This means
	the medium priority task should execute and increment the guarded
	variable.   When this task next	runs both the high and medium priority
	tasks will have been suspended again. */
	if( xSemaphoreGive( xLocalMutex ) != pdPASS )
 2000df0:	000f883a 	mov	r7,zero
 2000df4:	000d883a 	mov	r6,zero
 2000df8:	000b883a 	mov	r5,zero
 2000dfc:	e13fff17 	ldw	r4,-4(fp)
 2000e00:	20047700 	call	2004770 <xQueueGenericSend>
 2000e04:	10800060 	cmpeqi	r2,r2,1
 2000e08:	1000021e 	bne	r2,zero,2000e14 <prvTakeTwoMutexesReturnInDifferentOrder+0x14c>
	{
		xErrorDetected = pdTRUE;
 2000e0c:	00800044 	movi	r2,1
 2000e10:	d0a02715 	stw	r2,-32612(gp)
	#if configUSE_PREEMPTION == 0
		taskYIELD();
	#endif

	/* Check the guarded variable did indeed increment... */
	if( ulGuardedVariable != 1 )
 2000e14:	d0a02a17 	ldw	r2,-32600(gp)
 2000e18:	10800060 	cmpeqi	r2,r2,1
 2000e1c:	1000021e 	bne	r2,zero,2000e28 <prvTakeTwoMutexesReturnInDifferentOrder+0x160>
	{
		xErrorDetected = pdTRUE;
 2000e20:	00800044 	movi	r2,1
 2000e24:	d0a02715 	stw	r2,-32612(gp)
	}

	/* ... and that the priority of this task has been disinherited to
	genqMUTEX_TEST_PRIORITY. */
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_TEST_PRIORITY )
 2000e28:	0009883a 	mov	r4,zero
 2000e2c:	20059bc0 	call	20059bc <uxTaskPriorityGet>
 2000e30:	10800060 	cmpeqi	r2,r2,1
 2000e34:	1000021e 	bne	r2,zero,2000e40 <prvTakeTwoMutexesReturnInDifferentOrder+0x178>
	{
		xErrorDetected = pdTRUE;
 2000e38:	00800044 	movi	r2,1
 2000e3c:	d0a02715 	stw	r2,-32612(gp)
	}

	/* Set the priority of this task back to its original value, ready for
	the next loop around this test. */
	vTaskPrioritySet( NULL, genqMUTEX_LOW_PRIORITY );
 2000e40:	000b883a 	mov	r5,zero
 2000e44:	0009883a 	mov	r4,zero
 2000e48:	2005a600 	call	2005a60 <vTaskPrioritySet>
}
 2000e4c:	0001883a 	nop
 2000e50:	e037883a 	mov	sp,fp
 2000e54:	dfc00117 	ldw	ra,4(sp)
 2000e58:	df000017 	ldw	fp,0(sp)
 2000e5c:	dec00204 	addi	sp,sp,8
 2000e60:	f800283a 	ret

02000e64 <prvTakeTwoMutexesReturnInSameOrder>:
/*-----------------------------------------------------------*/

static void prvTakeTwoMutexesReturnInSameOrder( SemaphoreHandle_t xMutex, SemaphoreHandle_t xLocalMutex )
{
 2000e64:	defffc04 	addi	sp,sp,-16
 2000e68:	dfc00315 	stw	ra,12(sp)
 2000e6c:	df000215 	stw	fp,8(sp)
 2000e70:	df000204 	addi	fp,sp,8
 2000e74:	e13ffe15 	stw	r4,-8(fp)
 2000e78:	e17fff15 	stw	r5,-4(fp)
	/* Take the mutex.  It should be available now. */
	if( xSemaphoreTake( xMutex, intsemNO_BLOCK ) != pdPASS )
 2000e7c:	000f883a 	mov	r7,zero
 2000e80:	000d883a 	mov	r6,zero
 2000e84:	000b883a 	mov	r5,zero
 2000e88:	e13ffe17 	ldw	r4,-8(fp)
 2000e8c:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2000e90:	10800060 	cmpeqi	r2,r2,1
 2000e94:	1000021e 	bne	r2,zero,2000ea0 <prvTakeTwoMutexesReturnInSameOrder+0x3c>
	{
		xErrorDetected = pdTRUE;
 2000e98:	00800044 	movi	r2,1
 2000e9c:	d0a02715 	stw	r2,-32612(gp)
	}

	/* Set the guarded variable to a known start value. */
	ulGuardedVariable = 0;
 2000ea0:	d0202a15 	stw	zero,-32600(gp)

	/* This task's priority should be as per that assigned when the task was
	created. */
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_LOW_PRIORITY )
 2000ea4:	0009883a 	mov	r4,zero
 2000ea8:	20059bc0 	call	20059bc <uxTaskPriorityGet>
 2000eac:	10000226 	beq	r2,zero,2000eb8 <prvTakeTwoMutexesReturnInSameOrder+0x54>
	{
		xErrorDetected = pdTRUE;
 2000eb0:	00800044 	movi	r2,1
 2000eb4:	d0a02715 	stw	r2,-32612(gp)
	}

	/* Now unsuspend the high priority task.  This will attempt to take the
	mutex, and block when it finds it cannot obtain it. */
	vTaskResume( xHighPriorityMutexTask );
 2000eb8:	d0a02b17 	ldw	r2,-32596(gp)
 2000ebc:	1009883a 	mov	r4,r2
 2000ec0:	2005da80 	call	2005da8 <vTaskResume>
	}
	#endif /* INCLUDE_eTaskGetState */

	/* The priority of the high priority task should now have been inherited
	as by now it will have attempted to get the mutex. */
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
 2000ec4:	0009883a 	mov	r4,zero
 2000ec8:	20059bc0 	call	20059bc <uxTaskPriorityGet>
 2000ecc:	108000e0 	cmpeqi	r2,r2,3
 2000ed0:	1000021e 	bne	r2,zero,2000edc <prvTakeTwoMutexesReturnInSameOrder+0x78>
	{
		xErrorDetected = pdTRUE;
 2000ed4:	00800044 	movi	r2,1
 2000ed8:	d0a02715 	stw	r2,-32612(gp)
	}

	/* Now unsuspend the medium priority task.  This should not run as the
	inherited priority of this task is above that of the medium priority
	task. */
	vTaskResume( xMediumPriorityMutexTask );
 2000edc:	d0a02c17 	ldw	r2,-32592(gp)
 2000ee0:	1009883a 	mov	r4,r2
 2000ee4:	2005da80 	call	2005da8 <vTaskResume>

	/* If the medium priority task did run then it will have incremented the
	guarded variable. */
	if( ulGuardedVariable != 0 )
 2000ee8:	d0a02a17 	ldw	r2,-32600(gp)
 2000eec:	10000226 	beq	r2,zero,2000ef8 <prvTakeTwoMutexesReturnInSameOrder+0x94>
	{
		xErrorDetected = pdTRUE;
 2000ef0:	00800044 	movi	r2,1
 2000ef4:	d0a02715 	stw	r2,-32612(gp)
	}

	/* Take the local mutex too, so two mutexes are now held. */
	if( xSemaphoreTake( xLocalMutex, intsemNO_BLOCK ) != pdPASS )
 2000ef8:	000f883a 	mov	r7,zero
 2000efc:	000d883a 	mov	r6,zero
 2000f00:	000b883a 	mov	r5,zero
 2000f04:	e13fff17 	ldw	r4,-4(fp)
 2000f08:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2000f0c:	10800060 	cmpeqi	r2,r2,1
 2000f10:	1000021e 	bne	r2,zero,2000f1c <prvTakeTwoMutexesReturnInSameOrder+0xb8>
	{
		xErrorDetected = pdTRUE;
 2000f14:	00800044 	movi	r2,1
 2000f18:	d0a02715 	stw	r2,-32612(gp)
	not	yet be disinherited because the shared mutex is still held.  This is a
	simplification to allow FreeRTOS to be integrated with middleware that
	attempts to hold multiple mutexes without bloating the code with complex
	algorithms.  It is possible that the high priority mutex task will
	execute as it shares a priority with this task. */
	if( xSemaphoreGive( xLocalMutex ) != pdPASS )
 2000f1c:	000f883a 	mov	r7,zero
 2000f20:	000d883a 	mov	r6,zero
 2000f24:	000b883a 	mov	r5,zero
 2000f28:	e13fff17 	ldw	r4,-4(fp)
 2000f2c:	20047700 	call	2004770 <xQueueGenericSend>
 2000f30:	10800060 	cmpeqi	r2,r2,1
 2000f34:	1000021e 	bne	r2,zero,2000f40 <prvTakeTwoMutexesReturnInSameOrder+0xdc>
	{
		xErrorDetected = pdTRUE;
 2000f38:	00800044 	movi	r2,1
 2000f3c:	d0a02715 	stw	r2,-32612(gp)
	#endif

	/* The guarded variable is only incremented by the medium priority task,
	which still should not have executed as this task should remain at the
	higher priority, ensure this is the case. */
	if( ulGuardedVariable != 0 )
 2000f40:	d0a02a17 	ldw	r2,-32600(gp)
 2000f44:	10000226 	beq	r2,zero,2000f50 <prvTakeTwoMutexesReturnInSameOrder+0xec>
	{
		xErrorDetected = pdTRUE;
 2000f48:	00800044 	movi	r2,1
 2000f4c:	d0a02715 	stw	r2,-32612(gp)
	}

	if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
 2000f50:	0009883a 	mov	r4,zero
 2000f54:	20059bc0 	call	20059bc <uxTaskPriorityGet>
 2000f58:	108000e0 	cmpeqi	r2,r2,3
 2000f5c:	1000021e 	bne	r2,zero,2000f68 <prvTakeTwoMutexesReturnInSameOrder+0x104>
	{
		xErrorDetected = pdTRUE;
 2000f60:	00800044 	movi	r2,1
 2000f64:	d0a02715 	stw	r2,-32612(gp)
	/* Now also give back the shared mutex, taking the held count back to 0.
	This time the priority of this task should be disinherited back to the
	priority at which it was created.  This means the medium priority task
	should execute and increment the guarded variable.  When this task next runs
	both the high and medium priority tasks will have been suspended again. */
	if( xSemaphoreGive( xMutex ) != pdPASS )
 2000f68:	000f883a 	mov	r7,zero
 2000f6c:	000d883a 	mov	r6,zero
 2000f70:	000b883a 	mov	r5,zero
 2000f74:	e13ffe17 	ldw	r4,-8(fp)
 2000f78:	20047700 	call	2004770 <xQueueGenericSend>
 2000f7c:	10800060 	cmpeqi	r2,r2,1
 2000f80:	1000021e 	bne	r2,zero,2000f8c <prvTakeTwoMutexesReturnInSameOrder+0x128>
	{
		xErrorDetected = pdTRUE;
 2000f84:	00800044 	movi	r2,1
 2000f88:	d0a02715 	stw	r2,-32612(gp)
	#if configUSE_PREEMPTION == 0
		taskYIELD();
	#endif

	/* Check the guarded variable did indeed increment... */
	if( ulGuardedVariable != 1 )
 2000f8c:	d0a02a17 	ldw	r2,-32600(gp)
 2000f90:	10800060 	cmpeqi	r2,r2,1
 2000f94:	1000021e 	bne	r2,zero,2000fa0 <prvTakeTwoMutexesReturnInSameOrder+0x13c>
	{
		xErrorDetected = pdTRUE;
 2000f98:	00800044 	movi	r2,1
 2000f9c:	d0a02715 	stw	r2,-32612(gp)
	}

	/* ... and that the priority of this task has been disinherited to
	genqMUTEX_LOW_PRIORITY. */
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_LOW_PRIORITY )
 2000fa0:	0009883a 	mov	r4,zero
 2000fa4:	20059bc0 	call	20059bc <uxTaskPriorityGet>
 2000fa8:	10000226 	beq	r2,zero,2000fb4 <prvTakeTwoMutexesReturnInSameOrder+0x150>
	{
		xErrorDetected = pdTRUE;
 2000fac:	00800044 	movi	r2,1
 2000fb0:	d0a02715 	stw	r2,-32612(gp)
	}
}
 2000fb4:	0001883a 	nop
 2000fb8:	e037883a 	mov	sp,fp
 2000fbc:	dfc00117 	ldw	ra,4(sp)
 2000fc0:	df000017 	ldw	fp,0(sp)
 2000fc4:	dec00204 	addi	sp,sp,8
 2000fc8:	f800283a 	ret

02000fcc <prvLowPriorityMutexTask>:
/*-----------------------------------------------------------*/

static void prvLowPriorityMutexTask( void *pvParameters )
{
 2000fcc:	defffb04 	addi	sp,sp,-20
 2000fd0:	dfc00415 	stw	ra,16(sp)
 2000fd4:	df000315 	stw	fp,12(sp)
 2000fd8:	df000304 	addi	fp,sp,12
 2000fdc:	e13fff15 	stw	r4,-4(fp)
SemaphoreHandle_t xMutex = ( SemaphoreHandle_t ) pvParameters, xLocalMutex;
 2000fe0:	e0bfff17 	ldw	r2,-4(fp)
 2000fe4:	e0bffd15 	stw	r2,-12(fp)
		/* Queue a message for printing to say the task has started. */
		vPrintDisplayMessage( &pcTaskStartMsg );
	#endif

	/* The local mutex is used to check the 'mutexs held' count. */
	xLocalMutex = xSemaphoreCreateMutex();
 2000fe8:	01000044 	movi	r4,1
 2000fec:	20045880 	call	2004588 <xQueueCreateMutex>
 2000ff0:	e0bffe15 	stw	r2,-8(fp)
	for( ;; )
	{
		/* The first tests exercise the priority inheritance when two mutexes
		are taken then returned in a different order to which they were
		taken. */
		prvTakeTwoMutexesReturnInDifferentOrder( xMutex, xLocalMutex );
 2000ff4:	e17ffe17 	ldw	r5,-8(fp)
 2000ff8:	e13ffd17 	ldw	r4,-12(fp)
 2000ffc:	2000cc80 	call	2000cc8 <prvTakeTwoMutexesReturnInDifferentOrder>

		/* Just to show this task is still running. */
		ulLoopCounter2++;
 2001000:	d0a02917 	ldw	r2,-32604(gp)
 2001004:	10800044 	addi	r2,r2,1
 2001008:	d0a02915 	stw	r2,-32604(gp)
			taskYIELD();
		#endif

		/* The second tests exercise the priority inheritance when two mutexes
		are taken then returned in the same order in which they were taken. */
		prvTakeTwoMutexesReturnInSameOrder( xMutex, xLocalMutex );
 200100c:	e17ffe17 	ldw	r5,-8(fp)
 2001010:	e13ffd17 	ldw	r4,-12(fp)
 2001014:	2000e640 	call	2000e64 <prvTakeTwoMutexesReturnInSameOrder>

		/* Just to show this task is still running. */
		ulLoopCounter2++;
 2001018:	d0a02917 	ldw	r2,-32604(gp)
 200101c:	10800044 	addi	r2,r2,1
 2001020:	d0a02915 	stw	r2,-32604(gp)

		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif
	}
 2001024:	003ff306 	br	2000ff4 <__reset+0xfdfffff4>

02001028 <prvMediumPriorityMutexTask>:
}
/*-----------------------------------------------------------*/

static void prvMediumPriorityMutexTask( void *pvParameters )
{
 2001028:	defffd04 	addi	sp,sp,-12
 200102c:	dfc00215 	stw	ra,8(sp)
 2001030:	df000115 	stw	fp,4(sp)
 2001034:	df000104 	addi	fp,sp,4
 2001038:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* The medium priority task starts by suspending itself.  The low
		priority task will unsuspend this task when required. */
		vTaskSuspend( NULL );
 200103c:	0009883a 	mov	r4,zero
 2001040:	2005c340 	call	2005c34 <vTaskSuspend>

		/* When this task unsuspends all it does is increment the guarded
		variable, this is so the low priority task knows that it has
		executed. */
		ulGuardedVariable++;
 2001044:	d0a02a17 	ldw	r2,-32600(gp)
 2001048:	10800044 	addi	r2,r2,1
 200104c:	d0a02a15 	stw	r2,-32600(gp)
	}
 2001050:	003ffa06 	br	200103c <__reset+0xfe00003c>

02001054 <prvHighPriorityMutexTask>:
}
/*-----------------------------------------------------------*/

static void prvHighPriorityMutexTask( void *pvParameters )
{
 2001054:	defffc04 	addi	sp,sp,-16
 2001058:	dfc00315 	stw	ra,12(sp)
 200105c:	df000215 	stw	fp,8(sp)
 2001060:	df000204 	addi	fp,sp,8
 2001064:	e13fff15 	stw	r4,-4(fp)
SemaphoreHandle_t xMutex = ( SemaphoreHandle_t ) pvParameters;
 2001068:	e0bfff17 	ldw	r2,-4(fp)
 200106c:	e0bffe15 	stw	r2,-8(fp)

	for( ;; )
	{
		/* The high priority task starts by suspending itself.  The low
		priority task will unsuspend this task when required. */
		vTaskSuspend( NULL );
 2001070:	0009883a 	mov	r4,zero
 2001074:	2005c340 	call	2005c34 <vTaskSuspend>

		/* When this task unsuspends all it does is attempt to obtain
		the mutex.  It should find the mutex is not available so a
		block time is specified. */
		if( xSemaphoreTake( xMutex, portMAX_DELAY ) != pdPASS )
 2001078:	000f883a 	mov	r7,zero
 200107c:	01bfffc4 	movi	r6,-1
 2001080:	000b883a 	mov	r5,zero
 2001084:	e13ffe17 	ldw	r4,-8(fp)
 2001088:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 200108c:	10800060 	cmpeqi	r2,r2,1
 2001090:	1000021e 	bne	r2,zero,200109c <prvHighPriorityMutexTask+0x48>
		{
			xErrorDetected = pdTRUE;
 2001094:	00800044 	movi	r2,1
 2001098:	d0a02715 	stw	r2,-32612(gp)
		}

		/* When the mutex is eventually obtained it is just given back before
		returning to suspend ready for the next cycle. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
 200109c:	000f883a 	mov	r7,zero
 20010a0:	000d883a 	mov	r6,zero
 20010a4:	000b883a 	mov	r5,zero
 20010a8:	e13ffe17 	ldw	r4,-8(fp)
 20010ac:	20047700 	call	2004770 <xQueueGenericSend>
 20010b0:	10800060 	cmpeqi	r2,r2,1
 20010b4:	103fee1e 	bne	r2,zero,2001070 <__reset+0xfe000070>
		{
			xErrorDetected = pdTRUE;
 20010b8:	00800044 	movi	r2,1
 20010bc:	d0a02715 	stw	r2,-32612(gp)
		}
	}
 20010c0:	003feb06 	br	2001070 <__reset+0xfe000070>

020010c4 <xAreGenericQueueTasksStillRunning>:
/*-----------------------------------------------------------*/


/* This is called to check that all the created tasks are still running. */
BaseType_t xAreGenericQueueTasksStillRunning( void )
{
 20010c4:	deffff04 	addi	sp,sp,-4
 20010c8:	df000015 	stw	fp,0(sp)
 20010cc:	d839883a 	mov	fp,sp
static uint32_t ulLastLoopCounter = 0, ulLastLoopCounter2 = 0;

	/* If the demo task is still running then we expect the loop counters to
	have incremented since this function was last called. */
	if( ulLastLoopCounter == ulLoopCounter )
 20010d0:	d0e02d17 	ldw	r3,-32588(gp)
 20010d4:	d0a02817 	ldw	r2,-32608(gp)
 20010d8:	1880021e 	bne	r3,r2,20010e4 <xAreGenericQueueTasksStillRunning+0x20>
	{
		xErrorDetected = pdTRUE;
 20010dc:	00800044 	movi	r2,1
 20010e0:	d0a02715 	stw	r2,-32612(gp)
	}

	if( ulLastLoopCounter2 == ulLoopCounter2 )
 20010e4:	d0e02e17 	ldw	r3,-32584(gp)
 20010e8:	d0a02917 	ldw	r2,-32604(gp)
 20010ec:	1880021e 	bne	r3,r2,20010f8 <xAreGenericQueueTasksStillRunning+0x34>
	{
		xErrorDetected = pdTRUE;
 20010f0:	00800044 	movi	r2,1
 20010f4:	d0a02715 	stw	r2,-32612(gp)
	}

	ulLastLoopCounter = ulLoopCounter;
 20010f8:	d0a02817 	ldw	r2,-32608(gp)
 20010fc:	d0a02d15 	stw	r2,-32588(gp)
	ulLastLoopCounter2 = ulLoopCounter2;
 2001100:	d0a02917 	ldw	r2,-32604(gp)
 2001104:	d0a02e15 	stw	r2,-32584(gp)

	/* Errors detected in the task itself will have latched xErrorDetected
	to true. */

	return ( BaseType_t ) !xErrorDetected;
 2001108:	d0a02717 	ldw	r2,-32612(gp)
 200110c:	1005003a 	cmpeq	r2,r2,zero
 2001110:	10803fcc 	andi	r2,r2,255
}
 2001114:	e037883a 	mov	sp,fp
 2001118:	df000017 	ldw	fp,0(sp)
 200111c:	dec00104 	addi	sp,sp,4
 2001120:	f800283a 	ret

02001124 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
 2001124:	defffb04 	addi	sp,sp,-20
 2001128:	dfc00415 	stw	ra,16(sp)
 200112c:	df000315 	stw	fp,12(sp)
 2001130:	df000304 	addi	fp,sp,12
 2001134:	e13fff15 	stw	r4,-4(fp)
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
 2001138:	000d883a 	mov	r6,zero
 200113c:	01400084 	movi	r5,2
 2001140:	01000284 	movi	r4,10
 2001144:	20044040 	call	2004404 <xQueueGenericCreate>
 2001148:	d0a03115 	stw	r2,-32572(gp)

	if( xPolledQueue != NULL )
 200114c:	d0a03117 	ldw	r2,-32572(gp)
 2001150:	10001426 	beq	r2,zero,20011a4 <vStartPolledQueueTasks+0x80>
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

		/* Spawn the producer and consumer. */
		xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
 2001154:	d8000115 	stw	zero,4(sp)
 2001158:	e0bfff17 	ldw	r2,-4(fp)
 200115c:	d8800015 	stw	r2,0(sp)
 2001160:	d1e03104 	addi	r7,gp,-32572
 2001164:	01810004 	movi	r6,1024
 2001168:	01408074 	movhi	r5,513
 200116c:	29488304 	addi	r5,r5,8716
 2001170:	01008034 	movhi	r4,512
 2001174:	21049804 	addi	r4,r4,4704
 2001178:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
 200117c:	d8000115 	stw	zero,4(sp)
 2001180:	e0bfff17 	ldw	r2,-4(fp)
 2001184:	d8800015 	stw	r2,0(sp)
 2001188:	d1e03104 	addi	r7,gp,-32572
 200118c:	01810004 	movi	r6,1024
 2001190:	01408074 	movhi	r5,513
 2001194:	29488504 	addi	r5,r5,8724
 2001198:	01008034 	movhi	r4,512
 200119c:	21046f04 	addi	r4,r4,4540
 20011a0:	20053c80 	call	20053c8 <xTaskCreate>
	}
}
 20011a4:	0001883a 	nop
 20011a8:	e037883a 	mov	sp,fp
 20011ac:	dfc00117 	ldw	ra,4(sp)
 20011b0:	df000017 	ldw	fp,0(sp)
 20011b4:	dec00204 	addi	sp,sp,8
 20011b8:	f800283a 	ret

020011bc <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
 20011bc:	defffa04 	addi	sp,sp,-24
 20011c0:	dfc00515 	stw	ra,20(sp)
 20011c4:	df000415 	stw	fp,16(sp)
 20011c8:	df000404 	addi	fp,sp,16
 20011cc:	e13fff15 	stw	r4,-4(fp)
uint16_t usValue = ( uint16_t ) 0;
 20011d0:	e03ffe0d 	sth	zero,-8(fp)
BaseType_t xError = pdFALSE, xLoop;
 20011d4:	e03ffc15 	stw	zero,-16(fp)

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
 20011d8:	e03ffd15 	stw	zero,-12(fp)
 20011dc:	00001a06 	br	2001248 <vPolledQueueProducer+0x8c>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
 20011e0:	e0bfff17 	ldw	r2,-4(fp)
 20011e4:	10800017 	ldw	r2,0(r2)
 20011e8:	e0fffe04 	addi	r3,fp,-8
 20011ec:	000f883a 	mov	r7,zero
 20011f0:	000d883a 	mov	r6,zero
 20011f4:	180b883a 	mov	r5,r3
 20011f8:	1009883a 	mov	r4,r2
 20011fc:	20047700 	call	2004770 <xQueueGenericSend>
 2001200:	10800060 	cmpeqi	r2,r2,1
 2001204:	1000031e 	bne	r2,zero,2001214 <vPolledQueueProducer+0x58>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
 2001208:	00800044 	movi	r2,1
 200120c:	e0bffc15 	stw	r2,-16(fp)
 2001210:	00000a06 	br	200123c <vPolledQueueProducer+0x80>
			}
			else
			{
				if( xError == pdFALSE )
 2001214:	e0bffc17 	ldw	r2,-16(fp)
 2001218:	1000051e 	bne	r2,zero,2001230 <vPolledQueueProducer+0x74>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
 200121c:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
						xPollingProducerCount++;
 2001220:	d0a03017 	ldw	r2,-32576(gp)
 2001224:	10800044 	addi	r2,r2,1
 2001228:	d0a03015 	stw	r2,-32576(gp)
					portEXIT_CRITICAL();
 200122c:	2006ef80 	call	2006ef8 <vTaskExitCritical>
				}

				/* Update the value we are going to post next time around. */
				usValue++;
 2001230:	e0bffe0b 	ldhu	r2,-8(fp)
 2001234:	10800044 	addi	r2,r2,1
 2001238:	e0bffe0d 	sth	r2,-8(fp)
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
 200123c:	e0bffd17 	ldw	r2,-12(fp)
 2001240:	10800044 	addi	r2,r2,1
 2001244:	e0bffd15 	stw	r2,-12(fp)
 2001248:	e0bffd17 	ldw	r2,-12(fp)
 200124c:	108000d0 	cmplti	r2,r2,3
 2001250:	103fe31e 	bne	r2,zero,20011e0 <__reset+0xfe0001e0>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
 2001254:	01003204 	movi	r4,200
 2001258:	20059600 	call	2005960 <vTaskDelay>
	}
 200125c:	003fde06 	br	20011d8 <__reset+0xfe0001d8>

02001260 <vPolledQueueConsumer>:
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
 2001260:	defffa04 	addi	sp,sp,-24
 2001264:	dfc00515 	stw	ra,20(sp)
 2001268:	df000415 	stw	fp,16(sp)
 200126c:	df000404 	addi	fp,sp,16
 2001270:	e13fff15 	stw	r4,-4(fp)
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
 2001274:	e03ffc0d 	sth	zero,-16(fp)
BaseType_t xError = pdFALSE;
 2001278:	e03ffd15 	stw	zero,-12(fp)

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
 200127c:	00001d06 	br	20012f4 <vPolledQueueConsumer+0x94>
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
 2001280:	e0bfff17 	ldw	r2,-4(fp)
 2001284:	10800017 	ldw	r2,0(r2)
 2001288:	e0fffe04 	addi	r3,fp,-8
 200128c:	000f883a 	mov	r7,zero
 2001290:	000d883a 	mov	r6,zero
 2001294:	180b883a 	mov	r5,r3
 2001298:	1009883a 	mov	r4,r2
 200129c:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 20012a0:	10800058 	cmpnei	r2,r2,1
 20012a4:	1000131e 	bne	r2,zero,20012f4 <vPolledQueueConsumer+0x94>
			{
				if( usData != usExpectedValue )
 20012a8:	e0bffe0b 	ldhu	r2,-8(fp)
 20012ac:	10ffffcc 	andi	r3,r2,65535
 20012b0:	e0bffc0b 	ldhu	r2,-16(fp)
 20012b4:	18800526 	beq	r3,r2,20012cc <vPolledQueueConsumer+0x6c>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
 20012b8:	00800044 	movi	r2,1
 20012bc:	e0bffd15 	stw	r2,-12(fp)

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
 20012c0:	e0bffe0b 	ldhu	r2,-8(fp)
 20012c4:	e0bffc0d 	sth	r2,-16(fp)
 20012c8:	00000706 	br	20012e8 <vPolledQueueConsumer+0x88>
				}
				else
				{
					if( xError == pdFALSE )
 20012cc:	e0bffd17 	ldw	r2,-12(fp)
 20012d0:	1000051e 	bne	r2,zero,20012e8 <vPolledQueueConsumer+0x88>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
 20012d4:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
							xPollingConsumerCount++;
 20012d8:	d0a02f17 	ldw	r2,-32580(gp)
 20012dc:	10800044 	addi	r2,r2,1
 20012e0:	d0a02f15 	stw	r2,-32580(gp)
						portEXIT_CRITICAL();
 20012e4:	2006ef80 	call	2006ef8 <vTaskExitCritical>
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
 20012e8:	e0bffc0b 	ldhu	r2,-16(fp)
 20012ec:	10800044 	addi	r2,r2,1
 20012f0:	e0bffc0d 	sth	r2,-16(fp)
BaseType_t xError = pdFALSE;

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
 20012f4:	e0bfff17 	ldw	r2,-4(fp)
 20012f8:	10800017 	ldw	r2,0(r2)
 20012fc:	1009883a 	mov	r4,r2
 2001300:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 2001304:	103fde1e 	bne	r2,zero,2001280 <__reset+0xfe000280>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
 2001308:	01002d04 	movi	r4,180
 200130c:	20059600 	call	2005960 <vTaskDelay>
	}
 2001310:	003fda06 	br	200127c <__reset+0xfe00027c>

02001314 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
 2001314:	defffe04 	addi	sp,sp,-8
 2001318:	df000115 	stw	fp,4(sp)
 200131c:	df000104 	addi	fp,sp,4

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
 2001320:	d0a02f17 	ldw	r2,-32580(gp)
 2001324:	10000226 	beq	r2,zero,2001330 <xArePollingQueuesStillRunning+0x1c>
		( xPollingProducerCount == pollqINITIAL_VALUE )
 2001328:	d0a03017 	ldw	r2,-32576(gp)

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
 200132c:	1000021e 	bne	r2,zero,2001338 <xArePollingQueuesStillRunning+0x24>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
 2001330:	e03fff15 	stw	zero,-4(fp)
 2001334:	00000206 	br	2001340 <xArePollingQueuesStillRunning+0x2c>
	}
	else
	{
		xReturn = pdTRUE;
 2001338:	00800044 	movi	r2,1
 200133c:	e0bfff15 	stw	r2,-4(fp)
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
 2001340:	d0202f15 	stw	zero,-32580(gp)
	xPollingProducerCount = pollqINITIAL_VALUE;
 2001344:	d0203015 	stw	zero,-32576(gp)

	return xReturn;
 2001348:	e0bfff17 	ldw	r2,-4(fp)
}
 200134c:	e037883a 	mov	sp,fp
 2001350:	df000017 	ldw	fp,0(sp)
 2001354:	dec00104 	addi	sp,sp,4
 2001358:	f800283a 	ret

0200135c <vStartQueuePeekTasks>:
/* Handles to the test tasks. */
TaskHandle_t xMediumPriorityTask, xHighPriorityTask, xHighestPriorityTask;
/*-----------------------------------------------------------*/

void vStartQueuePeekTasks( void )
{
 200135c:	defffb04 	addi	sp,sp,-20
 2001360:	dfc00415 	stw	ra,16(sp)
 2001364:	df000315 	stw	fp,12(sp)
 2001368:	df000304 	addi	fp,sp,12
QueueHandle_t xQueue;

	/* Create the queue that we are going to use for the test/demo. */
	xQueue = xQueueCreate( qpeekQUEUE_LENGTH, sizeof( uint32_t ) );
 200136c:	000d883a 	mov	r6,zero
 2001370:	01400104 	movi	r5,4
 2001374:	01000144 	movi	r4,5
 2001378:	20044040 	call	2004404 <xQueueGenericCreate>
 200137c:	e0bfff15 	stw	r2,-4(fp)

	if( xQueue != NULL )
 2001380:	e0bfff17 	ldw	r2,-4(fp)
 2001384:	10002a26 	beq	r2,zero,2001430 <vStartQueuePeekTasks+0xd4>
		vQueueAddToRegistry( xQueue, "QPeek_Test_Queue" );

		/* Create the demo tasks and pass it the queue just created.  We are
		passing the queue handle by value so it does not matter that it is declared
		on the stack here. */
		xTaskCreate( prvLowPriorityPeekTask, "PeekL", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekLOW_PRIORITY, NULL );
 2001388:	d8000115 	stw	zero,4(sp)
 200138c:	d8000015 	stw	zero,0(sp)
 2001390:	e1ffff17 	ldw	r7,-4(fp)
 2001394:	01810004 	movi	r6,1024
 2001398:	01408074 	movhi	r5,513
 200139c:	29488704 	addi	r5,r5,8732
 20013a0:	01008034 	movhi	r4,512
 20013a4:	2105c004 	addi	r4,r4,5888
 20013a8:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( prvMediumPriorityPeekTask, "PeekM", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekMEDIUM_PRIORITY, &xMediumPriorityTask );
 20013ac:	d0a03604 	addi	r2,gp,-32552
 20013b0:	d8800115 	stw	r2,4(sp)
 20013b4:	00800044 	movi	r2,1
 20013b8:	d8800015 	stw	r2,0(sp)
 20013bc:	e1ffff17 	ldw	r7,-4(fp)
 20013c0:	01810004 	movi	r6,1024
 20013c4:	01408074 	movhi	r5,513
 20013c8:	29488904 	addi	r5,r5,8740
 20013cc:	01008034 	movhi	r4,512
 20013d0:	21059d04 	addi	r4,r4,5748
 20013d4:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( prvHighPriorityPeekTask, "PeekH1", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekHIGH_PRIORITY, &xHighPriorityTask );
 20013d8:	d0a03504 	addi	r2,gp,-32556
 20013dc:	d8800115 	stw	r2,4(sp)
 20013e0:	00800084 	movi	r2,2
 20013e4:	d8800015 	stw	r2,0(sp)
 20013e8:	e1ffff17 	ldw	r7,-4(fp)
 20013ec:	01810004 	movi	r6,1024
 20013f0:	01408074 	movhi	r5,513
 20013f4:	29488b04 	addi	r5,r5,8748
 20013f8:	01008034 	movhi	r4,512
 20013fc:	21056b04 	addi	r4,r4,5548
 2001400:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( prvHighestPriorityPeekTask, "PeekH2", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekHIGHEST_PRIORITY, &xHighestPriorityTask );
 2001404:	d0a03704 	addi	r2,gp,-32548
 2001408:	d8800115 	stw	r2,4(sp)
 200140c:	008000c4 	movi	r2,3
 2001410:	d8800015 	stw	r2,0(sp)
 2001414:	e1ffff17 	ldw	r7,-4(fp)
 2001418:	01810004 	movi	r6,1024
 200141c:	01408074 	movhi	r5,513
 2001420:	29488d04 	addi	r5,r5,8756
 2001424:	01008034 	movhi	r4,512
 2001428:	21051204 	addi	r4,r4,5192
 200142c:	20053c80 	call	20053c8 <xTaskCreate>
	}
}
 2001430:	0001883a 	nop
 2001434:	e037883a 	mov	sp,fp
 2001438:	dfc00117 	ldw	ra,4(sp)
 200143c:	df000017 	ldw	fp,0(sp)
 2001440:	dec00204 	addi	sp,sp,8
 2001444:	f800283a 	ret

02001448 <prvHighestPriorityPeekTask>:
/*-----------------------------------------------------------*/

static void prvHighestPriorityPeekTask( void *pvParameters )
{
 2001448:	defffb04 	addi	sp,sp,-20
 200144c:	dfc00415 	stw	ra,16(sp)
 2001450:	df000315 	stw	fp,12(sp)
 2001454:	df000304 	addi	fp,sp,12
 2001458:	e13fff15 	stw	r4,-4(fp)
QueueHandle_t xQueue = ( QueueHandle_t ) pvParameters;
 200145c:	e0bfff17 	ldw	r2,-4(fp)
 2001460:	e0bffd15 	stw	r2,-12(fp)

	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the high priority task to execute. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
 2001464:	e0bffe04 	addi	r2,fp,-8
 2001468:	01c00044 	movi	r7,1
 200146c:	01bfffc4 	movi	r6,-1
 2001470:	100b883a 	mov	r5,r2
 2001474:	e13ffd17 	ldw	r4,-12(fp)
 2001478:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 200147c:	10800060 	cmpeqi	r2,r2,1
 2001480:	1000021e 	bne	r2,zero,200148c <prvHighestPriorityPeekTask+0x44>
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
 2001484:	00800044 	movi	r2,1
 2001488:	d0a03215 	stw	r2,-32568(gp)
		be blocked on the queue.  We unblocked because the low priority task
		wrote a value to the queue, which we should have peeked.  Peeking the
		data (rather than receiving it) will leave the data on the queue, so
		the high priority task should then have also been unblocked, but not
		yet executed. */
		if( ulValue != 0x11223344 )
 200148c:	e0fffe17 	ldw	r3,-8(fp)
 2001490:	008448b4 	movhi	r2,4386
 2001494:	108cd104 	addi	r2,r2,13124
 2001498:	18800226 	beq	r3,r2,20014a4 <prvHighestPriorityPeekTask+0x5c>
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
 200149c:	00800044 	movi	r2,1
 20014a0:	d0a03215 	stw	r2,-32568(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
 20014a4:	e13ffd17 	ldw	r4,-12(fp)
 20014a8:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 20014ac:	10800060 	cmpeqi	r2,r2,1
 20014b0:	1000021e 	bne	r2,zero,20014bc <prvHighestPriorityPeekTask+0x74>
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
 20014b4:	00800044 	movi	r2,1
 20014b8:	d0a03215 	stw	r2,-32568(gp)
		}

		/* Now we are going to actually receive the data, so when the high
		priority task runs it will find the queue empty and return to the
		blocked state. */
		ulValue = 0;
 20014bc:	e03ffe15 	stw	zero,-8(fp)
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
 20014c0:	e0bffe04 	addi	r2,fp,-8
 20014c4:	000f883a 	mov	r7,zero
 20014c8:	000d883a 	mov	r6,zero
 20014cc:	100b883a 	mov	r5,r2
 20014d0:	e13ffd17 	ldw	r4,-12(fp)
 20014d4:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 20014d8:	10800060 	cmpeqi	r2,r2,1
 20014dc:	1000021e 	bne	r2,zero,20014e8 <prvHighestPriorityPeekTask+0xa0>
		{
			/* We expected to receive the value. */
			xErrorDetected = pdTRUE;
 20014e0:	00800044 	movi	r2,1
 20014e4:	d0a03215 	stw	r2,-32568(gp)
		}

		if( ulValue != 0x11223344 )
 20014e8:	e0fffe17 	ldw	r3,-8(fp)
 20014ec:	008448b4 	movhi	r2,4386
 20014f0:	108cd104 	addi	r2,r2,13124
 20014f4:	18800226 	beq	r3,r2,2001500 <prvHighestPriorityPeekTask+0xb8>
		{
			/* We did not receive the expected value - which should have been
			the same value as was peeked. */
			xErrorDetected = pdTRUE;
 20014f8:	00800044 	movi	r2,1
 20014fc:	d0a03215 	stw	r2,-32568(gp)
		}

		/* Now we will block again as the queue is once more empty.  The low
		priority task can then execute again. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
 2001500:	e0bffe04 	addi	r2,fp,-8
 2001504:	01c00044 	movi	r7,1
 2001508:	01bfffc4 	movi	r6,-1
 200150c:	100b883a 	mov	r5,r2
 2001510:	e13ffd17 	ldw	r4,-12(fp)
 2001514:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2001518:	10800060 	cmpeqi	r2,r2,1
 200151c:	1000021e 	bne	r2,zero,2001528 <prvHighestPriorityPeekTask+0xe0>
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
 2001520:	00800044 	movi	r2,1
 2001524:	d0a03215 	stw	r2,-32568(gp)
		}

		/* When we get here the low priority task should have again written to the
		queue. */
		if( ulValue != 0x01234567 )
 2001528:	e0fffe17 	ldw	r3,-8(fp)
 200152c:	008048f4 	movhi	r2,291
 2001530:	109159c4 	addi	r2,r2,17767
 2001534:	18800226 	beq	r3,r2,2001540 <prvHighestPriorityPeekTask+0xf8>
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
 2001538:	00800044 	movi	r2,1
 200153c:	d0a03215 	stw	r2,-32568(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
 2001540:	e13ffd17 	ldw	r4,-12(fp)
 2001544:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 2001548:	10800060 	cmpeqi	r2,r2,1
 200154c:	1000021e 	bne	r2,zero,2001558 <prvHighestPriorityPeekTask+0x110>
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
 2001550:	00800044 	movi	r2,1
 2001554:	d0a03215 	stw	r2,-32568(gp)

		/* We only peeked the data, so suspending ourselves now should enable
		the high priority task to also peek the data.  The high priority task
		will have been unblocked when we peeked the data as we left the data
		in the queue. */
		vTaskSuspend( NULL );
 2001558:	0009883a 	mov	r4,zero
 200155c:	2005c340 	call	2005c34 <vTaskSuspend>


		/* This time we are going to do the same as the above test, but the
		high priority task is going to receive the data, rather than peek it.
		This means that the medium priority task should never peek the value. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
 2001560:	e0bffe04 	addi	r2,fp,-8
 2001564:	01c00044 	movi	r7,1
 2001568:	01bfffc4 	movi	r6,-1
 200156c:	100b883a 	mov	r5,r2
 2001570:	e13ffd17 	ldw	r4,-12(fp)
 2001574:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2001578:	10800060 	cmpeqi	r2,r2,1
 200157c:	1000021e 	bne	r2,zero,2001588 <prvHighestPriorityPeekTask+0x140>
		{
			xErrorDetected = pdTRUE;
 2001580:	00800044 	movi	r2,1
 2001584:	d0a03215 	stw	r2,-32568(gp)
		}

		if( ulValue != 0xaabbaabb )
 2001588:	e0fffe17 	ldw	r3,-8(fp)
 200158c:	00aaaf34 	movhi	r2,43708
 2001590:	10aaaec4 	addi	r2,r2,-21829
 2001594:	18800226 	beq	r3,r2,20015a0 <prvHighestPriorityPeekTask+0x158>
		{
			xErrorDetected = pdTRUE;
 2001598:	00800044 	movi	r2,1
 200159c:	d0a03215 	stw	r2,-32568(gp)
		}

		vTaskSuspend( NULL );
 20015a0:	0009883a 	mov	r4,zero
 20015a4:	2005c340 	call	2005c34 <vTaskSuspend>
	}
 20015a8:	003fae06 	br	2001464 <__reset+0xfe000464>

020015ac <prvHighPriorityPeekTask>:
}
/*-----------------------------------------------------------*/

static void prvHighPriorityPeekTask( void *pvParameters )
{
 20015ac:	defffb04 	addi	sp,sp,-20
 20015b0:	dfc00415 	stw	ra,16(sp)
 20015b4:	df000315 	stw	fp,12(sp)
 20015b8:	df000304 	addi	fp,sp,12
 20015bc:	e13fff15 	stw	r4,-4(fp)
QueueHandle_t xQueue = ( QueueHandle_t ) pvParameters;
 20015c0:	e0bfff17 	ldw	r2,-4(fp)
 20015c4:	e0bffd15 	stw	r2,-12(fp)
	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the medium priority task to execute.  Both the high
		and highest priority tasks will then be blocked on the queue. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
 20015c8:	e0bffe04 	addi	r2,fp,-8
 20015cc:	01c00044 	movi	r7,1
 20015d0:	01bfffc4 	movi	r6,-1
 20015d4:	100b883a 	mov	r5,r2
 20015d8:	e13ffd17 	ldw	r4,-12(fp)
 20015dc:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 20015e0:	10800060 	cmpeqi	r2,r2,1
 20015e4:	1000021e 	bne	r2,zero,20015f0 <prvHighPriorityPeekTask+0x44>
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
 20015e8:	00800044 	movi	r2,1
 20015ec:	d0a03215 	stw	r2,-32568(gp)
		}

		/* When we get here the highest priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
 20015f0:	e0fffe17 	ldw	r3,-8(fp)
 20015f4:	008048f4 	movhi	r2,291
 20015f8:	109159c4 	addi	r2,r2,17767
 20015fc:	18800226 	beq	r3,r2,2001608 <prvHighPriorityPeekTask+0x5c>
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
 2001600:	00800044 	movi	r2,1
 2001604:	d0a03215 	stw	r2,-32568(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
 2001608:	e13ffd17 	ldw	r4,-12(fp)
 200160c:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 2001610:	10800060 	cmpeqi	r2,r2,1
 2001614:	1000021e 	bne	r2,zero,2001620 <prvHighPriorityPeekTask+0x74>
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
 2001618:	00800044 	movi	r2,1
 200161c:	d0a03215 	stw	r2,-32568(gp)

		/* We only peeked the data, so suspending ourselves now should enable
		the medium priority task to also peek the data.  The medium priority task
		will have been unblocked when we peeked the data as we left the data
		in the queue. */
		vTaskSuspend( NULL );
 2001620:	0009883a 	mov	r4,zero
 2001624:	2005c340 	call	2005c34 <vTaskSuspend>


		/* This time we are going actually receive the value, so the medium
		priority task will never peek the data - we removed it from the queue. */
		if( xQueueReceive( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
 2001628:	e0bffe04 	addi	r2,fp,-8
 200162c:	000f883a 	mov	r7,zero
 2001630:	01bfffc4 	movi	r6,-1
 2001634:	100b883a 	mov	r5,r2
 2001638:	e13ffd17 	ldw	r4,-12(fp)
 200163c:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2001640:	10800060 	cmpeqi	r2,r2,1
 2001644:	1000021e 	bne	r2,zero,2001650 <prvHighPriorityPeekTask+0xa4>
		{
			xErrorDetected = pdTRUE;
 2001648:	00800044 	movi	r2,1
 200164c:	d0a03215 	stw	r2,-32568(gp)
		}

		if( ulValue != 0xaabbaabb )
 2001650:	e0fffe17 	ldw	r3,-8(fp)
 2001654:	00aaaf34 	movhi	r2,43708
 2001658:	10aaaec4 	addi	r2,r2,-21829
 200165c:	18800226 	beq	r3,r2,2001668 <prvHighPriorityPeekTask+0xbc>
		{
			xErrorDetected = pdTRUE;
 2001660:	00800044 	movi	r2,1
 2001664:	d0a03215 	stw	r2,-32568(gp)
		}

		vTaskSuspend( NULL );
 2001668:	0009883a 	mov	r4,zero
 200166c:	2005c340 	call	2005c34 <vTaskSuspend>
	}
 2001670:	003fd506 	br	20015c8 <__reset+0xfe0005c8>

02001674 <prvMediumPriorityPeekTask>:
}
/*-----------------------------------------------------------*/

static void prvMediumPriorityPeekTask( void *pvParameters )
{
 2001674:	defffb04 	addi	sp,sp,-20
 2001678:	dfc00415 	stw	ra,16(sp)
 200167c:	df000315 	stw	fp,12(sp)
 2001680:	df000304 	addi	fp,sp,12
 2001684:	e13fff15 	stw	r4,-4(fp)
QueueHandle_t xQueue = ( QueueHandle_t ) pvParameters;
 2001688:	e0bfff17 	ldw	r2,-4(fp)
 200168c:	e0bffd15 	stw	r2,-12(fp)
	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the low priority task to execute.  The highest, high
		and medium priority tasks will then all be blocked on the queue. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
 2001690:	e0bffe04 	addi	r2,fp,-8
 2001694:	01c00044 	movi	r7,1
 2001698:	01bfffc4 	movi	r6,-1
 200169c:	100b883a 	mov	r5,r2
 20016a0:	e13ffd17 	ldw	r4,-12(fp)
 20016a4:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 20016a8:	10800060 	cmpeqi	r2,r2,1
 20016ac:	1000021e 	bne	r2,zero,20016b8 <prvMediumPriorityPeekTask+0x44>
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
 20016b0:	00800044 	movi	r2,1
 20016b4:	d0a03215 	stw	r2,-32568(gp)
		}

		/* When we get here the high priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
 20016b8:	e0fffe17 	ldw	r3,-8(fp)
 20016bc:	008048f4 	movhi	r2,291
 20016c0:	109159c4 	addi	r2,r2,17767
 20016c4:	18800226 	beq	r3,r2,20016d0 <prvMediumPriorityPeekTask+0x5c>
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
 20016c8:	00800044 	movi	r2,1
 20016cc:	d0a03215 	stw	r2,-32568(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
 20016d0:	e13ffd17 	ldw	r4,-12(fp)
 20016d4:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 20016d8:	10800060 	cmpeqi	r2,r2,1
 20016dc:	1000021e 	bne	r2,zero,20016e8 <prvMediumPriorityPeekTask+0x74>
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
 20016e0:	00800044 	movi	r2,1
 20016e4:	d0a03215 	stw	r2,-32568(gp)
		}

		/* Just so we know the test is still running. */
		ulLoopCounter++;
 20016e8:	d0a03317 	ldw	r2,-32564(gp)
 20016ec:	10800044 	addi	r2,r2,1
 20016f0:	d0a03315 	stw	r2,-32564(gp)

		/* Now we can suspend ourselves so the low priority task can execute
		again. */
		vTaskSuspend( NULL );
 20016f4:	0009883a 	mov	r4,zero
 20016f8:	2005c340 	call	2005c34 <vTaskSuspend>
	}
 20016fc:	003fe406 	br	2001690 <__reset+0xfe000690>

02001700 <prvLowPriorityPeekTask>:
}
/*-----------------------------------------------------------*/

static void prvLowPriorityPeekTask( void *pvParameters )
{
 2001700:	defffb04 	addi	sp,sp,-20
 2001704:	dfc00415 	stw	ra,16(sp)
 2001708:	df000315 	stw	fp,12(sp)
 200170c:	df000304 	addi	fp,sp,12
 2001710:	e13fff15 	stw	r4,-4(fp)
QueueHandle_t xQueue = ( QueueHandle_t ) pvParameters;
 2001714:	e0bfff17 	ldw	r2,-4(fp)
 2001718:	e0bffd15 	stw	r2,-12(fp)

	for( ;; )
	{
		/* Write some data to the queue.  This should unblock the highest
		priority task that is waiting to peek data from the queue. */
		ulValue = 0x11223344;
 200171c:	008448b4 	movhi	r2,4386
 2001720:	108cd104 	addi	r2,r2,13124
 2001724:	e0bffe15 	stw	r2,-8(fp)
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
 2001728:	e0bffe04 	addi	r2,fp,-8
 200172c:	000f883a 	mov	r7,zero
 2001730:	000d883a 	mov	r6,zero
 2001734:	100b883a 	mov	r5,r2
 2001738:	e13ffd17 	ldw	r4,-12(fp)
 200173c:	20047700 	call	2004770 <xQueueGenericSend>
 2001740:	10800060 	cmpeqi	r2,r2,1
 2001744:	1000021e 	bne	r2,zero,2001750 <prvLowPriorityPeekTask+0x50>
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
 2001748:	00800044 	movi	r2,1
 200174c:	d0a03215 	stw	r2,-32568(gp)
			taskYIELD();
		#endif

		/* By the time we get here the data should have been removed from
		the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
 2001750:	e13ffd17 	ldw	r4,-12(fp)
 2001754:	2004e7c0 	call	2004e7c <uxQueueMessagesWaiting>
 2001758:	10000226 	beq	r2,zero,2001764 <prvLowPriorityPeekTask+0x64>
		{
			xErrorDetected = pdTRUE;
 200175c:	00800044 	movi	r2,1
 2001760:	d0a03215 	stw	r2,-32568(gp)
		}

		/* Write another value to the queue, again waking the highest priority
		task that is blocked on the queue. */
		ulValue = 0x01234567;
 2001764:	008048f4 	movhi	r2,291
 2001768:	109159c4 	addi	r2,r2,17767
 200176c:	e0bffe15 	stw	r2,-8(fp)
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
 2001770:	e0bffe04 	addi	r2,fp,-8
 2001774:	000f883a 	mov	r7,zero
 2001778:	000d883a 	mov	r6,zero
 200177c:	100b883a 	mov	r5,r2
 2001780:	e13ffd17 	ldw	r4,-12(fp)
 2001784:	20047700 	call	2004770 <xQueueGenericSend>
 2001788:	10800060 	cmpeqi	r2,r2,1
 200178c:	1000021e 	bne	r2,zero,2001798 <prvLowPriorityPeekTask+0x98>
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
 2001790:	00800044 	movi	r2,1
 2001794:	d0a03215 	stw	r2,-32568(gp)
			taskYIELD();
		#endif

		/* All the other tasks should now have successfully peeked the data.
		The data is still in the queue so we should be able to receive it. */
		ulValue = 0;
 2001798:	e03ffe15 	stw	zero,-8(fp)
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
 200179c:	e0bffe04 	addi	r2,fp,-8
 20017a0:	000f883a 	mov	r7,zero
 20017a4:	000d883a 	mov	r6,zero
 20017a8:	100b883a 	mov	r5,r2
 20017ac:	e13ffd17 	ldw	r4,-12(fp)
 20017b0:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 20017b4:	10800060 	cmpeqi	r2,r2,1
 20017b8:	1000021e 	bne	r2,zero,20017c4 <prvLowPriorityPeekTask+0xc4>
		{
			/* We expected to receive the data. */
			xErrorDetected = pdTRUE;
 20017bc:	00800044 	movi	r2,1
 20017c0:	d0a03215 	stw	r2,-32568(gp)
			/* We did not receive the expected value. */
		}

		/* Lets just delay a while as this is an intensive test as we don't
		want to starve other tests of processing time. */
		vTaskDelay( qpeekSHORT_DELAY );
 20017c4:	01000284 	movi	r4,10
 20017c8:	20059600 	call	2005960 <vTaskDelay>
		/* Unsuspend the other tasks so we can repeat the test - this time
		however not all the other tasks will peek the data as the high
		priority task is actually going to remove it from the queue.  Send
		to front is used just to be different.  As the queue is empty it
		makes no difference to the result. */
		vTaskResume( xMediumPriorityTask );
 20017cc:	d0a03617 	ldw	r2,-32552(gp)
 20017d0:	1009883a 	mov	r4,r2
 20017d4:	2005da80 	call	2005da8 <vTaskResume>
		vTaskResume( xHighPriorityTask );
 20017d8:	d0a03517 	ldw	r2,-32556(gp)
 20017dc:	1009883a 	mov	r4,r2
 20017e0:	2005da80 	call	2005da8 <vTaskResume>
		vTaskResume( xHighestPriorityTask );
 20017e4:	d0a03717 	ldw	r2,-32548(gp)
 20017e8:	1009883a 	mov	r4,r2
 20017ec:	2005da80 	call	2005da8 <vTaskResume>

		#if( configUSE_PREEMPTION == 0 )
			taskYIELD();
		#endif

		ulValue = 0xaabbaabb;
 20017f0:	00aaaf34 	movhi	r2,43708
 20017f4:	10aaaec4 	addi	r2,r2,-21829
 20017f8:	e0bffe15 	stw	r2,-8(fp)
		if( xQueueSendToFront( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
 20017fc:	e0bffe04 	addi	r2,fp,-8
 2001800:	01c00044 	movi	r7,1
 2001804:	000d883a 	mov	r6,zero
 2001808:	100b883a 	mov	r5,r2
 200180c:	e13ffd17 	ldw	r4,-12(fp)
 2001810:	20047700 	call	2004770 <xQueueGenericSend>
 2001814:	10800060 	cmpeqi	r2,r2,1
 2001818:	1000021e 	bne	r2,zero,2001824 <prvLowPriorityPeekTask+0x124>
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
 200181c:	00800044 	movi	r2,1
 2001820:	d0a03215 	stw	r2,-32568(gp)
			taskYIELD();
		#endif

		/* This time we should find that the queue is empty.  The high priority
		task actually removed the data rather than just peeking it. */
		if( xQueuePeek( xQueue, &ulValue, qpeekNO_BLOCK ) != errQUEUE_EMPTY )
 2001824:	e0bffe04 	addi	r2,fp,-8
 2001828:	01c00044 	movi	r7,1
 200182c:	000d883a 	mov	r6,zero
 2001830:	100b883a 	mov	r5,r2
 2001834:	e13ffd17 	ldw	r4,-12(fp)
 2001838:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 200183c:	10000226 	beq	r2,zero,2001848 <prvLowPriorityPeekTask+0x148>
		{
			/* We expected to receive the data. */
			xErrorDetected = pdTRUE;
 2001840:	00800044 	movi	r2,1
 2001844:	d0a03215 	stw	r2,-32568(gp)
		}

		/* Unsuspend the highest and high priority tasks so we can go back
		and repeat the whole thing.  The medium priority task should not be
		suspended as it was not able to peek the data in this last case. */
		vTaskResume( xHighPriorityTask );
 2001848:	d0a03517 	ldw	r2,-32556(gp)
 200184c:	1009883a 	mov	r4,r2
 2001850:	2005da80 	call	2005da8 <vTaskResume>
		vTaskResume( xHighestPriorityTask );
 2001854:	d0a03717 	ldw	r2,-32548(gp)
 2001858:	1009883a 	mov	r4,r2
 200185c:	2005da80 	call	2005da8 <vTaskResume>

		/* Lets just delay a while as this is an intensive test as we don't
		want to starve other tests of processing time. */
		vTaskDelay( qpeekSHORT_DELAY );
 2001860:	01000284 	movi	r4,10
 2001864:	20059600 	call	2005960 <vTaskDelay>
	}
 2001868:	003fac06 	br	200171c <__reset+0xfe00071c>

0200186c <xAreQueuePeekTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreQueuePeekTasksStillRunning( void )
{
 200186c:	deffff04 	addi	sp,sp,-4
 2001870:	df000015 	stw	fp,0(sp)
 2001874:	d839883a 	mov	fp,sp
static uint32_t ulLastLoopCounter = 0;

	/* If the demo task is still running then we expect the loopcounter to
	have incremented since this function was last called. */
	if( ulLastLoopCounter == ulLoopCounter )
 2001878:	d0e03417 	ldw	r3,-32560(gp)
 200187c:	d0a03317 	ldw	r2,-32564(gp)
 2001880:	1880021e 	bne	r3,r2,200188c <xAreQueuePeekTasksStillRunning+0x20>
	{
		xErrorDetected = pdTRUE;
 2001884:	00800044 	movi	r2,1
 2001888:	d0a03215 	stw	r2,-32568(gp)
	}

	ulLastLoopCounter = ulLoopCounter;
 200188c:	d0a03317 	ldw	r2,-32564(gp)
 2001890:	d0a03415 	stw	r2,-32560(gp)

	/* Errors detected in the task itself will have latched xErrorDetected
	to true. */

	return ( BaseType_t ) !xErrorDetected;
 2001894:	d0a03217 	ldw	r2,-32568(gp)
 2001898:	1005003a 	cmpeq	r2,r2,zero
 200189c:	10803fcc 	andi	r2,r2,255
}
 20018a0:	e037883a 	mov	sp,fp
 20018a4:	df000017 	ldw	fp,0(sp)
 20018a8:	dec00104 	addi	sp,sp,4
 20018ac:	f800283a 	ret

020018b0 <vCreateBlockTimeTasks>:
static volatile UBaseType_t xRunIndicator;

/*-----------------------------------------------------------*/

void vCreateBlockTimeTasks( void )
{
 20018b0:	defffc04 	addi	sp,sp,-16
 20018b4:	dfc00315 	stw	ra,12(sp)
 20018b8:	df000215 	stw	fp,8(sp)
 20018bc:	df000204 	addi	fp,sp,8
	/* Create the queue on which the two tasks block. */
	xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( BaseType_t ) );
 20018c0:	000d883a 	mov	r6,zero
 20018c4:	01400104 	movi	r5,4
 20018c8:	01000144 	movi	r4,5
 20018cc:	20044040 	call	2004404 <xQueueGenericCreate>
 20018d0:	d0a03815 	stw	r2,-32544(gp)

	if( xTestQueue != NULL )
 20018d4:	d0a03817 	ldw	r2,-32544(gp)
 20018d8:	10001526 	beq	r2,zero,2001930 <vCreateBlockTimeTasks+0x80>
		removed by the pre-processor if configQUEUE_REGISTRY_SIZE is not
		defined or is defined to be less than 1. */
		vQueueAddToRegistry( xTestQueue, "Block_Time_Queue" );

		/* Create the two test tasks. */
		xTaskCreate( vPrimaryBlockTimeTestTask, "BTest1", configMINIMAL_STACK_SIZE, NULL, bktPRIMARY_PRIORITY, NULL );
 20018dc:	d8000115 	stw	zero,4(sp)
 20018e0:	00800084 	movi	r2,2
 20018e4:	d8800015 	stw	r2,0(sp)
 20018e8:	000f883a 	mov	r7,zero
 20018ec:	01810004 	movi	r6,1024
 20018f0:	01408074 	movhi	r5,513
 20018f4:	29488f04 	addi	r5,r5,8764
 20018f8:	01008034 	movhi	r4,512
 20018fc:	21065204 	addi	r4,r4,6472
 2001900:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( vSecondaryBlockTimeTestTask, "BTest2", configMINIMAL_STACK_SIZE, NULL, bktSECONDARY_PRIORITY, &xSecondary );
 2001904:	d0a03904 	addi	r2,gp,-32540
 2001908:	d8800115 	stw	r2,4(sp)
 200190c:	00800044 	movi	r2,1
 2001910:	d8800015 	stw	r2,0(sp)
 2001914:	000f883a 	mov	r7,zero
 2001918:	01810004 	movi	r6,1024
 200191c:	01408074 	movhi	r5,513
 2001920:	29489104 	addi	r5,r5,8772
 2001924:	01008034 	movhi	r4,512
 2001928:	21075c04 	addi	r4,r4,7536
 200192c:	20053c80 	call	20053c8 <xTaskCreate>
	}
}
 2001930:	0001883a 	nop
 2001934:	e037883a 	mov	sp,fp
 2001938:	dfc00117 	ldw	ra,4(sp)
 200193c:	df000017 	ldw	fp,0(sp)
 2001940:	dec00204 	addi	sp,sp,8
 2001944:	f800283a 	ret

02001948 <vPrimaryBlockTimeTestTask>:
/*-----------------------------------------------------------*/

static void vPrimaryBlockTimeTestTask( void *pvParameters )
{
 2001948:	defff804 	addi	sp,sp,-32
 200194c:	dfc00715 	stw	ra,28(sp)
 2001950:	df000615 	stw	fp,24(sp)
 2001954:	df000604 	addi	fp,sp,24
 2001958:	e13fff15 	stw	r4,-4(fp)
	{
		/*********************************************************************
		Test 0

		Basic vTaskDelay() and vTaskDelayUntil() tests. */
		prvBasicDelayTests();
 200195c:	2001ea00 	call	2001ea0 <prvBasicDelayTests>

		/*********************************************************************
		Test 1

		Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 2001960:	e03ffd15 	stw	zero,-12(fp)
 2001964:	00002306 	br	20019f4 <vPrimaryBlockTimeTestTask+0xac>
		{
			/* The queue is empty. Attempt to read from the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = ( TickType_t ) ( bktPRIMARY_BLOCK_TIME << xItem );
 2001968:	e0bffd17 	ldw	r2,-12(fp)
 200196c:	00c00284 	movi	r3,10
 2001970:	1884983a 	sll	r2,r3,r2
 2001974:	e0bffa15 	stw	r2,-24(fp)

			xTimeWhenBlocking = xTaskGetTickCount();
 2001978:	20061d40 	call	20061d4 <xTaskGetTickCount>
 200197c:	e0bffb15 	stw	r2,-20(fp)

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
 2001980:	d0a03817 	ldw	r2,-32544(gp)
 2001984:	e0fffe04 	addi	r3,fp,-8
 2001988:	000f883a 	mov	r7,zero
 200198c:	e1bffa17 	ldw	r6,-24(fp)
 2001990:	180b883a 	mov	r5,r3
 2001994:	1009883a 	mov	r4,r2
 2001998:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 200199c:	10000226 	beq	r2,zero,20019a8 <vPrimaryBlockTimeTestTask+0x60>
			{
				xErrorOccurred = pdTRUE;
 20019a0:	00800044 	movi	r2,1
 20019a4:	d0a03c15 	stw	r2,-32528(gp)
			}

			/* How long were we blocked for? */
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 20019a8:	20061d40 	call	20061d4 <xTaskGetTickCount>
 20019ac:	1007883a 	mov	r3,r2
 20019b0:	e0bffb17 	ldw	r2,-20(fp)
 20019b4:	1885c83a 	sub	r2,r3,r2
 20019b8:	e0bffc15 	stw	r2,-16(fp)

			if( xBlockedTime < xTimeToBlock )
 20019bc:	e0fffc17 	ldw	r3,-16(fp)
 20019c0:	e0bffa17 	ldw	r2,-24(fp)
 20019c4:	1880022e 	bgeu	r3,r2,20019d0 <vPrimaryBlockTimeTestTask+0x88>
			{
				/* Should not have blocked for less than we requested. */
				xErrorOccurred = pdTRUE;
 20019c8:	00800044 	movi	r2,1
 20019cc:	d0a03c15 	stw	r2,-32528(gp)
			}

			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 20019d0:	e0bffa17 	ldw	r2,-24(fp)
 20019d4:	10c003c4 	addi	r3,r2,15
 20019d8:	e0bffc17 	ldw	r2,-16(fp)
 20019dc:	1880022e 	bgeu	r3,r2,20019e8 <vPrimaryBlockTimeTestTask+0xa0>
			{
				/* Should not have blocked for longer than we requested,
				although we would not necessarily run as soon as we were
				unblocked so a margin is allowed. */
				xErrorOccurred = pdTRUE;
 20019e0:	00800044 	movi	r2,1
 20019e4:	d0a03c15 	stw	r2,-32528(gp)

		/*********************************************************************
		Test 1

		Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 20019e8:	e0bffd17 	ldw	r2,-12(fp)
 20019ec:	10800044 	addi	r2,r2,1
 20019f0:	e0bffd15 	stw	r2,-12(fp)
 20019f4:	e0bffd17 	ldw	r2,-12(fp)
 20019f8:	10800150 	cmplti	r2,r2,5
 20019fc:	103fda1e 	bne	r2,zero,2001968 <__reset+0xfe000968>
		Test 2

		Simple block time wakeup test on queue sends.

		First fill the queue.  It should be empty so all sends should pass. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 2001a00:	e03ffd15 	stw	zero,-12(fp)
 2001a04:	00000e06 	br	2001a40 <vPrimaryBlockTimeTestTask+0xf8>
		{
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 2001a08:	d0a03817 	ldw	r2,-32544(gp)
 2001a0c:	e0fffd04 	addi	r3,fp,-12
 2001a10:	000f883a 	mov	r7,zero
 2001a14:	000d883a 	mov	r6,zero
 2001a18:	180b883a 	mov	r5,r3
 2001a1c:	1009883a 	mov	r4,r2
 2001a20:	20047700 	call	2004770 <xQueueGenericSend>
 2001a24:	10800060 	cmpeqi	r2,r2,1
 2001a28:	1000021e 	bne	r2,zero,2001a34 <vPrimaryBlockTimeTestTask+0xec>
			{
				xErrorOccurred = pdTRUE;
 2001a2c:	00800044 	movi	r2,1
 2001a30:	d0a03c15 	stw	r2,-32528(gp)
		Test 2

		Simple block time wakeup test on queue sends.

		First fill the queue.  It should be empty so all sends should pass. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 2001a34:	e0bffd17 	ldw	r2,-12(fp)
 2001a38:	10800044 	addi	r2,r2,1
 2001a3c:	e0bffd15 	stw	r2,-12(fp)
 2001a40:	e0bffd17 	ldw	r2,-12(fp)
 2001a44:	10800150 	cmplti	r2,r2,5
 2001a48:	103fef1e 	bne	r2,zero,2001a08 <__reset+0xfe000a08>
			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 2001a4c:	e03ffd15 	stw	zero,-12(fp)
 2001a50:	00002306 	br	2001ae0 <vPrimaryBlockTimeTestTask+0x198>
		{
			/* The queue is full. Attempt to write to the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = ( TickType_t ) ( bktPRIMARY_BLOCK_TIME << xItem );
 2001a54:	e0bffd17 	ldw	r2,-12(fp)
 2001a58:	00c00284 	movi	r3,10
 2001a5c:	1884983a 	sll	r2,r3,r2
 2001a60:	e0bffa15 	stw	r2,-24(fp)

			xTimeWhenBlocking = xTaskGetTickCount();
 2001a64:	20061d40 	call	20061d4 <xTaskGetTickCount>
 2001a68:	e0bffb15 	stw	r2,-20(fp)

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
 2001a6c:	d0a03817 	ldw	r2,-32544(gp)
 2001a70:	e0fffd04 	addi	r3,fp,-12
 2001a74:	000f883a 	mov	r7,zero
 2001a78:	e1bffa17 	ldw	r6,-24(fp)
 2001a7c:	180b883a 	mov	r5,r3
 2001a80:	1009883a 	mov	r4,r2
 2001a84:	20047700 	call	2004770 <xQueueGenericSend>
 2001a88:	10000226 	beq	r2,zero,2001a94 <vPrimaryBlockTimeTestTask+0x14c>
			{
				xErrorOccurred = pdTRUE;
 2001a8c:	00800044 	movi	r2,1
 2001a90:	d0a03c15 	stw	r2,-32528(gp)
			}

			/* How long were we blocked for? */
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 2001a94:	20061d40 	call	20061d4 <xTaskGetTickCount>
 2001a98:	1007883a 	mov	r3,r2
 2001a9c:	e0bffb17 	ldw	r2,-20(fp)
 2001aa0:	1885c83a 	sub	r2,r3,r2
 2001aa4:	e0bffc15 	stw	r2,-16(fp)

			if( xBlockedTime < xTimeToBlock )
 2001aa8:	e0fffc17 	ldw	r3,-16(fp)
 2001aac:	e0bffa17 	ldw	r2,-24(fp)
 2001ab0:	1880022e 	bgeu	r3,r2,2001abc <vPrimaryBlockTimeTestTask+0x174>
			{
				/* Should not have blocked for less than we requested. */
				xErrorOccurred = pdTRUE;
 2001ab4:	00800044 	movi	r2,1
 2001ab8:	d0a03c15 	stw	r2,-32528(gp)
			}

			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 2001abc:	e0bffa17 	ldw	r2,-24(fp)
 2001ac0:	10c003c4 	addi	r3,r2,15
 2001ac4:	e0bffc17 	ldw	r2,-16(fp)
 2001ac8:	1880022e 	bgeu	r3,r2,2001ad4 <vPrimaryBlockTimeTestTask+0x18c>
			{
				/* Should not have blocked for longer than we requested,
				although we would not necessarily run as soon as we were
				unblocked so a margin is allowed. */
				xErrorOccurred = pdTRUE;
 2001acc:	00800044 	movi	r2,1
 2001ad0:	d0a03c15 	stw	r2,-32528(gp)
			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 2001ad4:	e0bffd17 	ldw	r2,-12(fp)
 2001ad8:	10800044 	addi	r2,r2,1
 2001adc:	e0bffd15 	stw	r2,-12(fp)
 2001ae0:	e0bffd17 	ldw	r2,-12(fp)
 2001ae4:	10800150 	cmplti	r2,r2,5
 2001ae8:	103fda1e 	bne	r2,zero,2001a54 <__reset+0xfe000a54>
		recognise that its block time has not expired and return to block for
		the remains of its block time.

		Wake the other task so it blocks attempting to post to the already
		full queue. */
		xRunIndicator = 0;
 2001aec:	d0203d15 	stw	zero,-32524(gp)
		vTaskResume( xSecondary );
 2001af0:	d0a03917 	ldw	r2,-32540(gp)
 2001af4:	1009883a 	mov	r4,r2
 2001af8:	2005da80 	call	2005da8 <vTaskResume>

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
 2001afc:	00000206 	br	2001b08 <vPrimaryBlockTimeTestTask+0x1c0>
		{
			/* The other task has not yet executed. */
			vTaskDelay( bktSHORT_WAIT );
 2001b00:	01000504 	movi	r4,20
 2001b04:	20059600 	call	2005960 <vTaskDelay>
		full queue. */
		xRunIndicator = 0;
		vTaskResume( xSecondary );

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
 2001b08:	d0a03d17 	ldw	r2,-32524(gp)
 2001b0c:	10801558 	cmpnei	r2,r2,85
 2001b10:	103ffb1e 	bne	r2,zero,2001b00 <__reset+0xfe000b00>
		{
			/* The other task has not yet executed. */
			vTaskDelay( bktSHORT_WAIT );
		}
		/* Make sure the other task is blocked on the queue. */
		vTaskDelay( bktSHORT_WAIT );
 2001b14:	01000504 	movi	r4,20
 2001b18:	20059600 	call	2005960 <vTaskDelay>
		xRunIndicator = 0;
 2001b1c:	d0203d15 	stw	zero,-32524(gp)

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 2001b20:	e03ffd15 	stw	zero,-12(fp)
 2001b24:	00002b06 	br	2001bd4 <vPrimaryBlockTimeTestTask+0x28c>
		{
			/* Now when we make space on the queue the other task should wake
			but not execute as this task has higher priority. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 2001b28:	d0a03817 	ldw	r2,-32544(gp)
 2001b2c:	e0fffe04 	addi	r3,fp,-8
 2001b30:	000f883a 	mov	r7,zero
 2001b34:	000d883a 	mov	r6,zero
 2001b38:	180b883a 	mov	r5,r3
 2001b3c:	1009883a 	mov	r4,r2
 2001b40:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2001b44:	10800060 	cmpeqi	r2,r2,1
 2001b48:	1000021e 	bne	r2,zero,2001b54 <vPrimaryBlockTimeTestTask+0x20c>
			{
				xErrorOccurred = pdTRUE;
 2001b4c:	00800044 	movi	r2,1
 2001b50:	d0a03c15 	stw	r2,-32528(gp)
			}

			/* Now fill the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			full ourselves, and the other task have set xRunIndicator. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 2001b54:	d0a03817 	ldw	r2,-32544(gp)
 2001b58:	e0fffd04 	addi	r3,fp,-12
 2001b5c:	000f883a 	mov	r7,zero
 2001b60:	000d883a 	mov	r6,zero
 2001b64:	180b883a 	mov	r5,r3
 2001b68:	1009883a 	mov	r4,r2
 2001b6c:	20047700 	call	2004770 <xQueueGenericSend>
 2001b70:	10800060 	cmpeqi	r2,r2,1
 2001b74:	1000021e 	bne	r2,zero,2001b80 <vPrimaryBlockTimeTestTask+0x238>
			{
				xErrorOccurred = pdTRUE;
 2001b78:	00800044 	movi	r2,1
 2001b7c:	d0a03c15 	stw	r2,-32528(gp)
			}

			if( xRunIndicator == bktRUN_INDICATOR )
 2001b80:	d0a03d17 	ldw	r2,-32524(gp)
 2001b84:	10801558 	cmpnei	r2,r2,85
 2001b88:	1000021e 	bne	r2,zero,2001b94 <vPrimaryBlockTimeTestTask+0x24c>
			{
				/* The other task should not have executed. */
				xErrorOccurred = pdTRUE;
 2001b8c:	00800044 	movi	r2,1
 2001b90:	d0a03c15 	stw	r2,-32528(gp)
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 2001b94:	d0a03917 	ldw	r2,-32540(gp)
 2001b98:	01400104 	movi	r5,4
 2001b9c:	1009883a 	mov	r4,r2
 2001ba0:	2005a600 	call	2005a60 <vTaskPrioritySet>

			/* The other task should now have re-blocked without exiting the
			queue function. */
			if( xRunIndicator == bktRUN_INDICATOR )
 2001ba4:	d0a03d17 	ldw	r2,-32524(gp)
 2001ba8:	10801558 	cmpnei	r2,r2,85
 2001bac:	1000021e 	bne	r2,zero,2001bb8 <vPrimaryBlockTimeTestTask+0x270>
			{
				/* The other task should not have executed outside of the
				queue function. */
				xErrorOccurred = pdTRUE;
 2001bb0:	00800044 	movi	r2,1
 2001bb4:	d0a03c15 	stw	r2,-32528(gp)
			}

			/* Set the priority back down. */
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
 2001bb8:	d0a03917 	ldw	r2,-32540(gp)
 2001bbc:	01400044 	movi	r5,1
 2001bc0:	1009883a 	mov	r4,r2
 2001bc4:	2005a600 	call	2005a60 <vTaskPrioritySet>
		}
		/* Make sure the other task is blocked on the queue. */
		vTaskDelay( bktSHORT_WAIT );
		xRunIndicator = 0;

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 2001bc8:	e0bffd17 	ldw	r2,-12(fp)
 2001bcc:	10800044 	addi	r2,r2,1
 2001bd0:	e0bffd15 	stw	r2,-12(fp)
 2001bd4:	e0bffd17 	ldw	r2,-12(fp)
 2001bd8:	10800150 	cmplti	r2,r2,5
 2001bdc:	103fd21e 	bne	r2,zero,2001b28 <__reset+0xfe000b28>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
 2001be0:	00000206 	br	2001bec <vPrimaryBlockTimeTestTask+0x2a4>
		{
			vTaskDelay( bktSHORT_WAIT );
 2001be4:	01000504 	movi	r4,20
 2001be8:	20059600 	call	2005960 <vTaskDelay>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
 2001bec:	d0a03d17 	ldw	r2,-32524(gp)
 2001bf0:	10801558 	cmpnei	r2,r2,85
 2001bf4:	103ffb1e 	bne	r2,zero,2001be4 <__reset+0xfe000be4>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
 2001bf8:	01000504 	movi	r4,20
 2001bfc:	20059600 	call	2005960 <vTaskDelay>
		xRunIndicator = 0;
 2001c00:	d0203d15 	stw	zero,-32524(gp)

		As per test 3 - but with the send and receive the other way around.
		The other task blocks attempting to read from the queue.

		Empty the queue.  We should find that it is full. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 2001c04:	e03ffd15 	stw	zero,-12(fp)
 2001c08:	00000e06 	br	2001c44 <vPrimaryBlockTimeTestTask+0x2fc>
		{
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 2001c0c:	d0a03817 	ldw	r2,-32544(gp)
 2001c10:	e0fffe04 	addi	r3,fp,-8
 2001c14:	000f883a 	mov	r7,zero
 2001c18:	000d883a 	mov	r6,zero
 2001c1c:	180b883a 	mov	r5,r3
 2001c20:	1009883a 	mov	r4,r2
 2001c24:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2001c28:	10800060 	cmpeqi	r2,r2,1
 2001c2c:	1000021e 	bne	r2,zero,2001c38 <vPrimaryBlockTimeTestTask+0x2f0>
			{
				xErrorOccurred = pdTRUE;
 2001c30:	00800044 	movi	r2,1
 2001c34:	d0a03c15 	stw	r2,-32528(gp)

		As per test 3 - but with the send and receive the other way around.
		The other task blocks attempting to read from the queue.

		Empty the queue.  We should find that it is full. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 2001c38:	e0bffd17 	ldw	r2,-12(fp)
 2001c3c:	10800044 	addi	r2,r2,1
 2001c40:	e0bffd15 	stw	r2,-12(fp)
 2001c44:	e0bffd17 	ldw	r2,-12(fp)
 2001c48:	10800150 	cmplti	r2,r2,5
 2001c4c:	103fef1e 	bne	r2,zero,2001c0c <__reset+0xfe000c0c>
			}
		}

		/* Wake the other task so it blocks attempting to read from  the
		already	empty queue. */
		vTaskResume( xSecondary );
 2001c50:	d0a03917 	ldw	r2,-32540(gp)
 2001c54:	1009883a 	mov	r4,r2
 2001c58:	2005da80 	call	2005da8 <vTaskResume>

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
 2001c5c:	00000206 	br	2001c68 <vPrimaryBlockTimeTestTask+0x320>
		{
			vTaskDelay( bktSHORT_WAIT );
 2001c60:	01000504 	movi	r4,20
 2001c64:	20059600 	call	2005960 <vTaskDelay>
		/* Wake the other task so it blocks attempting to read from  the
		already	empty queue. */
		vTaskResume( xSecondary );

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
 2001c68:	d0a03d17 	ldw	r2,-32524(gp)
 2001c6c:	10801558 	cmpnei	r2,r2,85
 2001c70:	103ffb1e 	bne	r2,zero,2001c60 <__reset+0xfe000c60>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
 2001c74:	01000504 	movi	r4,20
 2001c78:	20059600 	call	2005960 <vTaskDelay>
		xRunIndicator = 0;
 2001c7c:	d0203d15 	stw	zero,-32524(gp)

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 2001c80:	e03ffd15 	stw	zero,-12(fp)
 2001c84:	00002b06 	br	2001d34 <vPrimaryBlockTimeTestTask+0x3ec>
		{
			/* Now when we place an item on the queue the other task should
			wake but not execute as this task has higher priority. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 2001c88:	d0a03817 	ldw	r2,-32544(gp)
 2001c8c:	e0fffd04 	addi	r3,fp,-12
 2001c90:	000f883a 	mov	r7,zero
 2001c94:	000d883a 	mov	r6,zero
 2001c98:	180b883a 	mov	r5,r3
 2001c9c:	1009883a 	mov	r4,r2
 2001ca0:	20047700 	call	2004770 <xQueueGenericSend>
 2001ca4:	10800060 	cmpeqi	r2,r2,1
 2001ca8:	1000021e 	bne	r2,zero,2001cb4 <vPrimaryBlockTimeTestTask+0x36c>
			{
				xErrorOccurred = pdTRUE;
 2001cac:	00800044 	movi	r2,1
 2001cb0:	d0a03c15 	stw	r2,-32528(gp)
			}

			/* Now empty the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			empty ourselves, and the other task would be suspended. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 2001cb4:	d0a03817 	ldw	r2,-32544(gp)
 2001cb8:	e0fffe04 	addi	r3,fp,-8
 2001cbc:	000f883a 	mov	r7,zero
 2001cc0:	000d883a 	mov	r6,zero
 2001cc4:	180b883a 	mov	r5,r3
 2001cc8:	1009883a 	mov	r4,r2
 2001ccc:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2001cd0:	10800060 	cmpeqi	r2,r2,1
 2001cd4:	1000021e 	bne	r2,zero,2001ce0 <vPrimaryBlockTimeTestTask+0x398>
			{
				xErrorOccurred = pdTRUE;
 2001cd8:	00800044 	movi	r2,1
 2001cdc:	d0a03c15 	stw	r2,-32528(gp)
			}

			if( xRunIndicator == bktRUN_INDICATOR )
 2001ce0:	d0a03d17 	ldw	r2,-32524(gp)
 2001ce4:	10801558 	cmpnei	r2,r2,85
 2001ce8:	1000021e 	bne	r2,zero,2001cf4 <vPrimaryBlockTimeTestTask+0x3ac>
			{
				/* The other task should not have executed. */
				xErrorOccurred = pdTRUE;
 2001cec:	00800044 	movi	r2,1
 2001cf0:	d0a03c15 	stw	r2,-32528(gp)
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 2001cf4:	d0a03917 	ldw	r2,-32540(gp)
 2001cf8:	01400104 	movi	r5,4
 2001cfc:	1009883a 	mov	r4,r2
 2001d00:	2005a600 	call	2005a60 <vTaskPrioritySet>

			/* The other task should now have re-blocked without exiting the
			queue function. */
			if( xRunIndicator == bktRUN_INDICATOR )
 2001d04:	d0a03d17 	ldw	r2,-32524(gp)
 2001d08:	10801558 	cmpnei	r2,r2,85
 2001d0c:	1000021e 	bne	r2,zero,2001d18 <vPrimaryBlockTimeTestTask+0x3d0>
			{
				/* The other task should not have executed outside of the
				queue function. */
				xErrorOccurred = pdTRUE;
 2001d10:	00800044 	movi	r2,1
 2001d14:	d0a03c15 	stw	r2,-32528(gp)
			}
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
 2001d18:	d0a03917 	ldw	r2,-32540(gp)
 2001d1c:	01400044 	movi	r5,1
 2001d20:	1009883a 	mov	r4,r2
 2001d24:	2005a600 	call	2005a60 <vTaskPrioritySet>
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
		xRunIndicator = 0;

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 2001d28:	e0bffd17 	ldw	r2,-12(fp)
 2001d2c:	10800044 	addi	r2,r2,1
 2001d30:	e0bffd15 	stw	r2,-12(fp)
 2001d34:	e0bffd17 	ldw	r2,-12(fp)
 2001d38:	10800150 	cmplti	r2,r2,5
 2001d3c:	103fd21e 	bne	r2,zero,2001c88 <__reset+0xfe000c88>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
 2001d40:	00000206 	br	2001d4c <vPrimaryBlockTimeTestTask+0x404>
		{
			vTaskDelay( bktSHORT_WAIT );
 2001d44:	01000504 	movi	r4,20
 2001d48:	20059600 	call	2005960 <vTaskDelay>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
 2001d4c:	d0a03d17 	ldw	r2,-32524(gp)
 2001d50:	10801558 	cmpnei	r2,r2,85
 2001d54:	103ffb1e 	bne	r2,zero,2001d44 <__reset+0xfe000d44>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
 2001d58:	01000504 	movi	r4,20
 2001d5c:	20059600 	call	2005960 <vTaskDelay>

		xPrimaryCycles++;
 2001d60:	d0a03a17 	ldw	r2,-32536(gp)
 2001d64:	10800044 	addi	r2,r2,1
 2001d68:	d0a03a15 	stw	r2,-32536(gp)
	}
 2001d6c:	003efb06 	br	200195c <__reset+0xfe00095c>

02001d70 <vSecondaryBlockTimeTestTask>:
}
/*-----------------------------------------------------------*/

static void vSecondaryBlockTimeTestTask( void *pvParameters )
{
 2001d70:	defffa04 	addi	sp,sp,-24
 2001d74:	dfc00515 	stw	ra,20(sp)
 2001d78:	df000415 	stw	fp,16(sp)
 2001d7c:	df000404 	addi	fp,sp,16
 2001d80:	e13fff15 	stw	r4,-4(fp)
	{
		/*********************************************************************
		Test 0, 1 and 2

		This task does not participate in these tests. */
		vTaskSuspend( NULL );
 2001d84:	0009883a 	mov	r4,zero
 2001d88:	2005c340 	call	2005c34 <vTaskSuspend>
		Test 3

		The first thing we do is attempt to read from the queue.  It should be
		full so we block.  Note the time before we block so we can check the
		wake time is as per that expected. */
		xTimeWhenBlocking = xTaskGetTickCount();
 2001d8c:	20061d40 	call	20061d4 <xTaskGetTickCount>
 2001d90:	e0bffc15 	stw	r2,-16(fp)

		/* We should unblock after bktTIME_TO_BLOCK having not sent anything to
		the queue. */
		xData = 0;
 2001d94:	e03ffe15 	stw	zero,-8(fp)
		xRunIndicator = bktRUN_INDICATOR;
 2001d98:	00801544 	movi	r2,85
 2001d9c:	d0a03d15 	stw	r2,-32524(gp)
		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
 2001da0:	d0a03817 	ldw	r2,-32544(gp)
 2001da4:	e0fffe04 	addi	r3,fp,-8
 2001da8:	000f883a 	mov	r7,zero
 2001dac:	01802bc4 	movi	r6,175
 2001db0:	180b883a 	mov	r5,r3
 2001db4:	1009883a 	mov	r4,r2
 2001db8:	20047700 	call	2004770 <xQueueGenericSend>
 2001dbc:	10000226 	beq	r2,zero,2001dc8 <vSecondaryBlockTimeTestTask+0x58>
		{
			xErrorOccurred = pdTRUE;
 2001dc0:	00800044 	movi	r2,1
 2001dc4:	d0a03c15 	stw	r2,-32528(gp)
		}

		/* How long were we inside the send function? */
		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 2001dc8:	20061d40 	call	20061d4 <xTaskGetTickCount>
 2001dcc:	1007883a 	mov	r3,r2
 2001dd0:	e0bffc17 	ldw	r2,-16(fp)
 2001dd4:	1885c83a 	sub	r2,r3,r2
 2001dd8:	e0bffd15 	stw	r2,-12(fp)

		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
		if( xBlockedTime < bktTIME_TO_BLOCK )
 2001ddc:	e0bffd17 	ldw	r2,-12(fp)
 2001de0:	10802be8 	cmpgeui	r2,r2,175
 2001de4:	1000021e 	bne	r2,zero,2001df0 <vSecondaryBlockTimeTestTask+0x80>
		{
			xErrorOccurred = pdTRUE;
 2001de8:	00800044 	movi	r2,1
 2001dec:	d0a03c15 	stw	r2,-32528(gp)
		}

		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
		either.  A margin is permitted as we would not necessarily run as
		soon as we unblocked. */
		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
 2001df0:	e0bffd17 	ldw	r2,-12(fp)
 2001df4:	10802ff0 	cmpltui	r2,r2,191
 2001df8:	1000021e 	bne	r2,zero,2001e04 <vSecondaryBlockTimeTestTask+0x94>
		{
			xErrorOccurred = pdTRUE;
 2001dfc:	00800044 	movi	r2,1
 2001e00:	d0a03c15 	stw	r2,-32528(gp)
		}

		/* Suspend ready for test 3. */
		xRunIndicator = bktRUN_INDICATOR;
 2001e04:	00801544 	movi	r2,85
 2001e08:	d0a03d15 	stw	r2,-32524(gp)
		vTaskSuspend( NULL );
 2001e0c:	0009883a 	mov	r4,zero
 2001e10:	2005c340 	call	2005c34 <vTaskSuspend>

		/*********************************************************************
        Test 4

		As per test three, but with the send and receive reversed. */
		xTimeWhenBlocking = xTaskGetTickCount();
 2001e14:	20061d40 	call	20061d4 <xTaskGetTickCount>
 2001e18:	e0bffc15 	stw	r2,-16(fp)

		/* We should unblock after bktTIME_TO_BLOCK having not received
		anything on the queue. */
		xRunIndicator = bktRUN_INDICATOR;
 2001e1c:	00801544 	movi	r2,85
 2001e20:	d0a03d15 	stw	r2,-32524(gp)
		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
 2001e24:	d0a03817 	ldw	r2,-32544(gp)
 2001e28:	e0fffe04 	addi	r3,fp,-8
 2001e2c:	000f883a 	mov	r7,zero
 2001e30:	01802bc4 	movi	r6,175
 2001e34:	180b883a 	mov	r5,r3
 2001e38:	1009883a 	mov	r4,r2
 2001e3c:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2001e40:	10000226 	beq	r2,zero,2001e4c <vSecondaryBlockTimeTestTask+0xdc>
		{
			xErrorOccurred = pdTRUE;
 2001e44:	00800044 	movi	r2,1
 2001e48:	d0a03c15 	stw	r2,-32528(gp)
		}

		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 2001e4c:	20061d40 	call	20061d4 <xTaskGetTickCount>
 2001e50:	1007883a 	mov	r3,r2
 2001e54:	e0bffc17 	ldw	r2,-16(fp)
 2001e58:	1885c83a 	sub	r2,r3,r2
 2001e5c:	e0bffd15 	stw	r2,-12(fp)

		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
		if( xBlockedTime < bktTIME_TO_BLOCK )
 2001e60:	e0bffd17 	ldw	r2,-12(fp)
 2001e64:	10802be8 	cmpgeui	r2,r2,175
 2001e68:	1000021e 	bne	r2,zero,2001e74 <vSecondaryBlockTimeTestTask+0x104>
		{
			xErrorOccurred = pdTRUE;
 2001e6c:	00800044 	movi	r2,1
 2001e70:	d0a03c15 	stw	r2,-32528(gp)
		}

		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
		either.  A margin is permitted as we would not necessarily run as soon
		as we unblocked. */
		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
 2001e74:	e0bffd17 	ldw	r2,-12(fp)
 2001e78:	10802ff0 	cmpltui	r2,r2,191
 2001e7c:	1000021e 	bne	r2,zero,2001e88 <vSecondaryBlockTimeTestTask+0x118>
		{
			xErrorOccurred = pdTRUE;
 2001e80:	00800044 	movi	r2,1
 2001e84:	d0a03c15 	stw	r2,-32528(gp)
		}

		xRunIndicator = bktRUN_INDICATOR;
 2001e88:	00801544 	movi	r2,85
 2001e8c:	d0a03d15 	stw	r2,-32524(gp)

		xSecondaryCycles++;
 2001e90:	d0a03b17 	ldw	r2,-32532(gp)
 2001e94:	10800044 	addi	r2,r2,1
 2001e98:	d0a03b15 	stw	r2,-32532(gp)
	}
 2001e9c:	003fb906 	br	2001d84 <__reset+0xfe000d84>

02001ea0 <prvBasicDelayTests>:
}
/*-----------------------------------------------------------*/

static void prvBasicDelayTests( void )
{
 2001ea0:	defff604 	addi	sp,sp,-40
 2001ea4:	dfc00915 	stw	ra,36(sp)
 2001ea8:	df000815 	stw	fp,32(sp)
 2001eac:	df000804 	addi	fp,sp,32
TickType_t xPreTime, xPostTime, x, xLastUnblockTime, xExpectedUnblockTime;
const TickType_t xPeriod = 75, xCycles = 5, xAllowableMargin = ( bktALLOWABLE_MARGIN >> 1 );
 2001eb0:	008012c4 	movi	r2,75
 2001eb4:	e0bff915 	stw	r2,-28(fp)
 2001eb8:	00800144 	movi	r2,5
 2001ebc:	e0bffa15 	stw	r2,-24(fp)
 2001ec0:	008001c4 	movi	r2,7
 2001ec4:	e0bffb15 	stw	r2,-20(fp)

	/* Temporarily increase priority so the timing is more accurate, but not so
	high as to disrupt the timer tests. */
	vTaskPrioritySet( NULL, configTIMER_TASK_PRIORITY - 1 );
 2001ec8:	014000c4 	movi	r5,3
 2001ecc:	0009883a 	mov	r4,zero
 2001ed0:	2005a600 	call	2005a60 <vTaskPrioritySet>

	/* Crude check to too that vTaskDelay() blocks for the expected period. */
	xPreTime = xTaskGetTickCount();
 2001ed4:	20061d40 	call	20061d4 <xTaskGetTickCount>
 2001ed8:	e0bffc15 	stw	r2,-16(fp)
	vTaskDelay( bktTIME_TO_BLOCK );
 2001edc:	01002bc4 	movi	r4,175
 2001ee0:	20059600 	call	2005960 <vTaskDelay>
	xPostTime = xTaskGetTickCount();
 2001ee4:	20061d40 	call	20061d4 <xTaskGetTickCount>
 2001ee8:	e0bffd15 	stw	r2,-12(fp)

	/* The priority is higher, so the allowable margin is halved when compared
	to the other tests in this file. */
	if( ( xPostTime - xPreTime ) > ( bktTIME_TO_BLOCK + xAllowableMargin ) )
 2001eec:	e0fffd17 	ldw	r3,-12(fp)
 2001ef0:	e0bffc17 	ldw	r2,-16(fp)
 2001ef4:	1885c83a 	sub	r2,r3,r2
 2001ef8:	e0fffb17 	ldw	r3,-20(fp)
 2001efc:	18c02bc4 	addi	r3,r3,175
 2001f00:	1880022e 	bgeu	r3,r2,2001f0c <prvBasicDelayTests+0x6c>
	{
		xErrorOccurred = pdTRUE;
 2001f04:	00800044 	movi	r2,1
 2001f08:	d0a03c15 	stw	r2,-32528(gp)
	}

	/* Now crude tests to check the vTaskDelayUntil() functionality. */
	xPostTime = xTaskGetTickCount();
 2001f0c:	20061d40 	call	20061d4 <xTaskGetTickCount>
 2001f10:	e0bffd15 	stw	r2,-12(fp)
	xLastUnblockTime = xPostTime;
 2001f14:	e0bffd17 	ldw	r2,-12(fp)
 2001f18:	e0bfff15 	stw	r2,-4(fp)

	for( x = 0; x < xCycles; x++ )
 2001f1c:	e03ff815 	stw	zero,-32(fp)
 2001f20:	00001a06 	br	2001f8c <prvBasicDelayTests+0xec>
	{
		/* Calculate the next expected unblock time from the time taken before
		this loop was entered. */
		xExpectedUnblockTime = xPostTime + ( x * xPeriod );
 2001f24:	e17ff917 	ldw	r5,-28(fp)
 2001f28:	e13ff817 	ldw	r4,-32(fp)
 2001f2c:	2009bcc0 	call	2009bcc <__mulsi3>
 2001f30:	1007883a 	mov	r3,r2
 2001f34:	e0bffd17 	ldw	r2,-12(fp)
 2001f38:	1885883a 	add	r2,r3,r2
 2001f3c:	e0bffe15 	stw	r2,-8(fp)

		vTaskDelayUntil( &xLastUnblockTime, xPeriod );
 2001f40:	e0bfff04 	addi	r2,fp,-4
 2001f44:	e17ff917 	ldw	r5,-28(fp)
 2001f48:	1009883a 	mov	r4,r2
 2001f4c:	20058700 	call	2005870 <vTaskDelayUntil>

		if( ( xTaskGetTickCount() - xExpectedUnblockTime ) > ( bktTIME_TO_BLOCK + xAllowableMargin ) )
 2001f50:	20061d40 	call	20061d4 <xTaskGetTickCount>
 2001f54:	1007883a 	mov	r3,r2
 2001f58:	e0bffe17 	ldw	r2,-8(fp)
 2001f5c:	1885c83a 	sub	r2,r3,r2
 2001f60:	e0fffb17 	ldw	r3,-20(fp)
 2001f64:	18c02bc4 	addi	r3,r3,175
 2001f68:	1880022e 	bgeu	r3,r2,2001f74 <prvBasicDelayTests+0xd4>
		{
			xErrorOccurred = pdTRUE;
 2001f6c:	00800044 	movi	r2,1
 2001f70:	d0a03c15 	stw	r2,-32528(gp)
		}

		xPrimaryCycles++;
 2001f74:	d0a03a17 	ldw	r2,-32536(gp)
 2001f78:	10800044 	addi	r2,r2,1
 2001f7c:	d0a03a15 	stw	r2,-32536(gp)

	/* Now crude tests to check the vTaskDelayUntil() functionality. */
	xPostTime = xTaskGetTickCount();
	xLastUnblockTime = xPostTime;

	for( x = 0; x < xCycles; x++ )
 2001f80:	e0bff817 	ldw	r2,-32(fp)
 2001f84:	10800044 	addi	r2,r2,1
 2001f88:	e0bff815 	stw	r2,-32(fp)
 2001f8c:	e0fff817 	ldw	r3,-32(fp)
 2001f90:	e0bffa17 	ldw	r2,-24(fp)
 2001f94:	18bfe336 	bltu	r3,r2,2001f24 <__reset+0xfe000f24>

		xPrimaryCycles++;
	}

	/* Reset to the original task priority ready for the other tests. */
	vTaskPrioritySet( NULL, bktPRIMARY_PRIORITY );
 2001f98:	01400084 	movi	r5,2
 2001f9c:	0009883a 	mov	r4,zero
 2001fa0:	2005a600 	call	2005a60 <vTaskPrioritySet>
}
 2001fa4:	0001883a 	nop
 2001fa8:	e037883a 	mov	sp,fp
 2001fac:	dfc00117 	ldw	ra,4(sp)
 2001fb0:	df000017 	ldw	fp,0(sp)
 2001fb4:	dec00204 	addi	sp,sp,8
 2001fb8:	f800283a 	ret

02001fbc <xAreBlockTimeTestTasksStillRunning>:
/*-----------------------------------------------------------*/

BaseType_t xAreBlockTimeTestTasksStillRunning( void )
{
 2001fbc:	defffe04 	addi	sp,sp,-8
 2001fc0:	df000115 	stw	fp,4(sp)
 2001fc4:	df000104 	addi	fp,sp,4
static BaseType_t xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
BaseType_t xReturn = pdPASS;
 2001fc8:	00800044 	movi	r2,1
 2001fcc:	e0bfff15 	stw	r2,-4(fp)

	/* Have both tasks performed at least one cycle since this function was
	last called? */
	if( xPrimaryCycles == xLastPrimaryCycleCount )
 2001fd0:	d0e03a17 	ldw	r3,-32536(gp)
 2001fd4:	d0a03e17 	ldw	r2,-32520(gp)
 2001fd8:	1880011e 	bne	r3,r2,2001fe0 <xAreBlockTimeTestTasksStillRunning+0x24>
	{
		xReturn = pdFAIL;
 2001fdc:	e03fff15 	stw	zero,-4(fp)
	}

	if( xSecondaryCycles == xLastSecondaryCycleCount )
 2001fe0:	d0e03b17 	ldw	r3,-32532(gp)
 2001fe4:	d0a03f17 	ldw	r2,-32516(gp)
 2001fe8:	1880011e 	bne	r3,r2,2001ff0 <xAreBlockTimeTestTasksStillRunning+0x34>
	{
		xReturn = pdFAIL;
 2001fec:	e03fff15 	stw	zero,-4(fp)
	}

	if( xErrorOccurred == pdTRUE )
 2001ff0:	d0a03c17 	ldw	r2,-32528(gp)
 2001ff4:	10800058 	cmpnei	r2,r2,1
 2001ff8:	1000011e 	bne	r2,zero,2002000 <xAreBlockTimeTestTasksStillRunning+0x44>
	{
		xReturn = pdFAIL;
 2001ffc:	e03fff15 	stw	zero,-4(fp)
	}

	xLastSecondaryCycleCount = xSecondaryCycles;
 2002000:	d0a03b17 	ldw	r2,-32532(gp)
 2002004:	d0a03f15 	stw	r2,-32516(gp)
	xLastPrimaryCycleCount = xPrimaryCycles;
 2002008:	d0a03a17 	ldw	r2,-32536(gp)
 200200c:	d0a03e15 	stw	r2,-32520(gp)

	return xReturn;
 2002010:	e0bfff17 	ldw	r2,-4(fp)
}
 2002014:	e037883a 	mov	sp,fp
 2002018:	df000017 	ldw	fp,0(sp)
 200201c:	dec00104 	addi	sp,sp,4
 2002020:	f800283a 	ret

02002024 <vAltStartComTestTasks>:
static volatile UBaseType_t uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED )
{
 2002024:	defff904 	addi	sp,sp,-28
 2002028:	dfc00615 	stw	ra,24(sp)
 200202c:	df000515 	stw	fp,20(sp)
 2002030:	df000504 	addi	fp,sp,20
 2002034:	e13ffd15 	stw	r4,-12(fp)
 2002038:	e17ffe15 	stw	r5,-8(fp)
 200203c:	e1bfff15 	stw	r6,-4(fp)
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
 2002040:	e0bfff17 	ldw	r2,-4(fp)
 2002044:	d0a04115 	stw	r2,-32508(gp)
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
 2002048:	01400604 	movi	r5,24
 200204c:	e13ffe17 	ldw	r4,-8(fp)
 2002050:	2007b000 	call	2007b00 <xSerialPortInitMinimal>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( TaskHandle_t * ) NULL );
 2002054:	e0bffd17 	ldw	r2,-12(fp)
 2002058:	10bfffc4 	addi	r2,r2,-1
 200205c:	d8000115 	stw	zero,4(sp)
 2002060:	d8800015 	stw	r2,0(sp)
 2002064:	000f883a 	mov	r7,zero
 2002068:	01810004 	movi	r6,1024
 200206c:	01408074 	movhi	r5,513
 2002070:	29489304 	addi	r5,r5,8780
 2002074:	01008034 	movhi	r4,512
 2002078:	21083004 	addi	r4,r4,8384
 200207c:	20053c80 	call	20053c8 <xTaskCreate>
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
 2002080:	d8000115 	stw	zero,4(sp)
 2002084:	e0bffd17 	ldw	r2,-12(fp)
 2002088:	d8800015 	stw	r2,0(sp)
 200208c:	000f883a 	mov	r7,zero
 2002090:	01810004 	movi	r6,1024
 2002094:	01408074 	movhi	r5,513
 2002098:	29489504 	addi	r5,r5,8788
 200209c:	01008034 	movhi	r4,512
 20020a0:	21085d04 	addi	r4,r4,8564
 20020a4:	20053c80 	call	20053c8 <xTaskCreate>
}
 20020a8:	0001883a 	nop
 20020ac:	e037883a 	mov	sp,fp
 20020b0:	dfc00117 	ldw	ra,4(sp)
 20020b4:	df000017 	ldw	fp,0(sp)
 20020b8:	dec00204 	addi	sp,sp,8
 20020bc:	f800283a 	ret

020020c0 <vComTxTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComTxTask, pvParameters )
{
 20020c0:	defffb04 	addi	sp,sp,-20
 20020c4:	dfc00415 	stw	ra,16(sp)
 20020c8:	df000315 	stw	fp,12(sp)
 20020cc:	df000304 	addi	fp,sp,12
 20020d0:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
 20020d4:	00801044 	movi	r2,65
 20020d8:	e0bffd05 	stb	r2,-12(fp)
 20020dc:	00000e06 	br	2002118 <vComTxTask+0x58>
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
 20020e0:	d0a04017 	ldw	r2,-32512(gp)
 20020e4:	e0fffd07 	ldb	r3,-12(fp)
 20020e8:	000d883a 	mov	r6,zero
 20020ec:	180b883a 	mov	r5,r3
 20020f0:	1009883a 	mov	r4,r2
 20020f4:	2007c540 	call	2007c54 <xSerialPutChar>
 20020f8:	10800058 	cmpnei	r2,r2,1
 20020fc:	1000031e 	bne	r2,zero,200210c <vComTxTask+0x4c>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
 2002100:	d0a04117 	ldw	r2,-32508(gp)
 2002104:	1009883a 	mov	r4,r2
 2002108:	20037f00 	call	20037f0 <vParTestToggleLED>

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
 200210c:	e0bffd03 	ldbu	r2,-12(fp)
 2002110:	10800044 	addi	r2,r2,1
 2002114:	e0bffd05 	stb	r2,-12(fp)
 2002118:	e0bffd07 	ldb	r2,-12(fp)
 200211c:	10801650 	cmplti	r2,r2,89
 2002120:	103fef1e 	bne	r2,zero,20020e0 <__reset+0xfe0010e0>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
 2002124:	d0a04117 	ldw	r2,-32508(gp)
 2002128:	000b883a 	mov	r5,zero
 200212c:	1009883a 	mov	r4,r2
 2002130:	20037500 	call	2003750 <vParTestSetLED>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
 2002134:	20061d40 	call	20061d4 <xTaskGetTickCount>
 2002138:	108000c4 	addi	r2,r2,3
 200213c:	e0bffe15 	stw	r2,-8(fp)

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
 2002140:	e0bffe17 	ldw	r2,-8(fp)
 2002144:	01402584 	movi	r5,150
 2002148:	1009883a 	mov	r4,r2
 200214c:	2009b740 	call	2009b74 <__umodsi3>
 2002150:	e0bffe15 	stw	r2,-8(fp)

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
 2002154:	e0bffe17 	ldw	r2,-8(fp)
 2002158:	10800ca8 	cmpgeui	r2,r2,50
 200215c:	1000021e 	bne	r2,zero,2002168 <vComTxTask+0xa8>
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
 2002160:	00800c84 	movi	r2,50
 2002164:	e0bffe15 	stw	r2,-8(fp)
		}

		vTaskDelay( xTimeToWait );
 2002168:	e13ffe17 	ldw	r4,-8(fp)
 200216c:	20059600 	call	2005960 <vTaskDelay>
	}
 2002170:	003fd806 	br	20020d4 <__reset+0xfe0010d4>

02002174 <vComRxTask>:
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
 2002174:	defff904 	addi	sp,sp,-28
 2002178:	dfc00615 	stw	ra,24(sp)
 200217c:	df000515 	stw	fp,20(sp)
 2002180:	df000504 	addi	fp,sp,20
 2002184:	e13fff15 	stw	r4,-4(fp)
signed char cExpectedByte, cByteRxed;
BaseType_t xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
 2002188:	e03ffc15 	stw	zero,-16(fp)
 200218c:	e03ffd15 	stw	zero,-12(fp)

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
 2002190:	00801044 	movi	r2,65
 2002194:	e0bffb05 	stb	r2,-20(fp)
 2002198:	00001806 	br	20021fc <vComRxTask+0x88>
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
 200219c:	d0a04017 	ldw	r2,-32512(gp)
 20021a0:	e0fffe04 	addi	r3,fp,-8
 20021a4:	01bfffd4 	movui	r6,65535
 20021a8:	180b883a 	mov	r5,r3
 20021ac:	1009883a 	mov	r4,r2
 20021b0:	2007bdc0 	call	2007bdc <xSerialGetChar>
 20021b4:	10000e26 	beq	r2,zero,20021f0 <vComRxTask+0x7c>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
 20021b8:	e0bffe03 	ldbu	r2,-8(fp)
 20021bc:	10c03fcc 	andi	r3,r2,255
 20021c0:	18c0201c 	xori	r3,r3,128
 20021c4:	18ffe004 	addi	r3,r3,-128
 20021c8:	e0bffb07 	ldb	r2,-20(fp)
 20021cc:	1880051e 	bne	r3,r2,20021e4 <vComRxTask+0x70>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
 20021d0:	d0a04117 	ldw	r2,-32508(gp)
 20021d4:	10800044 	addi	r2,r2,1
 20021d8:	1009883a 	mov	r4,r2
 20021dc:	20037f00 	call	20037f0 <vParTestToggleLED>
 20021e0:	00000306 	br	20021f0 <vComRxTask+0x7c>
				}
				else
				{
					xResyncRequired = pdTRUE;
 20021e4:	00800044 	movi	r2,1
 20021e8:	e0bffc15 	stw	r2,-16(fp)
					break; /*lint !e960 Non-switch break allowed. */
 20021ec:	00000606 	br	2002208 <vComRxTask+0x94>

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
 20021f0:	e0bffb03 	ldbu	r2,-20(fp)
 20021f4:	10800044 	addi	r2,r2,1
 20021f8:	e0bffb05 	stb	r2,-20(fp)
 20021fc:	e0bffb07 	ldb	r2,-20(fp)
 2002200:	10801650 	cmplti	r2,r2,89
 2002204:	103fe51e 	bne	r2,zero,200219c <__reset+0xfe00119c>
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
 2002208:	d0a04117 	ldw	r2,-32508(gp)
 200220c:	10800044 	addi	r2,r2,1
 2002210:	000b883a 	mov	r5,zero
 2002214:	1009883a 	mov	r4,r2
 2002218:	20037500 	call	2003750 <vParTestSetLED>

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
 200221c:	e0bffc17 	ldw	r2,-16(fp)
 2002220:	10800058 	cmpnei	r2,r2,1
 2002224:	1000121e 	bne	r2,zero,2002270 <vComRxTask+0xfc>
		{
			while( cByteRxed != comLAST_BYTE )
 2002228:	00000606 	br	2002244 <vComRxTask+0xd0>
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
 200222c:	d0a04017 	ldw	r2,-32512(gp)
 2002230:	e0fffe04 	addi	r3,fp,-8
 2002234:	01bfffd4 	movui	r6,65535
 2002238:	180b883a 	mov	r5,r3
 200223c:	1009883a 	mov	r4,r2
 2002240:	2007bdc0 	call	2007bdc <xSerialGetChar>
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
 2002244:	e0bffe03 	ldbu	r2,-8(fp)
 2002248:	10803fcc 	andi	r2,r2,255
 200224c:	1080201c 	xori	r2,r2,128
 2002250:	10bfe004 	addi	r2,r2,-128
 2002254:	10801618 	cmpnei	r2,r2,88
 2002258:	103ff41e 	bne	r2,zero,200222c <__reset+0xfe00122c>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
 200225c:	e0bffd17 	ldw	r2,-12(fp)
 2002260:	10800044 	addi	r2,r2,1
 2002264:	e0bffd15 	stw	r2,-12(fp)

			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
 2002268:	e03ffc15 	stw	zero,-16(fp)
 200226c:	003fc806 	br	2002190 <__reset+0xfe001190>
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
 2002270:	e0bffd17 	ldw	r2,-12(fp)
 2002274:	10800088 	cmpgei	r2,r2,2
 2002278:	103fc51e 	bne	r2,zero,2002190 <__reset+0xfe001190>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
 200227c:	d0a04217 	ldw	r2,-32504(gp)
 2002280:	10800044 	addi	r2,r2,1
 2002284:	d0a04215 	stw	r2,-32504(gp)
			}
		}
	}
 2002288:	003fc106 	br	2002190 <__reset+0xfe001190>

0200228c <xAreComTestTasksStillRunning>:
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

BaseType_t xAreComTestTasksStillRunning( void )
{
 200228c:	defffe04 	addi	sp,sp,-8
 2002290:	df000115 	stw	fp,4(sp)
 2002294:	df000104 	addi	fp,sp,4
BaseType_t xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
 2002298:	d0a04217 	ldw	r2,-32504(gp)
 200229c:	1000021e 	bne	r2,zero,20022a8 <xAreComTestTasksStillRunning+0x1c>
	{
		xReturn = pdFALSE;
 20022a0:	e03fff15 	stw	zero,-4(fp)
 20022a4:	00000206 	br	20022b0 <xAreComTestTasksStillRunning+0x24>
	}
	else
	{
		xReturn = pdTRUE;
 20022a8:	00800044 	movi	r2,1
 20022ac:	e0bfff15 	stw	r2,-4(fp)
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
 20022b0:	d0204215 	stw	zero,-32504(gp)

	return xReturn;
 20022b4:	e0bfff17 	ldw	r2,-4(fp)
}
 20022b8:	e037883a 	mov	sp,fp
 20022bc:	df000017 	ldw	fp,0(sp)
 20022c0:	dec00104 	addi	sp,sp,4
 20022c4:	f800283a 	ret

020022c8 <vStartCountingSemaphoreTasks>:
static volatile xCountSemStruct xParameters[ countNUM_TEST_TASKS ];

/*-----------------------------------------------------------*/

void vStartCountingSemaphoreTasks( void )
{
 20022c8:	defffc04 	addi	sp,sp,-16
 20022cc:	dfc00315 	stw	ra,12(sp)
 20022d0:	df000215 	stw	fp,8(sp)
 20022d4:	df000204 	addi	fp,sp,8
	/* Create the semaphores that we are going to use for the test/demo.  The
	first should be created such that it starts at its maximum count value,
	the second should be created such that it starts with a count value of zero. */
	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE );
 20022d8:	01403204 	movi	r5,200
 20022dc:	01003204 	movi	r4,200
 20022e0:	20047180 	call	2004718 <xQueueCreateCountingSemaphore>
 20022e4:	1007883a 	mov	r3,r2
 20022e8:	00808074 	movhi	r2,513
 20022ec:	10913d04 	addi	r2,r2,17652
 20022f0:	10c00015 	stw	r3,0(r2)
	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
 20022f4:	00808074 	movhi	r2,513
 20022f8:	10913d04 	addi	r2,r2,17652
 20022fc:	00c02a84 	movi	r3,170
 2002300:	10c00115 	stw	r3,4(r2)
	xParameters[ 0 ].uxLoopCounter = 0;
 2002304:	00808074 	movhi	r2,513
 2002308:	10913d04 	addi	r2,r2,17652
 200230c:	10000215 	stw	zero,8(r2)

	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
 2002310:	000b883a 	mov	r5,zero
 2002314:	01003204 	movi	r4,200
 2002318:	20047180 	call	2004718 <xQueueCreateCountingSemaphore>
 200231c:	1007883a 	mov	r3,r2
 2002320:	00808074 	movhi	r2,513
 2002324:	10913d04 	addi	r2,r2,17652
 2002328:	10c00315 	stw	r3,12(r2)
	xParameters[ 1 ].uxExpectedStartCount = 0;
 200232c:	00808074 	movhi	r2,513
 2002330:	10913d04 	addi	r2,r2,17652
 2002334:	10000415 	stw	zero,16(r2)
	xParameters[ 1 ].uxLoopCounter = 0;
 2002338:	00808074 	movhi	r2,513
 200233c:	10913d04 	addi	r2,r2,17652
 2002340:	10000515 	stw	zero,20(r2)

	/* Were the semaphores created? */
	if( ( xParameters[ 0 ].xSemaphore != NULL ) || ( xParameters[ 1 ].xSemaphore != NULL ) )
 2002344:	00808074 	movhi	r2,513
 2002348:	10913d04 	addi	r2,r2,17652
 200234c:	10800017 	ldw	r2,0(r2)
 2002350:	1000041e 	bne	r2,zero,2002364 <vStartCountingSemaphoreTasks+0x9c>
 2002354:	00808074 	movhi	r2,513
 2002358:	10913d04 	addi	r2,r2,17652
 200235c:	10800317 	ldw	r2,12(r2)
 2002360:	10001426 	beq	r2,zero,20023b4 <vStartCountingSemaphoreTasks+0xec>
		defined or is defined to be less than 1. */
		vQueueAddToRegistry( ( QueueHandle_t ) xParameters[ 0 ].xSemaphore, "Counting_Sem_1" );
		vQueueAddToRegistry( ( QueueHandle_t ) xParameters[ 1 ].xSemaphore, "Counting_Sem_2" );

		/* Create the demo tasks, passing in the semaphore to use as the parameter. */
		xTaskCreate( prvCountingSemaphoreTask, "CNT1", configMINIMAL_STACK_SIZE, ( void * ) &( xParameters[ 0 ] ), tskIDLE_PRIORITY, NULL );
 2002364:	d8000115 	stw	zero,4(sp)
 2002368:	d8000015 	stw	zero,0(sp)
 200236c:	01c08074 	movhi	r7,513
 2002370:	39d13d04 	addi	r7,r7,17652
 2002374:	01810004 	movi	r6,1024
 2002378:	01408074 	movhi	r5,513
 200237c:	29489704 	addi	r5,r5,8796
 2002380:	01008034 	movhi	r4,512
 2002384:	21095b04 	addi	r4,r4,9580
 2002388:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( prvCountingSemaphoreTask, "CNT2", configMINIMAL_STACK_SIZE, ( void * ) &( xParameters[ 1 ] ), tskIDLE_PRIORITY, NULL );
 200238c:	d8000115 	stw	zero,4(sp)
 2002390:	d8000015 	stw	zero,0(sp)
 2002394:	01c08074 	movhi	r7,513
 2002398:	39d14004 	addi	r7,r7,17664
 200239c:	01810004 	movi	r6,1024
 20023a0:	01408074 	movhi	r5,513
 20023a4:	29489904 	addi	r5,r5,8804
 20023a8:	01008034 	movhi	r4,512
 20023ac:	21095b04 	addi	r4,r4,9580
 20023b0:	20053c80 	call	20053c8 <xTaskCreate>
	}
}
 20023b4:	0001883a 	nop
 20023b8:	e037883a 	mov	sp,fp
 20023bc:	dfc00117 	ldw	ra,4(sp)
 20023c0:	df000017 	ldw	fp,0(sp)
 20023c4:	dec00204 	addi	sp,sp,8
 20023c8:	f800283a 	ret

020023cc <prvDecrementSemaphoreCount>:
/*-----------------------------------------------------------*/

static void prvDecrementSemaphoreCount( SemaphoreHandle_t xSemaphore, UBaseType_t *puxLoopCounter )
{
 20023cc:	defffb04 	addi	sp,sp,-20
 20023d0:	dfc00415 	stw	ra,16(sp)
 20023d4:	df000315 	stw	fp,12(sp)
 20023d8:	df000304 	addi	fp,sp,12
 20023dc:	e13ffe15 	stw	r4,-8(fp)
 20023e0:	e17fff15 	stw	r5,-4(fp)
UBaseType_t ux;

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
 20023e4:	000f883a 	mov	r7,zero
 20023e8:	000d883a 	mov	r6,zero
 20023ec:	000b883a 	mov	r5,zero
 20023f0:	e13ffe17 	ldw	r4,-8(fp)
 20023f4:	20047700 	call	2004770 <xQueueGenericSend>
 20023f8:	10800058 	cmpnei	r2,r2,1
 20023fc:	1000021e 	bne	r2,zero,2002408 <prvDecrementSemaphoreCount+0x3c>
	{
		xErrorDetected = pdTRUE;
 2002400:	00800044 	movi	r2,1
 2002404:	d0a04315 	stw	r2,-32500(gp)
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 2002408:	e03ffd15 	stw	zero,-12(fp)
 200240c:	00001106 	br	2002454 <prvDecrementSemaphoreCount+0x88>
	{
		configASSERT( uxSemaphoreGetCount( xSemaphore ) == ( countMAX_COUNT_VALUE - ux ) );

		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
 2002410:	000f883a 	mov	r7,zero
 2002414:	000d883a 	mov	r6,zero
 2002418:	000b883a 	mov	r5,zero
 200241c:	e13ffe17 	ldw	r4,-8(fp)
 2002420:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2002424:	10800060 	cmpeqi	r2,r2,1
 2002428:	1000021e 	bne	r2,zero,2002434 <prvDecrementSemaphoreCount+0x68>
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
 200242c:	00800044 	movi	r2,1
 2002430:	d0a04315 	stw	r2,-32500(gp)
		}

		( *puxLoopCounter )++;
 2002434:	e0bfff17 	ldw	r2,-4(fp)
 2002438:	10800017 	ldw	r2,0(r2)
 200243c:	10c00044 	addi	r3,r2,1
 2002440:	e0bfff17 	ldw	r2,-4(fp)
 2002444:	10c00015 	stw	r3,0(r2)
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 2002448:	e0bffd17 	ldw	r2,-12(fp)
 200244c:	10800044 	addi	r2,r2,1
 2002450:	e0bffd15 	stw	r2,-12(fp)
 2002454:	e0bffd17 	ldw	r2,-12(fp)
 2002458:	10803230 	cmpltui	r2,r2,200
 200245c:	103fec1e 	bne	r2,zero,2002410 <__reset+0xfe001410>
	#endif

	/* If the semaphore count is zero then we should not be able to	'take'
	the semaphore. */
	configASSERT( uxSemaphoreGetCount( xSemaphore ) == 0 );
	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
 2002460:	000f883a 	mov	r7,zero
 2002464:	000d883a 	mov	r6,zero
 2002468:	000b883a 	mov	r5,zero
 200246c:	e13ffe17 	ldw	r4,-8(fp)
 2002470:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2002474:	10800058 	cmpnei	r2,r2,1
 2002478:	1000021e 	bne	r2,zero,2002484 <prvDecrementSemaphoreCount+0xb8>
	{
		xErrorDetected = pdTRUE;
 200247c:	00800044 	movi	r2,1
 2002480:	d0a04315 	stw	r2,-32500(gp)
	}
}
 2002484:	0001883a 	nop
 2002488:	e037883a 	mov	sp,fp
 200248c:	dfc00117 	ldw	ra,4(sp)
 2002490:	df000017 	ldw	fp,0(sp)
 2002494:	dec00204 	addi	sp,sp,8
 2002498:	f800283a 	ret

0200249c <prvIncrementSemaphoreCount>:
/*-----------------------------------------------------------*/

static void prvIncrementSemaphoreCount( SemaphoreHandle_t xSemaphore, UBaseType_t *puxLoopCounter )
{
 200249c:	defffb04 	addi	sp,sp,-20
 20024a0:	dfc00415 	stw	ra,16(sp)
 20024a4:	df000315 	stw	fp,12(sp)
 20024a8:	df000304 	addi	fp,sp,12
 20024ac:	e13ffe15 	stw	r4,-8(fp)
 20024b0:	e17fff15 	stw	r5,-4(fp)
UBaseType_t ux;

	/* If the semaphore count is zero then we should not be able to	'take'
	the semaphore. */
	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
 20024b4:	000f883a 	mov	r7,zero
 20024b8:	000d883a 	mov	r6,zero
 20024bc:	000b883a 	mov	r5,zero
 20024c0:	e13ffe17 	ldw	r4,-8(fp)
 20024c4:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 20024c8:	10800058 	cmpnei	r2,r2,1
 20024cc:	1000021e 	bne	r2,zero,20024d8 <prvIncrementSemaphoreCount+0x3c>
	{
		xErrorDetected = pdTRUE;
 20024d0:	00800044 	movi	r2,1
 20024d4:	d0a04315 	stw	r2,-32500(gp)
	}

	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 20024d8:	e03ffd15 	stw	zero,-12(fp)
 20024dc:	00001106 	br	2002524 <prvIncrementSemaphoreCount+0x88>
	{
		configASSERT( uxSemaphoreGetCount( xSemaphore ) == ux );

		if( xSemaphoreGive( xSemaphore ) != pdPASS )
 20024e0:	000f883a 	mov	r7,zero
 20024e4:	000d883a 	mov	r6,zero
 20024e8:	000b883a 	mov	r5,zero
 20024ec:	e13ffe17 	ldw	r4,-8(fp)
 20024f0:	20047700 	call	2004770 <xQueueGenericSend>
 20024f4:	10800060 	cmpeqi	r2,r2,1
 20024f8:	1000021e 	bne	r2,zero,2002504 <prvIncrementSemaphoreCount+0x68>
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
 20024fc:	00800044 	movi	r2,1
 2002500:	d0a04315 	stw	r2,-32500(gp)
		}

		( *puxLoopCounter )++;
 2002504:	e0bfff17 	ldw	r2,-4(fp)
 2002508:	10800017 	ldw	r2,0(r2)
 200250c:	10c00044 	addi	r3,r2,1
 2002510:	e0bfff17 	ldw	r2,-4(fp)
 2002514:	10c00015 	stw	r3,0(r2)
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 2002518:	e0bffd17 	ldw	r2,-12(fp)
 200251c:	10800044 	addi	r2,r2,1
 2002520:	e0bffd15 	stw	r2,-12(fp)
 2002524:	e0bffd17 	ldw	r2,-12(fp)
 2002528:	10803230 	cmpltui	r2,r2,200
 200252c:	103fec1e 	bne	r2,zero,20024e0 <__reset+0xfe0014e0>
		taskYIELD();
	#endif

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
 2002530:	000f883a 	mov	r7,zero
 2002534:	000d883a 	mov	r6,zero
 2002538:	000b883a 	mov	r5,zero
 200253c:	e13ffe17 	ldw	r4,-8(fp)
 2002540:	20047700 	call	2004770 <xQueueGenericSend>
 2002544:	10800058 	cmpnei	r2,r2,1
 2002548:	1000021e 	bne	r2,zero,2002554 <prvIncrementSemaphoreCount+0xb8>
	{
		xErrorDetected = pdTRUE;
 200254c:	00800044 	movi	r2,1
 2002550:	d0a04315 	stw	r2,-32500(gp)
	}
}
 2002554:	0001883a 	nop
 2002558:	e037883a 	mov	sp,fp
 200255c:	dfc00117 	ldw	ra,4(sp)
 2002560:	df000017 	ldw	fp,0(sp)
 2002564:	dec00204 	addi	sp,sp,8
 2002568:	f800283a 	ret

0200256c <prvCountingSemaphoreTask>:
/*-----------------------------------------------------------*/

static void prvCountingSemaphoreTask( void *pvParameters )
{
 200256c:	defffc04 	addi	sp,sp,-16
 2002570:	dfc00315 	stw	ra,12(sp)
 2002574:	df000215 	stw	fp,8(sp)
 2002578:	df000204 	addi	fp,sp,8
 200257c:	e13fff15 	stw	r4,-4(fp)
		/* Queue a message for printing to say the task has started. */
		vPrintDisplayMessage( &pcTaskStartMsg );
	#endif

	/* The semaphore to be used was passed as the parameter. */
	pxParameter = ( xCountSemStruct * ) pvParameters;
 2002580:	e0bfff17 	ldw	r2,-4(fp)
 2002584:	e0bffe15 	stw	r2,-8(fp)

	/* Did we expect to find the semaphore already at its max count value, or
	at zero? */
	if( pxParameter->uxExpectedStartCount == countSTART_AT_MAX_COUNT )
 2002588:	e0bffe17 	ldw	r2,-8(fp)
 200258c:	10800117 	ldw	r2,4(r2)
 2002590:	10802a98 	cmpnei	r2,r2,170
 2002594:	1000071e 	bne	r2,zero,20025b4 <prvCountingSemaphoreTask+0x48>
	{
		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 2002598:	e0bffe17 	ldw	r2,-8(fp)
 200259c:	10c00017 	ldw	r3,0(r2)
 20025a0:	e0bffe17 	ldw	r2,-8(fp)
 20025a4:	10800204 	addi	r2,r2,8
 20025a8:	100b883a 	mov	r5,r2
 20025ac:	1809883a 	mov	r4,r3
 20025b0:	20023cc0 	call	20023cc <prvDecrementSemaphoreCount>
	}

	/* Now we expect the semaphore count to be 0, so this time there is an
	error if we can take the semaphore. */
	if( xSemaphoreTake( pxParameter->xSemaphore, 0 ) == pdPASS )
 20025b4:	e0bffe17 	ldw	r2,-8(fp)
 20025b8:	10800017 	ldw	r2,0(r2)
 20025bc:	000f883a 	mov	r7,zero
 20025c0:	000d883a 	mov	r6,zero
 20025c4:	000b883a 	mov	r5,zero
 20025c8:	1009883a 	mov	r4,r2
 20025cc:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 20025d0:	10800058 	cmpnei	r2,r2,1
 20025d4:	1000021e 	bne	r2,zero,20025e0 <prvCountingSemaphoreTask+0x74>
	{
		xErrorDetected = pdTRUE;
 20025d8:	00800044 	movi	r2,1
 20025dc:	d0a04315 	stw	r2,-32500(gp)
	}

	for( ;; )
	{
		prvIncrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 20025e0:	e0bffe17 	ldw	r2,-8(fp)
 20025e4:	10c00017 	ldw	r3,0(r2)
 20025e8:	e0bffe17 	ldw	r2,-8(fp)
 20025ec:	10800204 	addi	r2,r2,8
 20025f0:	100b883a 	mov	r5,r2
 20025f4:	1809883a 	mov	r4,r3
 20025f8:	200249c0 	call	200249c <prvIncrementSemaphoreCount>
		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 20025fc:	e0bffe17 	ldw	r2,-8(fp)
 2002600:	10c00017 	ldw	r3,0(r2)
 2002604:	e0bffe17 	ldw	r2,-8(fp)
 2002608:	10800204 	addi	r2,r2,8
 200260c:	100b883a 	mov	r5,r2
 2002610:	1809883a 	mov	r4,r3
 2002614:	20023cc0 	call	20023cc <prvDecrementSemaphoreCount>
	}
 2002618:	003ff106 	br	20025e0 <__reset+0xfe0015e0>

0200261c <xAreCountingSemaphoreTasksStillRunning>:
}
/*-----------------------------------------------------------*/

BaseType_t xAreCountingSemaphoreTasksStillRunning( void )
{
 200261c:	defffe04 	addi	sp,sp,-8
 2002620:	df000115 	stw	fp,4(sp)
 2002624:	df000104 	addi	fp,sp,4
static UBaseType_t uxLastCount0 = 0, uxLastCount1 = 0;
BaseType_t xReturn = pdPASS;
 2002628:	00800044 	movi	r2,1
 200262c:	e0bfff15 	stw	r2,-4(fp)

	/* Return fail if any 'give' or 'take' did not result in the expected
	behaviour. */
	if( xErrorDetected != pdFALSE )
 2002630:	d0a04317 	ldw	r2,-32500(gp)
 2002634:	10000126 	beq	r2,zero,200263c <xAreCountingSemaphoreTasksStillRunning+0x20>
	{
		xReturn = pdFAIL;
 2002638:	e03fff15 	stw	zero,-4(fp)
	}

	/* Return fail if either task is not still incrementing its loop counter. */
	if( uxLastCount0 == xParameters[ 0 ].uxLoopCounter )
 200263c:	00808074 	movhi	r2,513
 2002640:	10913d04 	addi	r2,r2,17652
 2002644:	10c00217 	ldw	r3,8(r2)
 2002648:	d0a04417 	ldw	r2,-32496(gp)
 200264c:	1880021e 	bne	r3,r2,2002658 <xAreCountingSemaphoreTasksStillRunning+0x3c>
	{
		xReturn = pdFAIL;
 2002650:	e03fff15 	stw	zero,-4(fp)
 2002654:	00000406 	br	2002668 <xAreCountingSemaphoreTasksStillRunning+0x4c>
	}
	else
	{
		uxLastCount0 = xParameters[ 0 ].uxLoopCounter;
 2002658:	00808074 	movhi	r2,513
 200265c:	10913d04 	addi	r2,r2,17652
 2002660:	10800217 	ldw	r2,8(r2)
 2002664:	d0a04415 	stw	r2,-32496(gp)
	}

	if( uxLastCount1 == xParameters[ 1 ].uxLoopCounter )
 2002668:	00808074 	movhi	r2,513
 200266c:	10913d04 	addi	r2,r2,17652
 2002670:	10c00517 	ldw	r3,20(r2)
 2002674:	d0a04517 	ldw	r2,-32492(gp)
 2002678:	1880021e 	bne	r3,r2,2002684 <xAreCountingSemaphoreTasksStillRunning+0x68>
	{
		xReturn = pdFAIL;
 200267c:	e03fff15 	stw	zero,-4(fp)
 2002680:	00000406 	br	2002694 <xAreCountingSemaphoreTasksStillRunning+0x78>
	}
	else
	{
		uxLastCount1 = xParameters[ 1 ].uxLoopCounter;
 2002684:	00808074 	movhi	r2,513
 2002688:	10913d04 	addi	r2,r2,17652
 200268c:	10800517 	ldw	r2,20(r2)
 2002690:	d0a04515 	stw	r2,-32492(gp)
	}

	return xReturn;
 2002694:	e0bfff17 	ldw	r2,-4(fp)
}
 2002698:	e037883a 	mov	sp,fp
 200269c:	df000017 	ldw	fp,0(sp)
 20026a0:	dec00104 	addi	sp,sp,4
 20026a4:	f800283a 	ret

020026a8 <vCreateSuicidalTasks>:
TaskHandle_t xCreatedTask;

/*-----------------------------------------------------------*/

void vCreateSuicidalTasks( UBaseType_t uxPriority )
{
 20026a8:	defffb04 	addi	sp,sp,-20
 20026ac:	dfc00415 	stw	ra,16(sp)
 20026b0:	df000315 	stw	fp,12(sp)
 20026b4:	df000304 	addi	fp,sp,12
 20026b8:	e13fff15 	stw	r4,-4(fp)
	xTaskCreate( vCreateTasks, "CREATOR", deathSTACK_SIZE, ( void * ) NULL, uxPriority, NULL );
 20026bc:	d8000115 	stw	zero,4(sp)
 20026c0:	e0bfff17 	ldw	r2,-4(fp)
 20026c4:	d8800015 	stw	r2,0(sp)
 20026c8:	000f883a 	mov	r7,zero
 20026cc:	01810f04 	movi	r6,1084
 20026d0:	01408074 	movhi	r5,513
 20026d4:	29489b04 	addi	r5,r5,8812
 20026d8:	01008034 	movhi	r4,512
 20026dc:	2109e704 	addi	r4,r4,10140
 20026e0:	20053c80 	call	20053c8 <xTaskCreate>

	/* Record the number of tasks that are running now so we know if any of the
	suicidal tasks have failed to be killed. */
	uxTasksRunningAtStart = ( UBaseType_t ) uxTaskGetNumberOfTasks();
 20026e4:	20062280 	call	2006228 <uxTaskGetNumberOfTasks>
 20026e8:	d0a04715 	stw	r2,-32484(gp)
	/* FreeRTOS.org versions before V3.0 started the idle-task as the very
	first task. The idle task was then already included in uxTasksRunningAtStart.
	From FreeRTOS V3.0 on, the idle task is started when the scheduler is
	started. Therefore the idle task is not yet accounted for. We correct
	this by increasing uxTasksRunningAtStart by 1. */
	uxTasksRunningAtStart++;
 20026ec:	d0a04717 	ldw	r2,-32484(gp)
 20026f0:	10800044 	addi	r2,r2,1
 20026f4:	d0a04715 	stw	r2,-32484(gp)
	#if configUSE_TIMERS == 1
	{
		uxTasksRunningAtStart++;
	}
	#endif
}
 20026f8:	0001883a 	nop
 20026fc:	e037883a 	mov	sp,fp
 2002700:	dfc00117 	ldw	ra,4(sp)
 2002704:	df000017 	ldw	fp,0(sp)
 2002708:	dec00204 	addi	sp,sp,8
 200270c:	f800283a 	ret

02002710 <vSuicidalTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vSuicidalTask, pvParameters )
{
 2002710:	defff904 	addi	sp,sp,-28
 2002714:	dfc00615 	stw	ra,24(sp)
 2002718:	df000515 	stw	fp,20(sp)
 200271c:	df000504 	addi	fp,sp,20
 2002720:	e13fff15 	stw	r4,-4(fp)
volatile long l1, l2;
TaskHandle_t xTaskToKill;
const TickType_t xDelay = pdMS_TO_TICKS( ( TickType_t ) 200 );
 2002724:	00803204 	movi	r2,200
 2002728:	e0bffc15 	stw	r2,-16(fp)

	if( pvParameters != NULL )
 200272c:	e0bfff17 	ldw	r2,-4(fp)
 2002730:	10000426 	beq	r2,zero,2002744 <vSuicidalTask+0x34>
	{
		/* This task is periodically created four times.  Two created tasks are
		passed a handle to the other task so it can kill it before killing itself.
		The other task is passed in null. */
		xTaskToKill = *( TaskHandle_t* )pvParameters;
 2002734:	e0bfff17 	ldw	r2,-4(fp)
 2002738:	10800017 	ldw	r2,0(r2)
 200273c:	e0bffb15 	stw	r2,-20(fp)
 2002740:	00000106 	br	2002748 <vSuicidalTask+0x38>
	}
	else
	{
		xTaskToKill = NULL;
 2002744:	e03ffb15 	stw	zero,-20(fp)
	}

	for( ;; )
	{
		/* Do something random just to use some stack and registers. */
		l1 = 2;
 2002748:	00800084 	movi	r2,2
 200274c:	e0bffd15 	stw	r2,-12(fp)
		l2 = 89;
 2002750:	00801644 	movi	r2,89
 2002754:	e0bffe15 	stw	r2,-8(fp)
		l2 *= l1;
 2002758:	e0bffd17 	ldw	r2,-12(fp)
 200275c:	e0fffe17 	ldw	r3,-8(fp)
 2002760:	180b883a 	mov	r5,r3
 2002764:	1009883a 	mov	r4,r2
 2002768:	2009bcc0 	call	2009bcc <__mulsi3>
 200276c:	e0bffe15 	stw	r2,-8(fp)
		vTaskDelay( xDelay );
 2002770:	e13ffc17 	ldw	r4,-16(fp)
 2002774:	20059600 	call	2005960 <vTaskDelay>

		if( xTaskToKill != NULL )
 2002778:	e0bffb17 	ldw	r2,-20(fp)
 200277c:	103ff226 	beq	r2,zero,2002748 <__reset+0xfe001748>
		{
			/* Make sure the other task has a go before we delete it. */
			vTaskDelay( ( TickType_t ) 0 );
 2002780:	0009883a 	mov	r4,zero
 2002784:	20059600 	call	2005960 <vTaskDelay>

			/* Kill the other task that was created by vCreateTasks(). */
			vTaskDelete( xTaskToKill );
 2002788:	e13ffb17 	ldw	r4,-20(fp)
 200278c:	20057880 	call	2005788 <vTaskDelete>

			/* Kill ourselves. */
			vTaskDelete( NULL );
 2002790:	0009883a 	mov	r4,zero
 2002794:	20057880 	call	2005788 <vTaskDelete>
		}
	}
 2002798:	003feb06 	br	2002748 <__reset+0xfe001748>

0200279c <vCreateTasks>:
}/*lint !e818 !e550 Function prototype must be as per standard for task functions. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCreateTasks, pvParameters )
{
 200279c:	defff904 	addi	sp,sp,-28
 20027a0:	dfc00615 	stw	ra,24(sp)
 20027a4:	df000515 	stw	fp,20(sp)
 20027a8:	df000504 	addi	fp,sp,20
 20027ac:	e13fff15 	stw	r4,-4(fp)
const TickType_t xDelay = pdMS_TO_TICKS( ( TickType_t ) 1000 );
 20027b0:	0080fa04 	movi	r2,1000
 20027b4:	e0bffd15 	stw	r2,-12(fp)
UBaseType_t uxPriority;

	/* Remove compiler warning about unused parameter. */
	( void ) pvParameters;

	uxPriority = uxTaskPriorityGet( NULL );
 20027b8:	0009883a 	mov	r4,zero
 20027bc:	20059bc0 	call	20059bc <uxTaskPriorityGet>
 20027c0:	e0bffe15 	stw	r2,-8(fp)

	for( ;; )
	{
		/* Just loop round, delaying then creating the four suicidal tasks. */
		vTaskDelay( xDelay );
 20027c4:	e13ffd17 	ldw	r4,-12(fp)
 20027c8:	20059600 	call	2005960 <vTaskDelay>

		xCreatedTask = NULL;
 20027cc:	d0204915 	stw	zero,-32476(gp)

		xTaskCreate( vSuicidalTask, "SUICID1", configMINIMAL_STACK_SIZE, NULL, uxPriority, &xCreatedTask );
 20027d0:	d0a04904 	addi	r2,gp,-32476
 20027d4:	d8800115 	stw	r2,4(sp)
 20027d8:	e0bffe17 	ldw	r2,-8(fp)
 20027dc:	d8800015 	stw	r2,0(sp)
 20027e0:	000f883a 	mov	r7,zero
 20027e4:	01810004 	movi	r6,1024
 20027e8:	01408074 	movhi	r5,513
 20027ec:	29489d04 	addi	r5,r5,8820
 20027f0:	01008034 	movhi	r4,512
 20027f4:	2109c404 	addi	r4,r4,10000
 20027f8:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( vSuicidalTask, "SUICID2", configMINIMAL_STACK_SIZE, &xCreatedTask, uxPriority, NULL );
 20027fc:	d8000115 	stw	zero,4(sp)
 2002800:	e0bffe17 	ldw	r2,-8(fp)
 2002804:	d8800015 	stw	r2,0(sp)
 2002808:	d1e04904 	addi	r7,gp,-32476
 200280c:	01810004 	movi	r6,1024
 2002810:	01408074 	movhi	r5,513
 2002814:	29489f04 	addi	r5,r5,8828
 2002818:	01008034 	movhi	r4,512
 200281c:	2109c404 	addi	r4,r4,10000
 2002820:	20053c80 	call	20053c8 <xTaskCreate>

		++usCreationCount;
 2002824:	d0a0460b 	ldhu	r2,-32488(gp)
 2002828:	10800044 	addi	r2,r2,1
 200282c:	d0a0460d 	sth	r2,-32488(gp)
	}
 2002830:	003fe406 	br	20027c4 <__reset+0xfe0017c4>

02002834 <xIsCreateTaskStillRunning>:
/*-----------------------------------------------------------*/

/* This is called to check that the creator task is still running and that there
are not any more than four extra tasks. */
BaseType_t xIsCreateTaskStillRunning( void )
{
 2002834:	defffd04 	addi	sp,sp,-12
 2002838:	dfc00215 	stw	ra,8(sp)
 200283c:	df000115 	stw	fp,4(sp)
 2002840:	df000104 	addi	fp,sp,4
static uint16_t usLastCreationCount = 0xfff;
BaseType_t xReturn = pdTRUE;
 2002844:	00800044 	movi	r2,1
 2002848:	e0bfff15 	stw	r2,-4(fp)
static UBaseType_t uxTasksRunningNow;

	if( usLastCreationCount == usCreationCount )
 200284c:	d0e0010b 	ldhu	r3,-32764(gp)
 2002850:	d0a0460b 	ldhu	r2,-32488(gp)
 2002854:	18ffffcc 	andi	r3,r3,65535
 2002858:	10bfffcc 	andi	r2,r2,65535
 200285c:	1880021e 	bne	r3,r2,2002868 <xIsCreateTaskStillRunning+0x34>
	{
		xReturn = pdFALSE;
 2002860:	e03fff15 	stw	zero,-4(fp)
 2002864:	00000206 	br	2002870 <xIsCreateTaskStillRunning+0x3c>
	}
	else
	{
		usLastCreationCount = usCreationCount;
 2002868:	d0a0460b 	ldhu	r2,-32488(gp)
 200286c:	d0a0010d 	sth	r2,-32764(gp)
	}

	uxTasksRunningNow = ( UBaseType_t ) uxTaskGetNumberOfTasks();
 2002870:	20062280 	call	2006228 <uxTaskGetNumberOfTasks>
 2002874:	d0a04815 	stw	r2,-32480(gp)

	if( uxTasksRunningNow < uxTasksRunningAtStart )
 2002878:	d0e04817 	ldw	r3,-32480(gp)
 200287c:	d0a04717 	ldw	r2,-32484(gp)
 2002880:	1880022e 	bgeu	r3,r2,200288c <xIsCreateTaskStillRunning+0x58>
	{
		xReturn = pdFALSE;
 2002884:	e03fff15 	stw	zero,-4(fp)
 2002888:	00000606 	br	20028a4 <xIsCreateTaskStillRunning+0x70>
	}
	else if( ( uxTasksRunningNow - uxTasksRunningAtStart ) > uxMaxNumberOfExtraTasksRunning )
 200288c:	d0e04817 	ldw	r3,-32480(gp)
 2002890:	d0a04717 	ldw	r2,-32484(gp)
 2002894:	1885c83a 	sub	r2,r3,r2
 2002898:	00c000c4 	movi	r3,3
 200289c:	1880012e 	bgeu	r3,r2,20028a4 <xIsCreateTaskStillRunning+0x70>
	{
		xReturn = pdFALSE;
 20028a0:	e03fff15 	stw	zero,-4(fp)
	else
	{
		/* Everything is okay. */
	}

	return xReturn;
 20028a4:	e0bfff17 	ldw	r2,-4(fp)
}
 20028a8:	e037883a 	mov	sp,fp
 20028ac:	dfc00117 	ldw	ra,4(sp)
 20028b0:	df000017 	ldw	fp,0(sp)
 20028b4:	dec00204 	addi	sp,sp,8
 20028b8:	f800283a 	ret

020028bc <vStartDynamicPriorityTasks>:
/*
 * Start the three tasks as described at the top of the file.
 * Note that the limited count task is given a higher priority.
 */
void vStartDynamicPriorityTasks( void )
{
 20028bc:	defffc04 	addi	sp,sp,-16
 20028c0:	dfc00315 	stw	ra,12(sp)
 20028c4:	df000215 	stw	fp,8(sp)
 20028c8:	df000204 	addi	fp,sp,8
	xSuspendedTestQueue = xQueueCreate( priSUSPENDED_QUEUE_LENGTH, sizeof( uint32_t ) );
 20028cc:	000d883a 	mov	r6,zero
 20028d0:	01400104 	movi	r5,4
 20028d4:	01000044 	movi	r4,1
 20028d8:	20044040 	call	2004404 <xQueueGenericCreate>
 20028dc:	d0a05415 	stw	r2,-32432(gp)

	if( xSuspendedTestQueue != NULL )
 20028e0:	d0a05417 	ldw	r2,-32432(gp)
 20028e4:	10003026 	beq	r2,zero,20029a8 <vStartDynamicPriorityTasks+0xec>
		is not being used.  The call to vQueueAddToRegistry() will be removed
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( xSuspendedTestQueue, "Suspended_Test_Queue" );

		xTaskCreate( vContinuousIncrementTask, "CNT_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY, &xContinuousIncrementHandle );
 20028e8:	d0a04a04 	addi	r2,gp,-32472
 20028ec:	d8800115 	stw	r2,4(sp)
 20028f0:	d8000015 	stw	zero,0(sp)
 20028f4:	d1e04c04 	addi	r7,gp,-32464
 20028f8:	01810004 	movi	r6,1024
 20028fc:	01408074 	movhi	r5,513
 2002900:	2948a104 	addi	r5,r5,8836
 2002904:	01008034 	movhi	r4,512
 2002908:	210a8504 	addi	r4,r4,10772
 200290c:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( vLimitedIncrementTask, "LIM_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY + 1, &xLimitedIncrementHandle );
 2002910:	d0a04b04 	addi	r2,gp,-32468
 2002914:	d8800115 	stw	r2,4(sp)
 2002918:	00800044 	movi	r2,1
 200291c:	d8800015 	stw	r2,0(sp)
 2002920:	d1e04c04 	addi	r7,gp,-32464
 2002924:	01810004 	movi	r6,1024
 2002928:	01408074 	movhi	r5,513
 200292c:	2948a304 	addi	r5,r5,8844
 2002930:	01008034 	movhi	r4,512
 2002934:	210a7004 	addi	r4,r4,10688
 2002938:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( vCounterControlTask, "C_CTRL", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
 200293c:	d8000115 	stw	zero,4(sp)
 2002940:	d8000015 	stw	zero,0(sp)
 2002944:	000f883a 	mov	r7,zero
 2002948:	01810004 	movi	r6,1024
 200294c:	01408074 	movhi	r5,513
 2002950:	2948a504 	addi	r5,r5,8852
 2002954:	01008034 	movhi	r4,512
 2002958:	210a9d04 	addi	r4,r4,10868
 200295c:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( vQueueSendWhenSuspendedTask, "SUSP_TX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
 2002960:	d8000115 	stw	zero,4(sp)
 2002964:	d8000015 	stw	zero,0(sp)
 2002968:	000f883a 	mov	r7,zero
 200296c:	01810004 	movi	r6,1024
 2002970:	01408074 	movhi	r5,513
 2002974:	2948a704 	addi	r5,r5,8860
 2002978:	01008034 	movhi	r4,512
 200297c:	210ad404 	addi	r4,r4,11088
 2002980:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( vQueueReceiveWhenSuspendedTask, "SUSP_RX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
 2002984:	d8000115 	stw	zero,4(sp)
 2002988:	d8000015 	stw	zero,0(sp)
 200298c:	000f883a 	mov	r7,zero
 2002990:	01810004 	movi	r6,1024
 2002994:	01408074 	movhi	r5,513
 2002998:	2948a904 	addi	r5,r5,8868
 200299c:	01008034 	movhi	r4,512
 20029a0:	210aeb04 	addi	r4,r4,11180
 20029a4:	20053c80 	call	20053c8 <xTaskCreate>
	}
}
 20029a8:	0001883a 	nop
 20029ac:	e037883a 	mov	sp,fp
 20029b0:	dfc00117 	ldw	ra,4(sp)
 20029b4:	df000017 	ldw	fp,0(sp)
 20029b8:	dec00204 	addi	sp,sp,8
 20029bc:	f800283a 	ret

020029c0 <vLimitedIncrementTask>:
/*
 * Just loops around incrementing the shared variable until the limit has been
 * reached.  Once the limit has been reached it suspends itself.
 */
static portTASK_FUNCTION( vLimitedIncrementTask, pvParameters )
{
 20029c0:	defffc04 	addi	sp,sp,-16
 20029c4:	dfc00315 	stw	ra,12(sp)
 20029c8:	df000215 	stw	fp,8(sp)
 20029cc:	df000204 	addi	fp,sp,8
 20029d0:	e13fff15 	stw	r4,-4(fp)
uint32_t *pulCounter;

	/* Take a pointer to the shared variable from the parameters passed into
	the task. */
	pulCounter = ( uint32_t * ) pvParameters;
 20029d4:	e0bfff17 	ldw	r2,-4(fp)
 20029d8:	e0bffe15 	stw	r2,-8(fp)

	/* This will run before the control task, so the first thing it does is
	suspend - the control task will resume it when ready. */
	vTaskSuspend( NULL );
 20029dc:	0009883a 	mov	r4,zero
 20029e0:	2005c340 	call	2005c34 <vTaskSuspend>

	for( ;; )
	{
		/* Just count up to a value then suspend. */
		( *pulCounter )++;
 20029e4:	e0bffe17 	ldw	r2,-8(fp)
 20029e8:	10800017 	ldw	r2,0(r2)
 20029ec:	10c00044 	addi	r3,r2,1
 20029f0:	e0bffe17 	ldw	r2,-8(fp)
 20029f4:	10c00015 	stw	r3,0(r2)

		if( *pulCounter >= priMAX_COUNT )
 20029f8:	e0bffe17 	ldw	r2,-8(fp)
 20029fc:	10800017 	ldw	r2,0(r2)
 2002a00:	10803ff0 	cmpltui	r2,r2,255
 2002a04:	103ff71e 	bne	r2,zero,20029e4 <__reset+0xfe0019e4>
		{
			vTaskSuspend( NULL );
 2002a08:	0009883a 	mov	r4,zero
 2002a0c:	2005c340 	call	2005c34 <vTaskSuspend>
		}
	}
 2002a10:	003ff406 	br	20029e4 <__reset+0xfe0019e4>

02002a14 <vContinuousIncrementTask>:
/*
 * Just keep counting the shared variable up.  The control task will suspend
 * this task when it wants.
 */
static portTASK_FUNCTION( vContinuousIncrementTask, pvParameters )
{
 2002a14:	defffb04 	addi	sp,sp,-20
 2002a18:	dfc00415 	stw	ra,16(sp)
 2002a1c:	df000315 	stw	fp,12(sp)
 2002a20:	df000304 	addi	fp,sp,12
 2002a24:	e13fff15 	stw	r4,-4(fp)
volatile uint32_t *pulCounter;
UBaseType_t uxOurPriority;

	/* Take a pointer to the shared variable from the parameters passed into
	the task. */
	pulCounter = ( uint32_t * ) pvParameters;
 2002a28:	e0bfff17 	ldw	r2,-4(fp)
 2002a2c:	e0bffd15 	stw	r2,-12(fp)

	/* Query our priority so we can raise it when exclusive access to the
	shared variable is required. */
	uxOurPriority = uxTaskPriorityGet( NULL );
 2002a30:	0009883a 	mov	r4,zero
 2002a34:	20059bc0 	call	20059bc <uxTaskPriorityGet>
 2002a38:	e0bffe15 	stw	r2,-8(fp)

	for( ;; )
	{
		/* Raise the priority above the controller task to ensure a context
		switch does not occur while the variable is being accessed. */
		vTaskPrioritySet( NULL, uxOurPriority + 1 );
 2002a3c:	e0bffe17 	ldw	r2,-8(fp)
 2002a40:	10800044 	addi	r2,r2,1
 2002a44:	100b883a 	mov	r5,r2
 2002a48:	0009883a 	mov	r4,zero
 2002a4c:	2005a600 	call	2005a60 <vTaskPrioritySet>
		{
			configASSERT( ( uxTaskPriorityGet( NULL ) == ( uxOurPriority + 1 ) ) );
			( *pulCounter )++;
 2002a50:	e0bffd17 	ldw	r2,-12(fp)
 2002a54:	10800017 	ldw	r2,0(r2)
 2002a58:	10c00044 	addi	r3,r2,1
 2002a5c:	e0bffd17 	ldw	r2,-12(fp)
 2002a60:	10c00015 	stw	r3,0(r2)
		}
		vTaskPrioritySet( NULL, uxOurPriority );
 2002a64:	e17ffe17 	ldw	r5,-8(fp)
 2002a68:	0009883a 	mov	r4,zero
 2002a6c:	2005a600 	call	2005a60 <vTaskPrioritySet>
		#if( configUSE_PREEMPTION == 0 )
			taskYIELD();
		#endif

		configASSERT( ( uxTaskPriorityGet( NULL ) == uxOurPriority ) );
	}
 2002a70:	003ff206 	br	2002a3c <__reset+0xfe001a3c>

02002a74 <vCounterControlTask>:

/*
 * Controller task as described above.
 */
static portTASK_FUNCTION( vCounterControlTask, pvParameters )
{
 2002a74:	defffb04 	addi	sp,sp,-20
 2002a78:	dfc00415 	stw	ra,16(sp)
 2002a7c:	df000315 	stw	fp,12(sp)
 2002a80:	df000304 	addi	fp,sp,12
 2002a84:	e13fff15 	stw	r4,-4(fp)
uint32_t ulLastCounter;
short sLoops;
short sError = pdFALSE;
 2002a88:	e03ffd8d 	sth	zero,-10(fp)
	( void ) pvParameters;

	for( ;; )
	{
		/* Start with the counter at zero. */
		ulCounter = ( uint32_t ) 0;
 2002a8c:	d0204c15 	stw	zero,-32464(gp)

		/* First section : */

		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
 2002a90:	e03ffd0d 	sth	zero,-12(fp)
 2002a94:	00001406 	br	2002ae8 <vCounterControlTask+0x74>
		{
			/* Suspend the continuous count task so we can take a mirror of the
			shared variable without risk of corruption.  This is not really
			needed as the other task raises its priority above this task's
			priority. */
			vTaskSuspend( xContinuousIncrementHandle );
 2002a98:	d0a04a17 	ldw	r2,-32472(gp)
 2002a9c:	1009883a 	mov	r4,r2
 2002aa0:	2005c340 	call	2005c34 <vTaskSuspend>
				{
					configASSERT( eTaskGetState( xContinuousIncrementHandle ) == eSuspended );
				}
				#endif /* INCLUDE_eTaskGetState */

				ulLastCounter = ulCounter;
 2002aa4:	d0a04c17 	ldw	r2,-32464(gp)
 2002aa8:	e0bffe15 	stw	r2,-8(fp)
			}
			vTaskResume( xContinuousIncrementHandle );
 2002aac:	d0a04a17 	ldw	r2,-32472(gp)
 2002ab0:	1009883a 	mov	r4,r2
 2002ab4:	2005da80 	call	2005da8 <vTaskResume>
				configASSERT( eTaskGetState( xContinuousIncrementHandle ) == eReady );
			}
			#endif /* INCLUDE_eTaskGetState */

			/* Now delay to ensure the other task has processor time. */
			vTaskDelay( priSLEEP_TIME );
 2002ab8:	01002004 	movi	r4,128
 2002abc:	20059600 	call	2005960 <vTaskDelay>

			/* Check the shared variable again.  This time to ensure mutual
			exclusion the whole scheduler will be locked.  This is just for
			demo purposes! */
			vTaskSuspendAll();
 2002ac0:	20060440 	call	2006044 <vTaskSuspendAll>
			{
				if( ulLastCounter == ulCounter )
 2002ac4:	d0a04c17 	ldw	r2,-32464(gp)
 2002ac8:	e0fffe17 	ldw	r3,-8(fp)
 2002acc:	1880021e 	bne	r3,r2,2002ad8 <vCounterControlTask+0x64>
				{
					/* The shared variable has not changed.  There is a problem
					with the continuous count task so flag an error. */
					sError = pdTRUE;
 2002ad0:	00800044 	movi	r2,1
 2002ad4:	e0bffd8d 	sth	r2,-10(fp)
				}
			}
			xTaskResumeAll();
 2002ad8:	20060700 	call	2006070 <xTaskResumeAll>
		ulCounter = ( uint32_t ) 0;

		/* First section : */

		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
 2002adc:	e0bffd0b 	ldhu	r2,-12(fp)
 2002ae0:	10800044 	addi	r2,r2,1
 2002ae4:	e0bffd0d 	sth	r2,-12(fp)
 2002ae8:	e0bffd0f 	ldh	r2,-12(fp)
 2002aec:	10800150 	cmplti	r2,r2,5
 2002af0:	103fe91e 	bne	r2,zero,2002a98 <__reset+0xfe001a98>

		/* Second section: */

		/* Suspend the continuous counter task so it stops accessing the shared
		variable. */
		vTaskSuspend( xContinuousIncrementHandle );
 2002af4:	d0a04a17 	ldw	r2,-32472(gp)
 2002af8:	1009883a 	mov	r4,r2
 2002afc:	2005c340 	call	2005c34 <vTaskSuspend>

		/* Reset the variable. */
		ulCounter = ( uint32_t ) 0;
 2002b00:	d0204c15 	stw	zero,-32464(gp)
		#endif /* INCLUDE_eTaskGetState */

		/* Resume the limited count task which has a higher priority than us.
		We should therefore not return from this call until the limited count
		task has suspended itself with a known value in the counter variable. */
		vTaskResume( xLimitedIncrementHandle );
 2002b04:	d0a04b17 	ldw	r2,-32468(gp)
 2002b08:	1009883a 	mov	r4,r2
 2002b0c:	2005da80 	call	2005da8 <vTaskResume>
			configASSERT( eTaskGetState( xLimitedIncrementHandle ) == eSuspended );
		}
		#endif /* INCLUDE_eTaskGetState */

		/* Does the counter variable have the expected value? */
		if( ulCounter != priMAX_COUNT )
 2002b10:	d0a04c17 	ldw	r2,-32464(gp)
 2002b14:	10803fe0 	cmpeqi	r2,r2,255
 2002b18:	1000021e 	bne	r2,zero,2002b24 <vCounterControlTask+0xb0>
		{
			sError = pdTRUE;
 2002b1c:	00800044 	movi	r2,1
 2002b20:	e0bffd8d 	sth	r2,-10(fp)
		}

		if( sError == pdFALSE )
 2002b24:	e0bffd8f 	ldh	r2,-10(fp)
 2002b28:	1000051e 	bne	r2,zero,2002b40 <vCounterControlTask+0xcc>
		{
			/* If no errors have occurred then increment the check variable. */
			portENTER_CRITICAL();
 2002b2c:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
				usCheckVariable++;
 2002b30:	d0a04d0b 	ldhu	r2,-32460(gp)
 2002b34:	10800044 	addi	r2,r2,1
 2002b38:	d0a04d0d 	sth	r2,-32460(gp)
			portEXIT_CRITICAL();
 2002b3c:	2006ef80 	call	2006ef8 <vTaskExitCritical>
		}

		/* Resume the continuous count task and do it all again. */
		vTaskResume( xContinuousIncrementHandle );
 2002b40:	d0a04a17 	ldw	r2,-32472(gp)
 2002b44:	1009883a 	mov	r4,r2
 2002b48:	2005da80 	call	2005da8 <vTaskResume>

		#if( configUSE_PREEMPTION == 0 )
			taskYIELD();
		#endif
	}
 2002b4c:	003fcf06 	br	2002a8c <__reset+0xfe001a8c>

02002b50 <vQueueSendWhenSuspendedTask>:
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vQueueSendWhenSuspendedTask, pvParameters )
{
 2002b50:	defffd04 	addi	sp,sp,-12
 2002b54:	dfc00215 	stw	ra,8(sp)
 2002b58:	df000115 	stw	fp,4(sp)
 2002b5c:	df000104 	addi	fp,sp,4
 2002b60:	e13fff15 	stw	r4,-4(fp)
	/* Just to stop warning messages. */
	( void ) pvParameters;

	for( ;; )
	{
		vTaskSuspendAll();
 2002b64:	20060440 	call	2006044 <vTaskSuspendAll>
		{
			/* We must not block while the scheduler is suspended! */
			if( xQueueSend( xSuspendedTestQueue, ( void * ) &ulValueToSend, priNO_BLOCK ) != pdTRUE )
 2002b68:	d0a05417 	ldw	r2,-32432(gp)
 2002b6c:	000f883a 	mov	r7,zero
 2002b70:	000d883a 	mov	r6,zero
 2002b74:	d1605104 	addi	r5,gp,-32444
 2002b78:	1009883a 	mov	r4,r2
 2002b7c:	20047700 	call	2004770 <xQueueGenericSend>
 2002b80:	10800060 	cmpeqi	r2,r2,1
 2002b84:	1000021e 	bne	r2,zero,2002b90 <vQueueSendWhenSuspendedTask+0x40>
			{
				xSuspendedQueueSendError = pdTRUE;
 2002b88:	00800044 	movi	r2,1
 2002b8c:	d0a04e15 	stw	r2,-32456(gp)
			}
		}
		xTaskResumeAll();
 2002b90:	20060700 	call	2006070 <xTaskResumeAll>

		vTaskDelay( priSLEEP_TIME );
 2002b94:	01002004 	movi	r4,128
 2002b98:	20059600 	call	2005960 <vTaskDelay>

		++ulValueToSend;
 2002b9c:	d0a05117 	ldw	r2,-32444(gp)
 2002ba0:	10800044 	addi	r2,r2,1
 2002ba4:	d0a05115 	stw	r2,-32444(gp)
	}
 2002ba8:	003fee06 	br	2002b64 <__reset+0xfe001b64>

02002bac <vQueueReceiveWhenSuspendedTask>:
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vQueueReceiveWhenSuspendedTask, pvParameters )
{
 2002bac:	defffb04 	addi	sp,sp,-20
 2002bb0:	dfc00415 	stw	ra,16(sp)
 2002bb4:	df000315 	stw	fp,12(sp)
 2002bb8:	df000304 	addi	fp,sp,12
 2002bbc:	e13fff15 	stw	r4,-4(fp)
			/* Suspending the scheduler here is fairly pointless and
			undesirable for a normal application.  It is done here purely
			to test the scheduler.  The inner xTaskResumeAll() should
			never return pdTRUE as the scheduler is still locked by the
			outer call. */
			vTaskSuspendAll();
 2002bc0:	20060440 	call	2006044 <vTaskSuspendAll>
			{
				vTaskSuspendAll();
 2002bc4:	20060440 	call	2006044 <vTaskSuspendAll>
				{
					xGotValue = xQueueReceive( xSuspendedTestQueue, ( void * ) &ulReceivedValue, priNO_BLOCK );
 2002bc8:	d0a05417 	ldw	r2,-32432(gp)
 2002bcc:	e0fffe04 	addi	r3,fp,-8
 2002bd0:	000f883a 	mov	r7,zero
 2002bd4:	000d883a 	mov	r6,zero
 2002bd8:	180b883a 	mov	r5,r3
 2002bdc:	1009883a 	mov	r4,r2
 2002be0:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2002be4:	e0bffd15 	stw	r2,-12(fp)
				}
				if( xTaskResumeAll() != pdFALSE )
 2002be8:	20060700 	call	2006070 <xTaskResumeAll>
 2002bec:	10000226 	beq	r2,zero,2002bf8 <vQueueReceiveWhenSuspendedTask+0x4c>
				{
					xSuspendedQueueReceiveError = pdTRUE;
 2002bf0:	00800044 	movi	r2,1
 2002bf4:	d0a04f15 	stw	r2,-32452(gp)
				}
			}
			xTaskResumeAll();
 2002bf8:	20060700 	call	2006070 <xTaskResumeAll>
			{
				taskYIELD();
			}
			#endif

		} while( xGotValue == pdFALSE );
 2002bfc:	e0bffd17 	ldw	r2,-12(fp)
 2002c00:	103fef26 	beq	r2,zero,2002bc0 <__reset+0xfe001bc0>

		if( ulReceivedValue != ulExpectedValue )
 2002c04:	e0fffe17 	ldw	r3,-8(fp)
 2002c08:	d0a05017 	ldw	r2,-32448(gp)
 2002c0c:	18800226 	beq	r3,r2,2002c18 <vQueueReceiveWhenSuspendedTask+0x6c>
		{
			xSuspendedQueueReceiveError = pdTRUE;
 2002c10:	00800044 	movi	r2,1
 2002c14:	d0a04f15 	stw	r2,-32452(gp)
		}

		if( xSuspendedQueueReceiveError != pdTRUE )
 2002c18:	d0a04f17 	ldw	r2,-32452(gp)
 2002c1c:	10800060 	cmpeqi	r2,r2,1
 2002c20:	103fe71e 	bne	r2,zero,2002bc0 <__reset+0xfe001bc0>
		{
			/* Only increment the variable if an error has not occurred.  This
			allows xAreDynamicPriorityTasksStillRunning() to check for stalled
			tasks as well as explicit errors. */
			++ulExpectedValue;
 2002c24:	d0a05017 	ldw	r2,-32448(gp)
 2002c28:	10800044 	addi	r2,r2,1
 2002c2c:	d0a05015 	stw	r2,-32448(gp)
		}
	}
 2002c30:	003fe306 	br	2002bc0 <__reset+0xfe001bc0>

02002c34 <xAreDynamicPriorityTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* Called to check that all the created tasks are still running without error. */
BaseType_t xAreDynamicPriorityTasksStillRunning( void )
{
 2002c34:	defffe04 	addi	sp,sp,-8
 2002c38:	df000115 	stw	fp,4(sp)
 2002c3c:	df000104 	addi	fp,sp,4
/* Keep a history of the check variables so we know if it has been incremented
since the last call. */
static uint16_t usLastTaskCheck = ( uint16_t ) 0;
static uint32_t ulLastExpectedValue = ( uint32_t ) 0U;
BaseType_t xReturn = pdTRUE;
 2002c40:	00800044 	movi	r2,1
 2002c44:	e0bfff15 	stw	r2,-4(fp)

	/* Check the tasks are still running by ensuring the check variable
	is still incrementing. */

	if( usCheckVariable == usLastTaskCheck )
 2002c48:	d0e04d0b 	ldhu	r3,-32460(gp)
 2002c4c:	d0a0520b 	ldhu	r2,-32440(gp)
 2002c50:	18ffffcc 	andi	r3,r3,65535
 2002c54:	10bfffcc 	andi	r2,r2,65535
 2002c58:	1880011e 	bne	r3,r2,2002c60 <xAreDynamicPriorityTasksStillRunning+0x2c>
	{
		/* The check has not incremented so an error exists. */
		xReturn = pdFALSE;
 2002c5c:	e03fff15 	stw	zero,-4(fp)
	}

	if( ulExpectedValue == ulLastExpectedValue )
 2002c60:	d0e05017 	ldw	r3,-32448(gp)
 2002c64:	d0a05317 	ldw	r2,-32436(gp)
 2002c68:	1880011e 	bne	r3,r2,2002c70 <xAreDynamicPriorityTasksStillRunning+0x3c>
	{
		/* The value being received by the queue receive task has not
		incremented so an error exists. */
		xReturn = pdFALSE;
 2002c6c:	e03fff15 	stw	zero,-4(fp)
	}

	if( xSuspendedQueueSendError == pdTRUE )
 2002c70:	d0a04e17 	ldw	r2,-32456(gp)
 2002c74:	10800058 	cmpnei	r2,r2,1
 2002c78:	1000011e 	bne	r2,zero,2002c80 <xAreDynamicPriorityTasksStillRunning+0x4c>
	{
		xReturn = pdFALSE;
 2002c7c:	e03fff15 	stw	zero,-4(fp)
	}

	if( xSuspendedQueueReceiveError == pdTRUE )
 2002c80:	d0a04f17 	ldw	r2,-32452(gp)
 2002c84:	10800058 	cmpnei	r2,r2,1
 2002c88:	1000011e 	bne	r2,zero,2002c90 <xAreDynamicPriorityTasksStillRunning+0x5c>
	{
		xReturn = pdFALSE;
 2002c8c:	e03fff15 	stw	zero,-4(fp)
	}

	usLastTaskCheck = usCheckVariable;
 2002c90:	d0a04d0b 	ldhu	r2,-32460(gp)
 2002c94:	d0a0520d 	sth	r2,-32440(gp)
	ulLastExpectedValue = ulExpectedValue;
 2002c98:	d0a05017 	ldw	r2,-32448(gp)
 2002c9c:	d0a05315 	stw	r2,-32436(gp)

	return xReturn;
 2002ca0:	e0bfff17 	ldw	r2,-4(fp)
}
 2002ca4:	e037883a 	mov	sp,fp
 2002ca8:	df000017 	ldw	fp,0(sp)
 2002cac:	dec00104 	addi	sp,sp,4
 2002cb0:	f800283a 	ret

02002cb4 <vStartLEDFlashTasks>:
static portTASK_FUNCTION_PROTO( vLEDFlashTask, pvParameters );

/*-----------------------------------------------------------*/

void vStartLEDFlashTasks( UBaseType_t uxPriority )
{
 2002cb4:	defffa04 	addi	sp,sp,-24
 2002cb8:	dfc00515 	stw	ra,20(sp)
 2002cbc:	df000415 	stw	fp,16(sp)
 2002cc0:	df000404 	addi	fp,sp,16
 2002cc4:	e13fff15 	stw	r4,-4(fp)
BaseType_t xLEDTask;

	/* Create the three tasks. */
	for( xLEDTask = 0; xLEDTask < ledNUMBER_OF_LEDS; ++xLEDTask )
 2002cc8:	e03ffe15 	stw	zero,-8(fp)
 2002ccc:	00000d06 	br	2002d04 <vStartLEDFlashTasks+0x50>
	{
		/* Spawn the task. */
		xTaskCreate( vLEDFlashTask, "LEDx", ledSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
 2002cd0:	d8000115 	stw	zero,4(sp)
 2002cd4:	e0bfff17 	ldw	r2,-4(fp)
 2002cd8:	d8800015 	stw	r2,0(sp)
 2002cdc:	000f883a 	mov	r7,zero
 2002ce0:	01810004 	movi	r6,1024
 2002ce4:	01408074 	movhi	r5,513
 2002ce8:	2948ab04 	addi	r5,r5,8876
 2002cec:	01008034 	movhi	r4,512
 2002cf0:	210b4a04 	addi	r4,r4,11560
 2002cf4:	20053c80 	call	20053c8 <xTaskCreate>
void vStartLEDFlashTasks( UBaseType_t uxPriority )
{
BaseType_t xLEDTask;

	/* Create the three tasks. */
	for( xLEDTask = 0; xLEDTask < ledNUMBER_OF_LEDS; ++xLEDTask )
 2002cf8:	e0bffe17 	ldw	r2,-8(fp)
 2002cfc:	10800044 	addi	r2,r2,1
 2002d00:	e0bffe15 	stw	r2,-8(fp)
 2002d04:	e0bffe17 	ldw	r2,-8(fp)
 2002d08:	108000d0 	cmplti	r2,r2,3
 2002d0c:	103ff01e 	bne	r2,zero,2002cd0 <__reset+0xfe001cd0>
	{
		/* Spawn the task. */
		xTaskCreate( vLEDFlashTask, "LEDx", ledSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
	}
}
 2002d10:	0001883a 	nop
 2002d14:	e037883a 	mov	sp,fp
 2002d18:	dfc00117 	ldw	ra,4(sp)
 2002d1c:	df000017 	ldw	fp,0(sp)
 2002d20:	dec00204 	addi	sp,sp,8
 2002d24:	f800283a 	ret

02002d28 <vLEDFlashTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vLEDFlashTask, pvParameters )
{
 2002d28:	defffa04 	addi	sp,sp,-24
 2002d2c:	dfc00515 	stw	ra,20(sp)
 2002d30:	df000415 	stw	fp,16(sp)
 2002d34:	df000404 	addi	fp,sp,16
 2002d38:	e13fff15 	stw	r4,-4(fp)

	/* The parameters are not used. */
	( void ) pvParameters;

	/* Calculate the LED and flash rate. */
	portENTER_CRITICAL();
 2002d3c:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
	{
		/* See which of the eight LED's we should use. */
		uxLED = uxFlashTaskNumber;
 2002d40:	d0a05517 	ldw	r2,-32428(gp)
 2002d44:	e0bffc15 	stw	r2,-16(fp)

		/* Update so the next task uses the next LED. */
		uxFlashTaskNumber++;
 2002d48:	d0a05517 	ldw	r2,-32428(gp)
 2002d4c:	10800044 	addi	r2,r2,1
 2002d50:	d0a05515 	stw	r2,-32428(gp)
	}
	portEXIT_CRITICAL();
 2002d54:	2006ef80 	call	2006ef8 <vTaskExitCritical>

	xFlashRate = ledFLASH_RATE_BASE + ( ledFLASH_RATE_BASE * ( TickType_t ) uxLED );
 2002d58:	e0bffc17 	ldw	r2,-16(fp)
 2002d5c:	10800044 	addi	r2,r2,1
 2002d60:	01405344 	movi	r5,333
 2002d64:	1009883a 	mov	r4,r2
 2002d68:	2009bcc0 	call	2009bcc <__mulsi3>
 2002d6c:	e0bffd15 	stw	r2,-12(fp)
	xFlashRate /= portTICK_PERIOD_MS;

	/* We will turn the LED on and off again in the delay period, so each
	delay is only half the total period. */
	xFlashRate /= ( TickType_t ) 2;
 2002d70:	e0bffd17 	ldw	r2,-12(fp)
 2002d74:	1004d07a 	srli	r2,r2,1
 2002d78:	e0bffd15 	stw	r2,-12(fp)

	/* We need to initialise xLastFlashTime prior to the first call to 
	vTaskDelayUntil(). */
	xLastFlashTime = xTaskGetTickCount();
 2002d7c:	20061d40 	call	20061d4 <xTaskGetTickCount>
 2002d80:	e0bffe15 	stw	r2,-8(fp)

	for(;;)
	{
		/* Delay for half the flash period then turn the LED on. */
		vTaskDelayUntil( &xLastFlashTime, xFlashRate );
 2002d84:	e0bffe04 	addi	r2,fp,-8
 2002d88:	e17ffd17 	ldw	r5,-12(fp)
 2002d8c:	1009883a 	mov	r4,r2
 2002d90:	20058700 	call	2005870 <vTaskDelayUntil>
		vParTestToggleLED( uxLED );
 2002d94:	e13ffc17 	ldw	r4,-16(fp)
 2002d98:	20037f00 	call	20037f0 <vParTestToggleLED>

		/* Delay for half the flash period then turn the LED off. */
		vTaskDelayUntil( &xLastFlashTime, xFlashRate );
 2002d9c:	e0bffe04 	addi	r2,fp,-8
 2002da0:	e17ffd17 	ldw	r5,-12(fp)
 2002da4:	1009883a 	mov	r4,r2
 2002da8:	20058700 	call	2005870 <vTaskDelayUntil>
		vParTestToggleLED( uxLED );
 2002dac:	e13ffc17 	ldw	r4,-16(fp)
 2002db0:	20037f00 	call	20037f0 <vParTestToggleLED>
	}
 2002db4:	003ff306 	br	2002d84 <__reset+0xfe001d84>

02002db8 <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
 2002db8:	defffa04 	addi	sp,sp,-24
 2002dbc:	dfc00515 	stw	ra,20(sp)
 2002dc0:	df000415 	stw	fp,16(sp)
 2002dc4:	df000404 	addi	fp,sp,16
 2002dc8:	e13fff15 	stw	r4,-4(fp)
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
 2002dcc:	e03ffe0d 	sth	zero,-8(fp)
 2002dd0:	00001206 	br	2002e1c <vStartIntegerMathTasks+0x64>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
 2002dd4:	e0bffe0f 	ldh	r2,-8(fp)
 2002dd8:	1085883a 	add	r2,r2,r2
 2002ddc:	1087883a 	add	r3,r2,r2
 2002de0:	d0a05604 	addi	r2,gp,-32424
 2002de4:	1887883a 	add	r3,r3,r2
 2002de8:	d8000115 	stw	zero,4(sp)
 2002dec:	e0bfff17 	ldw	r2,-4(fp)
 2002df0:	d8800015 	stw	r2,0(sp)
 2002df4:	180f883a 	mov	r7,r3
 2002df8:	01810004 	movi	r6,1024
 2002dfc:	01408074 	movhi	r5,513
 2002e00:	2948ad04 	addi	r5,r5,8884
 2002e04:	01008034 	movhi	r4,512
 2002e08:	210b8f04 	addi	r4,r4,11836
 2002e0c:	20053c80 	call	20053c8 <xTaskCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
 2002e10:	e0bffe0b 	ldhu	r2,-8(fp)
 2002e14:	10800044 	addi	r2,r2,1
 2002e18:	e0bffe0d 	sth	r2,-8(fp)
 2002e1c:	e0bffe0f 	ldh	r2,-8(fp)
 2002e20:	00bfec0e 	bge	zero,r2,2002dd4 <__reset+0xfe001dd4>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
 2002e24:	0001883a 	nop
 2002e28:	e037883a 	mov	sp,fp
 2002e2c:	dfc00117 	ldw	ra,4(sp)
 2002e30:	df000017 	ldw	fp,0(sp)
 2002e34:	dec00204 	addi	sp,sp,8
 2002e38:	f800283a 	ret

02002e3c <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
 2002e3c:	defffa04 	addi	sp,sp,-24
 2002e40:	dfc00515 	stw	ra,20(sp)
 2002e44:	df000415 	stw	fp,16(sp)
 2002e48:	df000404 	addi	fp,sp,16
 2002e4c:	e13fff15 	stw	r4,-4(fp)
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
 2002e50:	e03ffc0d 	sth	zero,-16(fp)
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
 2002e54:	e0bfff17 	ldw	r2,-4(fp)
 2002e58:	e0bffd15 	stw	r2,-12(fp)
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
 2002e5c:	00801ec4 	movi	r2,123
 2002e60:	e0bffe15 	stw	r2,-8(fp)
		lValue += intgCONST2;
 2002e64:	e0fffe17 	ldw	r3,-8(fp)
 2002e68:	00800134 	movhi	r2,4
 2002e6c:	10a511c4 	addi	r2,r2,-27577
 2002e70:	1885883a 	add	r2,r3,r2
 2002e74:	e0bffe15 	stw	r2,-8(fp)
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
 2002e78:	e0bffe17 	ldw	r2,-8(fp)
 2002e7c:	017fff44 	movi	r5,-3
 2002e80:	1009883a 	mov	r4,r2
 2002e84:	2009bcc0 	call	2009bcc <__mulsi3>
 2002e88:	e0bffe15 	stw	r2,-8(fp)
		lValue /= intgCONST4;
 2002e8c:	e0bffe17 	ldw	r2,-8(fp)
 2002e90:	014001c4 	movi	r5,7
 2002e94:	1009883a 	mov	r4,r2
 2002e98:	2009a180 	call	2009a18 <__divsi3>
 2002e9c:	e0bffe15 	stw	r2,-8(fp)

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
 2002ea0:	e0fffe17 	ldw	r3,-8(fp)
 2002ea4:	00bfffb4 	movhi	r2,65534
 2002ea8:	109dc6c4 	addi	r2,r2,30491
 2002eac:	18800226 	beq	r3,r2,2002eb8 <vCompeteingIntMathTask+0x7c>
		{
			sError = pdTRUE;
 2002eb0:	00800044 	movi	r2,1
 2002eb4:	e0bffc0d 	sth	r2,-16(fp)
		}

		if( sError == pdFALSE )
 2002eb8:	e0bffc0f 	ldh	r2,-16(fp)
 2002ebc:	103fe71e 	bne	r2,zero,2002e5c <__reset+0xfe001e5c>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
 2002ec0:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
				*pxTaskHasExecuted = pdTRUE;
 2002ec4:	e0bffd17 	ldw	r2,-12(fp)
 2002ec8:	00c00044 	movi	r3,1
 2002ecc:	10c00015 	stw	r3,0(r2)
			portEXIT_CRITICAL();
 2002ed0:	2006ef80 	call	2006ef8 <vTaskExitCritical>
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
 2002ed4:	003fe106 	br	2002e5c <__reset+0xfe001e5c>

02002ed8 <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
 2002ed8:	defffd04 	addi	sp,sp,-12
 2002edc:	df000215 	stw	fp,8(sp)
 2002ee0:	df000204 	addi	fp,sp,8
BaseType_t xReturn = pdTRUE;
 2002ee4:	00800044 	movi	r2,1
 2002ee8:	e0bffe15 	stw	r2,-8(fp)
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
 2002eec:	e03fff0d 	sth	zero,-4(fp)
 2002ef0:	00001106 	br	2002f38 <xAreIntegerMathsTaskStillRunning+0x60>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
 2002ef4:	e0bfff0f 	ldh	r2,-4(fp)
 2002ef8:	1085883a 	add	r2,r2,r2
 2002efc:	1087883a 	add	r3,r2,r2
 2002f00:	d0a05604 	addi	r2,gp,-32424
 2002f04:	1885883a 	add	r2,r3,r2
 2002f08:	10800017 	ldw	r2,0(r2)
 2002f0c:	1000011e 	bne	r2,zero,2002f14 <xAreIntegerMathsTaskStillRunning+0x3c>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
 2002f10:	e03ffe15 	stw	zero,-8(fp)
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
 2002f14:	e0bfff0f 	ldh	r2,-4(fp)
 2002f18:	1085883a 	add	r2,r2,r2
 2002f1c:	1087883a 	add	r3,r2,r2
 2002f20:	d0a05604 	addi	r2,gp,-32424
 2002f24:	1885883a 	add	r2,r3,r2
 2002f28:	10000015 	stw	zero,0(r2)
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
 2002f2c:	e0bfff0b 	ldhu	r2,-4(fp)
 2002f30:	10800044 	addi	r2,r2,1
 2002f34:	e0bfff0d 	sth	r2,-4(fp)
 2002f38:	e0bfff0f 	ldh	r2,-4(fp)
 2002f3c:	00bfed0e 	bge	zero,r2,2002ef4 <__reset+0xfe001ef4>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
 2002f40:	e0bffe17 	ldw	r2,-8(fp)
}
 2002f44:	e037883a 	mov	sp,fp
 2002f48:	df000017 	ldw	fp,0(sp)
 2002f4c:	dec00104 	addi	sp,sp,4
 2002f50:	f800283a 	ret

02002f54 <vStartRecursiveMutexTasks>:
static TaskHandle_t xControllingTaskHandle, xBlockingTaskHandle;

/*-----------------------------------------------------------*/

void vStartRecursiveMutexTasks( void )
{
 2002f54:	defffc04 	addi	sp,sp,-16
 2002f58:	dfc00315 	stw	ra,12(sp)
 2002f5c:	df000215 	stw	fp,8(sp)
 2002f60:	df000204 	addi	fp,sp,8
	/* Just creates the mutex and the three tasks. */

	xMutex = xSemaphoreCreateRecursiveMutex();
 2002f64:	01000104 	movi	r4,4
 2002f68:	20045880 	call	2004588 <xQueueCreateMutex>
 2002f6c:	d0a05715 	stw	r2,-32420(gp)

	if( xMutex != NULL )
 2002f70:	d0a05717 	ldw	r2,-32420(gp)
 2002f74:	10001f26 	beq	r2,zero,2002ff4 <vStartRecursiveMutexTasks+0xa0>
		is not being used.  The call to vQueueAddToRegistry() will be removed
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( ( QueueHandle_t ) xMutex, "Recursive_Mutex" );

		xTaskCreate( prvRecursiveMutexControllingTask, "Rec1", configMINIMAL_STACK_SIZE, NULL, recmuCONTROLLING_TASK_PRIORITY, &xControllingTaskHandle );
 2002f78:	d0a05e04 	addi	r2,gp,-32392
 2002f7c:	d8800115 	stw	r2,4(sp)
 2002f80:	00800084 	movi	r2,2
 2002f84:	d8800015 	stw	r2,0(sp)
 2002f88:	000f883a 	mov	r7,zero
 2002f8c:	01810004 	movi	r6,1024
 2002f90:	01408074 	movhi	r5,513
 2002f94:	2948af04 	addi	r5,r5,8892
 2002f98:	01008034 	movhi	r4,512
 2002f9c:	210c0304 	addi	r4,r4,12300
 2002fa0:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( prvRecursiveMutexBlockingTask, "Rec2", configMINIMAL_STACK_SIZE, NULL, recmuBLOCKING_TASK_PRIORITY, &xBlockingTaskHandle );
 2002fa4:	d0a05f04 	addi	r2,gp,-32388
 2002fa8:	d8800115 	stw	r2,4(sp)
 2002fac:	00800044 	movi	r2,1
 2002fb0:	d8800015 	stw	r2,0(sp)
 2002fb4:	000f883a 	mov	r7,zero
 2002fb8:	01810004 	movi	r6,1024
 2002fbc:	01408074 	movhi	r5,513
 2002fc0:	2948b104 	addi	r5,r5,8900
 2002fc4:	01008034 	movhi	r4,512
 2002fc8:	210c4204 	addi	r4,r4,12552
 2002fcc:	20053c80 	call	20053c8 <xTaskCreate>
		xTaskCreate( prvRecursiveMutexPollingTask, "Rec3", configMINIMAL_STACK_SIZE, NULL, recmuPOLLING_TASK_PRIORITY, NULL );
 2002fd0:	d8000115 	stw	zero,4(sp)
 2002fd4:	d8000015 	stw	zero,0(sp)
 2002fd8:	000f883a 	mov	r7,zero
 2002fdc:	01810004 	movi	r6,1024
 2002fe0:	01408074 	movhi	r5,513
 2002fe4:	2948b304 	addi	r5,r5,8908
 2002fe8:	01008034 	movhi	r4,512
 2002fec:	210c6c04 	addi	r4,r4,12720
 2002ff0:	20053c80 	call	20053c8 <xTaskCreate>
	}
}
 2002ff4:	0001883a 	nop
 2002ff8:	e037883a 	mov	sp,fp
 2002ffc:	dfc00117 	ldw	ra,4(sp)
 2003000:	df000017 	ldw	fp,0(sp)
 2003004:	dec00204 	addi	sp,sp,8
 2003008:	f800283a 	ret

0200300c <prvRecursiveMutexControllingTask>:
/*-----------------------------------------------------------*/

static void prvRecursiveMutexControllingTask( void *pvParameters )
{
 200300c:	defffc04 	addi	sp,sp,-16
 2003010:	dfc00315 	stw	ra,12(sp)
 2003014:	df000215 	stw	fp,8(sp)
 2003018:	df000204 	addi	fp,sp,8
 200301c:	e13fff15 	stw	r4,-4(fp)
	{
		/* Should not be able to 'give' the mutex, as we have not yet 'taken'
		it.   The first time through, the mutex will not have been used yet,
		subsequent times through, at this point the mutex will be held by the
		polling task. */
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
 2003020:	d0a05717 	ldw	r2,-32420(gp)
 2003024:	1009883a 	mov	r4,r2
 2003028:	20045e40 	call	20045e4 <xQueueGiveMutexRecursive>
 200302c:	10800058 	cmpnei	r2,r2,1
 2003030:	1000021e 	bne	r2,zero,200303c <prvRecursiveMutexControllingTask+0x30>
		{
			xErrorOccurred = pdTRUE;
 2003034:	00800044 	movi	r2,1
 2003038:	d0a05815 	stw	r2,-32416(gp)
		}

		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 200303c:	e03ffe15 	stw	zero,-8(fp)
 2003040:	00000d06 	br	2003078 <prvRecursiveMutexControllingTask+0x6c>
			at this point and this Take will cause the polling task to inherit
			the priority of this task.  In this case the block time must be
			long enough to ensure the polling task will execute again before the
			block time expires.  If the block time does expire then the error
			flag will be set here. */
			if( xSemaphoreTakeRecursive( xMutex, recmu15ms_DELAY ) != pdPASS )
 2003044:	d0a05717 	ldw	r2,-32420(gp)
 2003048:	014003c4 	movi	r5,15
 200304c:	1009883a 	mov	r4,r2
 2003050:	20046740 	call	2004674 <xQueueTakeMutexRecursive>
 2003054:	10800060 	cmpeqi	r2,r2,1
 2003058:	1000021e 	bne	r2,zero,2003064 <prvRecursiveMutexControllingTask+0x58>
			{
				xErrorOccurred = pdTRUE;
 200305c:	00800044 	movi	r2,1
 2003060:	d0a05815 	stw	r2,-32416(gp)

			/* Ensure the other task attempting to access the mutex (and the
			other demo tasks) are able to execute to ensure they either block
			(where a block time is specified) or return an error (where no
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
 2003064:	01000504 	movi	r4,20
 2003068:	20059600 	call	2005960 <vTaskDelay>
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
		{
			xErrorOccurred = pdTRUE;
		}

		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 200306c:	e0bffe17 	ldw	r2,-8(fp)
 2003070:	10800044 	addi	r2,r2,1
 2003074:	e0bffe15 	stw	r2,-8(fp)
 2003078:	e0bffe17 	ldw	r2,-8(fp)
 200307c:	108002b0 	cmpltui	r2,r2,10
 2003080:	103ff01e 	bne	r2,zero,2003044 <__reset+0xfe002044>
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
		}

		/* For each time we took the mutex, give it back. */
		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 2003084:	e03ffe15 	stw	zero,-8(fp)
 2003088:	00000c06 	br	20030bc <prvRecursiveMutexControllingTask+0xb0>
		{
			/* Ensure the other task attempting to access the mutex (and the
			other demo tasks) are able to execute. */
			vTaskDelay( recmuSHORT_DELAY );
 200308c:	01000504 	movi	r4,20
 2003090:	20059600 	call	2005960 <vTaskDelay>
			/* We should now be able to give the mutex as many times as we
			took it.  When the mutex is available again the Blocking task
			should be unblocked but not run because it has a lower priority
			than this task.  The polling task should also not run at this point
			as it too has a lower priority than this task. */
			if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 2003094:	d0a05717 	ldw	r2,-32420(gp)
 2003098:	1009883a 	mov	r4,r2
 200309c:	20045e40 	call	20045e4 <xQueueGiveMutexRecursive>
 20030a0:	10800060 	cmpeqi	r2,r2,1
 20030a4:	1000021e 	bne	r2,zero,20030b0 <prvRecursiveMutexControllingTask+0xa4>
			{
				xErrorOccurred = pdTRUE;
 20030a8:	00800044 	movi	r2,1
 20030ac:	d0a05815 	stw	r2,-32416(gp)
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
		}

		/* For each time we took the mutex, give it back. */
		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 20030b0:	e0bffe17 	ldw	r2,-8(fp)
 20030b4:	10800044 	addi	r2,r2,1
 20030b8:	e0bffe15 	stw	r2,-8(fp)
 20030bc:	e0bffe17 	ldw	r2,-8(fp)
 20030c0:	108002b0 	cmpltui	r2,r2,10
 20030c4:	103ff11e 	bne	r2,zero,200308c <__reset+0xfe00208c>
			#endif
		}

		/* Having given it back the same number of times as it was taken, we
		should no longer be the mutex owner, so the next give should fail. */
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
 20030c8:	d0a05717 	ldw	r2,-32420(gp)
 20030cc:	1009883a 	mov	r4,r2
 20030d0:	20045e40 	call	20045e4 <xQueueGiveMutexRecursive>
 20030d4:	10800058 	cmpnei	r2,r2,1
 20030d8:	1000021e 	bne	r2,zero,20030e4 <prvRecursiveMutexControllingTask+0xd8>
		{
			xErrorOccurred = pdTRUE;
 20030dc:	00800044 	movi	r2,1
 20030e0:	d0a05815 	stw	r2,-32416(gp)
		}

		/* Keep count of the number of cycles this task has performed so a
		stall can be detected. */
		uxControllingCycles++;
 20030e4:	d0a05b17 	ldw	r2,-32404(gp)
 20030e8:	10800044 	addi	r2,r2,1
 20030ec:	d0a05b15 	stw	r2,-32404(gp)

		/* Suspend ourselves so the blocking task can execute. */
		xControllingIsSuspended = pdTRUE;
 20030f0:	00800044 	movi	r2,1
 20030f4:	d0a05915 	stw	r2,-32412(gp)
		vTaskSuspend( NULL );
 20030f8:	0009883a 	mov	r4,zero
 20030fc:	2005c340 	call	2005c34 <vTaskSuspend>
		xControllingIsSuspended = pdFALSE;
 2003100:	d0205915 	stw	zero,-32412(gp)
	}
 2003104:	003fc606 	br	2003020 <__reset+0xfe002020>

02003108 <prvRecursiveMutexBlockingTask>:
}
/*-----------------------------------------------------------*/

static void prvRecursiveMutexBlockingTask( void *pvParameters )
{
 2003108:	defffd04 	addi	sp,sp,-12
 200310c:	dfc00215 	stw	ra,8(sp)
 2003110:	df000115 	stw	fp,4(sp)
 2003114:	df000104 	addi	fp,sp,4
 2003118:	e13fff15 	stw	r4,-4(fp)
		this call should block until the controlling task has given up the
		mutex, and not actually execute	past this call until the controlling
		task is suspended.  portMAX_DELAY - 1 is used instead of portMAX_DELAY
		to ensure the task's state is reported as Blocked and not Suspended in
		a later call to configASSERT() (within the polling task). */
		if( xSemaphoreTakeRecursive( xMutex, ( portMAX_DELAY - 1 ) ) == pdPASS )
 200311c:	d0a05717 	ldw	r2,-32420(gp)
 2003120:	017fff84 	movi	r5,-2
 2003124:	1009883a 	mov	r4,r2
 2003128:	20046740 	call	2004674 <xQueueTakeMutexRecursive>
 200312c:	10800058 	cmpnei	r2,r2,1
 2003130:	1000131e 	bne	r2,zero,2003180 <prvRecursiveMutexBlockingTask+0x78>
		{
			if( xControllingIsSuspended != pdTRUE )
 2003134:	d0a05917 	ldw	r2,-32412(gp)
 2003138:	10800060 	cmpeqi	r2,r2,1
 200313c:	1000031e 	bne	r2,zero,200314c <prvRecursiveMutexBlockingTask+0x44>
			{
				/* Did not expect to execute until the controlling task was
				suspended. */
				xErrorOccurred = pdTRUE;
 2003140:	00800044 	movi	r2,1
 2003144:	d0a05815 	stw	r2,-32416(gp)
 2003148:	00000f06 	br	2003188 <prvRecursiveMutexBlockingTask+0x80>
			}
			else
			{
				/* Give the mutex back before suspending ourselves to allow
				the polling task to obtain the mutex. */
				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 200314c:	d0a05717 	ldw	r2,-32420(gp)
 2003150:	1009883a 	mov	r4,r2
 2003154:	20045e40 	call	20045e4 <xQueueGiveMutexRecursive>
 2003158:	10800060 	cmpeqi	r2,r2,1
 200315c:	1000021e 	bne	r2,zero,2003168 <prvRecursiveMutexBlockingTask+0x60>
				{
					xErrorOccurred = pdTRUE;
 2003160:	00800044 	movi	r2,1
 2003164:	d0a05815 	stw	r2,-32416(gp)
				}

				xBlockingIsSuspended = pdTRUE;
 2003168:	00800044 	movi	r2,1
 200316c:	d0a05a15 	stw	r2,-32408(gp)
				vTaskSuspend( NULL );
 2003170:	0009883a 	mov	r4,zero
 2003174:	2005c340 	call	2005c34 <vTaskSuspend>
				xBlockingIsSuspended = pdFALSE;
 2003178:	d0205a15 	stw	zero,-32408(gp)
 200317c:	00000206 	br	2003188 <prvRecursiveMutexBlockingTask+0x80>
		}
		else
		{
			/* We should not leave the xSemaphoreTakeRecursive() function
			until the mutex was obtained. */
			xErrorOccurred = pdTRUE;
 2003180:	00800044 	movi	r2,1
 2003184:	d0a05815 	stw	r2,-32416(gp)
		}

		/* The controlling and blocking tasks should be in lock step. */
		if( uxControllingCycles != ( uxBlockingCycles + 1 ) )
 2003188:	d0a05c17 	ldw	r2,-32400(gp)
 200318c:	10c00044 	addi	r3,r2,1
 2003190:	d0a05b17 	ldw	r2,-32404(gp)
 2003194:	18800226 	beq	r3,r2,20031a0 <prvRecursiveMutexBlockingTask+0x98>
		{
			xErrorOccurred = pdTRUE;
 2003198:	00800044 	movi	r2,1
 200319c:	d0a05815 	stw	r2,-32416(gp)
		}

		/* Keep count of the number of cycles this task has performed so a
		stall can be detected. */
		uxBlockingCycles++;
 20031a0:	d0a05c17 	ldw	r2,-32400(gp)
 20031a4:	10800044 	addi	r2,r2,1
 20031a8:	d0a05c15 	stw	r2,-32400(gp)
	}
 20031ac:	003fdb06 	br	200311c <__reset+0xfe00211c>

020031b0 <prvRecursiveMutexPollingTask>:
}
/*-----------------------------------------------------------*/

static void prvRecursiveMutexPollingTask( void *pvParameters )
{
 20031b0:	defffd04 	addi	sp,sp,-12
 20031b4:	dfc00215 	stw	ra,8(sp)
 20031b8:	df000115 	stw	fp,4(sp)
 20031bc:	df000104 	addi	fp,sp,4
 20031c0:	e13fff15 	stw	r4,-4(fp)
	for( ;; )
	{
		/* Keep attempting to obtain the mutex.  We should only obtain it when
		the blocking task has suspended itself, which in turn should only
		happen when the controlling task is also suspended. */
		if( xSemaphoreTakeRecursive( xMutex, recmuNO_DELAY ) == pdPASS )
 20031c4:	d0a05717 	ldw	r2,-32420(gp)
 20031c8:	000b883a 	mov	r5,zero
 20031cc:	1009883a 	mov	r4,r2
 20031d0:	20046740 	call	2004674 <xQueueTakeMutexRecursive>
 20031d4:	10800058 	cmpnei	r2,r2,1
 20031d8:	103ffa1e 	bne	r2,zero,20031c4 <__reset+0xfe0021c4>
				configASSERT( eTaskGetState( xBlockingTaskHandle ) == eSuspended );
			}
			#endif /* INCLUDE_eTaskGetState */

			/* Is the blocking task suspended? */
			if( ( xBlockingIsSuspended != pdTRUE ) || ( xControllingIsSuspended != pdTRUE ) )
 20031dc:	d0a05a17 	ldw	r2,-32408(gp)
 20031e0:	10800058 	cmpnei	r2,r2,1
 20031e4:	1000031e 	bne	r2,zero,20031f4 <prvRecursiveMutexPollingTask+0x44>
 20031e8:	d0a05917 	ldw	r2,-32412(gp)
 20031ec:	10800060 	cmpeqi	r2,r2,1
 20031f0:	1000031e 	bne	r2,zero,2003200 <prvRecursiveMutexPollingTask+0x50>
			{
				xErrorOccurred = pdTRUE;
 20031f4:	00800044 	movi	r2,1
 20031f8:	d0a05815 	stw	r2,-32416(gp)
 20031fc:	00001806 	br	2003260 <prvRecursiveMutexPollingTask+0xb0>
			}
			else
			{
				/* Keep count of the number of cycles this task has performed
				so a stall can be detected. */
				uxPollingCycles++;
 2003200:	d0a05d17 	ldw	r2,-32396(gp)
 2003204:	10800044 	addi	r2,r2,1
 2003208:	d0a05d15 	stw	r2,-32396(gp)
				will then inherit the higher priority.  The Blocking task will
				block indefinitely when it attempts to obtain the mutex, the
				Controlling task will only block for a fixed period and an
				error will be latched if the polling task has not returned the
				mutex by the time this fixed period has expired. */
				vTaskResume( xBlockingTaskHandle );
 200320c:	d0a05f17 	ldw	r2,-32388(gp)
 2003210:	1009883a 	mov	r4,r2
 2003214:	2005da80 	call	2005da8 <vTaskResume>
				#if( configUSE_PREEMPTION == 0 )
					taskYIELD();
				#endif

				vTaskResume( xControllingTaskHandle );
 2003218:	d0a05e17 	ldw	r2,-32392(gp)
 200321c:	1009883a 	mov	r4,r2
 2003220:	2005da80 	call	2005da8 <vTaskResume>
					taskYIELD();
				#endif

				/* The other two tasks should now have executed and no longer
				be suspended. */
				if( ( xBlockingIsSuspended == pdTRUE ) || ( xControllingIsSuspended == pdTRUE ) )
 2003224:	d0a05a17 	ldw	r2,-32408(gp)
 2003228:	10800060 	cmpeqi	r2,r2,1
 200322c:	1000031e 	bne	r2,zero,200323c <prvRecursiveMutexPollingTask+0x8c>
 2003230:	d0a05917 	ldw	r2,-32412(gp)
 2003234:	10800058 	cmpnei	r2,r2,1
 2003238:	1000021e 	bne	r2,zero,2003244 <prvRecursiveMutexPollingTask+0x94>
				{
					xErrorOccurred = pdTRUE;
 200323c:	00800044 	movi	r2,1
 2003240:	d0a05815 	stw	r2,-32416(gp)
					configASSERT( eTaskGetState( xBlockingTaskHandle ) == eBlocked );
				}
				#endif /* INCLUDE_eTaskGetState */

				/* Release the mutex, disinheriting the higher priority again. */
				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 2003244:	d0a05717 	ldw	r2,-32420(gp)
 2003248:	1009883a 	mov	r4,r2
 200324c:	20045e40 	call	20045e4 <xQueueGiveMutexRecursive>
 2003250:	10800060 	cmpeqi	r2,r2,1
 2003254:	103fdb1e 	bne	r2,zero,20031c4 <__reset+0xfe0021c4>
				{
					xErrorOccurred = pdTRUE;
 2003258:	00800044 	movi	r2,1
 200325c:	d0a05815 	stw	r2,-32416(gp)
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
 2003260:	003fd806 	br	20031c4 <__reset+0xfe0021c4>

02003264 <xAreRecursiveMutexTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreRecursiveMutexTasksStillRunning( void )
{
 2003264:	defffe04 	addi	sp,sp,-8
 2003268:	df000115 	stw	fp,4(sp)
 200326c:	df000104 	addi	fp,sp,4
BaseType_t xReturn;
static UBaseType_t uxLastControllingCycles = 0, uxLastBlockingCycles = 0, uxLastPollingCycles = 0;

	/* Is the controlling task still cycling? */
	if( uxLastControllingCycles == uxControllingCycles )
 2003270:	d0e06017 	ldw	r3,-32384(gp)
 2003274:	d0a05b17 	ldw	r2,-32404(gp)
 2003278:	1880031e 	bne	r3,r2,2003288 <xAreRecursiveMutexTasksStillRunning+0x24>
	{
		xErrorOccurred = pdTRUE;
 200327c:	00800044 	movi	r2,1
 2003280:	d0a05815 	stw	r2,-32416(gp)
 2003284:	00000206 	br	2003290 <xAreRecursiveMutexTasksStillRunning+0x2c>
	}
	else
	{
		uxLastControllingCycles = uxControllingCycles;
 2003288:	d0a05b17 	ldw	r2,-32404(gp)
 200328c:	d0a06015 	stw	r2,-32384(gp)
	}

	/* Is the blocking task still cycling? */
	if( uxLastBlockingCycles == uxBlockingCycles )
 2003290:	d0e06117 	ldw	r3,-32380(gp)
 2003294:	d0a05c17 	ldw	r2,-32400(gp)
 2003298:	1880031e 	bne	r3,r2,20032a8 <xAreRecursiveMutexTasksStillRunning+0x44>
	{
		xErrorOccurred = pdTRUE;
 200329c:	00800044 	movi	r2,1
 20032a0:	d0a05815 	stw	r2,-32416(gp)
 20032a4:	00000206 	br	20032b0 <xAreRecursiveMutexTasksStillRunning+0x4c>
	}
	else
	{
		uxLastBlockingCycles = uxBlockingCycles;
 20032a8:	d0a05c17 	ldw	r2,-32400(gp)
 20032ac:	d0a06115 	stw	r2,-32380(gp)
	}

	/* Is the polling task still cycling? */
	if( uxLastPollingCycles == uxPollingCycles )
 20032b0:	d0e06217 	ldw	r3,-32376(gp)
 20032b4:	d0a05d17 	ldw	r2,-32396(gp)
 20032b8:	1880031e 	bne	r3,r2,20032c8 <xAreRecursiveMutexTasksStillRunning+0x64>
	{
		xErrorOccurred = pdTRUE;
 20032bc:	00800044 	movi	r2,1
 20032c0:	d0a05815 	stw	r2,-32416(gp)
 20032c4:	00000206 	br	20032d0 <xAreRecursiveMutexTasksStillRunning+0x6c>
	}
	else
	{
		uxLastPollingCycles = uxPollingCycles;
 20032c8:	d0a05d17 	ldw	r2,-32396(gp)
 20032cc:	d0a06215 	stw	r2,-32376(gp)
	}

	if( xErrorOccurred == pdTRUE )
 20032d0:	d0a05817 	ldw	r2,-32416(gp)
 20032d4:	10800058 	cmpnei	r2,r2,1
 20032d8:	1000021e 	bne	r2,zero,20032e4 <xAreRecursiveMutexTasksStillRunning+0x80>
	{
		xReturn = pdFAIL;
 20032dc:	e03fff15 	stw	zero,-4(fp)
 20032e0:	00000206 	br	20032ec <xAreRecursiveMutexTasksStillRunning+0x88>
	}
	else
	{
		xReturn = pdPASS;
 20032e4:	00800044 	movi	r2,1
 20032e8:	e0bfff15 	stw	r2,-4(fp)
	}

	return xReturn;
 20032ec:	e0bfff17 	ldw	r2,-4(fp)
}
 20032f0:	e037883a 	mov	sp,fp
 20032f4:	df000017 	ldw	fp,0(sp)
 20032f8:	dec00104 	addi	sp,sp,4
 20032fc:	f800283a 	ret

02003300 <vStartSemaphoreTasks>:
static volatile short sNextCheckVariable = 0;

/*-----------------------------------------------------------*/

void vStartSemaphoreTasks( UBaseType_t uxPriority )
{
 2003300:	defff804 	addi	sp,sp,-32
 2003304:	dfc00715 	stw	ra,28(sp)
 2003308:	df000615 	stw	fp,24(sp)
 200330c:	df000604 	addi	fp,sp,24
 2003310:	e13fff15 	stw	r4,-4(fp)
xSemaphoreParameters *pxFirstSemaphoreParameters, *pxSecondSemaphoreParameters;
const TickType_t xBlockTime = ( TickType_t ) 100;
 2003314:	00801904 	movi	r2,100
 2003318:	e0bffc15 	stw	r2,-16(fp)

	/* Create the structure used to pass parameters to the first two tasks. */
	pxFirstSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
 200331c:	01000304 	movi	r4,12
 2003320:	2003f840 	call	2003f84 <pvPortMalloc>
 2003324:	e0bffd15 	stw	r2,-12(fp)

	if( pxFirstSemaphoreParameters != NULL )
 2003328:	e0bffd17 	ldw	r2,-12(fp)
 200332c:	10002e26 	beq	r2,zero,20033e8 <vStartSemaphoreTasks+0xe8>
	{
		/* Create the semaphore used by the first two tasks. */
		pxFirstSemaphoreParameters->xSemaphore = xSemaphoreCreateBinary();		
 2003330:	018000c4 	movi	r6,3
 2003334:	000b883a 	mov	r5,zero
 2003338:	01000044 	movi	r4,1
 200333c:	20044040 	call	2004404 <xQueueGenericCreate>
 2003340:	1007883a 	mov	r3,r2
 2003344:	e0bffd17 	ldw	r2,-12(fp)
 2003348:	10c00015 	stw	r3,0(r2)

		if( pxFirstSemaphoreParameters->xSemaphore != NULL )
 200334c:	e0bffd17 	ldw	r2,-12(fp)
 2003350:	10800017 	ldw	r2,0(r2)
 2003354:	10002426 	beq	r2,zero,20033e8 <vStartSemaphoreTasks+0xe8>
		{
			xSemaphoreGive( pxFirstSemaphoreParameters->xSemaphore );
 2003358:	e0bffd17 	ldw	r2,-12(fp)
 200335c:	10800017 	ldw	r2,0(r2)
 2003360:	000f883a 	mov	r7,zero
 2003364:	000d883a 	mov	r6,zero
 2003368:	000b883a 	mov	r5,zero
 200336c:	1009883a 	mov	r4,r2
 2003370:	20047700 	call	2004770 <xQueueGenericSend>
			
			/* Create the variable which is to be shared by the first two tasks. */
			pxFirstSemaphoreParameters->pulSharedVariable = ( uint32_t * ) pvPortMalloc( sizeof( uint32_t ) );
 2003374:	01000104 	movi	r4,4
 2003378:	2003f840 	call	2003f84 <pvPortMalloc>
 200337c:	1007883a 	mov	r3,r2
 2003380:	e0bffd17 	ldw	r2,-12(fp)
 2003384:	10c00115 	stw	r3,4(r2)

			/* Initialise the share variable to the value the tasks expect. */
			*( pxFirstSemaphoreParameters->pulSharedVariable ) = semtstNON_BLOCKING_EXPECTED_VALUE;
 2003388:	e0bffd17 	ldw	r2,-12(fp)
 200338c:	10800117 	ldw	r2,4(r2)
 2003390:	00c03fc4 	movi	r3,255
 2003394:	10c00015 	stw	r3,0(r2)

			/* The first two tasks do not block on semaphore calls. */
			pxFirstSemaphoreParameters->xBlockTime = ( TickType_t ) 0;
 2003398:	e0bffd17 	ldw	r2,-12(fp)
 200339c:	10000215 	stw	zero,8(r2)

			/* Spawn the first two tasks.  As they poll they operate at the idle priority. */
			xTaskCreate( prvSemaphoreTest, "PolSEM1", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( TaskHandle_t * ) NULL );
 20033a0:	d8000115 	stw	zero,4(sp)
 20033a4:	d8000015 	stw	zero,0(sp)
 20033a8:	e1fffd17 	ldw	r7,-12(fp)
 20033ac:	01810004 	movi	r6,1024
 20033b0:	01408074 	movhi	r5,513
 20033b4:	2948b504 	addi	r5,r5,8916
 20033b8:	01008034 	movhi	r4,512
 20033bc:	210d3604 	addi	r4,r4,13528
 20033c0:	20053c80 	call	20053c8 <xTaskCreate>
			xTaskCreate( prvSemaphoreTest, "PolSEM2", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( TaskHandle_t * ) NULL );
 20033c4:	d8000115 	stw	zero,4(sp)
 20033c8:	d8000015 	stw	zero,0(sp)
 20033cc:	e1fffd17 	ldw	r7,-12(fp)
 20033d0:	01810004 	movi	r6,1024
 20033d4:	01408074 	movhi	r5,513
 20033d8:	2948b704 	addi	r5,r5,8924
 20033dc:	01008034 	movhi	r4,512
 20033e0:	210d3604 	addi	r4,r4,13528
 20033e4:	20053c80 	call	20053c8 <xTaskCreate>
		}
	}

	/* Do exactly the same to create the second set of tasks, only this time
	provide a block time for the semaphore calls. */
	pxSecondSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
 20033e8:	01000304 	movi	r4,12
 20033ec:	2003f840 	call	2003f84 <pvPortMalloc>
 20033f0:	e0bffe15 	stw	r2,-8(fp)
	if( pxSecondSemaphoreParameters != NULL )
 20033f4:	e0bffe17 	ldw	r2,-8(fp)
 20033f8:	10003126 	beq	r2,zero,20034c0 <vStartSemaphoreTasks+0x1c0>
	{
		pxSecondSemaphoreParameters->xSemaphore = xSemaphoreCreateBinary();		
 20033fc:	018000c4 	movi	r6,3
 2003400:	000b883a 	mov	r5,zero
 2003404:	01000044 	movi	r4,1
 2003408:	20044040 	call	2004404 <xQueueGenericCreate>
 200340c:	1007883a 	mov	r3,r2
 2003410:	e0bffe17 	ldw	r2,-8(fp)
 2003414:	10c00015 	stw	r3,0(r2)

		if( pxSecondSemaphoreParameters->xSemaphore != NULL )
 2003418:	e0bffe17 	ldw	r2,-8(fp)
 200341c:	10800017 	ldw	r2,0(r2)
 2003420:	10002726 	beq	r2,zero,20034c0 <vStartSemaphoreTasks+0x1c0>
		{
			xSemaphoreGive( pxSecondSemaphoreParameters->xSemaphore );
 2003424:	e0bffe17 	ldw	r2,-8(fp)
 2003428:	10800017 	ldw	r2,0(r2)
 200342c:	000f883a 	mov	r7,zero
 2003430:	000d883a 	mov	r6,zero
 2003434:	000b883a 	mov	r5,zero
 2003438:	1009883a 	mov	r4,r2
 200343c:	20047700 	call	2004770 <xQueueGenericSend>
			
			pxSecondSemaphoreParameters->pulSharedVariable = ( uint32_t * ) pvPortMalloc( sizeof( uint32_t ) );
 2003440:	01000104 	movi	r4,4
 2003444:	2003f840 	call	2003f84 <pvPortMalloc>
 2003448:	1007883a 	mov	r3,r2
 200344c:	e0bffe17 	ldw	r2,-8(fp)
 2003450:	10c00115 	stw	r3,4(r2)
			*( pxSecondSemaphoreParameters->pulSharedVariable ) = semtstBLOCKING_EXPECTED_VALUE;
 2003454:	e0bffe17 	ldw	r2,-8(fp)
 2003458:	10800117 	ldw	r2,4(r2)
 200345c:	00c3ffc4 	movi	r3,4095
 2003460:	10c00015 	stw	r3,0(r2)
			pxSecondSemaphoreParameters->xBlockTime = xBlockTime / portTICK_PERIOD_MS;
 2003464:	e0bffe17 	ldw	r2,-8(fp)
 2003468:	e0fffc17 	ldw	r3,-16(fp)
 200346c:	10c00215 	stw	r3,8(r2)

			xTaskCreate( prvSemaphoreTest, "BlkSEM1", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( TaskHandle_t * ) NULL );
 2003470:	d8000115 	stw	zero,4(sp)
 2003474:	e0bfff17 	ldw	r2,-4(fp)
 2003478:	d8800015 	stw	r2,0(sp)
 200347c:	e1fffe17 	ldw	r7,-8(fp)
 2003480:	01810004 	movi	r6,1024
 2003484:	01408074 	movhi	r5,513
 2003488:	2948b904 	addi	r5,r5,8932
 200348c:	01008034 	movhi	r4,512
 2003490:	210d3604 	addi	r4,r4,13528
 2003494:	20053c80 	call	20053c8 <xTaskCreate>
			xTaskCreate( prvSemaphoreTest, "BlkSEM2", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( TaskHandle_t * ) NULL );
 2003498:	d8000115 	stw	zero,4(sp)
 200349c:	e0bfff17 	ldw	r2,-4(fp)
 20034a0:	d8800015 	stw	r2,0(sp)
 20034a4:	e1fffe17 	ldw	r7,-8(fp)
 20034a8:	01810004 	movi	r6,1024
 20034ac:	01408074 	movhi	r5,513
 20034b0:	2948bb04 	addi	r5,r5,8940
 20034b4:	01008034 	movhi	r4,512
 20034b8:	210d3604 	addi	r4,r4,13528
 20034bc:	20053c80 	call	20053c8 <xTaskCreate>
			be removed by the pre-processor if configQUEUE_REGISTRY_SIZE is not
			defined or is defined to be less than 1. */
			vQueueAddToRegistry( ( QueueHandle_t ) pxSecondSemaphoreParameters->xSemaphore, "Counting_Sem_2" );
		}
	}
}
 20034c0:	0001883a 	nop
 20034c4:	e037883a 	mov	sp,fp
 20034c8:	dfc00117 	ldw	ra,4(sp)
 20034cc:	df000017 	ldw	fp,0(sp)
 20034d0:	dec00204 	addi	sp,sp,8
 20034d4:	f800283a 	ret

020034d8 <prvSemaphoreTest>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvSemaphoreTest, pvParameters )
{
 20034d8:	defff804 	addi	sp,sp,-32
 20034dc:	dfc00715 	stw	ra,28(sp)
 20034e0:	df000615 	stw	fp,24(sp)
 20034e4:	df000604 	addi	fp,sp,24
 20034e8:	e13fff15 	stw	r4,-4(fp)
xSemaphoreParameters *pxParameters;
volatile uint32_t *pulSharedVariable, ulExpectedValue;
uint32_t ulCounter;
short sError = pdFALSE, sCheckVariableToUse;
 20034ec:	e03ffb0d 	sth	zero,-20(fp)

	/* See which check variable to use.  sNextCheckVariable is not semaphore
	protected! */
	portENTER_CRITICAL();
 20034f0:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		sCheckVariableToUse = sNextCheckVariable;
 20034f4:	d0a0650b 	ldhu	r2,-32364(gp)
 20034f8:	e0bffb8d 	sth	r2,-18(fp)
		sNextCheckVariable++;
 20034fc:	d0a0650b 	ldhu	r2,-32364(gp)
 2003500:	10800044 	addi	r2,r2,1
 2003504:	d0a0650d 	sth	r2,-32364(gp)
	portEXIT_CRITICAL();
 2003508:	2006ef80 	call	2006ef8 <vTaskExitCritical>

	/* A structure is passed in as the parameter.  This contains the shared
	variable being guarded. */
	pxParameters = ( xSemaphoreParameters * ) pvParameters;
 200350c:	e0bfff17 	ldw	r2,-4(fp)
 2003510:	e0bffc15 	stw	r2,-16(fp)
	pulSharedVariable = pxParameters->pulSharedVariable;
 2003514:	e0bffc17 	ldw	r2,-16(fp)
 2003518:	10800117 	ldw	r2,4(r2)
 200351c:	e0bffd15 	stw	r2,-12(fp)

	/* If we are blocking we use a much higher count to ensure loads of context
	switches occur during the count. */
	if( pxParameters->xBlockTime > ( TickType_t ) 0 )
 2003520:	e0bffc17 	ldw	r2,-16(fp)
 2003524:	10800217 	ldw	r2,8(r2)
 2003528:	10000326 	beq	r2,zero,2003538 <prvSemaphoreTest+0x60>
	{
		ulExpectedValue = semtstBLOCKING_EXPECTED_VALUE;
 200352c:	0083ffc4 	movi	r2,4095
 2003530:	e0bffe15 	stw	r2,-8(fp)
 2003534:	00000206 	br	2003540 <prvSemaphoreTest+0x68>
	}
	else
	{
		ulExpectedValue = semtstNON_BLOCKING_EXPECTED_VALUE;
 2003538:	00803fc4 	movi	r2,255
 200353c:	e0bffe15 	stw	r2,-8(fp)
	}

	for( ;; )
	{
		/* Try to obtain the semaphore. */
		if( xSemaphoreTake( pxParameters->xSemaphore, pxParameters->xBlockTime ) == pdPASS )
 2003540:	e0bffc17 	ldw	r2,-16(fp)
 2003544:	10c00017 	ldw	r3,0(r2)
 2003548:	e0bffc17 	ldw	r2,-16(fp)
 200354c:	10800217 	ldw	r2,8(r2)
 2003550:	000f883a 	mov	r7,zero
 2003554:	100d883a 	mov	r6,r2
 2003558:	000b883a 	mov	r5,zero
 200355c:	1809883a 	mov	r4,r3
 2003560:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2003564:	10800058 	cmpnei	r2,r2,1
 2003568:	1000391e 	bne	r2,zero,2003650 <prvSemaphoreTest+0x178>
		{
			/* We have the semaphore and so expect any other tasks using the
			shared variable to have left it in the state we expect to find
			it. */
			if( *pulSharedVariable != ulExpectedValue )
 200356c:	e0bffd17 	ldw	r2,-12(fp)
 2003570:	10c00017 	ldw	r3,0(r2)
 2003574:	e0bffe17 	ldw	r2,-8(fp)
 2003578:	18800226 	beq	r3,r2,2003584 <prvSemaphoreTest+0xac>
			{
				sError = pdTRUE;
 200357c:	00800044 	movi	r2,1
 2003580:	e0bffb0d 	sth	r2,-20(fp)
			}

			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( uint32_t ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
 2003584:	e03ffa15 	stw	zero,-24(fp)
 2003588:	00000c06 	br	20035bc <prvSemaphoreTest+0xe4>
			{
				*pulSharedVariable = ulCounter;
 200358c:	e0bffd17 	ldw	r2,-12(fp)
 2003590:	e0fffa17 	ldw	r3,-24(fp)
 2003594:	10c00015 	stw	r3,0(r2)
				if( *pulSharedVariable != ulCounter )
 2003598:	e0bffd17 	ldw	r2,-12(fp)
 200359c:	10c00017 	ldw	r3,0(r2)
 20035a0:	e0bffa17 	ldw	r2,-24(fp)
 20035a4:	18800226 	beq	r3,r2,20035b0 <prvSemaphoreTest+0xd8>
				{
					sError = pdTRUE;
 20035a8:	00800044 	movi	r2,1
 20035ac:	e0bffb0d 	sth	r2,-20(fp)
			}

			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( uint32_t ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
 20035b0:	e0bffa17 	ldw	r2,-24(fp)
 20035b4:	10800044 	addi	r2,r2,1
 20035b8:	e0bffa15 	stw	r2,-24(fp)
 20035bc:	e0fffe17 	ldw	r3,-8(fp)
 20035c0:	e0bffa17 	ldw	r2,-24(fp)
 20035c4:	18bff12e 	bgeu	r3,r2,200358c <__reset+0xfe00258c>
				}
			}

			/* Release the semaphore, and if no errors have occurred increment the check
			variable. */
			if(	xSemaphoreGive( pxParameters->xSemaphore ) == pdFALSE )
 20035c8:	e0bffc17 	ldw	r2,-16(fp)
 20035cc:	10800017 	ldw	r2,0(r2)
 20035d0:	000f883a 	mov	r7,zero
 20035d4:	000d883a 	mov	r6,zero
 20035d8:	000b883a 	mov	r5,zero
 20035dc:	1009883a 	mov	r4,r2
 20035e0:	20047700 	call	2004770 <xQueueGenericSend>
 20035e4:	1000021e 	bne	r2,zero,20035f0 <prvSemaphoreTest+0x118>
			{
				sError = pdTRUE;
 20035e8:	00800044 	movi	r2,1
 20035ec:	e0bffb0d 	sth	r2,-20(fp)
			}

			if( sError == pdFALSE )
 20035f0:	e0bffb0f 	ldh	r2,-20(fp)
 20035f4:	10000e1e 	bne	r2,zero,2003630 <prvSemaphoreTest+0x158>
			{
				if( sCheckVariableToUse < semtstNUM_TASKS )
 20035f8:	e0bffb8f 	ldh	r2,-18(fp)
 20035fc:	10800108 	cmpgei	r2,r2,4
 2003600:	10000b1e 	bne	r2,zero,2003630 <prvSemaphoreTest+0x158>
				{
					( sCheckVariables[ sCheckVariableToUse ] )++;
 2003604:	e0bffb8f 	ldh	r2,-18(fp)
 2003608:	1089883a 	add	r4,r2,r2
 200360c:	d0e06304 	addi	r3,gp,-32372
 2003610:	20c7883a 	add	r3,r4,r3
 2003614:	18c0000b 	ldhu	r3,0(r3)
 2003618:	18c00044 	addi	r3,r3,1
 200361c:	1809883a 	mov	r4,r3
 2003620:	1087883a 	add	r3,r2,r2
 2003624:	d0a06304 	addi	r2,gp,-32372
 2003628:	1885883a 	add	r2,r3,r2
 200362c:	1100000d 	sth	r4,0(r2)
			/* If we have a block time then we are running at a priority higher
			than the idle priority.  This task takes a long time to complete
			a cycle	(deliberately so to test the guarding) so will be starving
			out lower priority tasks.  Block for some time to allow give lower
			priority tasks some processor time. */
			vTaskDelay( pxParameters->xBlockTime * semtstDELAY_FACTOR );
 2003630:	e0bffc17 	ldw	r2,-16(fp)
 2003634:	10800217 	ldw	r2,8(r2)
 2003638:	01400284 	movi	r5,10
 200363c:	1009883a 	mov	r4,r2
 2003640:	2009bcc0 	call	2009bcc <__mulsi3>
 2003644:	1009883a 	mov	r4,r2
 2003648:	20059600 	call	2005960 <vTaskDelay>
 200364c:	003fbc06 	br	2003540 <__reset+0xfe002540>
		}
		else
		{
			if( pxParameters->xBlockTime == ( TickType_t ) 0 )
 2003650:	e0bffc17 	ldw	r2,-16(fp)
 2003654:	10800217 	ldw	r2,8(r2)
 2003658:	103fb91e 	bne	r2,zero,2003540 <__reset+0xfe002540>
			{
				/* We have not got the semaphore yet, so no point using the
				processor.  We are not blocking when attempting to obtain the
				semaphore. */
				taskYIELD();
 200365c:	003b683a 	trap	0
			}
		}
	}
 2003660:	003fb706 	br	2003540 <__reset+0xfe002540>

02003664 <xAreSemaphoreTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreSemaphoreTasksStillRunning( void )
{
 2003664:	defffd04 	addi	sp,sp,-12
 2003668:	df000215 	stw	fp,8(sp)
 200366c:	df000204 	addi	fp,sp,8
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
BaseType_t xTask, xReturn = pdTRUE;
 2003670:	00800044 	movi	r2,1
 2003674:	e0bfff15 	stw	r2,-4(fp)

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
 2003678:	e03ffe15 	stw	zero,-8(fp)
 200367c:	00001f06 	br	20036fc <xAreSemaphoreTasksStillRunning+0x98>
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
 2003680:	e0bffe17 	ldw	r2,-8(fp)
 2003684:	1087883a 	add	r3,r2,r2
 2003688:	d0a06584 	addi	r2,gp,-32362
 200368c:	1885883a 	add	r2,r3,r2
 2003690:	1100000b 	ldhu	r4,0(r2)
 2003694:	e0bffe17 	ldw	r2,-8(fp)
 2003698:	1087883a 	add	r3,r2,r2
 200369c:	d0a06304 	addi	r2,gp,-32372
 20036a0:	1885883a 	add	r2,r3,r2
 20036a4:	1080000b 	ldhu	r2,0(r2)
 20036a8:	20ffffcc 	andi	r3,r4,65535
 20036ac:	18e0001c 	xori	r3,r3,32768
 20036b0:	18e00004 	addi	r3,r3,-32768
 20036b4:	10bfffcc 	andi	r2,r2,65535
 20036b8:	10a0001c 	xori	r2,r2,32768
 20036bc:	10a00004 	addi	r2,r2,-32768
 20036c0:	1880011e 	bne	r3,r2,20036c8 <xAreSemaphoreTasksStillRunning+0x64>
		{
			xReturn = pdFALSE;
 20036c4:	e03fff15 	stw	zero,-4(fp)
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
 20036c8:	e0bffe17 	ldw	r2,-8(fp)
 20036cc:	1087883a 	add	r3,r2,r2
 20036d0:	d0a06304 	addi	r2,gp,-32372
 20036d4:	1885883a 	add	r2,r3,r2
 20036d8:	10c0000b 	ldhu	r3,0(r2)
 20036dc:	e0bffe17 	ldw	r2,-8(fp)
 20036e0:	1089883a 	add	r4,r2,r2
 20036e4:	d0a06584 	addi	r2,gp,-32362
 20036e8:	2085883a 	add	r2,r4,r2
 20036ec:	10c0000d 	sth	r3,0(r2)
BaseType_t xAreSemaphoreTasksStillRunning( void )
{
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
BaseType_t xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
 20036f0:	e0bffe17 	ldw	r2,-8(fp)
 20036f4:	10800044 	addi	r2,r2,1
 20036f8:	e0bffe15 	stw	r2,-8(fp)
 20036fc:	e0bffe17 	ldw	r2,-8(fp)
 2003700:	10800110 	cmplti	r2,r2,4
 2003704:	103fde1e 	bne	r2,zero,2003680 <__reset+0xfe002680>
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
	}

	return xReturn;
 2003708:	e0bfff17 	ldw	r2,-4(fp)
}
 200370c:	e037883a 	mov	sp,fp
 2003710:	df000017 	ldw	fp,0(sp)
 2003714:	dec00104 	addi	sp,sp,4
 2003718:	f800283a 	ret

0200371c <vParTestInitialise>:
 **
 **     @param
 **
 */
/* ===================================================================*/
void vParTestInitialise(void) {
 200371c:	deffff04 	addi	sp,sp,-4
 2003720:	df000015 	stw	fp,0(sp)
 2003724:	d839883a 	mov	fp,sp
	IOWR_ALT_UP_PARALLEL_PORT_DIRECTION(LED_PIO_BASE, 0xFFFFFFFF);
 2003728:	00ffffc4 	movi	r3,-1
 200372c:	00810034 	movhi	r2,1024
 2003730:	10882104 	addi	r2,r2,8324
 2003734:	10c00035 	stwio	r3,0(r2)
	ulLedStates = 0;
 2003738:	d0206815 	stw	zero,-32352(gp)
}
 200373c:	0001883a 	nop
 2003740:	e037883a 	mov	sp,fp
 2003744:	df000017 	ldw	fp,0(sp)
 2003748:	dec00104 	addi	sp,sp,4
 200374c:	f800283a 	ret

02003750 <vParTestSetLED>:
 **
 **     @param
 **
 */
/* ===================================================================*/
void vParTestSetLED(unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue) {
 2003750:	defffc04 	addi	sp,sp,-16
 2003754:	dfc00315 	stw	ra,12(sp)
 2003758:	df000215 	stw	fp,8(sp)
 200375c:	df000204 	addi	fp,sp,8
 2003760:	e13ffe15 	stw	r4,-8(fp)
 2003764:	e17fff15 	stw	r5,-4(fp)
	if (uxLED < partstNUM_LEDS) {
 2003768:	e0bffe17 	ldw	r2,-8(fp)
 200376c:	10800228 	cmpgeui	r2,r2,8
 2003770:	1000191e 	bne	r2,zero,20037d8 <vParTestSetLED+0x88>
		taskENTER_CRITICAL();
 2003774:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			if (xValue > 0) {
 2003778:	e0bfff17 	ldw	r2,-4(fp)
 200377c:	0080080e 	bge	zero,r2,20037a0 <vParTestSetLED+0x50>
				ulLedStates |= 1 << uxLED;
 2003780:	00c00044 	movi	r3,1
 2003784:	e0bffe17 	ldw	r2,-8(fp)
 2003788:	1884983a 	sll	r2,r3,r2
 200378c:	1007883a 	mov	r3,r2
 2003790:	d0a06817 	ldw	r2,-32352(gp)
 2003794:	1884b03a 	or	r2,r3,r2
 2003798:	d0a06815 	stw	r2,-32352(gp)
 200379c:	00000806 	br	20037c0 <vParTestSetLED+0x70>
			} else {
				ulLedStates &= ~(1 << uxLED);
 20037a0:	00c00044 	movi	r3,1
 20037a4:	e0bffe17 	ldw	r2,-8(fp)
 20037a8:	1884983a 	sll	r2,r3,r2
 20037ac:	0084303a 	nor	r2,zero,r2
 20037b0:	1007883a 	mov	r3,r2
 20037b4:	d0a06817 	ldw	r2,-32352(gp)
 20037b8:	1884703a 	and	r2,r3,r2
 20037bc:	d0a06815 	stw	r2,-32352(gp)
			}
			IOWR_ALT_UP_PARALLEL_PORT_DATA(LED_PIO_BASE, ulLedStates);
 20037c0:	d0a06817 	ldw	r2,-32352(gp)
 20037c4:	1007883a 	mov	r3,r2
 20037c8:	00810034 	movhi	r2,1024
 20037cc:	10882004 	addi	r2,r2,8320
 20037d0:	10c00035 	stwio	r3,0(r2)
		}
		taskEXIT_CRITICAL();
 20037d4:	2006ef80 	call	2006ef8 <vTaskExitCritical>
	}
}
 20037d8:	0001883a 	nop
 20037dc:	e037883a 	mov	sp,fp
 20037e0:	dfc00117 	ldw	ra,4(sp)
 20037e4:	df000017 	ldw	fp,0(sp)
 20037e8:	dec00204 	addi	sp,sp,8
 20037ec:	f800283a 	ret

020037f0 <vParTestToggleLED>:
 **
 **     @param
 **
 */
/* ===================================================================*/
void vParTestToggleLED(unsigned portBASE_TYPE uxLED) {
 20037f0:	defffd04 	addi	sp,sp,-12
 20037f4:	dfc00215 	stw	ra,8(sp)
 20037f8:	df000115 	stw	fp,4(sp)
 20037fc:	df000104 	addi	fp,sp,4
 2003800:	e13fff15 	stw	r4,-4(fp)
	if (uxLED < partstNUM_LEDS) {
 2003804:	e0bfff17 	ldw	r2,-4(fp)
 2003808:	10800228 	cmpgeui	r2,r2,8
 200380c:	10000d1e 	bne	r2,zero,2003844 <vParTestToggleLED+0x54>
		taskENTER_CRITICAL();
 2003810:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			vParTestSetLED(uxLED, !(ulLedStates & (1 << uxLED)));
 2003814:	00c00044 	movi	r3,1
 2003818:	e0bfff17 	ldw	r2,-4(fp)
 200381c:	1884983a 	sll	r2,r3,r2
 2003820:	1007883a 	mov	r3,r2
 2003824:	d0a06817 	ldw	r2,-32352(gp)
 2003828:	1884703a 	and	r2,r3,r2
 200382c:	1005003a 	cmpeq	r2,r2,zero
 2003830:	10803fcc 	andi	r2,r2,255
 2003834:	100b883a 	mov	r5,r2
 2003838:	e13fff17 	ldw	r4,-4(fp)
 200383c:	20037500 	call	2003750 <vParTestSetLED>
		}
		taskEXIT_CRITICAL();
 2003840:	2006ef80 	call	2006ef8 <vTaskExitCritical>
	}
}
 2003844:	0001883a 	nop
 2003848:	e037883a 	mov	sp,fp
 200384c:	dfc00117 	ldw	ra,4(sp)
 2003850:	df000017 	ldw	fp,0(sp)
 2003854:	dec00204 	addi	sp,sp,8
 2003858:	f800283a 	ret

0200385c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 200385c:	defffe04 	addi	sp,sp,-8
 2003860:	df000115 	stw	fp,4(sp)
 2003864:	df000104 	addi	fp,sp,4
 2003868:	e13fff15 	stw	r4,-4(fp)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 200386c:	e0bfff17 	ldw	r2,-4(fp)
 2003870:	10c00204 	addi	r3,r2,8
 2003874:	e0bfff17 	ldw	r2,-4(fp)
 2003878:	10c00115 	stw	r3,4(r2)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 200387c:	e0bfff17 	ldw	r2,-4(fp)
 2003880:	00ffffc4 	movi	r3,-1
 2003884:	10c00215 	stw	r3,8(r2)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 2003888:	e0bfff17 	ldw	r2,-4(fp)
 200388c:	10c00204 	addi	r3,r2,8
 2003890:	e0bfff17 	ldw	r2,-4(fp)
 2003894:	10c00315 	stw	r3,12(r2)
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 2003898:	e0bfff17 	ldw	r2,-4(fp)
 200389c:	10c00204 	addi	r3,r2,8
 20038a0:	e0bfff17 	ldw	r2,-4(fp)
 20038a4:	10c00415 	stw	r3,16(r2)

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 20038a8:	e0bfff17 	ldw	r2,-4(fp)
 20038ac:	10000015 	stw	zero,0(r2)

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 20038b0:	0001883a 	nop
 20038b4:	e037883a 	mov	sp,fp
 20038b8:	df000017 	ldw	fp,0(sp)
 20038bc:	dec00104 	addi	sp,sp,4
 20038c0:	f800283a 	ret

020038c4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 20038c4:	defffe04 	addi	sp,sp,-8
 20038c8:	df000115 	stw	fp,4(sp)
 20038cc:	df000104 	addi	fp,sp,4
 20038d0:	e13fff15 	stw	r4,-4(fp)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 20038d4:	e0bfff17 	ldw	r2,-4(fp)
 20038d8:	10000415 	stw	zero,16(r2)

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 20038dc:	0001883a 	nop
 20038e0:	e037883a 	mov	sp,fp
 20038e4:	df000017 	ldw	fp,0(sp)
 20038e8:	dec00104 	addi	sp,sp,4
 20038ec:	f800283a 	ret

020038f0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 20038f0:	defffc04 	addi	sp,sp,-16
 20038f4:	df000315 	stw	fp,12(sp)
 20038f8:	df000304 	addi	fp,sp,12
 20038fc:	e13ffe15 	stw	r4,-8(fp)
 2003900:	e17fff15 	stw	r5,-4(fp)
ListItem_t * const pxIndex = pxList->pxIndex;
 2003904:	e0bffe17 	ldw	r2,-8(fp)
 2003908:	10800117 	ldw	r2,4(r2)
 200390c:	e0bffd15 	stw	r2,-12(fp)
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 2003910:	e0bfff17 	ldw	r2,-4(fp)
 2003914:	e0fffd17 	ldw	r3,-12(fp)
 2003918:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 200391c:	e0bffd17 	ldw	r2,-12(fp)
 2003920:	10c00217 	ldw	r3,8(r2)
 2003924:	e0bfff17 	ldw	r2,-4(fp)
 2003928:	10c00215 	stw	r3,8(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 200392c:	e0bffd17 	ldw	r2,-12(fp)
 2003930:	10800217 	ldw	r2,8(r2)
 2003934:	e0ffff17 	ldw	r3,-4(fp)
 2003938:	10c00115 	stw	r3,4(r2)
	pxIndex->pxPrevious = pxNewListItem;
 200393c:	e0bffd17 	ldw	r2,-12(fp)
 2003940:	e0ffff17 	ldw	r3,-4(fp)
 2003944:	10c00215 	stw	r3,8(r2)

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 2003948:	e0bfff17 	ldw	r2,-4(fp)
 200394c:	e0fffe17 	ldw	r3,-8(fp)
 2003950:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 2003954:	e0bffe17 	ldw	r2,-8(fp)
 2003958:	10800017 	ldw	r2,0(r2)
 200395c:	10c00044 	addi	r3,r2,1
 2003960:	e0bffe17 	ldw	r2,-8(fp)
 2003964:	10c00015 	stw	r3,0(r2)
}
 2003968:	0001883a 	nop
 200396c:	e037883a 	mov	sp,fp
 2003970:	df000017 	ldw	fp,0(sp)
 2003974:	dec00104 	addi	sp,sp,4
 2003978:	f800283a 	ret

0200397c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 200397c:	defffb04 	addi	sp,sp,-20
 2003980:	df000415 	stw	fp,16(sp)
 2003984:	df000404 	addi	fp,sp,16
 2003988:	e13ffe15 	stw	r4,-8(fp)
 200398c:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 2003990:	e0bfff17 	ldw	r2,-4(fp)
 2003994:	10800017 	ldw	r2,0(r2)
 2003998:	e0bffd15 	stw	r2,-12(fp)
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 200399c:	e0bffd17 	ldw	r2,-12(fp)
 20039a0:	10bfffd8 	cmpnei	r2,r2,-1
 20039a4:	1000041e 	bne	r2,zero,20039b8 <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 20039a8:	e0bffe17 	ldw	r2,-8(fp)
 20039ac:	10800417 	ldw	r2,16(r2)
 20039b0:	e0bffc15 	stw	r2,-16(fp)
 20039b4:	00000c06 	br	20039e8 <vListInsert+0x6c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 20039b8:	e0bffe17 	ldw	r2,-8(fp)
 20039bc:	10800204 	addi	r2,r2,8
 20039c0:	e0bffc15 	stw	r2,-16(fp)
 20039c4:	00000306 	br	20039d4 <vListInsert+0x58>
 20039c8:	e0bffc17 	ldw	r2,-16(fp)
 20039cc:	10800117 	ldw	r2,4(r2)
 20039d0:	e0bffc15 	stw	r2,-16(fp)
 20039d4:	e0bffc17 	ldw	r2,-16(fp)
 20039d8:	10800117 	ldw	r2,4(r2)
 20039dc:	10800017 	ldw	r2,0(r2)
 20039e0:	e0fffd17 	ldw	r3,-12(fp)
 20039e4:	18bff82e 	bgeu	r3,r2,20039c8 <__reset+0xfe0029c8>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 20039e8:	e0bffc17 	ldw	r2,-16(fp)
 20039ec:	10c00117 	ldw	r3,4(r2)
 20039f0:	e0bfff17 	ldw	r2,-4(fp)
 20039f4:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 20039f8:	e0bfff17 	ldw	r2,-4(fp)
 20039fc:	10800117 	ldw	r2,4(r2)
 2003a00:	e0ffff17 	ldw	r3,-4(fp)
 2003a04:	10c00215 	stw	r3,8(r2)
	pxNewListItem->pxPrevious = pxIterator;
 2003a08:	e0bfff17 	ldw	r2,-4(fp)
 2003a0c:	e0fffc17 	ldw	r3,-16(fp)
 2003a10:	10c00215 	stw	r3,8(r2)
	pxIterator->pxNext = pxNewListItem;
 2003a14:	e0bffc17 	ldw	r2,-16(fp)
 2003a18:	e0ffff17 	ldw	r3,-4(fp)
 2003a1c:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 2003a20:	e0bfff17 	ldw	r2,-4(fp)
 2003a24:	e0fffe17 	ldw	r3,-8(fp)
 2003a28:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 2003a2c:	e0bffe17 	ldw	r2,-8(fp)
 2003a30:	10800017 	ldw	r2,0(r2)
 2003a34:	10c00044 	addi	r3,r2,1
 2003a38:	e0bffe17 	ldw	r2,-8(fp)
 2003a3c:	10c00015 	stw	r3,0(r2)
}
 2003a40:	0001883a 	nop
 2003a44:	e037883a 	mov	sp,fp
 2003a48:	df000017 	ldw	fp,0(sp)
 2003a4c:	dec00104 	addi	sp,sp,4
 2003a50:	f800283a 	ret

02003a54 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 2003a54:	defffd04 	addi	sp,sp,-12
 2003a58:	df000215 	stw	fp,8(sp)
 2003a5c:	df000204 	addi	fp,sp,8
 2003a60:	e13fff15 	stw	r4,-4(fp)
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 2003a64:	e0bfff17 	ldw	r2,-4(fp)
 2003a68:	10800417 	ldw	r2,16(r2)
 2003a6c:	e0bffe15 	stw	r2,-8(fp)

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 2003a70:	e0bfff17 	ldw	r2,-4(fp)
 2003a74:	10800117 	ldw	r2,4(r2)
 2003a78:	e0ffff17 	ldw	r3,-4(fp)
 2003a7c:	18c00217 	ldw	r3,8(r3)
 2003a80:	10c00215 	stw	r3,8(r2)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 2003a84:	e0bfff17 	ldw	r2,-4(fp)
 2003a88:	10800217 	ldw	r2,8(r2)
 2003a8c:	e0ffff17 	ldw	r3,-4(fp)
 2003a90:	18c00117 	ldw	r3,4(r3)
 2003a94:	10c00115 	stw	r3,4(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 2003a98:	e0bffe17 	ldw	r2,-8(fp)
 2003a9c:	10c00117 	ldw	r3,4(r2)
 2003aa0:	e0bfff17 	ldw	r2,-4(fp)
 2003aa4:	1880041e 	bne	r3,r2,2003ab8 <uxListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 2003aa8:	e0bfff17 	ldw	r2,-4(fp)
 2003aac:	10c00217 	ldw	r3,8(r2)
 2003ab0:	e0bffe17 	ldw	r2,-8(fp)
 2003ab4:	10c00115 	stw	r3,4(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 2003ab8:	e0bfff17 	ldw	r2,-4(fp)
 2003abc:	10000415 	stw	zero,16(r2)
	( pxList->uxNumberOfItems )--;
 2003ac0:	e0bffe17 	ldw	r2,-8(fp)
 2003ac4:	10800017 	ldw	r2,0(r2)
 2003ac8:	10ffffc4 	addi	r3,r2,-1
 2003acc:	e0bffe17 	ldw	r2,-8(fp)
 2003ad0:	10c00015 	stw	r3,0(r2)

	return pxList->uxNumberOfItems;
 2003ad4:	e0bffe17 	ldw	r2,-8(fp)
 2003ad8:	10800017 	ldw	r2,0(r2)
}
 2003adc:	e037883a 	mov	sp,fp
 2003ae0:	df000017 	ldw	fp,0(sp)
 2003ae4:	dec00104 	addi	sp,sp,4
 2003ae8:	f800283a 	ret

02003aec <prvReadGp>:
#else
void vPortSysTickHandler( void * context, alt_u32 id );
#endif
/*-----------------------------------------------------------*/

void prvReadGp(unsigned long *ulValue) {
 2003aec:	defffe04 	addi	sp,sp,-8
 2003af0:	df000115 	stw	fp,4(sp)
 2003af4:	df000104 	addi	fp,sp,4
 2003af8:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (r4) " );
 2003afc:	26800015 	stw	gp,0(r4)
}
 2003b00:	0001883a 	nop
 2003b04:	e037883a 	mov	sp,fp
 2003b08:	df000017 	ldw	fp,0(sp)
 2003b0c:	dec00104 	addi	sp,sp,4
 2003b10:	f800283a 	ret

02003b14 <pxPortInitialiseStack>:
 **     @param
 **
 */
/* ===================================================================*/
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack,
pdTASK_CODE pxCode, void *pvParameters) {
 2003b14:	defff904 	addi	sp,sp,-28
 2003b18:	dfc00615 	stw	ra,24(sp)
 2003b1c:	df000515 	stw	fp,20(sp)
 2003b20:	df000504 	addi	fp,sp,20
 2003b24:	e13ffd15 	stw	r4,-12(fp)
 2003b28:	e17ffe15 	stw	r5,-8(fp)
 2003b2c:	e1bfff15 	stw	r6,-4(fp)
	portSTACK_TYPE *pxFramePointer = pxTopOfStack - 1;
 2003b30:	e0bffd17 	ldw	r2,-12(fp)
 2003b34:	10bfff04 	addi	r2,r2,-4
 2003b38:	e0bffb15 	stw	r2,-20(fp)
	portSTACK_TYPE xGlobalPointer;

	prvReadGp(&xGlobalPointer);
 2003b3c:	e0bffc04 	addi	r2,fp,-16
 2003b40:	1009883a 	mov	r4,r2
 2003b44:	2003aec0 	call	2003aec <prvReadGp>

	/* End of stack marker. */
	*pxTopOfStack = 0xdeadbeef;
 2003b48:	e0fffd17 	ldw	r3,-12(fp)
 2003b4c:	00b7abb4 	movhi	r2,57006
 2003b50:	10afbbc4 	addi	r2,r2,-16657
 2003b54:	18800015 	stw	r2,0(r3)
	pxTopOfStack--;
 2003b58:	e0bffd17 	ldw	r2,-12(fp)
 2003b5c:	10bfff04 	addi	r2,r2,-4
 2003b60:	e0bffd15 	stw	r2,-12(fp)

	*pxTopOfStack = ( portSTACK_TYPE ) pxFramePointer;
 2003b64:	e0fffb17 	ldw	r3,-20(fp)
 2003b68:	e0bffd17 	ldw	r2,-12(fp)
 2003b6c:	10c00015 	stw	r3,0(r2)
	pxTopOfStack--;
 2003b70:	e0bffd17 	ldw	r2,-12(fp)
 2003b74:	10bfff04 	addi	r2,r2,-4
 2003b78:	e0bffd15 	stw	r2,-12(fp)

	*pxTopOfStack = xGlobalPointer;
 2003b7c:	e0fffc17 	ldw	r3,-16(fp)
 2003b80:	e0bffd17 	ldw	r2,-12(fp)
 2003b84:	10c00015 	stw	r3,0(r2)

	/* Space for R23 to R16. */
	pxTopOfStack -= 9;
 2003b88:	e0bffd17 	ldw	r2,-12(fp)
 2003b8c:	10bff704 	addi	r2,r2,-36
 2003b90:	e0bffd15 	stw	r2,-12(fp)

	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;
 2003b94:	e0fffe17 	ldw	r3,-8(fp)
 2003b98:	e0bffd17 	ldw	r2,-12(fp)
 2003b9c:	10c00015 	stw	r3,0(r2)
	pxTopOfStack--;
 2003ba0:	e0bffd17 	ldw	r2,-12(fp)
 2003ba4:	10bfff04 	addi	r2,r2,-4
 2003ba8:	e0bffd15 	stw	r2,-12(fp)

	*pxTopOfStack = portINITIAL_ESTATUS;
 2003bac:	e0bffd17 	ldw	r2,-12(fp)
 2003bb0:	00c00044 	movi	r3,1
 2003bb4:	10c00015 	stw	r3,0(r2)

	/* Space for R15 to R5. */
	pxTopOfStack -= 12;
 2003bb8:	e0bffd17 	ldw	r2,-12(fp)
 2003bbc:	10bff404 	addi	r2,r2,-48
 2003bc0:	e0bffd15 	stw	r2,-12(fp)

	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;
 2003bc4:	e0ffff17 	ldw	r3,-4(fp)
 2003bc8:	e0bffd17 	ldw	r2,-12(fp)
 2003bcc:	10c00015 	stw	r3,0(r2)

	/* Space for R3 to R1, muldiv and RA. */
	pxTopOfStack -= 5;
 2003bd0:	e0bffd17 	ldw	r2,-12(fp)
 2003bd4:	10bffb04 	addi	r2,r2,-20
 2003bd8:	e0bffd15 	stw	r2,-12(fp)

	return pxTopOfStack;
 2003bdc:	e0bffd17 	ldw	r2,-12(fp)
}
 2003be0:	e037883a 	mov	sp,fp
 2003be4:	dfc00117 	ldw	ra,4(sp)
 2003be8:	df000017 	ldw	fp,0(sp)
 2003bec:	dec00204 	addi	sp,sp,8
 2003bf0:	f800283a 	ret

02003bf4 <xPortStartScheduler>:
 **
 **     @param
 **
 */
/* ===================================================================*/
portBASE_TYPE xPortStartScheduler(void) {
 2003bf4:	defffe04 	addi	sp,sp,-8
 2003bf8:	dfc00115 	stw	ra,4(sp)
 2003bfc:	df000015 	stw	fp,0(sp)
 2003c00:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	 here already. */
	prvSetupTimerInterrupt();
 2003c04:	2003c4c0 	call	2003c4c <prvSetupTimerInterrupt>
 2003c08:	00808034 	movhi	r2,512

	/* Start the first task. */
	asm volatile ( " movia r2, restore_sp_from_pxCurrentTCB        \n"
 2003c0c:	10803104 	addi	r2,r2,196
 2003c10:	1000683a 	jmp	r2
			" jmp r2                                          " );

	/* Should not get here! */
	return 0;
 2003c14:	0005883a 	mov	r2,zero
}
 2003c18:	e037883a 	mov	sp,fp
 2003c1c:	dfc00117 	ldw	ra,4(sp)
 2003c20:	df000017 	ldw	fp,0(sp)
 2003c24:	dec00204 	addi	sp,sp,8
 2003c28:	f800283a 	ret

02003c2c <vPortEndScheduler>:
 **
 **     @param
 **
 */
/* ===================================================================*/
void vPortEndScheduler(void) {
 2003c2c:	deffff04 	addi	sp,sp,-4
 2003c30:	df000015 	stw	fp,0(sp)
 2003c34:	d839883a 	mov	fp,sp

}
 2003c38:	0001883a 	nop
 2003c3c:	e037883a 	mov	sp,fp
 2003c40:	df000017 	ldw	fp,0(sp)
 2003c44:	dec00104 	addi	sp,sp,4
 2003c48:	f800283a 	ret

02003c4c <prvSetupTimerInterrupt>:
 **
 **     @param
 **
 */
/* ===================================================================*/
void prvSetupTimerInterrupt(void) {
 2003c4c:	defffd04 	addi	sp,sp,-12
 2003c50:	dfc00215 	stw	ra,8(sp)
 2003c54:	df000115 	stw	fp,4(sp)
 2003c58:	df000104 	addi	fp,sp,4
	/* Try to register the interrupt handler. */
	//cjr Jul-1-2010 new API
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
	if (-EINVAL
			== alt_ic_isr_register(SYS_CLK_IRQ_INTERRUPT_CONTROLLER_ID,
 2003c5c:	d8000015 	stw	zero,0(sp)
 2003c60:	000f883a 	mov	r7,zero
 2003c64:	01808034 	movhi	r6,512
 2003c68:	318f3c04 	addi	r6,r6,15600
 2003c6c:	01400084 	movi	r5,2
 2003c70:	0009883a 	mov	r4,zero
 2003c74:	200e00c0 	call	200e00c <alt_ic_isr_register>
/* ===================================================================*/
void prvSetupTimerInterrupt(void) {
	/* Try to register the interrupt handler. */
	//cjr Jul-1-2010 new API
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
	if (-EINVAL
 2003c78:	10bffa98 	cmpnei	r2,r2,-22
 2003c7c:	1000021e 	bne	r2,zero,2003c88 <prvSetupTimerInterrupt+0x3c>
#else
					if ( -EINVAL == alt_irq_register( SYS_CLK_IRQ, 0x0, vPortSysTickHandler ) )
#endif
					{
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
 2003c80:	003da03a 	break	0
 2003c84:	00001006 	br	2003cc8 <prvSetupTimerInterrupt+0x7c>
	} else {
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL(SYS_CLK_BASE,
 2003c88:	00c00204 	movi	r3,8
 2003c8c:	00810034 	movhi	r2,1024
 2003c90:	10880904 	addi	r2,r2,8228
 2003c94:	10c00035 	stwio	r3,0(r2)
				ALTERA_AVALON_TIMER_CONTROL_STOP_MSK);
		IOWR_ALTERA_AVALON_TIMER_PERIODL(SYS_CLK_BASE,
 2003c98:	00e1a814 	movui	r3,34464
 2003c9c:	00810034 	movhi	r2,1024
 2003ca0:	10880a04 	addi	r2,r2,8232
 2003ca4:	10c00035 	stwio	r3,0(r2)
				( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF);
		IOWR_ALTERA_AVALON_TIMER_PERIODH(SYS_CLK_BASE,
 2003ca8:	00c00044 	movi	r3,1
 2003cac:	00810034 	movhi	r2,1024
 2003cb0:	10880b04 	addi	r2,r2,8236
 2003cb4:	10c00035 	stwio	r3,0(r2)
				( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16);
		IOWR_ALTERA_AVALON_TIMER_CONTROL(SYS_CLK_BASE,
 2003cb8:	00c001c4 	movi	r3,7
 2003cbc:	00810034 	movhi	r2,1024
 2003cc0:	10880904 	addi	r2,r2,8228
 2003cc4:	10c00035 	stwio	r3,0(r2)
				ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
	}

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS(SYS_CLK_BASE,
 2003cc8:	00ffff84 	movi	r3,-2
 2003ccc:	00810034 	movhi	r2,1024
 2003cd0:	10880804 	addi	r2,r2,8224
 2003cd4:	10c00035 	stwio	r3,0(r2)
			~ALTERA_AVALON_TIMER_STATUS_TO_MSK);
}
 2003cd8:	0001883a 	nop
 2003cdc:	e037883a 	mov	sp,fp
 2003ce0:	dfc00117 	ldw	ra,4(sp)
 2003ce4:	df000017 	ldw	fp,0(sp)
 2003ce8:	dec00204 	addi	sp,sp,8
 2003cec:	f800283a 	ret

02003cf0 <vPortSysTickHandler>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
void vPortSysTickHandler(void * context)
#else
void vPortSysTickHandler( void * context, alt_u32 id )
#endif
{
 2003cf0:	defffd04 	addi	sp,sp,-12
 2003cf4:	dfc00215 	stw	ra,8(sp)
 2003cf8:	df000115 	stw	fp,4(sp)
 2003cfc:	df000104 	addi	fp,sp,4
 2003d00:	e13fff15 	stw	r4,-4(fp)
	/* Increment the Kernel Tick. */
	//vTaskIncrementTick();
	(void) xTaskIncrementTick();
 2003d04:	20062880 	call	2006288 <xTaskIncrementTick>

	/* If using preemption, also force a context switch. */
#if configUSE_PREEMPTION == 1
	vTaskSwitchContext();
 2003d08:	20064680 	call	2006468 <vTaskSwitchContext>
#endif

	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS(SYS_CLK_BASE,
 2003d0c:	00ffff84 	movi	r3,-2
 2003d10:	00810034 	movhi	r2,1024
 2003d14:	10880804 	addi	r2,r2,8224
 2003d18:	10c00035 	stwio	r3,0(r2)
			~ALTERA_AVALON_TIMER_STATUS_TO_MSK);
}
 2003d1c:	0001883a 	nop
 2003d20:	e037883a 	mov	sp,fp
 2003d24:	dfc00117 	ldw	ra,4(sp)
 2003d28:	df000017 	ldw	fp,0(sp)
 2003d2c:	dec00204 	addi	sp,sp,8
 2003d30:	f800283a 	ret

02003d34 <alt_irq_register>:
#ifndef ALT_ENHANCED_INTERRUPT_API_PRESENT
int alt_irq_register( alt_u32 id, void* context, void (*handler)(void*, alt_u32) )
#else
int alt_irq_register(alt_u32 id, void* context, alt_isr_func handler)
#endif
{
 2003d34:	defff104 	addi	sp,sp,-60
 2003d38:	df000e15 	stw	fp,56(sp)
 2003d3c:	df000e04 	addi	fp,sp,56
 2003d40:	e13ffd15 	stw	r4,-12(fp)
 2003d44:	e17ffe15 	stw	r5,-8(fp)
 2003d48:	e1bfff15 	stw	r6,-4(fp)
	int rc = -EINVAL;
 2003d4c:	00bffa84 	movi	r2,-22
 2003d50:	e0bff215 	stw	r2,-56(fp)
	alt_irq_context status;

	if (id < ALT_NIRQ) {
 2003d54:	e0bffd17 	ldw	r2,-12(fp)
 2003d58:	10800828 	cmpgeui	r2,r2,32
 2003d5c:	10004c1e 	bne	r2,zero,2003e90 <alt_irq_register+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2003d60:	0005303a 	rdctl	r2,status
 2003d64:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2003d68:	e0fff617 	ldw	r3,-40(fp)
 2003d6c:	00bfff84 	movi	r2,-2
 2003d70:	1884703a 	and	r2,r3,r2
 2003d74:	1001703a 	wrctl	status,r2
  
  return context;
 2003d78:	e0bff617 	ldw	r2,-40(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistent
		 * state.
		 */

		status = alt_irq_disable_all();
 2003d7c:	e0bff415 	stw	r2,-48(fp)

		alt_irq[id].handler = handler;
 2003d80:	0080a074 	movhi	r2,641
 2003d84:	1091b904 	addi	r2,r2,18148
 2003d88:	e0fffd17 	ldw	r3,-12(fp)
 2003d8c:	180690fa 	slli	r3,r3,3
 2003d90:	10c5883a 	add	r2,r2,r3
 2003d94:	e0ffff17 	ldw	r3,-4(fp)
 2003d98:	10c00015 	stw	r3,0(r2)
		alt_irq[id].context = context;
 2003d9c:	0080a074 	movhi	r2,641
 2003da0:	1091b904 	addi	r2,r2,18148
 2003da4:	e0fffd17 	ldw	r3,-12(fp)
 2003da8:	180690fa 	slli	r3,r3,3
 2003dac:	10c5883a 	add	r2,r2,r3
 2003db0:	10800104 	addi	r2,r2,4
 2003db4:	e0fffe17 	ldw	r3,-8(fp)
 2003db8:	10c00015 	stw	r3,0(r2)

		rc = (handler) ? alt_irq_enable(id) : alt_irq_disable(id);
 2003dbc:	e0bfff17 	ldw	r2,-4(fp)
 2003dc0:	10001926 	beq	r2,zero,2003e28 <alt_irq_register+0xf4>
 2003dc4:	e0bffd17 	ldw	r2,-12(fp)
 2003dc8:	e0bff315 	stw	r2,-52(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2003dcc:	0005303a 	rdctl	r2,status
 2003dd0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2003dd4:	e0fff717 	ldw	r3,-36(fp)
 2003dd8:	00bfff84 	movi	r2,-2
 2003ddc:	1884703a 	and	r2,r3,r2
 2003de0:	1001703a 	wrctl	status,r2
  
  return context;
 2003de4:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 2003de8:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
 2003dec:	00c00044 	movi	r3,1
 2003df0:	e0bff317 	ldw	r2,-52(fp)
 2003df4:	1884983a 	sll	r2,r3,r2
 2003df8:	1007883a 	mov	r3,r2
 2003dfc:	d0a08e17 	ldw	r2,-32200(gp)
 2003e00:	1884b03a 	or	r2,r3,r2
 2003e04:	d0a08e15 	stw	r2,-32200(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 2003e08:	d0a08e17 	ldw	r2,-32200(gp)
 2003e0c:	100170fa 	wrctl	ienable,r2
 2003e10:	e0bff817 	ldw	r2,-32(fp)
 2003e14:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2003e18:	e0bff917 	ldw	r2,-28(fp)
 2003e1c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 2003e20:	0005883a 	mov	r2,zero
 2003e24:	00001906 	br	2003e8c <alt_irq_register+0x158>
 2003e28:	e0bffd17 	ldw	r2,-12(fp)
 2003e2c:	e0bff515 	stw	r2,-44(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2003e30:	0005303a 	rdctl	r2,status
 2003e34:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2003e38:	e0fffa17 	ldw	r3,-24(fp)
 2003e3c:	00bfff84 	movi	r2,-2
 2003e40:	1884703a 	and	r2,r3,r2
 2003e44:	1001703a 	wrctl	status,r2
  
  return context;
 2003e48:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 2003e4c:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
 2003e50:	00c00044 	movi	r3,1
 2003e54:	e0bff517 	ldw	r2,-44(fp)
 2003e58:	1884983a 	sll	r2,r3,r2
 2003e5c:	0084303a 	nor	r2,zero,r2
 2003e60:	1007883a 	mov	r3,r2
 2003e64:	d0a08e17 	ldw	r2,-32200(gp)
 2003e68:	1884703a 	and	r2,r3,r2
 2003e6c:	d0a08e15 	stw	r2,-32200(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 2003e70:	d0a08e17 	ldw	r2,-32200(gp)
 2003e74:	100170fa 	wrctl	ienable,r2
 2003e78:	e0bffb17 	ldw	r2,-20(fp)
 2003e7c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2003e80:	e0bffc17 	ldw	r2,-16(fp)
 2003e84:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 2003e88:	0005883a 	mov	r2,zero
 2003e8c:	e0bff215 	stw	r2,-56(fp)

		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}

	return rc;
 2003e90:	e0bff217 	ldw	r2,-56(fp)
}
 2003e94:	e037883a 	mov	sp,fp
 2003e98:	df000017 	ldw	fp,0(sp)
 2003e9c:	dec00104 	addi	sp,sp,4
 2003ea0:	f800283a 	ret

02003ea4 <alt_iic_isr_register>:
 * @param isr_context      Opaque pointer passed to ISR
 * @param flags
 * @return                 0 if successful, else error (-1)
 */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr,
		void *isr_context, void *flags) {
 2003ea4:	defff604 	addi	sp,sp,-40
 2003ea8:	dfc00915 	stw	ra,36(sp)
 2003eac:	df000815 	stw	fp,32(sp)
 2003eb0:	df000804 	addi	fp,sp,32
 2003eb4:	e13ffc15 	stw	r4,-16(fp)
 2003eb8:	e17ffd15 	stw	r5,-12(fp)
 2003ebc:	e1bffe15 	stw	r6,-8(fp)
 2003ec0:	e1ffff15 	stw	r7,-4(fp)
	int rc = -EINVAL;
 2003ec4:	00bffa84 	movi	r2,-22
 2003ec8:	e0bff815 	stw	r2,-32(fp)
	int id = irq; /* IRQ interpreted as the interrupt ID. */
 2003ecc:	e0bffd17 	ldw	r2,-12(fp)
 2003ed0:	e0bff915 	stw	r2,-28(fp)
	alt_irq_context status;

	if (id < ALT_NIRQ) {
 2003ed4:	e0bff917 	ldw	r2,-28(fp)
 2003ed8:	10800808 	cmpgei	r2,r2,32
 2003edc:	1000231e 	bne	r2,zero,2003f6c <alt_iic_isr_register+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2003ee0:	0005303a 	rdctl	r2,status
 2003ee4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2003ee8:	e0fffb17 	ldw	r3,-20(fp)
 2003eec:	00bfff84 	movi	r2,-2
 2003ef0:	1884703a 	and	r2,r3,r2
 2003ef4:	1001703a 	wrctl	status,r2
  
  return context;
 2003ef8:	e0bffb17 	ldw	r2,-20(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistant
		 * state.
		 */

		status = alt_irq_disable_all();
 2003efc:	e0bffa15 	stw	r2,-24(fp)

		alt_irq[id].handler = isr;
 2003f00:	0080a074 	movhi	r2,641
 2003f04:	1091b904 	addi	r2,r2,18148
 2003f08:	e0fff917 	ldw	r3,-28(fp)
 2003f0c:	180690fa 	slli	r3,r3,3
 2003f10:	10c5883a 	add	r2,r2,r3
 2003f14:	e0fffe17 	ldw	r3,-8(fp)
 2003f18:	10c00015 	stw	r3,0(r2)
		alt_irq[id].context = isr_context;
 2003f1c:	0080a074 	movhi	r2,641
 2003f20:	1091b904 	addi	r2,r2,18148
 2003f24:	e0fff917 	ldw	r3,-28(fp)
 2003f28:	180690fa 	slli	r3,r3,3
 2003f2c:	10c5883a 	add	r2,r2,r3
 2003f30:	10800104 	addi	r2,r2,4
 2003f34:	e0ffff17 	ldw	r3,-4(fp)
 2003f38:	10c00015 	stw	r3,0(r2)

		rc = (isr) ?
				alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 2003f3c:	e0bffe17 	ldw	r2,-8(fp)
 2003f40:	10000526 	beq	r2,zero,2003f58 <alt_iic_isr_register+0xb4>
 2003f44:	e0bff917 	ldw	r2,-28(fp)
 2003f48:	100b883a 	mov	r5,r2
 2003f4c:	e13ffc17 	ldw	r4,-16(fp)
 2003f50:	200e05c0 	call	200e05c <alt_ic_irq_enable>
 2003f54:	00000406 	br	2003f68 <alt_iic_isr_register+0xc4>
 2003f58:	e0bff917 	ldw	r2,-28(fp)
 2003f5c:	100b883a 	mov	r5,r2
 2003f60:	e13ffc17 	ldw	r4,-16(fp)
 2003f64:	200e0e40 	call	200e0e4 <alt_ic_irq_disable>
		status = alt_irq_disable_all();

		alt_irq[id].handler = isr;
		alt_irq[id].context = isr_context;

		rc = (isr) ?
 2003f68:	e0bff815 	stw	r2,-32(fp)
				alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);

		//  alt_irq_enable_all(status);
	}

	return rc;
 2003f6c:	e0bff817 	ldw	r2,-32(fp)
}
 2003f70:	e037883a 	mov	sp,fp
 2003f74:	dfc00117 	ldw	ra,4(sp)
 2003f78:	df000017 	ldw	fp,0(sp)
 2003f7c:	dec00204 	addi	sp,sp,8
 2003f80:	f800283a 	ret

02003f84 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 2003f84:	defff704 	addi	sp,sp,-36
 2003f88:	dfc00815 	stw	ra,32(sp)
 2003f8c:	df000715 	stw	fp,28(sp)
 2003f90:	df000704 	addi	fp,sp,28
 2003f94:	e13fff15 	stw	r4,-4(fp)
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 2003f98:	e03ffb15 	stw	zero,-20(fp)

	vTaskSuspendAll();
 2003f9c:	20060440 	call	2006044 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 2003fa0:	d0a06d17 	ldw	r2,-32332(gp)
 2003fa4:	1000031e 	bne	r2,zero,2003fb4 <pvPortMalloc+0x30>
		{
			prvHeapInit();
 2003fa8:	20042640 	call	2004264 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
 2003fac:	00800044 	movi	r2,1
 2003fb0:	d0a06d15 	stw	r2,-32332(gp)
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 2003fb4:	e0bfff17 	ldw	r2,-4(fp)
 2003fb8:	10000d26 	beq	r2,zero,2003ff0 <pvPortMalloc+0x6c>
		{
			xWantedSize += heapSTRUCT_SIZE;
 2003fbc:	00800204 	movi	r2,8
 2003fc0:	10bfffcc 	andi	r2,r2,65535
 2003fc4:	e0ffff17 	ldw	r3,-4(fp)
 2003fc8:	1885883a 	add	r2,r3,r2
 2003fcc:	e0bfff15 	stw	r2,-4(fp)

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
 2003fd0:	e0bfff17 	ldw	r2,-4(fp)
 2003fd4:	108000cc 	andi	r2,r2,3
 2003fd8:	10000526 	beq	r2,zero,2003ff0 <pvPortMalloc+0x6c>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 2003fdc:	e0ffff17 	ldw	r3,-4(fp)
 2003fe0:	00bfff04 	movi	r2,-4
 2003fe4:	1884703a 	and	r2,r3,r2
 2003fe8:	10800104 	addi	r2,r2,4
 2003fec:	e0bfff15 	stw	r2,-4(fp)
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 2003ff0:	e0bfff17 	ldw	r2,-4(fp)
 2003ff4:	10005126 	beq	r2,zero,200413c <pvPortMalloc+0x1b8>
 2003ff8:	e0ffff17 	ldw	r3,-4(fp)
 2003ffc:	00802034 	movhi	r2,128
 2004000:	10bffec4 	addi	r2,r2,-5
 2004004:	10c04d36 	bltu	r2,r3,200413c <pvPortMalloc+0x1b8>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 2004008:	d0a06904 	addi	r2,gp,-32348
 200400c:	e0bffa15 	stw	r2,-24(fp)
			pxBlock = xStart.pxNextFreeBlock;
 2004010:	d0a06917 	ldw	r2,-32348(gp)
 2004014:	e0bff915 	stw	r2,-28(fp)
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 2004018:	00000506 	br	2004030 <pvPortMalloc+0xac>
			{
				pxPreviousBlock = pxBlock;
 200401c:	e0bff917 	ldw	r2,-28(fp)
 2004020:	e0bffa15 	stw	r2,-24(fp)
				pxBlock = pxBlock->pxNextFreeBlock;
 2004024:	e0bff917 	ldw	r2,-28(fp)
 2004028:	10800017 	ldw	r2,0(r2)
 200402c:	e0bff915 	stw	r2,-28(fp)
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 2004030:	e0bff917 	ldw	r2,-28(fp)
 2004034:	10c00117 	ldw	r3,4(r2)
 2004038:	e0bfff17 	ldw	r2,-4(fp)
 200403c:	1880032e 	bgeu	r3,r2,200404c <pvPortMalloc+0xc8>
 2004040:	e0bff917 	ldw	r2,-28(fp)
 2004044:	10800017 	ldw	r2,0(r2)
 2004048:	103ff41e 	bne	r2,zero,200401c <__reset+0xfe00301c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 200404c:	e0fff917 	ldw	r3,-28(fp)
 2004050:	d0a06b04 	addi	r2,gp,-32340
 2004054:	18803926 	beq	r3,r2,200413c <pvPortMalloc+0x1b8>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 2004058:	e0bffa17 	ldw	r2,-24(fp)
 200405c:	10c00017 	ldw	r3,0(r2)
 2004060:	00800204 	movi	r2,8
 2004064:	10bfffcc 	andi	r2,r2,65535
 2004068:	1885883a 	add	r2,r3,r2
 200406c:	e0bffb15 	stw	r2,-20(fp)

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 2004070:	e0bff917 	ldw	r2,-28(fp)
 2004074:	10c00017 	ldw	r3,0(r2)
 2004078:	e0bffa17 	ldw	r2,-24(fp)
 200407c:	10c00015 	stw	r3,0(r2)

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 2004080:	e0bff917 	ldw	r2,-28(fp)
 2004084:	10c00117 	ldw	r3,4(r2)
 2004088:	e0bfff17 	ldw	r2,-4(fp)
 200408c:	1887c83a 	sub	r3,r3,r2
 2004090:	00800204 	movi	r2,8
 2004094:	10bfffcc 	andi	r2,r2,65535
 2004098:	1085883a 	add	r2,r2,r2
 200409c:	10c0222e 	bgeu	r2,r3,2004128 <pvPortMalloc+0x1a4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 20040a0:	e0fff917 	ldw	r3,-28(fp)
 20040a4:	e0bfff17 	ldw	r2,-4(fp)
 20040a8:	1885883a 	add	r2,r3,r2
 20040ac:	e0bffd15 	stw	r2,-12(fp)

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 20040b0:	e0bff917 	ldw	r2,-28(fp)
 20040b4:	10c00117 	ldw	r3,4(r2)
 20040b8:	e0bfff17 	ldw	r2,-4(fp)
 20040bc:	1887c83a 	sub	r3,r3,r2
 20040c0:	e0bffd17 	ldw	r2,-12(fp)
 20040c4:	10c00115 	stw	r3,4(r2)
					pxBlock->xBlockSize = xWantedSize;
 20040c8:	e0bff917 	ldw	r2,-28(fp)
 20040cc:	e0ffff17 	ldw	r3,-4(fp)
 20040d0:	10c00115 	stw	r3,4(r2)

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 20040d4:	e0bffd17 	ldw	r2,-12(fp)
 20040d8:	10800117 	ldw	r2,4(r2)
 20040dc:	e0bffe15 	stw	r2,-8(fp)
 20040e0:	d0a06904 	addi	r2,gp,-32348
 20040e4:	e0bffc15 	stw	r2,-16(fp)
 20040e8:	00000306 	br	20040f8 <pvPortMalloc+0x174>
 20040ec:	e0bffc17 	ldw	r2,-16(fp)
 20040f0:	10800017 	ldw	r2,0(r2)
 20040f4:	e0bffc15 	stw	r2,-16(fp)
 20040f8:	e0bffc17 	ldw	r2,-16(fp)
 20040fc:	10800017 	ldw	r2,0(r2)
 2004100:	10c00117 	ldw	r3,4(r2)
 2004104:	e0bffe17 	ldw	r2,-8(fp)
 2004108:	18bff836 	bltu	r3,r2,20040ec <__reset+0xfe0030ec>
 200410c:	e0bffc17 	ldw	r2,-16(fp)
 2004110:	10c00017 	ldw	r3,0(r2)
 2004114:	e0bffd17 	ldw	r2,-12(fp)
 2004118:	10c00015 	stw	r3,0(r2)
 200411c:	e0bffc17 	ldw	r2,-16(fp)
 2004120:	e0fffd17 	ldw	r3,-12(fp)
 2004124:	10c00015 	stw	r3,0(r2)
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 2004128:	d0e00317 	ldw	r3,-32756(gp)
 200412c:	e0bff917 	ldw	r2,-28(fp)
 2004130:	10800117 	ldw	r2,4(r2)
 2004134:	1885c83a 	sub	r2,r3,r2
 2004138:	d0a00315 	stw	r2,-32756(gp)
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 200413c:	20060700 	call	2006070 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
 2004140:	e0bffb17 	ldw	r2,-20(fp)
}
 2004144:	e037883a 	mov	sp,fp
 2004148:	dfc00117 	ldw	ra,4(sp)
 200414c:	df000017 	ldw	fp,0(sp)
 2004150:	dec00204 	addi	sp,sp,8
 2004154:	f800283a 	ret

02004158 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 2004158:	defff904 	addi	sp,sp,-28
 200415c:	dfc00615 	stw	ra,24(sp)
 2004160:	df000515 	stw	fp,20(sp)
 2004164:	df000504 	addi	fp,sp,20
 2004168:	e13fff15 	stw	r4,-4(fp)
uint8_t *puc = ( uint8_t * ) pv;
 200416c:	e0bfff17 	ldw	r2,-4(fp)
 2004170:	e0bffc15 	stw	r2,-16(fp)
BlockLink_t *pxLink;

	if( pv != NULL )
 2004174:	e0bfff17 	ldw	r2,-4(fp)
 2004178:	10002426 	beq	r2,zero,200420c <vPortFree+0xb4>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 200417c:	00800204 	movi	r2,8
 2004180:	10bfffcc 	andi	r2,r2,65535
 2004184:	0085c83a 	sub	r2,zero,r2
 2004188:	e0fffc17 	ldw	r3,-16(fp)
 200418c:	1885883a 	add	r2,r3,r2
 2004190:	e0bffc15 	stw	r2,-16(fp)

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
 2004194:	e0bffc17 	ldw	r2,-16(fp)
 2004198:	e0bffd15 	stw	r2,-12(fp)

		vTaskSuspendAll();
 200419c:	20060440 	call	2006044 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 20041a0:	e0bffd17 	ldw	r2,-12(fp)
 20041a4:	10800117 	ldw	r2,4(r2)
 20041a8:	e0bffe15 	stw	r2,-8(fp)
 20041ac:	d0a06904 	addi	r2,gp,-32348
 20041b0:	e0bffb15 	stw	r2,-20(fp)
 20041b4:	00000306 	br	20041c4 <vPortFree+0x6c>
 20041b8:	e0bffb17 	ldw	r2,-20(fp)
 20041bc:	10800017 	ldw	r2,0(r2)
 20041c0:	e0bffb15 	stw	r2,-20(fp)
 20041c4:	e0bffb17 	ldw	r2,-20(fp)
 20041c8:	10800017 	ldw	r2,0(r2)
 20041cc:	10c00117 	ldw	r3,4(r2)
 20041d0:	e0bffe17 	ldw	r2,-8(fp)
 20041d4:	18bff836 	bltu	r3,r2,20041b8 <__reset+0xfe0031b8>
 20041d8:	e0bffb17 	ldw	r2,-20(fp)
 20041dc:	10c00017 	ldw	r3,0(r2)
 20041e0:	e0bffd17 	ldw	r2,-12(fp)
 20041e4:	10c00015 	stw	r3,0(r2)
 20041e8:	e0bffb17 	ldw	r2,-20(fp)
 20041ec:	e0fffd17 	ldw	r3,-12(fp)
 20041f0:	10c00015 	stw	r3,0(r2)
			xFreeBytesRemaining += pxLink->xBlockSize;
 20041f4:	e0bffd17 	ldw	r2,-12(fp)
 20041f8:	10c00117 	ldw	r3,4(r2)
 20041fc:	d0a00317 	ldw	r2,-32756(gp)
 2004200:	1885883a 	add	r2,r3,r2
 2004204:	d0a00315 	stw	r2,-32756(gp)
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 2004208:	20060700 	call	2006070 <xTaskResumeAll>
	}
}
 200420c:	0001883a 	nop
 2004210:	e037883a 	mov	sp,fp
 2004214:	dfc00117 	ldw	ra,4(sp)
 2004218:	df000017 	ldw	fp,0(sp)
 200421c:	dec00204 	addi	sp,sp,8
 2004220:	f800283a 	ret

02004224 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 2004224:	deffff04 	addi	sp,sp,-4
 2004228:	df000015 	stw	fp,0(sp)
 200422c:	d839883a 	mov	fp,sp
	return xFreeBytesRemaining;
 2004230:	d0a00317 	ldw	r2,-32756(gp)
}
 2004234:	e037883a 	mov	sp,fp
 2004238:	df000017 	ldw	fp,0(sp)
 200423c:	dec00104 	addi	sp,sp,4
 2004240:	f800283a 	ret

02004244 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 2004244:	deffff04 	addi	sp,sp,-4
 2004248:	df000015 	stw	fp,0(sp)
 200424c:	d839883a 	mov	fp,sp
	/* This just exists to keep the linker quiet. */
}
 2004250:	0001883a 	nop
 2004254:	e037883a 	mov	sp,fp
 2004258:	df000017 	ldw	fp,0(sp)
 200425c:	dec00104 	addi	sp,sp,4
 2004260:	f800283a 	ret

02004264 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 2004264:	defffd04 	addi	sp,sp,-12
 2004268:	df000215 	stw	fp,8(sp)
 200426c:	df000204 	addi	fp,sp,8
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 2004270:	00808074 	movhi	r2,513
 2004274:	10914404 	addi	r2,r2,17680
 2004278:	00ffff04 	movi	r3,-4
 200427c:	10c4703a 	and	r2,r2,r3
 2004280:	e0bffe15 	stw	r2,-8(fp)

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 2004284:	e0bffe17 	ldw	r2,-8(fp)
 2004288:	d0a06915 	stw	r2,-32348(gp)
	xStart.xBlockSize = ( size_t ) 0;
 200428c:	d0206a15 	stw	zero,-32344(gp)

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 2004290:	00802034 	movhi	r2,128
 2004294:	10bfff04 	addi	r2,r2,-4
 2004298:	d0a06c15 	stw	r2,-32336(gp)
	xEnd.pxNextFreeBlock = NULL;
 200429c:	d0206b15 	stw	zero,-32340(gp)

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 20042a0:	e0bffe17 	ldw	r2,-8(fp)
 20042a4:	e0bfff15 	stw	r2,-4(fp)
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
 20042a8:	e0ffff17 	ldw	r3,-4(fp)
 20042ac:	00802034 	movhi	r2,128
 20042b0:	10bfff04 	addi	r2,r2,-4
 20042b4:	18800115 	stw	r2,4(r3)
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 20042b8:	e0bfff17 	ldw	r2,-4(fp)
 20042bc:	d0e06b04 	addi	r3,gp,-32340
 20042c0:	10c00015 	stw	r3,0(r2)
}
 20042c4:	0001883a 	nop
 20042c8:	e037883a 	mov	sp,fp
 20042cc:	df000017 	ldw	fp,0(sp)
 20042d0:	dec00104 	addi	sp,sp,4
 20042d4:	f800283a 	ret

020042d8 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 20042d8:	defffa04 	addi	sp,sp,-24
 20042dc:	dfc00515 	stw	ra,20(sp)
 20042e0:	df000415 	stw	fp,16(sp)
 20042e4:	dc000315 	stw	r16,12(sp)
 20042e8:	df000404 	addi	fp,sp,16
 20042ec:	e13ffd15 	stw	r4,-12(fp)
 20042f0:	e17ffe15 	stw	r5,-8(fp)
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 20042f4:	e0bffd17 	ldw	r2,-12(fp)
 20042f8:	e0bffc15 	stw	r2,-16(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 20042fc:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 2004300:	e0bffc17 	ldw	r2,-16(fp)
 2004304:	14000017 	ldw	r16,0(r2)
 2004308:	e0bffc17 	ldw	r2,-16(fp)
 200430c:	10c00f17 	ldw	r3,60(r2)
 2004310:	e0bffc17 	ldw	r2,-16(fp)
 2004314:	10801017 	ldw	r2,64(r2)
 2004318:	100b883a 	mov	r5,r2
 200431c:	1809883a 	mov	r4,r3
 2004320:	2009bcc0 	call	2009bcc <__mulsi3>
 2004324:	8087883a 	add	r3,r16,r2
 2004328:	e0bffc17 	ldw	r2,-16(fp)
 200432c:	10c00115 	stw	r3,4(r2)
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 2004330:	e0bffc17 	ldw	r2,-16(fp)
 2004334:	10000e15 	stw	zero,56(r2)
		pxQueue->pcWriteTo = pxQueue->pcHead;
 2004338:	e0bffc17 	ldw	r2,-16(fp)
 200433c:	10c00017 	ldw	r3,0(r2)
 2004340:	e0bffc17 	ldw	r2,-16(fp)
 2004344:	10c00215 	stw	r3,8(r2)
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 2004348:	e0bffc17 	ldw	r2,-16(fp)
 200434c:	14000017 	ldw	r16,0(r2)
 2004350:	e0bffc17 	ldw	r2,-16(fp)
 2004354:	10800f17 	ldw	r2,60(r2)
 2004358:	10ffffc4 	addi	r3,r2,-1
 200435c:	e0bffc17 	ldw	r2,-16(fp)
 2004360:	10801017 	ldw	r2,64(r2)
 2004364:	100b883a 	mov	r5,r2
 2004368:	1809883a 	mov	r4,r3
 200436c:	2009bcc0 	call	2009bcc <__mulsi3>
 2004370:	8087883a 	add	r3,r16,r2
 2004374:	e0bffc17 	ldw	r2,-16(fp)
 2004378:	10c00315 	stw	r3,12(r2)
		pxQueue->cRxLock = queueUNLOCKED;
 200437c:	e0bffc17 	ldw	r2,-16(fp)
 2004380:	00ffffc4 	movi	r3,-1
 2004384:	10c01105 	stb	r3,68(r2)
		pxQueue->cTxLock = queueUNLOCKED;
 2004388:	e0bffc17 	ldw	r2,-16(fp)
 200438c:	00ffffc4 	movi	r3,-1
 2004390:	10c01145 	stb	r3,69(r2)

		if( xNewQueue == pdFALSE )
 2004394:	e0bffe17 	ldw	r2,-8(fp)
 2004398:	10000a1e 	bne	r2,zero,20043c4 <xQueueGenericReset+0xec>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 200439c:	e0bffc17 	ldw	r2,-16(fp)
 20043a0:	10800417 	ldw	r2,16(r2)
 20043a4:	10000f26 	beq	r2,zero,20043e4 <xQueueGenericReset+0x10c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 20043a8:	e0bffc17 	ldw	r2,-16(fp)
 20043ac:	10800404 	addi	r2,r2,16
 20043b0:	1009883a 	mov	r4,r2
 20043b4:	20066140 	call	2006614 <xTaskRemoveFromEventList>
 20043b8:	10000a26 	beq	r2,zero,20043e4 <xQueueGenericReset+0x10c>
				{
					queueYIELD_IF_USING_PREEMPTION();
 20043bc:	003b683a 	trap	0
 20043c0:	00000806 	br	20043e4 <xQueueGenericReset+0x10c>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 20043c4:	e0bffc17 	ldw	r2,-16(fp)
 20043c8:	10800404 	addi	r2,r2,16
 20043cc:	1009883a 	mov	r4,r2
 20043d0:	200385c0 	call	200385c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 20043d4:	e0bffc17 	ldw	r2,-16(fp)
 20043d8:	10800904 	addi	r2,r2,36
 20043dc:	1009883a 	mov	r4,r2
 20043e0:	200385c0 	call	200385c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 20043e4:	2006ef80 	call	2006ef8 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 20043e8:	00800044 	movi	r2,1
}
 20043ec:	e6ffff04 	addi	sp,fp,-4
 20043f0:	dfc00217 	ldw	ra,8(sp)
 20043f4:	df000117 	ldw	fp,4(sp)
 20043f8:	dc000017 	ldw	r16,0(sp)
 20043fc:	dec00304 	addi	sp,sp,12
 2004400:	f800283a 	ret

02004404 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 2004404:	defff704 	addi	sp,sp,-36
 2004408:	dfc00815 	stw	ra,32(sp)
 200440c:	df000715 	stw	fp,28(sp)
 2004410:	df000704 	addi	fp,sp,28
 2004414:	e13ffd15 	stw	r4,-12(fp)
 2004418:	e17ffe15 	stw	r5,-8(fp)
 200441c:	3005883a 	mov	r2,r6
 2004420:	e0bfff05 	stb	r2,-4(fp)
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
 2004424:	e0bffe17 	ldw	r2,-8(fp)
 2004428:	1000021e 	bne	r2,zero,2004434 <xQueueGenericCreate+0x30>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
 200442c:	e03ffa15 	stw	zero,-24(fp)
 2004430:	00000406 	br	2004444 <xQueueGenericCreate+0x40>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2004434:	e17ffe17 	ldw	r5,-8(fp)
 2004438:	e13ffd17 	ldw	r4,-12(fp)
 200443c:	2009bcc0 	call	2009bcc <__mulsi3>
 2004440:	e0bffa15 	stw	r2,-24(fp)
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 2004444:	e0bffa17 	ldw	r2,-24(fp)
 2004448:	10801204 	addi	r2,r2,72
 200444c:	1009883a 	mov	r4,r2
 2004450:	2003f840 	call	2003f84 <pvPortMalloc>
 2004454:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewQueue != NULL )
 2004458:	e0bffb17 	ldw	r2,-20(fp)
 200445c:	10000b26 	beq	r2,zero,200448c <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 2004460:	e0bffb17 	ldw	r2,-20(fp)
 2004464:	10801204 	addi	r2,r2,72
 2004468:	e0bffc15 	stw	r2,-16(fp)
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 200446c:	e0ffff03 	ldbu	r3,-4(fp)
 2004470:	e0bffb17 	ldw	r2,-20(fp)
 2004474:	d8800015 	stw	r2,0(sp)
 2004478:	180f883a 	mov	r7,r3
 200447c:	e1bffc17 	ldw	r6,-16(fp)
 2004480:	e17ffe17 	ldw	r5,-8(fp)
 2004484:	e13ffd17 	ldw	r4,-12(fp)
 2004488:	20044a40 	call	20044a4 <prvInitialiseNewQueue>
		}

		return pxNewQueue;
 200448c:	e0bffb17 	ldw	r2,-20(fp)
	}
 2004490:	e037883a 	mov	sp,fp
 2004494:	dfc00117 	ldw	ra,4(sp)
 2004498:	df000017 	ldw	fp,0(sp)
 200449c:	dec00204 	addi	sp,sp,8
 20044a0:	f800283a 	ret

020044a4 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 20044a4:	defffa04 	addi	sp,sp,-24
 20044a8:	dfc00515 	stw	ra,20(sp)
 20044ac:	df000415 	stw	fp,16(sp)
 20044b0:	df000404 	addi	fp,sp,16
 20044b4:	e13ffc15 	stw	r4,-16(fp)
 20044b8:	e17ffd15 	stw	r5,-12(fp)
 20044bc:	e1bffe15 	stw	r6,-8(fp)
 20044c0:	3805883a 	mov	r2,r7
 20044c4:	e0bfff05 	stb	r2,-4(fp)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 20044c8:	e0bffd17 	ldw	r2,-12(fp)
 20044cc:	1000041e 	bne	r2,zero,20044e0 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 20044d0:	e0800217 	ldw	r2,8(fp)
 20044d4:	e0c00217 	ldw	r3,8(fp)
 20044d8:	10c00015 	stw	r3,0(r2)
 20044dc:	00000306 	br	20044ec <prvInitialiseNewQueue+0x48>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 20044e0:	e0800217 	ldw	r2,8(fp)
 20044e4:	e0fffe17 	ldw	r3,-8(fp)
 20044e8:	10c00015 	stw	r3,0(r2)
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 20044ec:	e0800217 	ldw	r2,8(fp)
 20044f0:	e0fffc17 	ldw	r3,-16(fp)
 20044f4:	10c00f15 	stw	r3,60(r2)
	pxNewQueue->uxItemSize = uxItemSize;
 20044f8:	e0800217 	ldw	r2,8(fp)
 20044fc:	e0fffd17 	ldw	r3,-12(fp)
 2004500:	10c01015 	stw	r3,64(r2)
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 2004504:	01400044 	movi	r5,1
 2004508:	e1000217 	ldw	r4,8(fp)
 200450c:	20042d80 	call	20042d8 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 2004510:	0001883a 	nop
 2004514:	e037883a 	mov	sp,fp
 2004518:	dfc00117 	ldw	ra,4(sp)
 200451c:	df000017 	ldw	fp,0(sp)
 2004520:	dec00204 	addi	sp,sp,8
 2004524:	f800283a 	ret

02004528 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
 2004528:	defffd04 	addi	sp,sp,-12
 200452c:	dfc00215 	stw	ra,8(sp)
 2004530:	df000115 	stw	fp,4(sp)
 2004534:	df000104 	addi	fp,sp,4
 2004538:	e13fff15 	stw	r4,-4(fp)
		if( pxNewQueue != NULL )
 200453c:	e0bfff17 	ldw	r2,-4(fp)
 2004540:	10000b26 	beq	r2,zero,2004570 <prvInitialiseMutex+0x48>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 2004544:	e0bfff17 	ldw	r2,-4(fp)
 2004548:	10000115 	stw	zero,4(r2)
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 200454c:	e0bfff17 	ldw	r2,-4(fp)
 2004550:	10000015 	stw	zero,0(r2)

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
 2004554:	e0bfff17 	ldw	r2,-4(fp)
 2004558:	10000315 	stw	zero,12(r2)

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 200455c:	000f883a 	mov	r7,zero
 2004560:	000d883a 	mov	r6,zero
 2004564:	000b883a 	mov	r5,zero
 2004568:	e13fff17 	ldw	r4,-4(fp)
 200456c:	20047700 	call	2004770 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
 2004570:	0001883a 	nop
 2004574:	e037883a 	mov	sp,fp
 2004578:	dfc00117 	ldw	ra,4(sp)
 200457c:	df000017 	ldw	fp,0(sp)
 2004580:	dec00204 	addi	sp,sp,8
 2004584:	f800283a 	ret

02004588 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
 2004588:	defffa04 	addi	sp,sp,-24
 200458c:	dfc00515 	stw	ra,20(sp)
 2004590:	df000415 	stw	fp,16(sp)
 2004594:	df000404 	addi	fp,sp,16
 2004598:	2005883a 	mov	r2,r4
 200459c:	e0bfff05 	stb	r2,-4(fp)
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 20045a0:	00800044 	movi	r2,1
 20045a4:	e0bffc15 	stw	r2,-16(fp)
 20045a8:	e03ffd15 	stw	zero,-12(fp)

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 20045ac:	e0bfff03 	ldbu	r2,-4(fp)
 20045b0:	100d883a 	mov	r6,r2
 20045b4:	e17ffd17 	ldw	r5,-12(fp)
 20045b8:	e13ffc17 	ldw	r4,-16(fp)
 20045bc:	20044040 	call	2004404 <xQueueGenericCreate>
 20045c0:	e0bffe15 	stw	r2,-8(fp)
		prvInitialiseMutex( pxNewQueue );
 20045c4:	e13ffe17 	ldw	r4,-8(fp)
 20045c8:	20045280 	call	2004528 <prvInitialiseMutex>

		return pxNewQueue;
 20045cc:	e0bffe17 	ldw	r2,-8(fp)
	}
 20045d0:	e037883a 	mov	sp,fp
 20045d4:	dfc00117 	ldw	ra,4(sp)
 20045d8:	df000017 	ldw	fp,0(sp)
 20045dc:	dec00204 	addi	sp,sp,8
 20045e0:	f800283a 	ret

020045e4 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
 20045e4:	defffa04 	addi	sp,sp,-24
 20045e8:	dfc00515 	stw	ra,20(sp)
 20045ec:	df000415 	stw	fp,16(sp)
 20045f0:	dc000315 	stw	r16,12(sp)
 20045f4:	df000404 	addi	fp,sp,16
 20045f8:	e13ffe15 	stw	r4,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 20045fc:	e0bffe17 	ldw	r2,-8(fp)
 2004600:	e0bffd15 	stw	r2,-12(fp)
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
 2004604:	e0bffd17 	ldw	r2,-12(fp)
 2004608:	14000117 	ldw	r16,4(r2)
 200460c:	2006c2c0 	call	2006c2c <xTaskGetCurrentTaskHandle>
 2004610:	8080101e 	bne	r16,r2,2004654 <xQueueGiveMutexRecursive+0x70>
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.uxRecursiveCallCount )--;
 2004614:	e0bffd17 	ldw	r2,-12(fp)
 2004618:	10800317 	ldw	r2,12(r2)
 200461c:	10ffffc4 	addi	r3,r2,-1
 2004620:	e0bffd17 	ldw	r2,-12(fp)
 2004624:	10c00315 	stw	r3,12(r2)

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 2004628:	e0bffd17 	ldw	r2,-12(fp)
 200462c:	10800317 	ldw	r2,12(r2)
 2004630:	1000051e 	bne	r2,zero,2004648 <xQueueGiveMutexRecursive+0x64>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 2004634:	000f883a 	mov	r7,zero
 2004638:	000d883a 	mov	r6,zero
 200463c:	000b883a 	mov	r5,zero
 2004640:	e13ffd17 	ldw	r4,-12(fp)
 2004644:	20047700 	call	2004770 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
 2004648:	00800044 	movi	r2,1
 200464c:	e0bffc15 	stw	r2,-16(fp)
 2004650:	00000106 	br	2004658 <xQueueGiveMutexRecursive+0x74>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
 2004654:	e03ffc15 	stw	zero,-16(fp)

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
 2004658:	e0bffc17 	ldw	r2,-16(fp)
	}
 200465c:	e6ffff04 	addi	sp,fp,-4
 2004660:	dfc00217 	ldw	ra,8(sp)
 2004664:	df000117 	ldw	fp,4(sp)
 2004668:	dc000017 	ldw	r16,0(sp)
 200466c:	dec00304 	addi	sp,sp,12
 2004670:	f800283a 	ret

02004674 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
 2004674:	defff904 	addi	sp,sp,-28
 2004678:	dfc00615 	stw	ra,24(sp)
 200467c:	df000515 	stw	fp,20(sp)
 2004680:	dc000415 	stw	r16,16(sp)
 2004684:	df000504 	addi	fp,sp,20
 2004688:	e13ffd15 	stw	r4,-12(fp)
 200468c:	e17ffe15 	stw	r5,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 2004690:	e0bffd17 	ldw	r2,-12(fp)
 2004694:	e0bffc15 	stw	r2,-16(fp)
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 2004698:	e0bffc17 	ldw	r2,-16(fp)
 200469c:	14000117 	ldw	r16,4(r2)
 20046a0:	2006c2c0 	call	2006c2c <xTaskGetCurrentTaskHandle>
 20046a4:	8080081e 	bne	r16,r2,20046c8 <xQueueTakeMutexRecursive+0x54>
		{
			( pxMutex->u.uxRecursiveCallCount )++;
 20046a8:	e0bffc17 	ldw	r2,-16(fp)
 20046ac:	10800317 	ldw	r2,12(r2)
 20046b0:	10c00044 	addi	r3,r2,1
 20046b4:	e0bffc17 	ldw	r2,-16(fp)
 20046b8:	10c00315 	stw	r3,12(r2)
			xReturn = pdPASS;
 20046bc:	00800044 	movi	r2,1
 20046c0:	e0bffb15 	stw	r2,-20(fp)
 20046c4:	00000d06 	br	20046fc <xQueueTakeMutexRecursive+0x88>
		}
		else
		{
			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 20046c8:	000f883a 	mov	r7,zero
 20046cc:	e1bffe17 	ldw	r6,-8(fp)
 20046d0:	000b883a 	mov	r5,zero
 20046d4:	e13ffc17 	ldw	r4,-16(fp)
 20046d8:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 20046dc:	e0bffb15 	stw	r2,-20(fp)

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
 20046e0:	e0bffb17 	ldw	r2,-20(fp)
 20046e4:	10000526 	beq	r2,zero,20046fc <xQueueTakeMutexRecursive+0x88>
			{
				( pxMutex->u.uxRecursiveCallCount )++;
 20046e8:	e0bffc17 	ldw	r2,-16(fp)
 20046ec:	10800317 	ldw	r2,12(r2)
 20046f0:	10c00044 	addi	r3,r2,1
 20046f4:	e0bffc17 	ldw	r2,-16(fp)
 20046f8:	10c00315 	stw	r3,12(r2)
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
 20046fc:	e0bffb17 	ldw	r2,-20(fp)
	}
 2004700:	e6ffff04 	addi	sp,fp,-4
 2004704:	dfc00217 	ldw	ra,8(sp)
 2004708:	df000117 	ldw	fp,4(sp)
 200470c:	dc000017 	ldw	r16,0(sp)
 2004710:	dec00304 	addi	sp,sp,12
 2004714:	f800283a 	ret

02004718 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 2004718:	defffb04 	addi	sp,sp,-20
 200471c:	dfc00415 	stw	ra,16(sp)
 2004720:	df000315 	stw	fp,12(sp)
 2004724:	df000304 	addi	fp,sp,12
 2004728:	e13ffe15 	stw	r4,-8(fp)
 200472c:	e17fff15 	stw	r5,-4(fp)
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 2004730:	01800084 	movi	r6,2
 2004734:	000b883a 	mov	r5,zero
 2004738:	e13ffe17 	ldw	r4,-8(fp)
 200473c:	20044040 	call	2004404 <xQueueGenericCreate>
 2004740:	e0bffd15 	stw	r2,-12(fp)

		if( xHandle != NULL )
 2004744:	e0bffd17 	ldw	r2,-12(fp)
 2004748:	10000326 	beq	r2,zero,2004758 <xQueueCreateCountingSemaphore+0x40>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 200474c:	e0bffd17 	ldw	r2,-12(fp)
 2004750:	e0ffff17 	ldw	r3,-4(fp)
 2004754:	10c00e15 	stw	r3,56(r2)
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
 2004758:	e0bffd17 	ldw	r2,-12(fp)
	}
 200475c:	e037883a 	mov	sp,fp
 2004760:	dfc00117 	ldw	ra,4(sp)
 2004764:	df000017 	ldw	fp,0(sp)
 2004768:	dec00204 	addi	sp,sp,8
 200476c:	f800283a 	ret

02004770 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 2004770:	defff504 	addi	sp,sp,-44
 2004774:	dfc00a15 	stw	ra,40(sp)
 2004778:	df000915 	stw	fp,36(sp)
 200477c:	df000904 	addi	fp,sp,36
 2004780:	e13ffc15 	stw	r4,-16(fp)
 2004784:	e17ffd15 	stw	r5,-12(fp)
 2004788:	e1bffe15 	stw	r6,-8(fp)
 200478c:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 2004790:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2004794:	e0bffc17 	ldw	r2,-16(fp)
 2004798:	e0bff815 	stw	r2,-32(fp)
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 200479c:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 20047a0:	e0bff817 	ldw	r2,-32(fp)
 20047a4:	10c00e17 	ldw	r3,56(r2)
 20047a8:	e0bff817 	ldw	r2,-32(fp)
 20047ac:	10800f17 	ldw	r2,60(r2)
 20047b0:	18800336 	bltu	r3,r2,20047c0 <xQueueGenericSend+0x50>
 20047b4:	e0bfff17 	ldw	r2,-4(fp)
 20047b8:	10800098 	cmpnei	r2,r2,2
 20047bc:	1000151e 	bne	r2,zero,2004814 <xQueueGenericSend+0xa4>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 20047c0:	e1bfff17 	ldw	r6,-4(fp)
 20047c4:	e17ffd17 	ldw	r5,-12(fp)
 20047c8:	e13ff817 	ldw	r4,-32(fp)
 20047cc:	2004f7c0 	call	2004f7c <prvCopyDataToQueue>
 20047d0:	e0bff915 	stw	r2,-28(fp)
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 20047d4:	e0bff817 	ldw	r2,-32(fp)
 20047d8:	10800917 	ldw	r2,36(r2)
 20047dc:	10000726 	beq	r2,zero,20047fc <xQueueGenericSend+0x8c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 20047e0:	e0bff817 	ldw	r2,-32(fp)
 20047e4:	10800904 	addi	r2,r2,36
 20047e8:	1009883a 	mov	r4,r2
 20047ec:	20066140 	call	2006614 <xTaskRemoveFromEventList>
 20047f0:	10000526 	beq	r2,zero,2004808 <xQueueGenericSend+0x98>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 20047f4:	003b683a 	trap	0
 20047f8:	00000306 	br	2004808 <xQueueGenericSend+0x98>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 20047fc:	e0bff917 	ldw	r2,-28(fp)
 2004800:	10000126 	beq	r2,zero,2004808 <xQueueGenericSend+0x98>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 2004804:	003b683a 	trap	0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 2004808:	2006ef80 	call	2006ef8 <vTaskExitCritical>
				return pdPASS;
 200480c:	00800044 	movi	r2,1
 2004810:	00003f06 	br	2004910 <xQueueGenericSend+0x1a0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 2004814:	e0bffe17 	ldw	r2,-8(fp)
 2004818:	1000031e 	bne	r2,zero,2004828 <xQueueGenericSend+0xb8>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 200481c:	2006ef80 	call	2006ef8 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 2004820:	0005883a 	mov	r2,zero
 2004824:	00003a06 	br	2004910 <xQueueGenericSend+0x1a0>
				}
				else if( xEntryTimeSet == pdFALSE )
 2004828:	e0bff717 	ldw	r2,-36(fp)
 200482c:	1000051e 	bne	r2,zero,2004844 <xQueueGenericSend+0xd4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 2004830:	e0bffa04 	addi	r2,fp,-24
 2004834:	1009883a 	mov	r4,r2
 2004838:	20067f80 	call	20067f8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 200483c:	00800044 	movi	r2,1
 2004840:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 2004844:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 2004848:	20060440 	call	2006044 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 200484c:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
 2004850:	e0bff817 	ldw	r2,-32(fp)
 2004854:	10801103 	ldbu	r2,68(r2)
 2004858:	10803fcc 	andi	r2,r2,255
 200485c:	1080201c 	xori	r2,r2,128
 2004860:	10bfe004 	addi	r2,r2,-128
 2004864:	10bfffd8 	cmpnei	r2,r2,-1
 2004868:	1000021e 	bne	r2,zero,2004874 <xQueueGenericSend+0x104>
 200486c:	e0bff817 	ldw	r2,-32(fp)
 2004870:	10001105 	stb	zero,68(r2)
 2004874:	e0bff817 	ldw	r2,-32(fp)
 2004878:	10801143 	ldbu	r2,69(r2)
 200487c:	10803fcc 	andi	r2,r2,255
 2004880:	1080201c 	xori	r2,r2,128
 2004884:	10bfe004 	addi	r2,r2,-128
 2004888:	10bfffd8 	cmpnei	r2,r2,-1
 200488c:	1000021e 	bne	r2,zero,2004898 <xQueueGenericSend+0x128>
 2004890:	e0bff817 	ldw	r2,-32(fp)
 2004894:	10001145 	stb	zero,69(r2)
 2004898:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 200489c:	e0fffe04 	addi	r3,fp,-8
 20048a0:	e0bffa04 	addi	r2,fp,-24
 20048a4:	180b883a 	mov	r5,r3
 20048a8:	1009883a 	mov	r4,r2
 20048ac:	20068340 	call	2006834 <xTaskCheckForTimeOut>
 20048b0:	1000131e 	bne	r2,zero,2004900 <xQueueGenericSend+0x190>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 20048b4:	e13ff817 	ldw	r4,-32(fp)
 20048b8:	20053280 	call	2005328 <prvIsQueueFull>
 20048bc:	10000c26 	beq	r2,zero,20048f0 <xQueueGenericSend+0x180>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 20048c0:	e0bff817 	ldw	r2,-32(fp)
 20048c4:	10800404 	addi	r2,r2,16
 20048c8:	e0fffe17 	ldw	r3,-8(fp)
 20048cc:	180b883a 	mov	r5,r3
 20048d0:	1009883a 	mov	r4,r2
 20048d4:	20065600 	call	2006560 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 20048d8:	e13ff817 	ldw	r4,-32(fp)
 20048dc:	20051a40 	call	20051a4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 20048e0:	20060700 	call	2006070 <xTaskResumeAll>
 20048e4:	103fad1e 	bne	r2,zero,200479c <__reset+0xfe00379c>
				{
					portYIELD_WITHIN_API();
 20048e8:	003b683a 	trap	0
 20048ec:	003fab06 	br	200479c <__reset+0xfe00379c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 20048f0:	e13ff817 	ldw	r4,-32(fp)
 20048f4:	20051a40 	call	20051a4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 20048f8:	20060700 	call	2006070 <xTaskResumeAll>
 20048fc:	003fa706 	br	200479c <__reset+0xfe00379c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 2004900:	e13ff817 	ldw	r4,-32(fp)
 2004904:	20051a40 	call	20051a4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 2004908:	20060700 	call	2006070 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 200490c:	0005883a 	mov	r2,zero
		}
	}
}
 2004910:	e037883a 	mov	sp,fp
 2004914:	dfc00117 	ldw	ra,4(sp)
 2004918:	df000017 	ldw	fp,0(sp)
 200491c:	dec00204 	addi	sp,sp,8
 2004920:	f800283a 	ret

02004924 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 2004924:	defff604 	addi	sp,sp,-40
 2004928:	dfc00915 	stw	ra,36(sp)
 200492c:	df000815 	stw	fp,32(sp)
 2004930:	df000804 	addi	fp,sp,32
 2004934:	e13ffc15 	stw	r4,-16(fp)
 2004938:	e17ffd15 	stw	r5,-12(fp)
 200493c:	e1bffe15 	stw	r6,-8(fp)
 2004940:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2004944:	e0bffc17 	ldw	r2,-16(fp)
 2004948:	e0bff915 	stw	r2,-28(fp)
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 200494c:	e03ffa15 	stw	zero,-24(fp)
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 2004950:	e0bff917 	ldw	r2,-28(fp)
 2004954:	10c00e17 	ldw	r3,56(r2)
 2004958:	e0bff917 	ldw	r2,-28(fp)
 200495c:	10800f17 	ldw	r2,60(r2)
 2004960:	18800336 	bltu	r3,r2,2004970 <xQueueGenericSendFromISR+0x4c>
 2004964:	e0bfff17 	ldw	r2,-4(fp)
 2004968:	10800098 	cmpnei	r2,r2,2
 200496c:	1000201e 	bne	r2,zero,20049f0 <xQueueGenericSendFromISR+0xcc>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 2004970:	e0bff917 	ldw	r2,-28(fp)
 2004974:	10801143 	ldbu	r2,69(r2)
 2004978:	e0bffb05 	stb	r2,-20(fp)
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 200497c:	e1bfff17 	ldw	r6,-4(fp)
 2004980:	e17ffd17 	ldw	r5,-12(fp)
 2004984:	e13ff917 	ldw	r4,-28(fp)
 2004988:	2004f7c0 	call	2004f7c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 200498c:	e0bffb07 	ldb	r2,-20(fp)
 2004990:	10bfffd8 	cmpnei	r2,r2,-1
 2004994:	10000e1e 	bne	r2,zero,20049d0 <xQueueGenericSendFromISR+0xac>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2004998:	e0bff917 	ldw	r2,-28(fp)
 200499c:	10800917 	ldw	r2,36(r2)
 20049a0:	10001026 	beq	r2,zero,20049e4 <xQueueGenericSendFromISR+0xc0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 20049a4:	e0bff917 	ldw	r2,-28(fp)
 20049a8:	10800904 	addi	r2,r2,36
 20049ac:	1009883a 	mov	r4,r2
 20049b0:	20066140 	call	2006614 <xTaskRemoveFromEventList>
 20049b4:	10000b26 	beq	r2,zero,20049e4 <xQueueGenericSendFromISR+0xc0>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 20049b8:	e0bffe17 	ldw	r2,-8(fp)
 20049bc:	10000926 	beq	r2,zero,20049e4 <xQueueGenericSendFromISR+0xc0>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 20049c0:	e0bffe17 	ldw	r2,-8(fp)
 20049c4:	00c00044 	movi	r3,1
 20049c8:	10c00015 	stw	r3,0(r2)
 20049cc:	00000506 	br	20049e4 <xQueueGenericSendFromISR+0xc0>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 20049d0:	e0bffb03 	ldbu	r2,-20(fp)
 20049d4:	10800044 	addi	r2,r2,1
 20049d8:	1007883a 	mov	r3,r2
 20049dc:	e0bff917 	ldw	r2,-28(fp)
 20049e0:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 20049e4:	00800044 	movi	r2,1
 20049e8:	e0bff815 	stw	r2,-32(fp)
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
 20049ec:	00000106 	br	20049f4 <xQueueGenericSendFromISR+0xd0>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 20049f0:	e03ff815 	stw	zero,-32(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 20049f4:	e0bff817 	ldw	r2,-32(fp)
}
 20049f8:	e037883a 	mov	sp,fp
 20049fc:	dfc00117 	ldw	ra,4(sp)
 2004a00:	df000017 	ldw	fp,0(sp)
 2004a04:	dec00204 	addi	sp,sp,8
 2004a08:	f800283a 	ret

02004a0c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
 2004a0c:	defff704 	addi	sp,sp,-36
 2004a10:	dfc00815 	stw	ra,32(sp)
 2004a14:	df000715 	stw	fp,28(sp)
 2004a18:	df000704 	addi	fp,sp,28
 2004a1c:	e13ffe15 	stw	r4,-8(fp)
 2004a20:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2004a24:	e0bffe17 	ldw	r2,-8(fp)
 2004a28:	e0bffa15 	stw	r2,-24(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2004a2c:	e03ffb15 	stw	zero,-20(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2004a30:	e0bffa17 	ldw	r2,-24(fp)
 2004a34:	10800e17 	ldw	r2,56(r2)
 2004a38:	e0bffc15 	stw	r2,-16(fp)

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
 2004a3c:	e0bffa17 	ldw	r2,-24(fp)
 2004a40:	10800f17 	ldw	r2,60(r2)
 2004a44:	e0fffc17 	ldw	r3,-16(fp)
 2004a48:	1880202e 	bgeu	r3,r2,2004acc <xQueueGiveFromISR+0xc0>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 2004a4c:	e0bffa17 	ldw	r2,-24(fp)
 2004a50:	10801143 	ldbu	r2,69(r2)
 2004a54:	e0bffd05 	stb	r2,-12(fp)
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 2004a58:	e0bffc17 	ldw	r2,-16(fp)
 2004a5c:	10c00044 	addi	r3,r2,1
 2004a60:	e0bffa17 	ldw	r2,-24(fp)
 2004a64:	10c00e15 	stw	r3,56(r2)

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 2004a68:	e0bffd07 	ldb	r2,-12(fp)
 2004a6c:	10bfffd8 	cmpnei	r2,r2,-1
 2004a70:	10000e1e 	bne	r2,zero,2004aac <xQueueGiveFromISR+0xa0>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2004a74:	e0bffa17 	ldw	r2,-24(fp)
 2004a78:	10800917 	ldw	r2,36(r2)
 2004a7c:	10001026 	beq	r2,zero,2004ac0 <xQueueGiveFromISR+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2004a80:	e0bffa17 	ldw	r2,-24(fp)
 2004a84:	10800904 	addi	r2,r2,36
 2004a88:	1009883a 	mov	r4,r2
 2004a8c:	20066140 	call	2006614 <xTaskRemoveFromEventList>
 2004a90:	10000b26 	beq	r2,zero,2004ac0 <xQueueGiveFromISR+0xb4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 2004a94:	e0bfff17 	ldw	r2,-4(fp)
 2004a98:	10000926 	beq	r2,zero,2004ac0 <xQueueGiveFromISR+0xb4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 2004a9c:	e0bfff17 	ldw	r2,-4(fp)
 2004aa0:	00c00044 	movi	r3,1
 2004aa4:	10c00015 	stw	r3,0(r2)
 2004aa8:	00000506 	br	2004ac0 <xQueueGiveFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 2004aac:	e0bffd03 	ldbu	r2,-12(fp)
 2004ab0:	10800044 	addi	r2,r2,1
 2004ab4:	1007883a 	mov	r3,r2
 2004ab8:	e0bffa17 	ldw	r2,-24(fp)
 2004abc:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 2004ac0:	00800044 	movi	r2,1
 2004ac4:	e0bff915 	stw	r2,-28(fp)
 2004ac8:	00000106 	br	2004ad0 <xQueueGiveFromISR+0xc4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 2004acc:	e03ff915 	stw	zero,-28(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 2004ad0:	e0bff917 	ldw	r2,-28(fp)
}
 2004ad4:	e037883a 	mov	sp,fp
 2004ad8:	dfc00117 	ldw	ra,4(sp)
 2004adc:	df000017 	ldw	fp,0(sp)
 2004ae0:	dec00204 	addi	sp,sp,8
 2004ae4:	f800283a 	ret

02004ae8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
 2004ae8:	defff404 	addi	sp,sp,-48
 2004aec:	dfc00b15 	stw	ra,44(sp)
 2004af0:	df000a15 	stw	fp,40(sp)
 2004af4:	df000a04 	addi	fp,sp,40
 2004af8:	e13ffc15 	stw	r4,-16(fp)
 2004afc:	e17ffd15 	stw	r5,-12(fp)
 2004b00:	e1bffe15 	stw	r6,-8(fp)
 2004b04:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 2004b08:	e03ff615 	stw	zero,-40(fp)
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2004b0c:	e0bffc17 	ldw	r2,-16(fp)
 2004b10:	e0bff715 	stw	r2,-36(fp)
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 2004b14:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2004b18:	e0bff717 	ldw	r2,-36(fp)
 2004b1c:	10800e17 	ldw	r2,56(r2)
 2004b20:	e0bff815 	stw	r2,-32(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2004b24:	e0bff817 	ldw	r2,-32(fp)
 2004b28:	10002c26 	beq	r2,zero,2004bdc <xQueueGenericReceive+0xf4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 2004b2c:	e0bff717 	ldw	r2,-36(fp)
 2004b30:	10800317 	ldw	r2,12(r2)
 2004b34:	e0bff915 	stw	r2,-28(fp)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 2004b38:	e17ffd17 	ldw	r5,-12(fp)
 2004b3c:	e13ff717 	ldw	r4,-36(fp)
 2004b40:	20051080 	call	2005108 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 2004b44:	e0bfff17 	ldw	r2,-4(fp)
 2004b48:	1000151e 	bne	r2,zero,2004ba0 <xQueueGenericReceive+0xb8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 2004b4c:	e0bff817 	ldw	r2,-32(fp)
 2004b50:	10ffffc4 	addi	r3,r2,-1
 2004b54:	e0bff717 	ldw	r2,-36(fp)
 2004b58:	10c00e15 	stw	r3,56(r2)

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2004b5c:	e0bff717 	ldw	r2,-36(fp)
 2004b60:	10800017 	ldw	r2,0(r2)
 2004b64:	1000041e 	bne	r2,zero,2004b78 <xQueueGenericReceive+0x90>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 2004b68:	2006f9c0 	call	2006f9c <pvTaskIncrementMutexHeldCount>
 2004b6c:	1007883a 	mov	r3,r2
 2004b70:	e0bff717 	ldw	r2,-36(fp)
 2004b74:	10c00115 	stw	r3,4(r2)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2004b78:	e0bff717 	ldw	r2,-36(fp)
 2004b7c:	10800417 	ldw	r2,16(r2)
 2004b80:	10001326 	beq	r2,zero,2004bd0 <xQueueGenericReceive+0xe8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2004b84:	e0bff717 	ldw	r2,-36(fp)
 2004b88:	10800404 	addi	r2,r2,16
 2004b8c:	1009883a 	mov	r4,r2
 2004b90:	20066140 	call	2006614 <xTaskRemoveFromEventList>
 2004b94:	10000e26 	beq	r2,zero,2004bd0 <xQueueGenericReceive+0xe8>
						{
							queueYIELD_IF_USING_PREEMPTION();
 2004b98:	003b683a 	trap	0
 2004b9c:	00000c06 	br	2004bd0 <xQueueGenericReceive+0xe8>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 2004ba0:	e0bff717 	ldw	r2,-36(fp)
 2004ba4:	e0fff917 	ldw	r3,-28(fp)
 2004ba8:	10c00315 	stw	r3,12(r2)

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2004bac:	e0bff717 	ldw	r2,-36(fp)
 2004bb0:	10800917 	ldw	r2,36(r2)
 2004bb4:	10000626 	beq	r2,zero,2004bd0 <xQueueGenericReceive+0xe8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2004bb8:	e0bff717 	ldw	r2,-36(fp)
 2004bbc:	10800904 	addi	r2,r2,36
 2004bc0:	1009883a 	mov	r4,r2
 2004bc4:	20066140 	call	2006614 <xTaskRemoveFromEventList>
 2004bc8:	10000126 	beq	r2,zero,2004bd0 <xQueueGenericReceive+0xe8>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
 2004bcc:	003b683a 	trap	0
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
 2004bd0:	2006ef80 	call	2006ef8 <vTaskExitCritical>
				return pdPASS;
 2004bd4:	00800044 	movi	r2,1
 2004bd8:	00004b06 	br	2004d08 <xQueueGenericReceive+0x220>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 2004bdc:	e0bffe17 	ldw	r2,-8(fp)
 2004be0:	1000031e 	bne	r2,zero,2004bf0 <xQueueGenericReceive+0x108>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 2004be4:	2006ef80 	call	2006ef8 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 2004be8:	0005883a 	mov	r2,zero
 2004bec:	00004606 	br	2004d08 <xQueueGenericReceive+0x220>
				}
				else if( xEntryTimeSet == pdFALSE )
 2004bf0:	e0bff617 	ldw	r2,-40(fp)
 2004bf4:	1000051e 	bne	r2,zero,2004c0c <xQueueGenericReceive+0x124>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 2004bf8:	e0bffa04 	addi	r2,fp,-24
 2004bfc:	1009883a 	mov	r4,r2
 2004c00:	20067f80 	call	20067f8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 2004c04:	00800044 	movi	r2,1
 2004c08:	e0bff615 	stw	r2,-40(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 2004c0c:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 2004c10:	20060440 	call	2006044 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 2004c14:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
 2004c18:	e0bff717 	ldw	r2,-36(fp)
 2004c1c:	10801103 	ldbu	r2,68(r2)
 2004c20:	10803fcc 	andi	r2,r2,255
 2004c24:	1080201c 	xori	r2,r2,128
 2004c28:	10bfe004 	addi	r2,r2,-128
 2004c2c:	10bfffd8 	cmpnei	r2,r2,-1
 2004c30:	1000021e 	bne	r2,zero,2004c3c <xQueueGenericReceive+0x154>
 2004c34:	e0bff717 	ldw	r2,-36(fp)
 2004c38:	10001105 	stb	zero,68(r2)
 2004c3c:	e0bff717 	ldw	r2,-36(fp)
 2004c40:	10801143 	ldbu	r2,69(r2)
 2004c44:	10803fcc 	andi	r2,r2,255
 2004c48:	1080201c 	xori	r2,r2,128
 2004c4c:	10bfe004 	addi	r2,r2,-128
 2004c50:	10bfffd8 	cmpnei	r2,r2,-1
 2004c54:	1000021e 	bne	r2,zero,2004c60 <xQueueGenericReceive+0x178>
 2004c58:	e0bff717 	ldw	r2,-36(fp)
 2004c5c:	10001145 	stb	zero,69(r2)
 2004c60:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 2004c64:	e0fffe04 	addi	r3,fp,-8
 2004c68:	e0bffa04 	addi	r2,fp,-24
 2004c6c:	180b883a 	mov	r5,r3
 2004c70:	1009883a 	mov	r4,r2
 2004c74:	20068340 	call	2006834 <xTaskCheckForTimeOut>
 2004c78:	10001c1e 	bne	r2,zero,2004cec <xQueueGenericReceive+0x204>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2004c7c:	e13ff717 	ldw	r4,-36(fp)
 2004c80:	20052980 	call	2005298 <prvIsQueueEmpty>
 2004c84:	10001526 	beq	r2,zero,2004cdc <xQueueGenericReceive+0x1f4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2004c88:	e0bff717 	ldw	r2,-36(fp)
 2004c8c:	10800017 	ldw	r2,0(r2)
 2004c90:	1000061e 	bne	r2,zero,2004cac <xQueueGenericReceive+0x1c4>
					{
						taskENTER_CRITICAL();
 2004c94:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 2004c98:	e0bff717 	ldw	r2,-36(fp)
 2004c9c:	10800117 	ldw	r2,4(r2)
 2004ca0:	1009883a 	mov	r4,r2
 2004ca4:	2006c540 	call	2006c54 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
 2004ca8:	2006ef80 	call	2006ef8 <vTaskExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2004cac:	e0bff717 	ldw	r2,-36(fp)
 2004cb0:	10800904 	addi	r2,r2,36
 2004cb4:	e0fffe17 	ldw	r3,-8(fp)
 2004cb8:	180b883a 	mov	r5,r3
 2004cbc:	1009883a 	mov	r4,r2
 2004cc0:	20065600 	call	2006560 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 2004cc4:	e13ff717 	ldw	r4,-36(fp)
 2004cc8:	20051a40 	call	20051a4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 2004ccc:	20060700 	call	2006070 <xTaskResumeAll>
 2004cd0:	103f901e 	bne	r2,zero,2004b14 <__reset+0xfe003b14>
				{
					portYIELD_WITHIN_API();
 2004cd4:	003b683a 	trap	0
 2004cd8:	003f8e06 	br	2004b14 <__reset+0xfe003b14>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 2004cdc:	e13ff717 	ldw	r4,-36(fp)
 2004ce0:	20051a40 	call	20051a4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 2004ce4:	20060700 	call	2006070 <xTaskResumeAll>
 2004ce8:	003f8a06 	br	2004b14 <__reset+0xfe003b14>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 2004cec:	e13ff717 	ldw	r4,-36(fp)
 2004cf0:	20051a40 	call	20051a4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 2004cf4:	20060700 	call	2006070 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2004cf8:	e13ff717 	ldw	r4,-36(fp)
 2004cfc:	20052980 	call	2005298 <prvIsQueueEmpty>
 2004d00:	103f8426 	beq	r2,zero,2004b14 <__reset+0xfe003b14>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 2004d04:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
 2004d08:	e037883a 	mov	sp,fp
 2004d0c:	dfc00117 	ldw	ra,4(sp)
 2004d10:	df000017 	ldw	fp,0(sp)
 2004d14:	dec00204 	addi	sp,sp,8
 2004d18:	f800283a 	ret

02004d1c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
 2004d1c:	defff604 	addi	sp,sp,-40
 2004d20:	dfc00915 	stw	ra,36(sp)
 2004d24:	df000815 	stw	fp,32(sp)
 2004d28:	df000804 	addi	fp,sp,32
 2004d2c:	e13ffd15 	stw	r4,-12(fp)
 2004d30:	e17ffe15 	stw	r5,-8(fp)
 2004d34:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2004d38:	e0bffd17 	ldw	r2,-12(fp)
 2004d3c:	e0bff915 	stw	r2,-28(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2004d40:	e03ffa15 	stw	zero,-24(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2004d44:	e0bff917 	ldw	r2,-28(fp)
 2004d48:	10800e17 	ldw	r2,56(r2)
 2004d4c:	e0bffb15 	stw	r2,-20(fp)

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2004d50:	e0bffb17 	ldw	r2,-20(fp)
 2004d54:	10002326 	beq	r2,zero,2004de4 <xQueueReceiveFromISR+0xc8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
 2004d58:	e0bff917 	ldw	r2,-28(fp)
 2004d5c:	10801103 	ldbu	r2,68(r2)
 2004d60:	e0bffc05 	stb	r2,-16(fp)

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 2004d64:	e17ffe17 	ldw	r5,-8(fp)
 2004d68:	e13ff917 	ldw	r4,-28(fp)
 2004d6c:	20051080 	call	2005108 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 2004d70:	e0bffb17 	ldw	r2,-20(fp)
 2004d74:	10ffffc4 	addi	r3,r2,-1
 2004d78:	e0bff917 	ldw	r2,-28(fp)
 2004d7c:	10c00e15 	stw	r3,56(r2)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
 2004d80:	e0bffc07 	ldb	r2,-16(fp)
 2004d84:	10bfffd8 	cmpnei	r2,r2,-1
 2004d88:	10000e1e 	bne	r2,zero,2004dc4 <xQueueReceiveFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2004d8c:	e0bff917 	ldw	r2,-28(fp)
 2004d90:	10800417 	ldw	r2,16(r2)
 2004d94:	10001026 	beq	r2,zero,2004dd8 <xQueueReceiveFromISR+0xbc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2004d98:	e0bff917 	ldw	r2,-28(fp)
 2004d9c:	10800404 	addi	r2,r2,16
 2004da0:	1009883a 	mov	r4,r2
 2004da4:	20066140 	call	2006614 <xTaskRemoveFromEventList>
 2004da8:	10000b26 	beq	r2,zero,2004dd8 <xQueueReceiveFromISR+0xbc>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 2004dac:	e0bfff17 	ldw	r2,-4(fp)
 2004db0:	10000926 	beq	r2,zero,2004dd8 <xQueueReceiveFromISR+0xbc>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 2004db4:	e0bfff17 	ldw	r2,-4(fp)
 2004db8:	00c00044 	movi	r3,1
 2004dbc:	10c00015 	stw	r3,0(r2)
 2004dc0:	00000506 	br	2004dd8 <xQueueReceiveFromISR+0xbc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 2004dc4:	e0bffc03 	ldbu	r2,-16(fp)
 2004dc8:	10800044 	addi	r2,r2,1
 2004dcc:	1007883a 	mov	r3,r2
 2004dd0:	e0bff917 	ldw	r2,-28(fp)
 2004dd4:	10c01105 	stb	r3,68(r2)
			}

			xReturn = pdPASS;
 2004dd8:	00800044 	movi	r2,1
 2004ddc:	e0bff815 	stw	r2,-32(fp)
 2004de0:	00000106 	br	2004de8 <xQueueReceiveFromISR+0xcc>
		}
		else
		{
			xReturn = pdFAIL;
 2004de4:	e03ff815 	stw	zero,-32(fp)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 2004de8:	e0bff817 	ldw	r2,-32(fp)
}
 2004dec:	e037883a 	mov	sp,fp
 2004df0:	dfc00117 	ldw	ra,4(sp)
 2004df4:	df000017 	ldw	fp,0(sp)
 2004df8:	dec00204 	addi	sp,sp,8
 2004dfc:	f800283a 	ret

02004e00 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
 2004e00:	defff804 	addi	sp,sp,-32
 2004e04:	dfc00715 	stw	ra,28(sp)
 2004e08:	df000615 	stw	fp,24(sp)
 2004e0c:	df000604 	addi	fp,sp,24
 2004e10:	e13ffe15 	stw	r4,-8(fp)
 2004e14:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2004e18:	e0bffe17 	ldw	r2,-8(fp)
 2004e1c:	e0bffb15 	stw	r2,-20(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2004e20:	e03ffc15 	stw	zero,-16(fp)
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2004e24:	e0bffb17 	ldw	r2,-20(fp)
 2004e28:	10800e17 	ldw	r2,56(r2)
 2004e2c:	10000c26 	beq	r2,zero,2004e60 <xQueuePeekFromISR+0x60>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 2004e30:	e0bffb17 	ldw	r2,-20(fp)
 2004e34:	10800317 	ldw	r2,12(r2)
 2004e38:	e0bffd15 	stw	r2,-12(fp)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 2004e3c:	e17fff17 	ldw	r5,-4(fp)
 2004e40:	e13ffb17 	ldw	r4,-20(fp)
 2004e44:	20051080 	call	2005108 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 2004e48:	e0bffb17 	ldw	r2,-20(fp)
 2004e4c:	e0fffd17 	ldw	r3,-12(fp)
 2004e50:	10c00315 	stw	r3,12(r2)

			xReturn = pdPASS;
 2004e54:	00800044 	movi	r2,1
 2004e58:	e0bffa15 	stw	r2,-24(fp)
 2004e5c:	00000106 	br	2004e64 <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
 2004e60:	e03ffa15 	stw	zero,-24(fp)
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 2004e64:	e0bffa17 	ldw	r2,-24(fp)
}
 2004e68:	e037883a 	mov	sp,fp
 2004e6c:	dfc00117 	ldw	ra,4(sp)
 2004e70:	df000017 	ldw	fp,0(sp)
 2004e74:	dec00204 	addi	sp,sp,8
 2004e78:	f800283a 	ret

02004e7c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 2004e7c:	defffc04 	addi	sp,sp,-16
 2004e80:	dfc00315 	stw	ra,12(sp)
 2004e84:	df000215 	stw	fp,8(sp)
 2004e88:	df000204 	addi	fp,sp,8
 2004e8c:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
 2004e90:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 2004e94:	e0bfff17 	ldw	r2,-4(fp)
 2004e98:	10800e17 	ldw	r2,56(r2)
 2004e9c:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 2004ea0:	2006ef80 	call	2006ef8 <vTaskExitCritical>

	return uxReturn;
 2004ea4:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2004ea8:	e037883a 	mov	sp,fp
 2004eac:	dfc00117 	ldw	ra,4(sp)
 2004eb0:	df000017 	ldw	fp,0(sp)
 2004eb4:	dec00204 	addi	sp,sp,8
 2004eb8:	f800283a 	ret

02004ebc <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 2004ebc:	defffb04 	addi	sp,sp,-20
 2004ec0:	dfc00415 	stw	ra,16(sp)
 2004ec4:	df000315 	stw	fp,12(sp)
 2004ec8:	df000304 	addi	fp,sp,12
 2004ecc:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
 2004ed0:	e0bfff17 	ldw	r2,-4(fp)
 2004ed4:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 2004ed8:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 2004edc:	e0bffd17 	ldw	r2,-12(fp)
 2004ee0:	10c00f17 	ldw	r3,60(r2)
 2004ee4:	e0bffd17 	ldw	r2,-12(fp)
 2004ee8:	10800e17 	ldw	r2,56(r2)
 2004eec:	1885c83a 	sub	r2,r3,r2
 2004ef0:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 2004ef4:	2006ef80 	call	2006ef8 <vTaskExitCritical>

	return uxReturn;
 2004ef8:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2004efc:	e037883a 	mov	sp,fp
 2004f00:	dfc00117 	ldw	ra,4(sp)
 2004f04:	df000017 	ldw	fp,0(sp)
 2004f08:	dec00204 	addi	sp,sp,8
 2004f0c:	f800283a 	ret

02004f10 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 2004f10:	defffd04 	addi	sp,sp,-12
 2004f14:	df000215 	stw	fp,8(sp)
 2004f18:	df000204 	addi	fp,sp,8
 2004f1c:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 2004f20:	e0bfff17 	ldw	r2,-4(fp)
 2004f24:	10800e17 	ldw	r2,56(r2)
 2004f28:	e0bffe15 	stw	r2,-8(fp)

	return uxReturn;
 2004f2c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2004f30:	e037883a 	mov	sp,fp
 2004f34:	df000017 	ldw	fp,0(sp)
 2004f38:	dec00104 	addi	sp,sp,4
 2004f3c:	f800283a 	ret

02004f40 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 2004f40:	defffc04 	addi	sp,sp,-16
 2004f44:	dfc00315 	stw	ra,12(sp)
 2004f48:	df000215 	stw	fp,8(sp)
 2004f4c:	df000204 	addi	fp,sp,8
 2004f50:	e13fff15 	stw	r4,-4(fp)
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2004f54:	e0bfff17 	ldw	r2,-4(fp)
 2004f58:	e0bffe15 	stw	r2,-8(fp)

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
 2004f5c:	e13ffe17 	ldw	r4,-8(fp)
 2004f60:	20041580 	call	2004158 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 2004f64:	0001883a 	nop
 2004f68:	e037883a 	mov	sp,fp
 2004f6c:	dfc00117 	ldw	ra,4(sp)
 2004f70:	df000017 	ldw	fp,0(sp)
 2004f74:	dec00204 	addi	sp,sp,8
 2004f78:	f800283a 	ret

02004f7c <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 2004f7c:	defff904 	addi	sp,sp,-28
 2004f80:	dfc00615 	stw	ra,24(sp)
 2004f84:	df000515 	stw	fp,20(sp)
 2004f88:	df000504 	addi	fp,sp,20
 2004f8c:	e13ffd15 	stw	r4,-12(fp)
 2004f90:	e17ffe15 	stw	r5,-8(fp)
 2004f94:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn = pdFALSE;
 2004f98:	e03ffb15 	stw	zero,-20(fp)
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2004f9c:	e0bffd17 	ldw	r2,-12(fp)
 2004fa0:	10800e17 	ldw	r2,56(r2)
 2004fa4:	e0bffc15 	stw	r2,-16(fp)

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 2004fa8:	e0bffd17 	ldw	r2,-12(fp)
 2004fac:	10801017 	ldw	r2,64(r2)
 2004fb0:	10000b1e 	bne	r2,zero,2004fe0 <prvCopyDataToQueue+0x64>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2004fb4:	e0bffd17 	ldw	r2,-12(fp)
 2004fb8:	10800017 	ldw	r2,0(r2)
 2004fbc:	1000481e 	bne	r2,zero,20050e0 <prvCopyDataToQueue+0x164>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 2004fc0:	e0bffd17 	ldw	r2,-12(fp)
 2004fc4:	10800117 	ldw	r2,4(r2)
 2004fc8:	1009883a 	mov	r4,r2
 2004fcc:	2006d9c0 	call	2006d9c <xTaskPriorityDisinherit>
 2004fd0:	e0bffb15 	stw	r2,-20(fp)
				pxQueue->pxMutexHolder = NULL;
 2004fd4:	e0bffd17 	ldw	r2,-12(fp)
 2004fd8:	10000115 	stw	zero,4(r2)
 2004fdc:	00004006 	br	20050e0 <prvCopyDataToQueue+0x164>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 2004fe0:	e0bfff17 	ldw	r2,-4(fp)
 2004fe4:	1000191e 	bne	r2,zero,200504c <prvCopyDataToQueue+0xd0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 2004fe8:	e0bffd17 	ldw	r2,-12(fp)
 2004fec:	10c00217 	ldw	r3,8(r2)
 2004ff0:	e0bffd17 	ldw	r2,-12(fp)
 2004ff4:	10801017 	ldw	r2,64(r2)
 2004ff8:	100d883a 	mov	r6,r2
 2004ffc:	e17ffe17 	ldw	r5,-8(fp)
 2005000:	1809883a 	mov	r4,r3
 2005004:	200af380 	call	200af38 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 2005008:	e0bffd17 	ldw	r2,-12(fp)
 200500c:	10c00217 	ldw	r3,8(r2)
 2005010:	e0bffd17 	ldw	r2,-12(fp)
 2005014:	10801017 	ldw	r2,64(r2)
 2005018:	1887883a 	add	r3,r3,r2
 200501c:	e0bffd17 	ldw	r2,-12(fp)
 2005020:	10c00215 	stw	r3,8(r2)
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 2005024:	e0bffd17 	ldw	r2,-12(fp)
 2005028:	10c00217 	ldw	r3,8(r2)
 200502c:	e0bffd17 	ldw	r2,-12(fp)
 2005030:	10800117 	ldw	r2,4(r2)
 2005034:	18802a36 	bltu	r3,r2,20050e0 <prvCopyDataToQueue+0x164>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 2005038:	e0bffd17 	ldw	r2,-12(fp)
 200503c:	10c00017 	ldw	r3,0(r2)
 2005040:	e0bffd17 	ldw	r2,-12(fp)
 2005044:	10c00215 	stw	r3,8(r2)
 2005048:	00002506 	br	20050e0 <prvCopyDataToQueue+0x164>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 200504c:	e0bffd17 	ldw	r2,-12(fp)
 2005050:	10c00317 	ldw	r3,12(r2)
 2005054:	e0bffd17 	ldw	r2,-12(fp)
 2005058:	10801017 	ldw	r2,64(r2)
 200505c:	100d883a 	mov	r6,r2
 2005060:	e17ffe17 	ldw	r5,-8(fp)
 2005064:	1809883a 	mov	r4,r3
 2005068:	200af380 	call	200af38 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 200506c:	e0bffd17 	ldw	r2,-12(fp)
 2005070:	10c00317 	ldw	r3,12(r2)
 2005074:	e0bffd17 	ldw	r2,-12(fp)
 2005078:	10801017 	ldw	r2,64(r2)
 200507c:	0085c83a 	sub	r2,zero,r2
 2005080:	1887883a 	add	r3,r3,r2
 2005084:	e0bffd17 	ldw	r2,-12(fp)
 2005088:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 200508c:	e0bffd17 	ldw	r2,-12(fp)
 2005090:	10c00317 	ldw	r3,12(r2)
 2005094:	e0bffd17 	ldw	r2,-12(fp)
 2005098:	10800017 	ldw	r2,0(r2)
 200509c:	1880082e 	bgeu	r3,r2,20050c0 <prvCopyDataToQueue+0x144>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 20050a0:	e0bffd17 	ldw	r2,-12(fp)
 20050a4:	10c00117 	ldw	r3,4(r2)
 20050a8:	e0bffd17 	ldw	r2,-12(fp)
 20050ac:	10801017 	ldw	r2,64(r2)
 20050b0:	0085c83a 	sub	r2,zero,r2
 20050b4:	1887883a 	add	r3,r3,r2
 20050b8:	e0bffd17 	ldw	r2,-12(fp)
 20050bc:	10c00315 	stw	r3,12(r2)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 20050c0:	e0bfff17 	ldw	r2,-4(fp)
 20050c4:	10800098 	cmpnei	r2,r2,2
 20050c8:	1000051e 	bne	r2,zero,20050e0 <prvCopyDataToQueue+0x164>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 20050cc:	e0bffc17 	ldw	r2,-16(fp)
 20050d0:	10000326 	beq	r2,zero,20050e0 <prvCopyDataToQueue+0x164>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 20050d4:	e0bffc17 	ldw	r2,-16(fp)
 20050d8:	10bfffc4 	addi	r2,r2,-1
 20050dc:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 20050e0:	e0bffc17 	ldw	r2,-16(fp)
 20050e4:	10c00044 	addi	r3,r2,1
 20050e8:	e0bffd17 	ldw	r2,-12(fp)
 20050ec:	10c00e15 	stw	r3,56(r2)

	return xReturn;
 20050f0:	e0bffb17 	ldw	r2,-20(fp)
}
 20050f4:	e037883a 	mov	sp,fp
 20050f8:	dfc00117 	ldw	ra,4(sp)
 20050fc:	df000017 	ldw	fp,0(sp)
 2005100:	dec00204 	addi	sp,sp,8
 2005104:	f800283a 	ret

02005108 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 2005108:	defffc04 	addi	sp,sp,-16
 200510c:	dfc00315 	stw	ra,12(sp)
 2005110:	df000215 	stw	fp,8(sp)
 2005114:	df000204 	addi	fp,sp,8
 2005118:	e13ffe15 	stw	r4,-8(fp)
 200511c:	e17fff15 	stw	r5,-4(fp)
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 2005120:	e0bffe17 	ldw	r2,-8(fp)
 2005124:	10801017 	ldw	r2,64(r2)
 2005128:	10001826 	beq	r2,zero,200518c <prvCopyDataFromQueue+0x84>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 200512c:	e0bffe17 	ldw	r2,-8(fp)
 2005130:	10c00317 	ldw	r3,12(r2)
 2005134:	e0bffe17 	ldw	r2,-8(fp)
 2005138:	10801017 	ldw	r2,64(r2)
 200513c:	1887883a 	add	r3,r3,r2
 2005140:	e0bffe17 	ldw	r2,-8(fp)
 2005144:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 2005148:	e0bffe17 	ldw	r2,-8(fp)
 200514c:	10c00317 	ldw	r3,12(r2)
 2005150:	e0bffe17 	ldw	r2,-8(fp)
 2005154:	10800117 	ldw	r2,4(r2)
 2005158:	18800436 	bltu	r3,r2,200516c <prvCopyDataFromQueue+0x64>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 200515c:	e0bffe17 	ldw	r2,-8(fp)
 2005160:	10c00017 	ldw	r3,0(r2)
 2005164:	e0bffe17 	ldw	r2,-8(fp)
 2005168:	10c00315 	stw	r3,12(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 200516c:	e0bffe17 	ldw	r2,-8(fp)
 2005170:	10c00317 	ldw	r3,12(r2)
 2005174:	e0bffe17 	ldw	r2,-8(fp)
 2005178:	10801017 	ldw	r2,64(r2)
 200517c:	100d883a 	mov	r6,r2
 2005180:	180b883a 	mov	r5,r3
 2005184:	e13fff17 	ldw	r4,-4(fp)
 2005188:	200af380 	call	200af38 <memcpy>
	}
}
 200518c:	0001883a 	nop
 2005190:	e037883a 	mov	sp,fp
 2005194:	dfc00117 	ldw	ra,4(sp)
 2005198:	df000017 	ldw	fp,0(sp)
 200519c:	dec00204 	addi	sp,sp,8
 20051a0:	f800283a 	ret

020051a4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 20051a4:	defffc04 	addi	sp,sp,-16
 20051a8:	dfc00315 	stw	ra,12(sp)
 20051ac:	df000215 	stw	fp,8(sp)
 20051b0:	df000204 	addi	fp,sp,8
 20051b4:	e13fff15 	stw	r4,-4(fp)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 20051b8:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 20051bc:	e0bfff17 	ldw	r2,-4(fp)
 20051c0:	10801143 	ldbu	r2,69(r2)
 20051c4:	e0bffe05 	stb	r2,-8(fp)

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 20051c8:	00000c06 	br	20051fc <prvUnlockQueue+0x58>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 20051cc:	e0bfff17 	ldw	r2,-4(fp)
 20051d0:	10800917 	ldw	r2,36(r2)
 20051d4:	10000c26 	beq	r2,zero,2005208 <prvUnlockQueue+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 20051d8:	e0bfff17 	ldw	r2,-4(fp)
 20051dc:	10800904 	addi	r2,r2,36
 20051e0:	1009883a 	mov	r4,r2
 20051e4:	20066140 	call	2006614 <xTaskRemoveFromEventList>
 20051e8:	10000126 	beq	r2,zero,20051f0 <prvUnlockQueue+0x4c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 20051ec:	20069100 	call	2006910 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 20051f0:	e0bffe03 	ldbu	r2,-8(fp)
 20051f4:	10bfffc4 	addi	r2,r2,-1
 20051f8:	e0bffe05 	stb	r2,-8(fp)
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 20051fc:	e0bffe07 	ldb	r2,-8(fp)
 2005200:	00bff216 	blt	zero,r2,20051cc <__reset+0xfe0041cc>
 2005204:	00000106 	br	200520c <prvUnlockQueue+0x68>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
 2005208:	0001883a 	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 200520c:	e0bfff17 	ldw	r2,-4(fp)
 2005210:	00ffffc4 	movi	r3,-1
 2005214:	10c01145 	stb	r3,69(r2)
	}
	taskEXIT_CRITICAL();
 2005218:	2006ef80 	call	2006ef8 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 200521c:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 2005220:	e0bfff17 	ldw	r2,-4(fp)
 2005224:	10801103 	ldbu	r2,68(r2)
 2005228:	e0bffe45 	stb	r2,-7(fp)

		while( cRxLock > queueLOCKED_UNMODIFIED )
 200522c:	00000c06 	br	2005260 <prvUnlockQueue+0xbc>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2005230:	e0bfff17 	ldw	r2,-4(fp)
 2005234:	10800417 	ldw	r2,16(r2)
 2005238:	10000c26 	beq	r2,zero,200526c <prvUnlockQueue+0xc8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 200523c:	e0bfff17 	ldw	r2,-4(fp)
 2005240:	10800404 	addi	r2,r2,16
 2005244:	1009883a 	mov	r4,r2
 2005248:	20066140 	call	2006614 <xTaskRemoveFromEventList>
 200524c:	10000126 	beq	r2,zero,2005254 <prvUnlockQueue+0xb0>
				{
					vTaskMissedYield();
 2005250:	20069100 	call	2006910 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 2005254:	e0bffe43 	ldbu	r2,-7(fp)
 2005258:	10bfffc4 	addi	r2,r2,-1
 200525c:	e0bffe45 	stb	r2,-7(fp)
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
 2005260:	e0bffe47 	ldb	r2,-7(fp)
 2005264:	00bff216 	blt	zero,r2,2005230 <__reset+0xfe004230>
 2005268:	00000106 	br	2005270 <prvUnlockQueue+0xcc>

				--cRxLock;
			}
			else
			{
				break;
 200526c:	0001883a 	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 2005270:	e0bfff17 	ldw	r2,-4(fp)
 2005274:	00ffffc4 	movi	r3,-1
 2005278:	10c01105 	stb	r3,68(r2)
	}
	taskEXIT_CRITICAL();
 200527c:	2006ef80 	call	2006ef8 <vTaskExitCritical>
}
 2005280:	0001883a 	nop
 2005284:	e037883a 	mov	sp,fp
 2005288:	dfc00117 	ldw	ra,4(sp)
 200528c:	df000017 	ldw	fp,0(sp)
 2005290:	dec00204 	addi	sp,sp,8
 2005294:	f800283a 	ret

02005298 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 2005298:	defffc04 	addi	sp,sp,-16
 200529c:	dfc00315 	stw	ra,12(sp)
 20052a0:	df000215 	stw	fp,8(sp)
 20052a4:	df000204 	addi	fp,sp,8
 20052a8:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 20052ac:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 20052b0:	e0bfff17 	ldw	r2,-4(fp)
 20052b4:	10800e17 	ldw	r2,56(r2)
 20052b8:	1000031e 	bne	r2,zero,20052c8 <prvIsQueueEmpty+0x30>
		{
			xReturn = pdTRUE;
 20052bc:	00800044 	movi	r2,1
 20052c0:	e0bffe15 	stw	r2,-8(fp)
 20052c4:	00000106 	br	20052cc <prvIsQueueEmpty+0x34>
		}
		else
		{
			xReturn = pdFALSE;
 20052c8:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 20052cc:	2006ef80 	call	2006ef8 <vTaskExitCritical>

	return xReturn;
 20052d0:	e0bffe17 	ldw	r2,-8(fp)
}
 20052d4:	e037883a 	mov	sp,fp
 20052d8:	dfc00117 	ldw	ra,4(sp)
 20052dc:	df000017 	ldw	fp,0(sp)
 20052e0:	dec00204 	addi	sp,sp,8
 20052e4:	f800283a 	ret

020052e8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 20052e8:	defffd04 	addi	sp,sp,-12
 20052ec:	df000215 	stw	fp,8(sp)
 20052f0:	df000204 	addi	fp,sp,8
 20052f4:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 20052f8:	e0bfff17 	ldw	r2,-4(fp)
 20052fc:	10800e17 	ldw	r2,56(r2)
 2005300:	1000031e 	bne	r2,zero,2005310 <xQueueIsQueueEmptyFromISR+0x28>
	{
		xReturn = pdTRUE;
 2005304:	00800044 	movi	r2,1
 2005308:	e0bffe15 	stw	r2,-8(fp)
 200530c:	00000106 	br	2005314 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
 2005310:	e03ffe15 	stw	zero,-8(fp)
	}

	return xReturn;
 2005314:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2005318:	e037883a 	mov	sp,fp
 200531c:	df000017 	ldw	fp,0(sp)
 2005320:	dec00104 	addi	sp,sp,4
 2005324:	f800283a 	ret

02005328 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 2005328:	defffc04 	addi	sp,sp,-16
 200532c:	dfc00315 	stw	ra,12(sp)
 2005330:	df000215 	stw	fp,8(sp)
 2005334:	df000204 	addi	fp,sp,8
 2005338:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 200533c:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2005340:	e0bfff17 	ldw	r2,-4(fp)
 2005344:	10c00e17 	ldw	r3,56(r2)
 2005348:	e0bfff17 	ldw	r2,-4(fp)
 200534c:	10800f17 	ldw	r2,60(r2)
 2005350:	1880031e 	bne	r3,r2,2005360 <prvIsQueueFull+0x38>
		{
			xReturn = pdTRUE;
 2005354:	00800044 	movi	r2,1
 2005358:	e0bffe15 	stw	r2,-8(fp)
 200535c:	00000106 	br	2005364 <prvIsQueueFull+0x3c>
		}
		else
		{
			xReturn = pdFALSE;
 2005360:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 2005364:	2006ef80 	call	2006ef8 <vTaskExitCritical>

	return xReturn;
 2005368:	e0bffe17 	ldw	r2,-8(fp)
}
 200536c:	e037883a 	mov	sp,fp
 2005370:	dfc00117 	ldw	ra,4(sp)
 2005374:	df000017 	ldw	fp,0(sp)
 2005378:	dec00204 	addi	sp,sp,8
 200537c:	f800283a 	ret

02005380 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 2005380:	defffd04 	addi	sp,sp,-12
 2005384:	df000215 	stw	fp,8(sp)
 2005388:	df000204 	addi	fp,sp,8
 200538c:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 2005390:	e0bfff17 	ldw	r2,-4(fp)
 2005394:	10c00e17 	ldw	r3,56(r2)
 2005398:	e0bfff17 	ldw	r2,-4(fp)
 200539c:	10800f17 	ldw	r2,60(r2)
 20053a0:	1880031e 	bne	r3,r2,20053b0 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
 20053a4:	00800044 	movi	r2,1
 20053a8:	e0bffe15 	stw	r2,-8(fp)
 20053ac:	00000106 	br	20053b4 <xQueueIsQueueFullFromISR+0x34>
	}
	else
	{
		xReturn = pdFALSE;
 20053b0:	e03ffe15 	stw	zero,-8(fp)
	}

	return xReturn;
 20053b4:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 20053b8:	e037883a 	mov	sp,fp
 20053bc:	df000017 	ldw	fp,0(sp)
 20053c0:	dec00104 	addi	sp,sp,4
 20053c4:	f800283a 	ret

020053c8 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 20053c8:	defff304 	addi	sp,sp,-52
 20053cc:	dfc00c15 	stw	ra,48(sp)
 20053d0:	df000b15 	stw	fp,44(sp)
 20053d4:	df000b04 	addi	fp,sp,44
 20053d8:	e13ffc15 	stw	r4,-16(fp)
 20053dc:	e17ffd15 	stw	r5,-12(fp)
 20053e0:	3005883a 	mov	r2,r6
 20053e4:	e1ffff15 	stw	r7,-4(fp)
 20053e8:	e0bffe0d 	sth	r2,-8(fp)
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 20053ec:	e0bffe0b 	ldhu	r2,-8(fp)
 20053f0:	1085883a 	add	r2,r2,r2
 20053f4:	1085883a 	add	r2,r2,r2
 20053f8:	1009883a 	mov	r4,r2
 20053fc:	2003f840 	call	2003f84 <pvPortMalloc>
 2005400:	e0bffb15 	stw	r2,-20(fp)

			if( pxStack != NULL )
 2005404:	e0bffb17 	ldw	r2,-20(fp)
 2005408:	10000c26 	beq	r2,zero,200543c <xTaskCreate+0x74>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 200540c:	01001404 	movi	r4,80
 2005410:	2003f840 	call	2003f84 <pvPortMalloc>
 2005414:	e0bff915 	stw	r2,-28(fp)

				if( pxNewTCB != NULL )
 2005418:	e0bff917 	ldw	r2,-28(fp)
 200541c:	10000426 	beq	r2,zero,2005430 <xTaskCreate+0x68>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 2005420:	e0bff917 	ldw	r2,-28(fp)
 2005424:	e0fffb17 	ldw	r3,-20(fp)
 2005428:	10c00c15 	stw	r3,48(r2)
 200542c:	00000406 	br	2005440 <xTaskCreate+0x78>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 2005430:	e13ffb17 	ldw	r4,-20(fp)
 2005434:	20041580 	call	2004158 <vPortFree>
 2005438:	00000106 	br	2005440 <xTaskCreate+0x78>
				}
			}
			else
			{
				pxNewTCB = NULL;
 200543c:	e03ff915 	stw	zero,-28(fp)
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 2005440:	e0bff917 	ldw	r2,-28(fp)
 2005444:	10001226 	beq	r2,zero,2005490 <xTaskCreate+0xc8>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 2005448:	e0fffe0b 	ldhu	r3,-8(fp)
 200544c:	d8000315 	stw	zero,12(sp)
 2005450:	e0bff917 	ldw	r2,-28(fp)
 2005454:	d8800215 	stw	r2,8(sp)
 2005458:	e0800317 	ldw	r2,12(fp)
 200545c:	d8800115 	stw	r2,4(sp)
 2005460:	e0800217 	ldw	r2,8(fp)
 2005464:	d8800015 	stw	r2,0(sp)
 2005468:	e1ffff17 	ldw	r7,-4(fp)
 200546c:	180d883a 	mov	r6,r3
 2005470:	e17ffd17 	ldw	r5,-12(fp)
 2005474:	e13ffc17 	ldw	r4,-16(fp)
 2005478:	20054b00 	call	20054b0 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 200547c:	e13ff917 	ldw	r4,-28(fp)
 2005480:	20056800 	call	2005680 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 2005484:	00800044 	movi	r2,1
 2005488:	e0bffa15 	stw	r2,-24(fp)
 200548c:	00000206 	br	2005498 <xTaskCreate+0xd0>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 2005490:	00bfffc4 	movi	r2,-1
 2005494:	e0bffa15 	stw	r2,-24(fp)
		}

		return xReturn;
 2005498:	e0bffa17 	ldw	r2,-24(fp)
	}
 200549c:	e037883a 	mov	sp,fp
 20054a0:	dfc00117 	ldw	ra,4(sp)
 20054a4:	df000017 	ldw	fp,0(sp)
 20054a8:	dec00204 	addi	sp,sp,8
 20054ac:	f800283a 	ret

020054b0 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 20054b0:	defff804 	addi	sp,sp,-32
 20054b4:	dfc00715 	stw	ra,28(sp)
 20054b8:	df000615 	stw	fp,24(sp)
 20054bc:	df000604 	addi	fp,sp,24
 20054c0:	e13ffc15 	stw	r4,-16(fp)
 20054c4:	e17ffd15 	stw	r5,-12(fp)
 20054c8:	e1bffe15 	stw	r6,-8(fp)
 20054cc:	e1ffff15 	stw	r7,-4(fp)

	/* Avoid dependency on memset() if it is not required. */
	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 20054d0:	e0800417 	ldw	r2,16(fp)
 20054d4:	10c00c17 	ldw	r3,48(r2)
 20054d8:	e0bffe17 	ldw	r2,-8(fp)
 20054dc:	1085883a 	add	r2,r2,r2
 20054e0:	1085883a 	add	r2,r2,r2
 20054e4:	100d883a 	mov	r6,r2
 20054e8:	01402944 	movi	r5,165
 20054ec:	1809883a 	mov	r4,r3
 20054f0:	200b0800 	call	200b080 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 20054f4:	e0800417 	ldw	r2,16(fp)
 20054f8:	10c00c17 	ldw	r3,48(r2)
 20054fc:	e13ffe17 	ldw	r4,-8(fp)
 2005500:	00900034 	movhi	r2,16384
 2005504:	10bfffc4 	addi	r2,r2,-1
 2005508:	2085883a 	add	r2,r4,r2
 200550c:	1085883a 	add	r2,r2,r2
 2005510:	1085883a 	add	r2,r2,r2
 2005514:	1885883a 	add	r2,r3,r2
 2005518:	e0bffb15 	stw	r2,-20(fp)
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 200551c:	e0fffb17 	ldw	r3,-20(fp)
 2005520:	00bfff04 	movi	r2,-4
 2005524:	1884703a 	and	r2,r3,r2
 2005528:	e0bffb15 	stw	r2,-20(fp)
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 200552c:	e03ffa15 	stw	zero,-24(fp)
 2005530:	00001406 	br	2005584 <prvInitialiseNewTask+0xd4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 2005534:	e0fffd17 	ldw	r3,-12(fp)
 2005538:	e0bffa17 	ldw	r2,-24(fp)
 200553c:	1885883a 	add	r2,r3,r2
 2005540:	10c00003 	ldbu	r3,0(r2)
 2005544:	e1000417 	ldw	r4,16(fp)
 2005548:	e0bffa17 	ldw	r2,-24(fp)
 200554c:	2085883a 	add	r2,r4,r2
 2005550:	10800d04 	addi	r2,r2,52
 2005554:	10c00005 	stb	r3,0(r2)

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 2005558:	e0fffd17 	ldw	r3,-12(fp)
 200555c:	e0bffa17 	ldw	r2,-24(fp)
 2005560:	1885883a 	add	r2,r3,r2
 2005564:	10800003 	ldbu	r2,0(r2)
 2005568:	10803fcc 	andi	r2,r2,255
 200556c:	1080201c 	xori	r2,r2,128
 2005570:	10bfe004 	addi	r2,r2,-128
 2005574:	10000726 	beq	r2,zero,2005594 <prvInitialiseNewTask+0xe4>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 2005578:	e0bffa17 	ldw	r2,-24(fp)
 200557c:	10800044 	addi	r2,r2,1
 2005580:	e0bffa15 	stw	r2,-24(fp)
 2005584:	e0bffa17 	ldw	r2,-24(fp)
 2005588:	10800230 	cmpltui	r2,r2,8
 200558c:	103fe91e 	bne	r2,zero,2005534 <__reset+0xfe004534>
 2005590:	00000106 	br	2005598 <prvInitialiseNewTask+0xe8>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
 2005594:	0001883a 	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 2005598:	e0800417 	ldw	r2,16(fp)
 200559c:	10000ec5 	stb	zero,59(r2)

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 20055a0:	e0800217 	ldw	r2,8(fp)
 20055a4:	10800170 	cmpltui	r2,r2,5
 20055a8:	1000021e 	bne	r2,zero,20055b4 <prvInitialiseNewTask+0x104>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 20055ac:	00800104 	movi	r2,4
 20055b0:	e0800215 	stw	r2,8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 20055b4:	e0800417 	ldw	r2,16(fp)
 20055b8:	e0c00217 	ldw	r3,8(fp)
 20055bc:	10c00b15 	stw	r3,44(r2)
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 20055c0:	e0800417 	ldw	r2,16(fp)
 20055c4:	e0c00217 	ldw	r3,8(fp)
 20055c8:	10c01015 	stw	r3,64(r2)
		pxNewTCB->uxMutexesHeld = 0;
 20055cc:	e0800417 	ldw	r2,16(fp)
 20055d0:	10001115 	stw	zero,68(r2)
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 20055d4:	e0800417 	ldw	r2,16(fp)
 20055d8:	10800104 	addi	r2,r2,4
 20055dc:	1009883a 	mov	r4,r2
 20055e0:	20038c40 	call	20038c4 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 20055e4:	e0800417 	ldw	r2,16(fp)
 20055e8:	10800604 	addi	r2,r2,24
 20055ec:	1009883a 	mov	r4,r2
 20055f0:	20038c40 	call	20038c4 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 20055f4:	e0800417 	ldw	r2,16(fp)
 20055f8:	e0c00417 	ldw	r3,16(fp)
 20055fc:	10c00415 	stw	r3,16(r2)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2005600:	00c00144 	movi	r3,5
 2005604:	e0800217 	ldw	r2,8(fp)
 2005608:	1887c83a 	sub	r3,r3,r2
 200560c:	e0800417 	ldw	r2,16(fp)
 2005610:	10c00615 	stw	r3,24(r2)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 2005614:	e0800417 	ldw	r2,16(fp)
 2005618:	e0c00417 	ldw	r3,16(fp)
 200561c:	10c00915 	stw	r3,36(r2)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 2005620:	e0800417 	ldw	r2,16(fp)
 2005624:	10000f15 	stw	zero,60(r2)
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 2005628:	e0800417 	ldw	r2,16(fp)
 200562c:	10001215 	stw	zero,72(r2)
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 2005630:	e0800417 	ldw	r2,16(fp)
 2005634:	10001305 	stb	zero,76(r2)
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 2005638:	e1bfff17 	ldw	r6,-4(fp)
 200563c:	e17ffc17 	ldw	r5,-16(fp)
 2005640:	e13ffb17 	ldw	r4,-20(fp)
 2005644:	2003b140 	call	2003b14 <pxPortInitialiseStack>
 2005648:	1007883a 	mov	r3,r2
 200564c:	e0800417 	ldw	r2,16(fp)
 2005650:	10c00015 	stw	r3,0(r2)
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
 2005654:	e0800317 	ldw	r2,12(fp)
 2005658:	10000326 	beq	r2,zero,2005668 <prvInitialiseNewTask+0x1b8>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 200565c:	e0800317 	ldw	r2,12(fp)
 2005660:	e0c00417 	ldw	r3,16(fp)
 2005664:	10c00015 	stw	r3,0(r2)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 2005668:	0001883a 	nop
 200566c:	e037883a 	mov	sp,fp
 2005670:	dfc00117 	ldw	ra,4(sp)
 2005674:	df000017 	ldw	fp,0(sp)
 2005678:	dec00204 	addi	sp,sp,8
 200567c:	f800283a 	ret

02005680 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 2005680:	defffd04 	addi	sp,sp,-12
 2005684:	dfc00215 	stw	ra,8(sp)
 2005688:	df000115 	stw	fp,4(sp)
 200568c:	df000104 	addi	fp,sp,4
 2005690:	e13fff15 	stw	r4,-4(fp)
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 2005694:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 2005698:	d0a07217 	ldw	r2,-32312(gp)
 200569c:	10800044 	addi	r2,r2,1
 20056a0:	d0a07215 	stw	r2,-32312(gp)
		if( pxCurrentTCB == NULL )
 20056a4:	d0a06e17 	ldw	r2,-32328(gp)
 20056a8:	1000071e 	bne	r2,zero,20056c8 <prvAddNewTaskToReadyList+0x48>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 20056ac:	e0bfff17 	ldw	r2,-4(fp)
 20056b0:	d0a06e15 	stw	r2,-32328(gp)

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 20056b4:	d0a07217 	ldw	r2,-32312(gp)
 20056b8:	10800058 	cmpnei	r2,r2,1
 20056bc:	10000b1e 	bne	r2,zero,20056ec <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 20056c0:	20069540 	call	2006954 <prvInitialiseTaskLists>
 20056c4:	00000906 	br	20056ec <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 20056c8:	d0a07517 	ldw	r2,-32300(gp)
 20056cc:	1000071e 	bne	r2,zero,20056ec <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 20056d0:	d0a06e17 	ldw	r2,-32328(gp)
 20056d4:	10800b17 	ldw	r2,44(r2)
 20056d8:	e0ffff17 	ldw	r3,-4(fp)
 20056dc:	18c00b17 	ldw	r3,44(r3)
 20056e0:	18800236 	bltu	r3,r2,20056ec <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
 20056e4:	e0bfff17 	ldw	r2,-4(fp)
 20056e8:	d0a06e15 	stw	r2,-32328(gp)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 20056ec:	d0a07917 	ldw	r2,-32284(gp)
 20056f0:	10800044 	addi	r2,r2,1
 20056f4:	d0a07915 	stw	r2,-32284(gp)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 20056f8:	e0bfff17 	ldw	r2,-4(fp)
 20056fc:	10800b17 	ldw	r2,44(r2)
 2005700:	d0e07417 	ldw	r3,-32304(gp)
 2005704:	1880032e 	bgeu	r3,r2,2005714 <prvAddNewTaskToReadyList+0x94>
 2005708:	e0bfff17 	ldw	r2,-4(fp)
 200570c:	10800b17 	ldw	r2,44(r2)
 2005710:	d0a07415 	stw	r2,-32304(gp)
 2005714:	e0bfff17 	ldw	r2,-4(fp)
 2005718:	10800b17 	ldw	r2,44(r2)
 200571c:	01400504 	movi	r5,20
 2005720:	1009883a 	mov	r4,r2
 2005724:	2009bcc0 	call	2009bcc <__mulsi3>
 2005728:	1007883a 	mov	r3,r2
 200572c:	0080a074 	movhi	r2,641
 2005730:	10914304 	addi	r2,r2,17676
 2005734:	1887883a 	add	r3,r3,r2
 2005738:	e0bfff17 	ldw	r2,-4(fp)
 200573c:	10800104 	addi	r2,r2,4
 2005740:	100b883a 	mov	r5,r2
 2005744:	1809883a 	mov	r4,r3
 2005748:	20038f00 	call	20038f0 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 200574c:	2006ef80 	call	2006ef8 <vTaskExitCritical>

	if( xSchedulerRunning != pdFALSE )
 2005750:	d0a07517 	ldw	r2,-32300(gp)
 2005754:	10000626 	beq	r2,zero,2005770 <prvAddNewTaskToReadyList+0xf0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 2005758:	d0a06e17 	ldw	r2,-32328(gp)
 200575c:	10c00b17 	ldw	r3,44(r2)
 2005760:	e0bfff17 	ldw	r2,-4(fp)
 2005764:	10800b17 	ldw	r2,44(r2)
 2005768:	1880012e 	bgeu	r3,r2,2005770 <prvAddNewTaskToReadyList+0xf0>
		{
			taskYIELD_IF_USING_PREEMPTION();
 200576c:	003b683a 	trap	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 2005770:	0001883a 	nop
 2005774:	e037883a 	mov	sp,fp
 2005778:	dfc00117 	ldw	ra,4(sp)
 200577c:	df000017 	ldw	fp,0(sp)
 2005780:	dec00204 	addi	sp,sp,8
 2005784:	f800283a 	ret

02005788 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
 2005788:	defffc04 	addi	sp,sp,-16
 200578c:	dfc00315 	stw	ra,12(sp)
 2005790:	df000215 	stw	fp,8(sp)
 2005794:	df000204 	addi	fp,sp,8
 2005798:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 200579c:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 20057a0:	e0bfff17 	ldw	r2,-4(fp)
 20057a4:	1000021e 	bne	r2,zero,20057b0 <vTaskDelete+0x28>
 20057a8:	d0a06e17 	ldw	r2,-32328(gp)
 20057ac:	00000106 	br	20057b4 <vTaskDelete+0x2c>
 20057b0:	e0bfff17 	ldw	r2,-4(fp)
 20057b4:	e0bffe15 	stw	r2,-8(fp)

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 20057b8:	e0bffe17 	ldw	r2,-8(fp)
 20057bc:	10800104 	addi	r2,r2,4
 20057c0:	1009883a 	mov	r4,r2
 20057c4:	2003a540 	call	2003a54 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 20057c8:	e0bffe17 	ldw	r2,-8(fp)
 20057cc:	10800a17 	ldw	r2,40(r2)
 20057d0:	10000426 	beq	r2,zero,20057e4 <vTaskDelete+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 20057d4:	e0bffe17 	ldw	r2,-8(fp)
 20057d8:	10800604 	addi	r2,r2,24
 20057dc:	1009883a 	mov	r4,r2
 20057e0:	2003a540 	call	2003a54 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
 20057e4:	d0a07917 	ldw	r2,-32284(gp)
 20057e8:	10800044 	addi	r2,r2,1
 20057ec:	d0a07915 	stw	r2,-32284(gp)

			if( pxTCB == pxCurrentTCB )
 20057f0:	d0a06e17 	ldw	r2,-32328(gp)
 20057f4:	e0fffe17 	ldw	r3,-8(fp)
 20057f8:	18800a1e 	bne	r3,r2,2005824 <vTaskDelete+0x9c>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 20057fc:	e0bffe17 	ldw	r2,-8(fp)
 2005800:	10800104 	addi	r2,r2,4
 2005804:	100b883a 	mov	r5,r2
 2005808:	0100a074 	movhi	r4,641
 200580c:	21116b04 	addi	r4,r4,17836
 2005810:	20038f00 	call	20038f0 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
 2005814:	d0a07117 	ldw	r2,-32316(gp)
 2005818:	10800044 	addi	r2,r2,1
 200581c:	d0a07115 	stw	r2,-32316(gp)
 2005820:	00000606 	br	200583c <vTaskDelete+0xb4>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
 2005824:	d0a07217 	ldw	r2,-32312(gp)
 2005828:	10bfffc4 	addi	r2,r2,-1
 200582c:	d0a07215 	stw	r2,-32312(gp)
				prvDeleteTCB( pxTCB );
 2005830:	e13ffe17 	ldw	r4,-8(fp)
 2005834:	2006b800 	call	2006b80 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
 2005838:	2006bc40 	call	2006bc4 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 200583c:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
 2005840:	d0a07517 	ldw	r2,-32300(gp)
 2005844:	10000426 	beq	r2,zero,2005858 <vTaskDelete+0xd0>
		{
			if( pxTCB == pxCurrentTCB )
 2005848:	d0a06e17 	ldw	r2,-32328(gp)
 200584c:	e0fffe17 	ldw	r3,-8(fp)
 2005850:	1880011e 	bne	r3,r2,2005858 <vTaskDelete+0xd0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 2005854:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 2005858:	0001883a 	nop
 200585c:	e037883a 	mov	sp,fp
 2005860:	dfc00117 	ldw	ra,4(sp)
 2005864:	df000017 	ldw	fp,0(sp)
 2005868:	dec00204 	addi	sp,sp,8
 200586c:	f800283a 	ret

02005870 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 2005870:	defff804 	addi	sp,sp,-32
 2005874:	dfc00715 	stw	ra,28(sp)
 2005878:	df000615 	stw	fp,24(sp)
 200587c:	df000604 	addi	fp,sp,24
 2005880:	e13ffe15 	stw	r4,-8(fp)
 2005884:	e17fff15 	stw	r5,-4(fp)
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 2005888:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
 200588c:	20060440 	call	2006044 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 2005890:	d0a07317 	ldw	r2,-32308(gp)
 2005894:	e0bffb15 	stw	r2,-20(fp)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 2005898:	e0bffe17 	ldw	r2,-8(fp)
 200589c:	10c00017 	ldw	r3,0(r2)
 20058a0:	e0bfff17 	ldw	r2,-4(fp)
 20058a4:	1885883a 	add	r2,r3,r2
 20058a8:	e0bffc15 	stw	r2,-16(fp)

			if( xConstTickCount < *pxPreviousWakeTime )
 20058ac:	e0bffe17 	ldw	r2,-8(fp)
 20058b0:	10800017 	ldw	r2,0(r2)
 20058b4:	e0fffb17 	ldw	r3,-20(fp)
 20058b8:	18800a2e 	bgeu	r3,r2,20058e4 <vTaskDelayUntil+0x74>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 20058bc:	e0bffe17 	ldw	r2,-8(fp)
 20058c0:	10800017 	ldw	r2,0(r2)
 20058c4:	e0fffc17 	ldw	r3,-16(fp)
 20058c8:	18800f2e 	bgeu	r3,r2,2005908 <vTaskDelayUntil+0x98>
 20058cc:	e0bffc17 	ldw	r2,-16(fp)
 20058d0:	e0fffb17 	ldw	r3,-20(fp)
 20058d4:	18800c2e 	bgeu	r3,r2,2005908 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 20058d8:	00800044 	movi	r2,1
 20058dc:	e0bffa15 	stw	r2,-24(fp)
 20058e0:	00000906 	br	2005908 <vTaskDelayUntil+0x98>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 20058e4:	e0bffe17 	ldw	r2,-8(fp)
 20058e8:	10800017 	ldw	r2,0(r2)
 20058ec:	e0fffc17 	ldw	r3,-16(fp)
 20058f0:	18800336 	bltu	r3,r2,2005900 <vTaskDelayUntil+0x90>
 20058f4:	e0bffc17 	ldw	r2,-16(fp)
 20058f8:	e0fffb17 	ldw	r3,-20(fp)
 20058fc:	1880022e 	bgeu	r3,r2,2005908 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 2005900:	00800044 	movi	r2,1
 2005904:	e0bffa15 	stw	r2,-24(fp)
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 2005908:	e0bffe17 	ldw	r2,-8(fp)
 200590c:	e0fffc17 	ldw	r3,-16(fp)
 2005910:	10c00015 	stw	r3,0(r2)

			if( xShouldDelay != pdFALSE )
 2005914:	e0bffa17 	ldw	r2,-24(fp)
 2005918:	10000626 	beq	r2,zero,2005934 <vTaskDelayUntil+0xc4>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 200591c:	e0fffc17 	ldw	r3,-16(fp)
 2005920:	e0bffb17 	ldw	r2,-20(fp)
 2005924:	1885c83a 	sub	r2,r3,r2
 2005928:	000b883a 	mov	r5,zero
 200592c:	1009883a 	mov	r4,r2
 2005930:	20076bc0 	call	20076bc <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 2005934:	20060700 	call	2006070 <xTaskResumeAll>
 2005938:	e0bffd15 	stw	r2,-12(fp)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 200593c:	e0bffd17 	ldw	r2,-12(fp)
 2005940:	1000011e 	bne	r2,zero,2005948 <vTaskDelayUntil+0xd8>
		{
			portYIELD_WITHIN_API();
 2005944:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2005948:	0001883a 	nop
 200594c:	e037883a 	mov	sp,fp
 2005950:	dfc00117 	ldw	ra,4(sp)
 2005954:	df000017 	ldw	fp,0(sp)
 2005958:	dec00204 	addi	sp,sp,8
 200595c:	f800283a 	ret

02005960 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 2005960:	defffc04 	addi	sp,sp,-16
 2005964:	dfc00315 	stw	ra,12(sp)
 2005968:	df000215 	stw	fp,8(sp)
 200596c:	df000204 	addi	fp,sp,8
 2005970:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xAlreadyYielded = pdFALSE;
 2005974:	e03ffe15 	stw	zero,-8(fp)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 2005978:	e0bfff17 	ldw	r2,-4(fp)
 200597c:	10000626 	beq	r2,zero,2005998 <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 2005980:	20060440 	call	2006044 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 2005984:	000b883a 	mov	r5,zero
 2005988:	e13fff17 	ldw	r4,-4(fp)
 200598c:	20076bc0 	call	20076bc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 2005990:	20060700 	call	2006070 <xTaskResumeAll>
 2005994:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 2005998:	e0bffe17 	ldw	r2,-8(fp)
 200599c:	1000011e 	bne	r2,zero,20059a4 <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
 20059a0:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 20059a4:	0001883a 	nop
 20059a8:	e037883a 	mov	sp,fp
 20059ac:	dfc00117 	ldw	ra,4(sp)
 20059b0:	df000017 	ldw	fp,0(sp)
 20059b4:	dec00204 	addi	sp,sp,8
 20059b8:	f800283a 	ret

020059bc <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
 20059bc:	defffb04 	addi	sp,sp,-20
 20059c0:	dfc00415 	stw	ra,16(sp)
 20059c4:	df000315 	stw	fp,12(sp)
 20059c8:	df000304 	addi	fp,sp,12
 20059cc:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
 20059d0:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 20059d4:	e0bfff17 	ldw	r2,-4(fp)
 20059d8:	1000021e 	bne	r2,zero,20059e4 <uxTaskPriorityGet+0x28>
 20059dc:	d0a06e17 	ldw	r2,-32328(gp)
 20059e0:	00000106 	br	20059e8 <uxTaskPriorityGet+0x2c>
 20059e4:	e0bfff17 	ldw	r2,-4(fp)
 20059e8:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 20059ec:	e0bffd17 	ldw	r2,-12(fp)
 20059f0:	10800b17 	ldw	r2,44(r2)
 20059f4:	e0bffe15 	stw	r2,-8(fp)
		}
		taskEXIT_CRITICAL();
 20059f8:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		return uxReturn;
 20059fc:	e0bffe17 	ldw	r2,-8(fp)
	}
 2005a00:	e037883a 	mov	sp,fp
 2005a04:	dfc00117 	ldw	ra,4(sp)
 2005a08:	df000017 	ldw	fp,0(sp)
 2005a0c:	dec00204 	addi	sp,sp,8
 2005a10:	f800283a 	ret

02005a14 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
	{
 2005a14:	defffb04 	addi	sp,sp,-20
 2005a18:	df000415 	stw	fp,16(sp)
 2005a1c:	df000404 	addi	fp,sp,16
 2005a20:	e13fff15 	stw	r4,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 2005a24:	e03ffc15 	stw	zero,-16(fp)
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 2005a28:	e0bfff17 	ldw	r2,-4(fp)
 2005a2c:	1000021e 	bne	r2,zero,2005a38 <uxTaskPriorityGetFromISR+0x24>
 2005a30:	d0a06e17 	ldw	r2,-32328(gp)
 2005a34:	00000106 	br	2005a3c <uxTaskPriorityGetFromISR+0x28>
 2005a38:	e0bfff17 	ldw	r2,-4(fp)
 2005a3c:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 2005a40:	e0bffd17 	ldw	r2,-12(fp)
 2005a44:	10800b17 	ldw	r2,44(r2)
 2005a48:	e0bffe15 	stw	r2,-8(fp)
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
 2005a4c:	e0bffe17 	ldw	r2,-8(fp)
	}
 2005a50:	e037883a 	mov	sp,fp
 2005a54:	df000017 	ldw	fp,0(sp)
 2005a58:	dec00104 	addi	sp,sp,4
 2005a5c:	f800283a 	ret

02005a60 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
 2005a60:	defff704 	addi	sp,sp,-36
 2005a64:	dfc00815 	stw	ra,32(sp)
 2005a68:	df000715 	stw	fp,28(sp)
 2005a6c:	dc000615 	stw	r16,24(sp)
 2005a70:	df000704 	addi	fp,sp,28
 2005a74:	e13ffd15 	stw	r4,-12(fp)
 2005a78:	e17ffe15 	stw	r5,-8(fp)
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
 2005a7c:	e03ff915 	stw	zero,-28(fp)

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 2005a80:	e0bffe17 	ldw	r2,-8(fp)
 2005a84:	10800170 	cmpltui	r2,r2,5
 2005a88:	1000021e 	bne	r2,zero,2005a94 <vTaskPrioritySet+0x34>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 2005a8c:	00800104 	movi	r2,4
 2005a90:	e0bffe15 	stw	r2,-8(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
 2005a94:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
 2005a98:	e0bffd17 	ldw	r2,-12(fp)
 2005a9c:	1000021e 	bne	r2,zero,2005aa8 <vTaskPrioritySet+0x48>
 2005aa0:	d0a06e17 	ldw	r2,-32328(gp)
 2005aa4:	00000106 	br	2005aac <vTaskPrioritySet+0x4c>
 2005aa8:	e0bffd17 	ldw	r2,-12(fp)
 2005aac:	e0bffa15 	stw	r2,-24(fp)

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 2005ab0:	e0bffa17 	ldw	r2,-24(fp)
 2005ab4:	10801017 	ldw	r2,64(r2)
 2005ab8:	e0bffb15 	stw	r2,-20(fp)
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
 2005abc:	e0fffb17 	ldw	r3,-20(fp)
 2005ac0:	e0bffe17 	ldw	r2,-8(fp)
 2005ac4:	18805326 	beq	r3,r2,2005c14 <vTaskPrioritySet+0x1b4>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
 2005ac8:	e0bffe17 	ldw	r2,-8(fp)
 2005acc:	e0fffb17 	ldw	r3,-20(fp)
 2005ad0:	18800a2e 	bgeu	r3,r2,2005afc <vTaskPrioritySet+0x9c>
				{
					if( pxTCB != pxCurrentTCB )
 2005ad4:	d0a06e17 	ldw	r2,-32328(gp)
 2005ad8:	e0fffa17 	ldw	r3,-24(fp)
 2005adc:	18800c26 	beq	r3,r2,2005b10 <vTaskPrioritySet+0xb0>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 2005ae0:	d0a06e17 	ldw	r2,-32328(gp)
 2005ae4:	10800b17 	ldw	r2,44(r2)
 2005ae8:	e0fffe17 	ldw	r3,-8(fp)
 2005aec:	18800836 	bltu	r3,r2,2005b10 <vTaskPrioritySet+0xb0>
						{
							xYieldRequired = pdTRUE;
 2005af0:	00800044 	movi	r2,1
 2005af4:	e0bff915 	stw	r2,-28(fp)
 2005af8:	00000506 	br	2005b10 <vTaskPrioritySet+0xb0>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
 2005afc:	d0a06e17 	ldw	r2,-32328(gp)
 2005b00:	e0fffa17 	ldw	r3,-24(fp)
 2005b04:	1880021e 	bne	r3,r2,2005b10 <vTaskPrioritySet+0xb0>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
 2005b08:	00800044 	movi	r2,1
 2005b0c:	e0bff915 	stw	r2,-28(fp)
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 2005b10:	e0bffa17 	ldw	r2,-24(fp)
 2005b14:	10800b17 	ldw	r2,44(r2)
 2005b18:	e0bffc15 	stw	r2,-16(fp)

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 2005b1c:	e0bffa17 	ldw	r2,-24(fp)
 2005b20:	10c01017 	ldw	r3,64(r2)
 2005b24:	e0bffa17 	ldw	r2,-24(fp)
 2005b28:	10800b17 	ldw	r2,44(r2)
 2005b2c:	1880031e 	bne	r3,r2,2005b3c <vTaskPrioritySet+0xdc>
					{
						pxTCB->uxPriority = uxNewPriority;
 2005b30:	e0bffa17 	ldw	r2,-24(fp)
 2005b34:	e0fffe17 	ldw	r3,-8(fp)
 2005b38:	10c00b15 	stw	r3,44(r2)
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 2005b3c:	e0bffa17 	ldw	r2,-24(fp)
 2005b40:	e0fffe17 	ldw	r3,-8(fp)
 2005b44:	10c01015 	stw	r3,64(r2)
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 2005b48:	e0bffa17 	ldw	r2,-24(fp)
 2005b4c:	10800617 	ldw	r2,24(r2)
 2005b50:	10000516 	blt	r2,zero,2005b68 <vTaskPrioritySet+0x108>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2005b54:	00c00144 	movi	r3,5
 2005b58:	e0bffe17 	ldw	r2,-8(fp)
 2005b5c:	1887c83a 	sub	r3,r3,r2
 2005b60:	e0bffa17 	ldw	r2,-24(fp)
 2005b64:	10c00615 	stw	r3,24(r2)

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 2005b68:	e0bffa17 	ldw	r2,-24(fp)
 2005b6c:	14000517 	ldw	r16,20(r2)
 2005b70:	01400504 	movi	r5,20
 2005b74:	e13ffc17 	ldw	r4,-16(fp)
 2005b78:	2009bcc0 	call	2009bcc <__mulsi3>
 2005b7c:	1007883a 	mov	r3,r2
 2005b80:	0080a074 	movhi	r2,641
 2005b84:	10914304 	addi	r2,r2,17676
 2005b88:	1885883a 	add	r2,r3,r2
 2005b8c:	8080021e 	bne	r16,r2,2005b98 <vTaskPrioritySet+0x138>
 2005b90:	00800044 	movi	r2,1
 2005b94:	00000106 	br	2005b9c <vTaskPrioritySet+0x13c>
 2005b98:	0005883a 	mov	r2,zero
 2005b9c:	10803fcc 	andi	r2,r2,255
 2005ba0:	10001926 	beq	r2,zero,2005c08 <vTaskPrioritySet+0x1a8>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 2005ba4:	e0bffa17 	ldw	r2,-24(fp)
 2005ba8:	10800104 	addi	r2,r2,4
 2005bac:	1009883a 	mov	r4,r2
 2005bb0:	2003a540 	call	2003a54 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
 2005bb4:	e0bffa17 	ldw	r2,-24(fp)
 2005bb8:	10800b17 	ldw	r2,44(r2)
 2005bbc:	d0e07417 	ldw	r3,-32304(gp)
 2005bc0:	1880032e 	bgeu	r3,r2,2005bd0 <vTaskPrioritySet+0x170>
 2005bc4:	e0bffa17 	ldw	r2,-24(fp)
 2005bc8:	10800b17 	ldw	r2,44(r2)
 2005bcc:	d0a07415 	stw	r2,-32304(gp)
 2005bd0:	e0bffa17 	ldw	r2,-24(fp)
 2005bd4:	10800b17 	ldw	r2,44(r2)
 2005bd8:	01400504 	movi	r5,20
 2005bdc:	1009883a 	mov	r4,r2
 2005be0:	2009bcc0 	call	2009bcc <__mulsi3>
 2005be4:	1007883a 	mov	r3,r2
 2005be8:	0080a074 	movhi	r2,641
 2005bec:	10914304 	addi	r2,r2,17676
 2005bf0:	1887883a 	add	r3,r3,r2
 2005bf4:	e0bffa17 	ldw	r2,-24(fp)
 2005bf8:	10800104 	addi	r2,r2,4
 2005bfc:	100b883a 	mov	r5,r2
 2005c00:	1809883a 	mov	r4,r3
 2005c04:	20038f00 	call	20038f0 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
 2005c08:	e0bff917 	ldw	r2,-28(fp)
 2005c0c:	10000126 	beq	r2,zero,2005c14 <vTaskPrioritySet+0x1b4>
				{
					taskYIELD_IF_USING_PREEMPTION();
 2005c10:	003b683a 	trap	0
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
 2005c14:	2006ef80 	call	2006ef8 <vTaskExitCritical>
	}
 2005c18:	0001883a 	nop
 2005c1c:	e6ffff04 	addi	sp,fp,-4
 2005c20:	dfc00217 	ldw	ra,8(sp)
 2005c24:	df000117 	ldw	fp,4(sp)
 2005c28:	dc000017 	ldw	r16,0(sp)
 2005c2c:	dec00304 	addi	sp,sp,12
 2005c30:	f800283a 	ret

02005c34 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 2005c34:	defffc04 	addi	sp,sp,-16
 2005c38:	dfc00315 	stw	ra,12(sp)
 2005c3c:	df000215 	stw	fp,8(sp)
 2005c40:	df000204 	addi	fp,sp,8
 2005c44:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 2005c48:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 2005c4c:	e0bfff17 	ldw	r2,-4(fp)
 2005c50:	1000021e 	bne	r2,zero,2005c5c <vTaskSuspend+0x28>
 2005c54:	d0a06e17 	ldw	r2,-32328(gp)
 2005c58:	00000106 	br	2005c60 <vTaskSuspend+0x2c>
 2005c5c:	e0bfff17 	ldw	r2,-4(fp)
 2005c60:	e0bffe15 	stw	r2,-8(fp)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 2005c64:	e0bffe17 	ldw	r2,-8(fp)
 2005c68:	10800104 	addi	r2,r2,4
 2005c6c:	1009883a 	mov	r4,r2
 2005c70:	2003a540 	call	2003a54 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2005c74:	e0bffe17 	ldw	r2,-8(fp)
 2005c78:	10800a17 	ldw	r2,40(r2)
 2005c7c:	10000426 	beq	r2,zero,2005c90 <vTaskSuspend+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2005c80:	e0bffe17 	ldw	r2,-8(fp)
 2005c84:	10800604 	addi	r2,r2,24
 2005c88:	1009883a 	mov	r4,r2
 2005c8c:	2003a540 	call	2003a54 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 2005c90:	e0bffe17 	ldw	r2,-8(fp)
 2005c94:	10800104 	addi	r2,r2,4
 2005c98:	100b883a 	mov	r5,r2
 2005c9c:	0100a074 	movhi	r4,641
 2005ca0:	21117004 	addi	r4,r4,17856
 2005ca4:	20038f00 	call	20038f0 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
 2005ca8:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		if( xSchedulerRunning != pdFALSE )
 2005cac:	d0a07517 	ldw	r2,-32300(gp)
 2005cb0:	10000326 	beq	r2,zero,2005cc0 <vTaskSuspend+0x8c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
 2005cb4:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
			{
				prvResetNextTaskUnblockTime();
 2005cb8:	2006bc40 	call	2006bc4 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
 2005cbc:	2006ef80 	call	2006ef8 <vTaskExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
 2005cc0:	d0a06e17 	ldw	r2,-32328(gp)
 2005cc4:	e0fffe17 	ldw	r3,-8(fp)
 2005cc8:	18800c1e 	bne	r3,r2,2005cfc <vTaskSuspend+0xc8>
		{
			if( xSchedulerRunning != pdFALSE )
 2005ccc:	d0a07517 	ldw	r2,-32300(gp)
 2005cd0:	10000226 	beq	r2,zero,2005cdc <vTaskSuspend+0xa8>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 2005cd4:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2005cd8:	00000806 	br	2005cfc <vTaskSuspend+0xc8>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 2005cdc:	0080a074 	movhi	r2,641
 2005ce0:	10917004 	addi	r2,r2,17856
 2005ce4:	10c00017 	ldw	r3,0(r2)
 2005ce8:	d0a07217 	ldw	r2,-32312(gp)
 2005cec:	1880021e 	bne	r3,r2,2005cf8 <vTaskSuspend+0xc4>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 2005cf0:	d0206e15 	stw	zero,-32328(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2005cf4:	00000106 	br	2005cfc <vTaskSuspend+0xc8>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
 2005cf8:	20064680 	call	2006468 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2005cfc:	0001883a 	nop
 2005d00:	e037883a 	mov	sp,fp
 2005d04:	dfc00117 	ldw	ra,4(sp)
 2005d08:	df000017 	ldw	fp,0(sp)
 2005d0c:	dec00204 	addi	sp,sp,8
 2005d10:	f800283a 	ret

02005d14 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
 2005d14:	defffc04 	addi	sp,sp,-16
 2005d18:	df000315 	stw	fp,12(sp)
 2005d1c:	df000304 	addi	fp,sp,12
 2005d20:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xReturn = pdFALSE;
 2005d24:	e03ffd15 	stw	zero,-12(fp)
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 2005d28:	e0bfff17 	ldw	r2,-4(fp)
 2005d2c:	e0bffe15 	stw	r2,-8(fp)

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 2005d30:	e0bffe17 	ldw	r2,-8(fp)
 2005d34:	10c00517 	ldw	r3,20(r2)
 2005d38:	0080a074 	movhi	r2,641
 2005d3c:	10917004 	addi	r2,r2,17856
 2005d40:	1880021e 	bne	r3,r2,2005d4c <prvTaskIsTaskSuspended+0x38>
 2005d44:	00800044 	movi	r2,1
 2005d48:	00000106 	br	2005d50 <prvTaskIsTaskSuspended+0x3c>
 2005d4c:	0005883a 	mov	r2,zero
 2005d50:	10803fcc 	andi	r2,r2,255
 2005d54:	10000f26 	beq	r2,zero,2005d94 <prvTaskIsTaskSuspended+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 2005d58:	e0bffe17 	ldw	r2,-8(fp)
 2005d5c:	10c00a17 	ldw	r3,40(r2)
 2005d60:	0080a074 	movhi	r2,641
 2005d64:	10916604 	addi	r2,r2,17816
 2005d68:	18800a26 	beq	r3,r2,2005d94 <prvTaskIsTaskSuspended+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 2005d6c:	e0bffe17 	ldw	r2,-8(fp)
 2005d70:	10800a17 	ldw	r2,40(r2)
 2005d74:	1000021e 	bne	r2,zero,2005d80 <prvTaskIsTaskSuspended+0x6c>
 2005d78:	00800044 	movi	r2,1
 2005d7c:	00000106 	br	2005d84 <prvTaskIsTaskSuspended+0x70>
 2005d80:	0005883a 	mov	r2,zero
 2005d84:	10803fcc 	andi	r2,r2,255
 2005d88:	10000226 	beq	r2,zero,2005d94 <prvTaskIsTaskSuspended+0x80>
				{
					xReturn = pdTRUE;
 2005d8c:	00800044 	movi	r2,1
 2005d90:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 2005d94:	e0bffd17 	ldw	r2,-12(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 2005d98:	e037883a 	mov	sp,fp
 2005d9c:	df000017 	ldw	fp,0(sp)
 2005da0:	dec00104 	addi	sp,sp,4
 2005da4:	f800283a 	ret

02005da8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
 2005da8:	defffc04 	addi	sp,sp,-16
 2005dac:	dfc00315 	stw	ra,12(sp)
 2005db0:	df000215 	stw	fp,8(sp)
 2005db4:	df000204 	addi	fp,sp,8
 2005db8:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 2005dbc:	e0bfff17 	ldw	r2,-4(fp)
 2005dc0:	e0bffe15 	stw	r2,-8(fp)
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 2005dc4:	e0bffe17 	ldw	r2,-8(fp)
 2005dc8:	10002726 	beq	r2,zero,2005e68 <vTaskResume+0xc0>
 2005dcc:	d0a06e17 	ldw	r2,-32328(gp)
 2005dd0:	e0fffe17 	ldw	r3,-8(fp)
 2005dd4:	18802426 	beq	r3,r2,2005e68 <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
 2005dd8:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 2005ddc:	e13ffe17 	ldw	r4,-8(fp)
 2005de0:	2005d140 	call	2005d14 <prvTaskIsTaskSuspended>
 2005de4:	10001f26 	beq	r2,zero,2005e64 <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 2005de8:	e0bffe17 	ldw	r2,-8(fp)
 2005dec:	10800104 	addi	r2,r2,4
 2005df0:	1009883a 	mov	r4,r2
 2005df4:	2003a540 	call	2003a54 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 2005df8:	e0bffe17 	ldw	r2,-8(fp)
 2005dfc:	10800b17 	ldw	r2,44(r2)
 2005e00:	d0e07417 	ldw	r3,-32304(gp)
 2005e04:	1880032e 	bgeu	r3,r2,2005e14 <vTaskResume+0x6c>
 2005e08:	e0bffe17 	ldw	r2,-8(fp)
 2005e0c:	10800b17 	ldw	r2,44(r2)
 2005e10:	d0a07415 	stw	r2,-32304(gp)
 2005e14:	e0bffe17 	ldw	r2,-8(fp)
 2005e18:	10800b17 	ldw	r2,44(r2)
 2005e1c:	01400504 	movi	r5,20
 2005e20:	1009883a 	mov	r4,r2
 2005e24:	2009bcc0 	call	2009bcc <__mulsi3>
 2005e28:	1007883a 	mov	r3,r2
 2005e2c:	0080a074 	movhi	r2,641
 2005e30:	10914304 	addi	r2,r2,17676
 2005e34:	1887883a 	add	r3,r3,r2
 2005e38:	e0bffe17 	ldw	r2,-8(fp)
 2005e3c:	10800104 	addi	r2,r2,4
 2005e40:	100b883a 	mov	r5,r2
 2005e44:	1809883a 	mov	r4,r3
 2005e48:	20038f00 	call	20038f0 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2005e4c:	e0bffe17 	ldw	r2,-8(fp)
 2005e50:	10c00b17 	ldw	r3,44(r2)
 2005e54:	d0a06e17 	ldw	r2,-32328(gp)
 2005e58:	10800b17 	ldw	r2,44(r2)
 2005e5c:	18800136 	bltu	r3,r2,2005e64 <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
 2005e60:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
 2005e64:	2006ef80 	call	2006ef8 <vTaskExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2005e68:	0001883a 	nop
 2005e6c:	e037883a 	mov	sp,fp
 2005e70:	dfc00117 	ldw	ra,4(sp)
 2005e74:	df000017 	ldw	fp,0(sp)
 2005e78:	dec00204 	addi	sp,sp,8
 2005e7c:	f800283a 	ret

02005e80 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
 2005e80:	defffa04 	addi	sp,sp,-24
 2005e84:	dfc00515 	stw	ra,20(sp)
 2005e88:	df000415 	stw	fp,16(sp)
 2005e8c:	df000404 	addi	fp,sp,16
 2005e90:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xYieldRequired = pdFALSE;
 2005e94:	e03ffc15 	stw	zero,-16(fp)
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 2005e98:	e0bfff17 	ldw	r2,-4(fp)
 2005e9c:	e0bffd15 	stw	r2,-12(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2005ea0:	e03ffe15 	stw	zero,-8(fp)
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 2005ea4:	e13ffd17 	ldw	r4,-12(fp)
 2005ea8:	2005d140 	call	2005d14 <prvTaskIsTaskSuspended>
 2005eac:	10002926 	beq	r2,zero,2005f54 <xTaskResumeFromISR+0xd4>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2005eb0:	d0a07c17 	ldw	r2,-32272(gp)
 2005eb4:	1000211e 	bne	r2,zero,2005f3c <xTaskResumeFromISR+0xbc>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2005eb8:	e0bffd17 	ldw	r2,-12(fp)
 2005ebc:	10c00b17 	ldw	r3,44(r2)
 2005ec0:	d0a06e17 	ldw	r2,-32328(gp)
 2005ec4:	10800b17 	ldw	r2,44(r2)
 2005ec8:	18800236 	bltu	r3,r2,2005ed4 <xTaskResumeFromISR+0x54>
					{
						xYieldRequired = pdTRUE;
 2005ecc:	00800044 	movi	r2,1
 2005ed0:	e0bffc15 	stw	r2,-16(fp)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2005ed4:	e0bffd17 	ldw	r2,-12(fp)
 2005ed8:	10800104 	addi	r2,r2,4
 2005edc:	1009883a 	mov	r4,r2
 2005ee0:	2003a540 	call	2003a54 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 2005ee4:	e0bffd17 	ldw	r2,-12(fp)
 2005ee8:	10800b17 	ldw	r2,44(r2)
 2005eec:	d0e07417 	ldw	r3,-32304(gp)
 2005ef0:	1880032e 	bgeu	r3,r2,2005f00 <xTaskResumeFromISR+0x80>
 2005ef4:	e0bffd17 	ldw	r2,-12(fp)
 2005ef8:	10800b17 	ldw	r2,44(r2)
 2005efc:	d0a07415 	stw	r2,-32304(gp)
 2005f00:	e0bffd17 	ldw	r2,-12(fp)
 2005f04:	10800b17 	ldw	r2,44(r2)
 2005f08:	01400504 	movi	r5,20
 2005f0c:	1009883a 	mov	r4,r2
 2005f10:	2009bcc0 	call	2009bcc <__mulsi3>
 2005f14:	1007883a 	mov	r3,r2
 2005f18:	0080a074 	movhi	r2,641
 2005f1c:	10914304 	addi	r2,r2,17676
 2005f20:	1887883a 	add	r3,r3,r2
 2005f24:	e0bffd17 	ldw	r2,-12(fp)
 2005f28:	10800104 	addi	r2,r2,4
 2005f2c:	100b883a 	mov	r5,r2
 2005f30:	1809883a 	mov	r4,r3
 2005f34:	20038f00 	call	20038f0 <vListInsertEnd>
 2005f38:	00000606 	br	2005f54 <xTaskResumeFromISR+0xd4>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 2005f3c:	e0bffd17 	ldw	r2,-12(fp)
 2005f40:	10800604 	addi	r2,r2,24
 2005f44:	100b883a 	mov	r5,r2
 2005f48:	0100a074 	movhi	r4,641
 2005f4c:	21116604 	addi	r4,r4,17816
 2005f50:	20038f00 	call	20038f0 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
 2005f54:	e0bffc17 	ldw	r2,-16(fp)
	}
 2005f58:	e037883a 	mov	sp,fp
 2005f5c:	dfc00117 	ldw	ra,4(sp)
 2005f60:	df000017 	ldw	fp,0(sp)
 2005f64:	dec00204 	addi	sp,sp,8
 2005f68:	f800283a 	ret

02005f6c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 2005f6c:	defffa04 	addi	sp,sp,-24
 2005f70:	dfc00515 	stw	ra,20(sp)
 2005f74:	df000415 	stw	fp,16(sp)
 2005f78:	df000404 	addi	fp,sp,16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 2005f7c:	d0a07b04 	addi	r2,gp,-32276
 2005f80:	d8800115 	stw	r2,4(sp)
 2005f84:	d8000015 	stw	zero,0(sp)
 2005f88:	000f883a 	mov	r7,zero
 2005f8c:	01810004 	movi	r6,1024
 2005f90:	01408074 	movhi	r5,513
 2005f94:	2948bd04 	addi	r5,r5,8948
 2005f98:	01008034 	movhi	r4,512
 2005f9c:	211a4e04 	addi	r4,r4,26936
 2005fa0:	20053c80 	call	20053c8 <xTaskCreate>
 2005fa4:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 2005fa8:	e0bffe17 	ldw	r2,-8(fp)
 2005fac:	10800058 	cmpnei	r2,r2,1
 2005fb0:	10000c1e 	bne	r2,zero,2005fe4 <vTaskStartScheduler+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2005fb4:	0005303a 	rdctl	r2,status
 2005fb8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2005fbc:	e0ffff17 	ldw	r3,-4(fp)
 2005fc0:	00bfff84 	movi	r2,-2
 2005fc4:	1884703a 	and	r2,r3,r2
 2005fc8:	1001703a 	wrctl	status,r2
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 2005fcc:	00bfffc4 	movi	r2,-1
 2005fd0:	d0a07a15 	stw	r2,-32280(gp)
		xSchedulerRunning = pdTRUE;
 2005fd4:	00800044 	movi	r2,1
 2005fd8:	d0a07515 	stw	r2,-32300(gp)
		xTickCount = ( TickType_t ) 0U;
 2005fdc:	d0207315 	stw	zero,-32308(gp)
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 2005fe0:	2003bf40 	call	2003bf4 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 2005fe4:	0001883a 	nop
 2005fe8:	e037883a 	mov	sp,fp
 2005fec:	dfc00117 	ldw	ra,4(sp)
 2005ff0:	df000017 	ldw	fp,0(sp)
 2005ff4:	dec00204 	addi	sp,sp,8
 2005ff8:	f800283a 	ret

02005ffc <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 2005ffc:	defffd04 	addi	sp,sp,-12
 2006000:	dfc00215 	stw	ra,8(sp)
 2006004:	df000115 	stw	fp,4(sp)
 2006008:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 200600c:	0005303a 	rdctl	r2,status
 2006010:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2006014:	e0ffff17 	ldw	r3,-4(fp)
 2006018:	00bfff84 	movi	r2,-2
 200601c:	1884703a 	and	r2,r3,r2
 2006020:	1001703a 	wrctl	status,r2
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
 2006024:	d0207515 	stw	zero,-32300(gp)
	vPortEndScheduler();
 2006028:	2003c2c0 	call	2003c2c <vPortEndScheduler>
}
 200602c:	0001883a 	nop
 2006030:	e037883a 	mov	sp,fp
 2006034:	dfc00117 	ldw	ra,4(sp)
 2006038:	df000017 	ldw	fp,0(sp)
 200603c:	dec00204 	addi	sp,sp,8
 2006040:	f800283a 	ret

02006044 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 2006044:	deffff04 	addi	sp,sp,-4
 2006048:	df000015 	stw	fp,0(sp)
 200604c:	d839883a 	mov	fp,sp
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 2006050:	d0a07c17 	ldw	r2,-32272(gp)
 2006054:	10800044 	addi	r2,r2,1
 2006058:	d0a07c15 	stw	r2,-32272(gp)
}
 200605c:	0001883a 	nop
 2006060:	e037883a 	mov	sp,fp
 2006064:	df000017 	ldw	fp,0(sp)
 2006068:	dec00104 	addi	sp,sp,4
 200606c:	f800283a 	ret

02006070 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 2006070:	defffb04 	addi	sp,sp,-20
 2006074:	dfc00415 	stw	ra,16(sp)
 2006078:	df000315 	stw	fp,12(sp)
 200607c:	df000304 	addi	fp,sp,12
TCB_t *pxTCB = NULL;
 2006080:	e03ffd15 	stw	zero,-12(fp)
BaseType_t xAlreadyYielded = pdFALSE;
 2006084:	e03ffe15 	stw	zero,-8(fp)
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 2006088:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
 200608c:	d0a07c17 	ldw	r2,-32272(gp)
 2006090:	10bfffc4 	addi	r2,r2,-1
 2006094:	d0a07c15 	stw	r2,-32272(gp)

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2006098:	d0a07c17 	ldw	r2,-32272(gp)
 200609c:	1000461e 	bne	r2,zero,20061b8 <xTaskResumeAll+0x148>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 20060a0:	d0a07217 	ldw	r2,-32312(gp)
 20060a4:	10004426 	beq	r2,zero,20061b8 <xTaskResumeAll+0x148>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 20060a8:	00002906 	br	2006150 <xTaskResumeAll+0xe0>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 20060ac:	0080a074 	movhi	r2,641
 20060b0:	10916604 	addi	r2,r2,17816
 20060b4:	10800317 	ldw	r2,12(r2)
 20060b8:	10800317 	ldw	r2,12(r2)
 20060bc:	e0bffd15 	stw	r2,-12(fp)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 20060c0:	e0bffd17 	ldw	r2,-12(fp)
 20060c4:	10800604 	addi	r2,r2,24
 20060c8:	1009883a 	mov	r4,r2
 20060cc:	2003a540 	call	2003a54 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 20060d0:	e0bffd17 	ldw	r2,-12(fp)
 20060d4:	10800104 	addi	r2,r2,4
 20060d8:	1009883a 	mov	r4,r2
 20060dc:	2003a540 	call	2003a54 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 20060e0:	e0bffd17 	ldw	r2,-12(fp)
 20060e4:	10800b17 	ldw	r2,44(r2)
 20060e8:	d0e07417 	ldw	r3,-32304(gp)
 20060ec:	1880032e 	bgeu	r3,r2,20060fc <xTaskResumeAll+0x8c>
 20060f0:	e0bffd17 	ldw	r2,-12(fp)
 20060f4:	10800b17 	ldw	r2,44(r2)
 20060f8:	d0a07415 	stw	r2,-32304(gp)
 20060fc:	e0bffd17 	ldw	r2,-12(fp)
 2006100:	10800b17 	ldw	r2,44(r2)
 2006104:	01400504 	movi	r5,20
 2006108:	1009883a 	mov	r4,r2
 200610c:	2009bcc0 	call	2009bcc <__mulsi3>
 2006110:	1007883a 	mov	r3,r2
 2006114:	0080a074 	movhi	r2,641
 2006118:	10914304 	addi	r2,r2,17676
 200611c:	1887883a 	add	r3,r3,r2
 2006120:	e0bffd17 	ldw	r2,-12(fp)
 2006124:	10800104 	addi	r2,r2,4
 2006128:	100b883a 	mov	r5,r2
 200612c:	1809883a 	mov	r4,r3
 2006130:	20038f00 	call	20038f0 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2006134:	e0bffd17 	ldw	r2,-12(fp)
 2006138:	10c00b17 	ldw	r3,44(r2)
 200613c:	d0a06e17 	ldw	r2,-32328(gp)
 2006140:	10800b17 	ldw	r2,44(r2)
 2006144:	18800236 	bltu	r3,r2,2006150 <xTaskResumeAll+0xe0>
					{
						xYieldPending = pdTRUE;
 2006148:	00800044 	movi	r2,1
 200614c:	d0a07715 	stw	r2,-32292(gp)
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 2006150:	0080a074 	movhi	r2,641
 2006154:	10916604 	addi	r2,r2,17816
 2006158:	10800017 	ldw	r2,0(r2)
 200615c:	103fd31e 	bne	r2,zero,20060ac <__reset+0xfe0050ac>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 2006160:	e0bffd17 	ldw	r2,-12(fp)
 2006164:	10000126 	beq	r2,zero,200616c <xTaskResumeAll+0xfc>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 2006168:	2006bc40 	call	2006bc4 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 200616c:	d0a07617 	ldw	r2,-32296(gp)
 2006170:	e0bfff15 	stw	r2,-4(fp)

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 2006174:	e0bfff17 	ldw	r2,-4(fp)
 2006178:	10000a26 	beq	r2,zero,20061a4 <xTaskResumeAll+0x134>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 200617c:	20062880 	call	2006288 <xTaskIncrementTick>
 2006180:	10000226 	beq	r2,zero,200618c <xTaskResumeAll+0x11c>
							{
								xYieldPending = pdTRUE;
 2006184:	00800044 	movi	r2,1
 2006188:	d0a07715 	stw	r2,-32292(gp)
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
 200618c:	e0bfff17 	ldw	r2,-4(fp)
 2006190:	10bfffc4 	addi	r2,r2,-1
 2006194:	e0bfff15 	stw	r2,-4(fp)
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 2006198:	e0bfff17 	ldw	r2,-4(fp)
 200619c:	103ff71e 	bne	r2,zero,200617c <__reset+0xfe00517c>

						uxPendedTicks = 0;
 20061a0:	d0207615 	stw	zero,-32296(gp)
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 20061a4:	d0a07717 	ldw	r2,-32292(gp)
 20061a8:	10000326 	beq	r2,zero,20061b8 <xTaskResumeAll+0x148>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 20061ac:	00800044 	movi	r2,1
 20061b0:	e0bffe15 	stw	r2,-8(fp)
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 20061b4:	003b683a 	trap	0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 20061b8:	2006ef80 	call	2006ef8 <vTaskExitCritical>

	return xAlreadyYielded;
 20061bc:	e0bffe17 	ldw	r2,-8(fp)
}
 20061c0:	e037883a 	mov	sp,fp
 20061c4:	dfc00117 	ldw	ra,4(sp)
 20061c8:	df000017 	ldw	fp,0(sp)
 20061cc:	dec00204 	addi	sp,sp,8
 20061d0:	f800283a 	ret

020061d4 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 20061d4:	defffe04 	addi	sp,sp,-8
 20061d8:	df000115 	stw	fp,4(sp)
 20061dc:	df000104 	addi	fp,sp,4
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 20061e0:	d0a07317 	ldw	r2,-32308(gp)
 20061e4:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 20061e8:	e0bfff17 	ldw	r2,-4(fp)
}
 20061ec:	e037883a 	mov	sp,fp
 20061f0:	df000017 	ldw	fp,0(sp)
 20061f4:	dec00104 	addi	sp,sp,4
 20061f8:	f800283a 	ret

020061fc <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 20061fc:	defffd04 	addi	sp,sp,-12
 2006200:	df000215 	stw	fp,8(sp)
 2006204:	df000204 	addi	fp,sp,8
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 2006208:	e03ffe15 	stw	zero,-8(fp)
	{
		xReturn = xTickCount;
 200620c:	d0a07317 	ldw	r2,-32308(gp)
 2006210:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 2006214:	e0bfff17 	ldw	r2,-4(fp)
}
 2006218:	e037883a 	mov	sp,fp
 200621c:	df000017 	ldw	fp,0(sp)
 2006220:	dec00104 	addi	sp,sp,4
 2006224:	f800283a 	ret

02006228 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 2006228:	deffff04 	addi	sp,sp,-4
 200622c:	df000015 	stw	fp,0(sp)
 2006230:	d839883a 	mov	fp,sp
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
 2006234:	d0a07217 	ldw	r2,-32312(gp)
}
 2006238:	e037883a 	mov	sp,fp
 200623c:	df000017 	ldw	fp,0(sp)
 2006240:	dec00104 	addi	sp,sp,4
 2006244:	f800283a 	ret

02006248 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 2006248:	defffd04 	addi	sp,sp,-12
 200624c:	df000215 	stw	fp,8(sp)
 2006250:	df000204 	addi	fp,sp,8
 2006254:	e13fff15 	stw	r4,-4(fp)
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 2006258:	e0bfff17 	ldw	r2,-4(fp)
 200625c:	1000021e 	bne	r2,zero,2006268 <pcTaskGetName+0x20>
 2006260:	d0a06e17 	ldw	r2,-32328(gp)
 2006264:	00000106 	br	200626c <pcTaskGetName+0x24>
 2006268:	e0bfff17 	ldw	r2,-4(fp)
 200626c:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
 2006270:	e0bffe17 	ldw	r2,-8(fp)
 2006274:	10800d04 	addi	r2,r2,52
}
 2006278:	e037883a 	mov	sp,fp
 200627c:	df000017 	ldw	fp,0(sp)
 2006280:	dec00104 	addi	sp,sp,4
 2006284:	f800283a 	ret

02006288 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 2006288:	defff804 	addi	sp,sp,-32
 200628c:	dfc00715 	stw	ra,28(sp)
 2006290:	df000615 	stw	fp,24(sp)
 2006294:	dc000515 	stw	r16,20(sp)
 2006298:	df000604 	addi	fp,sp,24
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 200629c:	e03ffa15 	stw	zero,-24(fp)

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 20062a0:	d0a07c17 	ldw	r2,-32272(gp)
 20062a4:	1000621e 	bne	r2,zero,2006430 <xTaskIncrementTick+0x1a8>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
 20062a8:	d0a07317 	ldw	r2,-32308(gp)
 20062ac:	10800044 	addi	r2,r2,1
 20062b0:	e0bffb15 	stw	r2,-20(fp)

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 20062b4:	e0bffb17 	ldw	r2,-20(fp)
 20062b8:	d0a07315 	stw	r2,-32308(gp)

		if( xConstTickCount == ( TickType_t ) 0U )
 20062bc:	e0bffb17 	ldw	r2,-20(fp)
 20062c0:	10000a1e 	bne	r2,zero,20062ec <xTaskIncrementTick+0x64>
		{
			taskSWITCH_DELAYED_LISTS();
 20062c4:	d0a06f17 	ldw	r2,-32324(gp)
 20062c8:	e0bffc15 	stw	r2,-16(fp)
 20062cc:	d0a07017 	ldw	r2,-32320(gp)
 20062d0:	d0a06f15 	stw	r2,-32324(gp)
 20062d4:	e0bffc17 	ldw	r2,-16(fp)
 20062d8:	d0a07015 	stw	r2,-32320(gp)
 20062dc:	d0a07817 	ldw	r2,-32288(gp)
 20062e0:	10800044 	addi	r2,r2,1
 20062e4:	d0a07815 	stw	r2,-32288(gp)
 20062e8:	2006bc40 	call	2006bc4 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 20062ec:	d0a07a17 	ldw	r2,-32280(gp)
 20062f0:	e0fffb17 	ldw	r3,-20(fp)
 20062f4:	18804036 	bltu	r3,r2,20063f8 <xTaskIncrementTick+0x170>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 20062f8:	d0a06f17 	ldw	r2,-32324(gp)
 20062fc:	10800017 	ldw	r2,0(r2)
 2006300:	1000021e 	bne	r2,zero,200630c <xTaskIncrementTick+0x84>
 2006304:	00800044 	movi	r2,1
 2006308:	00000106 	br	2006310 <xTaskIncrementTick+0x88>
 200630c:	0005883a 	mov	r2,zero
 2006310:	10803fcc 	andi	r2,r2,255
 2006314:	10000326 	beq	r2,zero,2006324 <xTaskIncrementTick+0x9c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2006318:	00bfffc4 	movi	r2,-1
 200631c:	d0a07a15 	stw	r2,-32280(gp)
					break;
 2006320:	00003506 	br	20063f8 <xTaskIncrementTick+0x170>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2006324:	d0a06f17 	ldw	r2,-32324(gp)
 2006328:	10800317 	ldw	r2,12(r2)
 200632c:	10800317 	ldw	r2,12(r2)
 2006330:	e0bffd15 	stw	r2,-12(fp)
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 2006334:	e0bffd17 	ldw	r2,-12(fp)
 2006338:	10800117 	ldw	r2,4(r2)
 200633c:	e0bffe15 	stw	r2,-8(fp)

					if( xConstTickCount < xItemValue )
 2006340:	e0fffb17 	ldw	r3,-20(fp)
 2006344:	e0bffe17 	ldw	r2,-8(fp)
 2006348:	1880032e 	bgeu	r3,r2,2006358 <xTaskIncrementTick+0xd0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 200634c:	e0bffe17 	ldw	r2,-8(fp)
 2006350:	d0a07a15 	stw	r2,-32280(gp)
						break;
 2006354:	00002806 	br	20063f8 <xTaskIncrementTick+0x170>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2006358:	e0bffd17 	ldw	r2,-12(fp)
 200635c:	10800104 	addi	r2,r2,4
 2006360:	1009883a 	mov	r4,r2
 2006364:	2003a540 	call	2003a54 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2006368:	e0bffd17 	ldw	r2,-12(fp)
 200636c:	10800a17 	ldw	r2,40(r2)
 2006370:	10000426 	beq	r2,zero,2006384 <xTaskIncrementTick+0xfc>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2006374:	e0bffd17 	ldw	r2,-12(fp)
 2006378:	10800604 	addi	r2,r2,24
 200637c:	1009883a 	mov	r4,r2
 2006380:	2003a540 	call	2003a54 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 2006384:	e0bffd17 	ldw	r2,-12(fp)
 2006388:	10800b17 	ldw	r2,44(r2)
 200638c:	d0e07417 	ldw	r3,-32304(gp)
 2006390:	1880032e 	bgeu	r3,r2,20063a0 <xTaskIncrementTick+0x118>
 2006394:	e0bffd17 	ldw	r2,-12(fp)
 2006398:	10800b17 	ldw	r2,44(r2)
 200639c:	d0a07415 	stw	r2,-32304(gp)
 20063a0:	e0bffd17 	ldw	r2,-12(fp)
 20063a4:	10800b17 	ldw	r2,44(r2)
 20063a8:	01400504 	movi	r5,20
 20063ac:	1009883a 	mov	r4,r2
 20063b0:	2009bcc0 	call	2009bcc <__mulsi3>
 20063b4:	1007883a 	mov	r3,r2
 20063b8:	0080a074 	movhi	r2,641
 20063bc:	10914304 	addi	r2,r2,17676
 20063c0:	1887883a 	add	r3,r3,r2
 20063c4:	e0bffd17 	ldw	r2,-12(fp)
 20063c8:	10800104 	addi	r2,r2,4
 20063cc:	100b883a 	mov	r5,r2
 20063d0:	1809883a 	mov	r4,r3
 20063d4:	20038f00 	call	20038f0 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 20063d8:	e0bffd17 	ldw	r2,-12(fp)
 20063dc:	10c00b17 	ldw	r3,44(r2)
 20063e0:	d0a06e17 	ldw	r2,-32328(gp)
 20063e4:	10800b17 	ldw	r2,44(r2)
 20063e8:	18bfc336 	bltu	r3,r2,20062f8 <__reset+0xfe0052f8>
						{
							xSwitchRequired = pdTRUE;
 20063ec:	00800044 	movi	r2,1
 20063f0:	e0bffa15 	stw	r2,-24(fp)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
 20063f4:	003fc006 	br	20062f8 <__reset+0xfe0052f8>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 20063f8:	d0a06e17 	ldw	r2,-32328(gp)
 20063fc:	10800b17 	ldw	r2,44(r2)
 2006400:	0400a074 	movhi	r16,641
 2006404:	84114304 	addi	r16,r16,17676
 2006408:	01400504 	movi	r5,20
 200640c:	1009883a 	mov	r4,r2
 2006410:	2009bcc0 	call	2009bcc <__mulsi3>
 2006414:	8085883a 	add	r2,r16,r2
 2006418:	10800017 	ldw	r2,0(r2)
 200641c:	108000b0 	cmpltui	r2,r2,2
 2006420:	1000061e 	bne	r2,zero,200643c <xTaskIncrementTick+0x1b4>
			{
				xSwitchRequired = pdTRUE;
 2006424:	00800044 	movi	r2,1
 2006428:	e0bffa15 	stw	r2,-24(fp)
 200642c:	00000306 	br	200643c <xTaskIncrementTick+0x1b4>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 2006430:	d0a07617 	ldw	r2,-32296(gp)
 2006434:	10800044 	addi	r2,r2,1
 2006438:	d0a07615 	stw	r2,-32296(gp)
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 200643c:	d0a07717 	ldw	r2,-32292(gp)
 2006440:	10000226 	beq	r2,zero,200644c <xTaskIncrementTick+0x1c4>
		{
			xSwitchRequired = pdTRUE;
 2006444:	00800044 	movi	r2,1
 2006448:	e0bffa15 	stw	r2,-24(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
 200644c:	e0bffa17 	ldw	r2,-24(fp)
}
 2006450:	e6ffff04 	addi	sp,fp,-4
 2006454:	dfc00217 	ldw	ra,8(sp)
 2006458:	df000117 	ldw	fp,4(sp)
 200645c:	dc000017 	ldw	r16,0(sp)
 2006460:	dec00304 	addi	sp,sp,12
 2006464:	f800283a 	ret

02006468 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 2006468:	defffb04 	addi	sp,sp,-20
 200646c:	dfc00415 	stw	ra,16(sp)
 2006470:	df000315 	stw	fp,12(sp)
 2006474:	dc000215 	stw	r16,8(sp)
 2006478:	df000304 	addi	fp,sp,12
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 200647c:	d0a07c17 	ldw	r2,-32272(gp)
 2006480:	10000326 	beq	r2,zero,2006490 <vTaskSwitchContext+0x28>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 2006484:	00800044 	movi	r2,1
 2006488:	d0a07715 	stw	r2,-32292(gp)
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 200648c:	00002d06 	br	2006544 <vTaskSwitchContext+0xdc>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 2006490:	d0207715 	stw	zero,-32292(gp)
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 2006494:	d0a07417 	ldw	r2,-32304(gp)
 2006498:	e0bffd15 	stw	r2,-12(fp)
 200649c:	00000306 	br	20064ac <vTaskSwitchContext+0x44>
 20064a0:	e0bffd17 	ldw	r2,-12(fp)
 20064a4:	10bfffc4 	addi	r2,r2,-1
 20064a8:	e0bffd15 	stw	r2,-12(fp)
 20064ac:	0400a074 	movhi	r16,641
 20064b0:	84114304 	addi	r16,r16,17676
 20064b4:	e0bffd17 	ldw	r2,-12(fp)
 20064b8:	01400504 	movi	r5,20
 20064bc:	1009883a 	mov	r4,r2
 20064c0:	2009bcc0 	call	2009bcc <__mulsi3>
 20064c4:	8085883a 	add	r2,r16,r2
 20064c8:	10800017 	ldw	r2,0(r2)
 20064cc:	103ff426 	beq	r2,zero,20064a0 <__reset+0xfe0054a0>
 20064d0:	01400504 	movi	r5,20
 20064d4:	e13ffd17 	ldw	r4,-12(fp)
 20064d8:	2009bcc0 	call	2009bcc <__mulsi3>
 20064dc:	1007883a 	mov	r3,r2
 20064e0:	0080a074 	movhi	r2,641
 20064e4:	10914304 	addi	r2,r2,17676
 20064e8:	1885883a 	add	r2,r3,r2
 20064ec:	e0bffe15 	stw	r2,-8(fp)
 20064f0:	e0bffe17 	ldw	r2,-8(fp)
 20064f4:	10800117 	ldw	r2,4(r2)
 20064f8:	10c00117 	ldw	r3,4(r2)
 20064fc:	e0bffe17 	ldw	r2,-8(fp)
 2006500:	10c00115 	stw	r3,4(r2)
 2006504:	e0bffe17 	ldw	r2,-8(fp)
 2006508:	10c00117 	ldw	r3,4(r2)
 200650c:	e0bffe17 	ldw	r2,-8(fp)
 2006510:	10800204 	addi	r2,r2,8
 2006514:	1880051e 	bne	r3,r2,200652c <vTaskSwitchContext+0xc4>
 2006518:	e0bffe17 	ldw	r2,-8(fp)
 200651c:	10800117 	ldw	r2,4(r2)
 2006520:	10c00117 	ldw	r3,4(r2)
 2006524:	e0bffe17 	ldw	r2,-8(fp)
 2006528:	10c00115 	stw	r3,4(r2)
 200652c:	e0bffe17 	ldw	r2,-8(fp)
 2006530:	10800117 	ldw	r2,4(r2)
 2006534:	10800317 	ldw	r2,12(r2)
 2006538:	d0a06e15 	stw	r2,-32328(gp)
 200653c:	e0bffd17 	ldw	r2,-12(fp)
 2006540:	d0a07415 	stw	r2,-32304(gp)
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 2006544:	0001883a 	nop
 2006548:	e6ffff04 	addi	sp,fp,-4
 200654c:	dfc00217 	ldw	ra,8(sp)
 2006550:	df000117 	ldw	fp,4(sp)
 2006554:	dc000017 	ldw	r16,0(sp)
 2006558:	dec00304 	addi	sp,sp,12
 200655c:	f800283a 	ret

02006560 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 2006560:	defffc04 	addi	sp,sp,-16
 2006564:	dfc00315 	stw	ra,12(sp)
 2006568:	df000215 	stw	fp,8(sp)
 200656c:	df000204 	addi	fp,sp,8
 2006570:	e13ffe15 	stw	r4,-8(fp)
 2006574:	e17fff15 	stw	r5,-4(fp)

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2006578:	d0a06e17 	ldw	r2,-32328(gp)
 200657c:	10800604 	addi	r2,r2,24
 2006580:	100b883a 	mov	r5,r2
 2006584:	e13ffe17 	ldw	r4,-8(fp)
 2006588:	200397c0 	call	200397c <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 200658c:	01400044 	movi	r5,1
 2006590:	e13fff17 	ldw	r4,-4(fp)
 2006594:	20076bc0 	call	20076bc <prvAddCurrentTaskToDelayedList>
}
 2006598:	0001883a 	nop
 200659c:	e037883a 	mov	sp,fp
 20065a0:	dfc00117 	ldw	ra,4(sp)
 20065a4:	df000017 	ldw	fp,0(sp)
 20065a8:	dec00204 	addi	sp,sp,8
 20065ac:	f800283a 	ret

020065b0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
 20065b0:	defffb04 	addi	sp,sp,-20
 20065b4:	dfc00415 	stw	ra,16(sp)
 20065b8:	df000315 	stw	fp,12(sp)
 20065bc:	df000304 	addi	fp,sp,12
 20065c0:	e13ffd15 	stw	r4,-12(fp)
 20065c4:	e17ffe15 	stw	r5,-8(fp)
 20065c8:	e1bfff15 	stw	r6,-4(fp)
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 20065cc:	d0a06e17 	ldw	r2,-32328(gp)
 20065d0:	e0fffe17 	ldw	r3,-8(fp)
 20065d4:	18e00034 	orhi	r3,r3,32768
 20065d8:	10c00615 	stw	r3,24(r2)
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 20065dc:	d0a06e17 	ldw	r2,-32328(gp)
 20065e0:	10800604 	addi	r2,r2,24
 20065e4:	100b883a 	mov	r5,r2
 20065e8:	e13ffd17 	ldw	r4,-12(fp)
 20065ec:	20038f00 	call	20038f0 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 20065f0:	01400044 	movi	r5,1
 20065f4:	e13fff17 	ldw	r4,-4(fp)
 20065f8:	20076bc0 	call	20076bc <prvAddCurrentTaskToDelayedList>
}
 20065fc:	0001883a 	nop
 2006600:	e037883a 	mov	sp,fp
 2006604:	dfc00117 	ldw	ra,4(sp)
 2006608:	df000017 	ldw	fp,0(sp)
 200660c:	dec00204 	addi	sp,sp,8
 2006610:	f800283a 	ret

02006614 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 2006614:	defffb04 	addi	sp,sp,-20
 2006618:	dfc00415 	stw	ra,16(sp)
 200661c:	df000315 	stw	fp,12(sp)
 2006620:	df000304 	addi	fp,sp,12
 2006624:	e13fff15 	stw	r4,-4(fp)
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2006628:	e0bfff17 	ldw	r2,-4(fp)
 200662c:	10800317 	ldw	r2,12(r2)
 2006630:	10800317 	ldw	r2,12(r2)
 2006634:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2006638:	e0bffe17 	ldw	r2,-8(fp)
 200663c:	10800604 	addi	r2,r2,24
 2006640:	1009883a 	mov	r4,r2
 2006644:	2003a540 	call	2003a54 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2006648:	d0a07c17 	ldw	r2,-32272(gp)
 200664c:	10001a1e 	bne	r2,zero,20066b8 <xTaskRemoveFromEventList+0xa4>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 2006650:	e0bffe17 	ldw	r2,-8(fp)
 2006654:	10800104 	addi	r2,r2,4
 2006658:	1009883a 	mov	r4,r2
 200665c:	2003a540 	call	2003a54 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 2006660:	e0bffe17 	ldw	r2,-8(fp)
 2006664:	10800b17 	ldw	r2,44(r2)
 2006668:	d0e07417 	ldw	r3,-32304(gp)
 200666c:	1880032e 	bgeu	r3,r2,200667c <xTaskRemoveFromEventList+0x68>
 2006670:	e0bffe17 	ldw	r2,-8(fp)
 2006674:	10800b17 	ldw	r2,44(r2)
 2006678:	d0a07415 	stw	r2,-32304(gp)
 200667c:	e0bffe17 	ldw	r2,-8(fp)
 2006680:	10800b17 	ldw	r2,44(r2)
 2006684:	01400504 	movi	r5,20
 2006688:	1009883a 	mov	r4,r2
 200668c:	2009bcc0 	call	2009bcc <__mulsi3>
 2006690:	1007883a 	mov	r3,r2
 2006694:	0080a074 	movhi	r2,641
 2006698:	10914304 	addi	r2,r2,17676
 200669c:	1887883a 	add	r3,r3,r2
 20066a0:	e0bffe17 	ldw	r2,-8(fp)
 20066a4:	10800104 	addi	r2,r2,4
 20066a8:	100b883a 	mov	r5,r2
 20066ac:	1809883a 	mov	r4,r3
 20066b0:	20038f00 	call	20038f0 <vListInsertEnd>
 20066b4:	00000606 	br	20066d0 <xTaskRemoveFromEventList+0xbc>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 20066b8:	e0bffe17 	ldw	r2,-8(fp)
 20066bc:	10800604 	addi	r2,r2,24
 20066c0:	100b883a 	mov	r5,r2
 20066c4:	0100a074 	movhi	r4,641
 20066c8:	21116604 	addi	r4,r4,17816
 20066cc:	20038f00 	call	20038f0 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 20066d0:	e0bffe17 	ldw	r2,-8(fp)
 20066d4:	10800b17 	ldw	r2,44(r2)
 20066d8:	d0e06e17 	ldw	r3,-32328(gp)
 20066dc:	18c00b17 	ldw	r3,44(r3)
 20066e0:	1880052e 	bgeu	r3,r2,20066f8 <xTaskRemoveFromEventList+0xe4>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 20066e4:	00800044 	movi	r2,1
 20066e8:	e0bffd15 	stw	r2,-12(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 20066ec:	00800044 	movi	r2,1
 20066f0:	d0a07715 	stw	r2,-32292(gp)
 20066f4:	00000106 	br	20066fc <xTaskRemoveFromEventList+0xe8>
	}
	else
	{
		xReturn = pdFALSE;
 20066f8:	e03ffd15 	stw	zero,-12(fp)
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
 20066fc:	e0bffd17 	ldw	r2,-12(fp)
}
 2006700:	e037883a 	mov	sp,fp
 2006704:	dfc00117 	ldw	ra,4(sp)
 2006708:	df000017 	ldw	fp,0(sp)
 200670c:	dec00204 	addi	sp,sp,8
 2006710:	f800283a 	ret

02006714 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
 2006714:	defffa04 	addi	sp,sp,-24
 2006718:	dfc00515 	stw	ra,20(sp)
 200671c:	df000415 	stw	fp,16(sp)
 2006720:	df000404 	addi	fp,sp,16
 2006724:	e13ffe15 	stw	r4,-8(fp)
 2006728:	e17fff15 	stw	r5,-4(fp)
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 200672c:	e0bfff17 	ldw	r2,-4(fp)
 2006730:	10e00034 	orhi	r3,r2,32768
 2006734:	e0bffe17 	ldw	r2,-8(fp)
 2006738:	10c00015 	stw	r3,0(r2)

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 200673c:	e0bffe17 	ldw	r2,-8(fp)
 2006740:	10800317 	ldw	r2,12(r2)
 2006744:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
 2006748:	e13ffe17 	ldw	r4,-8(fp)
 200674c:	2003a540 	call	2003a54 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 2006750:	e0bffd17 	ldw	r2,-12(fp)
 2006754:	10800104 	addi	r2,r2,4
 2006758:	1009883a 	mov	r4,r2
 200675c:	2003a540 	call	2003a54 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 2006760:	e0bffd17 	ldw	r2,-12(fp)
 2006764:	10800b17 	ldw	r2,44(r2)
 2006768:	d0e07417 	ldw	r3,-32304(gp)
 200676c:	1880032e 	bgeu	r3,r2,200677c <xTaskRemoveFromUnorderedEventList+0x68>
 2006770:	e0bffd17 	ldw	r2,-12(fp)
 2006774:	10800b17 	ldw	r2,44(r2)
 2006778:	d0a07415 	stw	r2,-32304(gp)
 200677c:	e0bffd17 	ldw	r2,-12(fp)
 2006780:	10800b17 	ldw	r2,44(r2)
 2006784:	01400504 	movi	r5,20
 2006788:	1009883a 	mov	r4,r2
 200678c:	2009bcc0 	call	2009bcc <__mulsi3>
 2006790:	1007883a 	mov	r3,r2
 2006794:	0080a074 	movhi	r2,641
 2006798:	10914304 	addi	r2,r2,17676
 200679c:	1887883a 	add	r3,r3,r2
 20067a0:	e0bffd17 	ldw	r2,-12(fp)
 20067a4:	10800104 	addi	r2,r2,4
 20067a8:	100b883a 	mov	r5,r2
 20067ac:	1809883a 	mov	r4,r3
 20067b0:	20038f00 	call	20038f0 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 20067b4:	e0bffd17 	ldw	r2,-12(fp)
 20067b8:	10800b17 	ldw	r2,44(r2)
 20067bc:	d0e06e17 	ldw	r3,-32328(gp)
 20067c0:	18c00b17 	ldw	r3,44(r3)
 20067c4:	1880052e 	bgeu	r3,r2,20067dc <xTaskRemoveFromUnorderedEventList+0xc8>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
 20067c8:	00800044 	movi	r2,1
 20067cc:	e0bffc15 	stw	r2,-16(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 20067d0:	00800044 	movi	r2,1
 20067d4:	d0a07715 	stw	r2,-32292(gp)
 20067d8:	00000106 	br	20067e0 <xTaskRemoveFromUnorderedEventList+0xcc>
	}
	else
	{
		xReturn = pdFALSE;
 20067dc:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
 20067e0:	e0bffc17 	ldw	r2,-16(fp)
}
 20067e4:	e037883a 	mov	sp,fp
 20067e8:	dfc00117 	ldw	ra,4(sp)
 20067ec:	df000017 	ldw	fp,0(sp)
 20067f0:	dec00204 	addi	sp,sp,8
 20067f4:	f800283a 	ret

020067f8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 20067f8:	defffe04 	addi	sp,sp,-8
 20067fc:	df000115 	stw	fp,4(sp)
 2006800:	df000104 	addi	fp,sp,4
 2006804:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2006808:	d0e07817 	ldw	r3,-32288(gp)
 200680c:	e0bfff17 	ldw	r2,-4(fp)
 2006810:	10c00015 	stw	r3,0(r2)
	pxTimeOut->xTimeOnEntering = xTickCount;
 2006814:	d0e07317 	ldw	r3,-32308(gp)
 2006818:	e0bfff17 	ldw	r2,-4(fp)
 200681c:	10c00115 	stw	r3,4(r2)
}
 2006820:	0001883a 	nop
 2006824:	e037883a 	mov	sp,fp
 2006828:	df000017 	ldw	fp,0(sp)
 200682c:	dec00104 	addi	sp,sp,4
 2006830:	f800283a 	ret

02006834 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 2006834:	defffa04 	addi	sp,sp,-24
 2006838:	dfc00515 	stw	ra,20(sp)
 200683c:	df000415 	stw	fp,16(sp)
 2006840:	df000404 	addi	fp,sp,16
 2006844:	e13ffe15 	stw	r4,-8(fp)
 2006848:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 200684c:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 2006850:	d0a07317 	ldw	r2,-32308(gp)
 2006854:	e0bffd15 	stw	r2,-12(fp)
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 2006858:	e0bfff17 	ldw	r2,-4(fp)
 200685c:	10800017 	ldw	r2,0(r2)
 2006860:	10bfffd8 	cmpnei	r2,r2,-1
 2006864:	1000021e 	bne	r2,zero,2006870 <xTaskCheckForTimeOut+0x3c>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 2006868:	e03ffc15 	stw	zero,-16(fp)
 200686c:	00002106 	br	20068f4 <xTaskCheckForTimeOut+0xc0>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 2006870:	e0bffe17 	ldw	r2,-8(fp)
 2006874:	10c00017 	ldw	r3,0(r2)
 2006878:	d0a07817 	ldw	r2,-32288(gp)
 200687c:	18800726 	beq	r3,r2,200689c <xTaskCheckForTimeOut+0x68>
 2006880:	e0bffe17 	ldw	r2,-8(fp)
 2006884:	10800117 	ldw	r2,4(r2)
 2006888:	e0fffd17 	ldw	r3,-12(fp)
 200688c:	18800336 	bltu	r3,r2,200689c <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 2006890:	00800044 	movi	r2,1
 2006894:	e0bffc15 	stw	r2,-16(fp)
 2006898:	00001606 	br	20068f4 <xTaskCheckForTimeOut+0xc0>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 200689c:	e0bffe17 	ldw	r2,-8(fp)
 20068a0:	10800117 	ldw	r2,4(r2)
 20068a4:	e0fffd17 	ldw	r3,-12(fp)
 20068a8:	1887c83a 	sub	r3,r3,r2
 20068ac:	e0bfff17 	ldw	r2,-4(fp)
 20068b0:	10800017 	ldw	r2,0(r2)
 20068b4:	18800d2e 	bgeu	r3,r2,20068ec <xTaskCheckForTimeOut+0xb8>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 20068b8:	e0bfff17 	ldw	r2,-4(fp)
 20068bc:	10c00017 	ldw	r3,0(r2)
 20068c0:	e0bffe17 	ldw	r2,-8(fp)
 20068c4:	11000117 	ldw	r4,4(r2)
 20068c8:	e0bffd17 	ldw	r2,-12(fp)
 20068cc:	2085c83a 	sub	r2,r4,r2
 20068d0:	1887883a 	add	r3,r3,r2
 20068d4:	e0bfff17 	ldw	r2,-4(fp)
 20068d8:	10c00015 	stw	r3,0(r2)
			vTaskSetTimeOutState( pxTimeOut );
 20068dc:	e13ffe17 	ldw	r4,-8(fp)
 20068e0:	20067f80 	call	20067f8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 20068e4:	e03ffc15 	stw	zero,-16(fp)
 20068e8:	00000206 	br	20068f4 <xTaskCheckForTimeOut+0xc0>
		}
		else
		{
			xReturn = pdTRUE;
 20068ec:	00800044 	movi	r2,1
 20068f0:	e0bffc15 	stw	r2,-16(fp)
		}
	}
	taskEXIT_CRITICAL();
 20068f4:	2006ef80 	call	2006ef8 <vTaskExitCritical>

	return xReturn;
 20068f8:	e0bffc17 	ldw	r2,-16(fp)
}
 20068fc:	e037883a 	mov	sp,fp
 2006900:	dfc00117 	ldw	ra,4(sp)
 2006904:	df000017 	ldw	fp,0(sp)
 2006908:	dec00204 	addi	sp,sp,8
 200690c:	f800283a 	ret

02006910 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 2006910:	deffff04 	addi	sp,sp,-4
 2006914:	df000015 	stw	fp,0(sp)
 2006918:	d839883a 	mov	fp,sp
	xYieldPending = pdTRUE;
 200691c:	00800044 	movi	r2,1
 2006920:	d0a07715 	stw	r2,-32292(gp)
}
 2006924:	0001883a 	nop
 2006928:	e037883a 	mov	sp,fp
 200692c:	df000017 	ldw	fp,0(sp)
 2006930:	dec00104 	addi	sp,sp,4
 2006934:	f800283a 	ret

02006938 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 2006938:	defffd04 	addi	sp,sp,-12
 200693c:	dfc00215 	stw	ra,8(sp)
 2006940:	df000115 	stw	fp,4(sp)
 2006944:	df000104 	addi	fp,sp,4
 2006948:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 200694c:	2006a140 	call	2006a14 <prvCheckTasksWaitingTermination>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 2006950:	003ffe06 	br	200694c <__reset+0xfe00594c>

02006954 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 2006954:	defffd04 	addi	sp,sp,-12
 2006958:	dfc00215 	stw	ra,8(sp)
 200695c:	df000115 	stw	fp,4(sp)
 2006960:	df000104 	addi	fp,sp,4
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 2006964:	e03fff15 	stw	zero,-4(fp)
 2006968:	00000c06 	br	200699c <prvInitialiseTaskLists+0x48>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 200696c:	01400504 	movi	r5,20
 2006970:	e13fff17 	ldw	r4,-4(fp)
 2006974:	2009bcc0 	call	2009bcc <__mulsi3>
 2006978:	1007883a 	mov	r3,r2
 200697c:	0080a074 	movhi	r2,641
 2006980:	10914304 	addi	r2,r2,17676
 2006984:	1885883a 	add	r2,r3,r2
 2006988:	1009883a 	mov	r4,r2
 200698c:	200385c0 	call	200385c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 2006990:	e0bfff17 	ldw	r2,-4(fp)
 2006994:	10800044 	addi	r2,r2,1
 2006998:	e0bfff15 	stw	r2,-4(fp)
 200699c:	e0bfff17 	ldw	r2,-4(fp)
 20069a0:	10800170 	cmpltui	r2,r2,5
 20069a4:	103ff11e 	bne	r2,zero,200696c <__reset+0xfe00596c>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 20069a8:	0100a074 	movhi	r4,641
 20069ac:	21115c04 	addi	r4,r4,17776
 20069b0:	200385c0 	call	200385c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 20069b4:	0100a074 	movhi	r4,641
 20069b8:	21116104 	addi	r4,r4,17796
 20069bc:	200385c0 	call	200385c <vListInitialise>
	vListInitialise( &xPendingReadyList );
 20069c0:	0100a074 	movhi	r4,641
 20069c4:	21116604 	addi	r4,r4,17816
 20069c8:	200385c0 	call	200385c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 20069cc:	0100a074 	movhi	r4,641
 20069d0:	21116b04 	addi	r4,r4,17836
 20069d4:	200385c0 	call	200385c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 20069d8:	0100a074 	movhi	r4,641
 20069dc:	21117004 	addi	r4,r4,17856
 20069e0:	200385c0 	call	200385c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 20069e4:	0080a074 	movhi	r2,641
 20069e8:	10915c04 	addi	r2,r2,17776
 20069ec:	d0a06f15 	stw	r2,-32324(gp)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 20069f0:	0080a074 	movhi	r2,641
 20069f4:	10916104 	addi	r2,r2,17796
 20069f8:	d0a07015 	stw	r2,-32320(gp)
}
 20069fc:	0001883a 	nop
 2006a00:	e037883a 	mov	sp,fp
 2006a04:	dfc00117 	ldw	ra,4(sp)
 2006a08:	df000017 	ldw	fp,0(sp)
 2006a0c:	dec00204 	addi	sp,sp,8
 2006a10:	f800283a 	ret

02006a14 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 2006a14:	defffc04 	addi	sp,sp,-16
 2006a18:	dfc00315 	stw	ra,12(sp)
 2006a1c:	df000215 	stw	fp,8(sp)
 2006a20:	df000204 	addi	fp,sp,8
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 2006a24:	00001d06 	br	2006a9c <prvCheckTasksWaitingTermination+0x88>
		{
			vTaskSuspendAll();
 2006a28:	20060440 	call	2006044 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 2006a2c:	0080a074 	movhi	r2,641
 2006a30:	10916b04 	addi	r2,r2,17836
 2006a34:	10800017 	ldw	r2,0(r2)
 2006a38:	1005003a 	cmpeq	r2,r2,zero
 2006a3c:	10803fcc 	andi	r2,r2,255
 2006a40:	e0bffe15 	stw	r2,-8(fp)
			}
			( void ) xTaskResumeAll();
 2006a44:	20060700 	call	2006070 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 2006a48:	e0bffe17 	ldw	r2,-8(fp)
 2006a4c:	1000131e 	bne	r2,zero,2006a9c <prvCheckTasksWaitingTermination+0x88>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 2006a50:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 2006a54:	0080a074 	movhi	r2,641
 2006a58:	10916b04 	addi	r2,r2,17836
 2006a5c:	10800317 	ldw	r2,12(r2)
 2006a60:	10800317 	ldw	r2,12(r2)
 2006a64:	e0bfff15 	stw	r2,-4(fp)
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2006a68:	e0bfff17 	ldw	r2,-4(fp)
 2006a6c:	10800104 	addi	r2,r2,4
 2006a70:	1009883a 	mov	r4,r2
 2006a74:	2003a540 	call	2003a54 <uxListRemove>
					--uxCurrentNumberOfTasks;
 2006a78:	d0a07217 	ldw	r2,-32312(gp)
 2006a7c:	10bfffc4 	addi	r2,r2,-1
 2006a80:	d0a07215 	stw	r2,-32312(gp)
					--uxDeletedTasksWaitingCleanUp;
 2006a84:	d0a07117 	ldw	r2,-32316(gp)
 2006a88:	10bfffc4 	addi	r2,r2,-1
 2006a8c:	d0a07115 	stw	r2,-32316(gp)
				}
				taskEXIT_CRITICAL();
 2006a90:	2006ef80 	call	2006ef8 <vTaskExitCritical>

				prvDeleteTCB( pxTCB );
 2006a94:	e13fff17 	ldw	r4,-4(fp)
 2006a98:	2006b800 	call	2006b80 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 2006a9c:	d0a07117 	ldw	r2,-32316(gp)
 2006aa0:	103fe11e 	bne	r2,zero,2006a28 <__reset+0xfe005a28>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 2006aa4:	0001883a 	nop
 2006aa8:	e037883a 	mov	sp,fp
 2006aac:	dfc00117 	ldw	ra,4(sp)
 2006ab0:	df000017 	ldw	fp,0(sp)
 2006ab4:	dec00204 	addi	sp,sp,8
 2006ab8:	f800283a 	ret

02006abc <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
 2006abc:	defffd04 	addi	sp,sp,-12
 2006ac0:	df000215 	stw	fp,8(sp)
 2006ac4:	df000204 	addi	fp,sp,8
 2006ac8:	e13fff15 	stw	r4,-4(fp)
	uint32_t ulCount = 0U;
 2006acc:	e03ffe15 	stw	zero,-8(fp)

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 2006ad0:	00000606 	br	2006aec <prvTaskCheckFreeStackSpace+0x30>
		{
			pucStackByte -= portSTACK_GROWTH;
 2006ad4:	e0bfff17 	ldw	r2,-4(fp)
 2006ad8:	10800044 	addi	r2,r2,1
 2006adc:	e0bfff15 	stw	r2,-4(fp)
			ulCount++;
 2006ae0:	e0bffe17 	ldw	r2,-8(fp)
 2006ae4:	10800044 	addi	r2,r2,1
 2006ae8:	e0bffe15 	stw	r2,-8(fp)

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 2006aec:	e0bfff17 	ldw	r2,-4(fp)
 2006af0:	10800003 	ldbu	r2,0(r2)
 2006af4:	10803fcc 	andi	r2,r2,255
 2006af8:	10802960 	cmpeqi	r2,r2,165
 2006afc:	103ff51e 	bne	r2,zero,2006ad4 <__reset+0xfe005ad4>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 2006b00:	e0bffe17 	ldw	r2,-8(fp)
 2006b04:	1004d0ba 	srli	r2,r2,2
 2006b08:	e0bffe15 	stw	r2,-8(fp)

		return ( uint16_t ) ulCount;
 2006b0c:	e0bffe17 	ldw	r2,-8(fp)
	}
 2006b10:	e037883a 	mov	sp,fp
 2006b14:	df000017 	ldw	fp,0(sp)
 2006b18:	dec00104 	addi	sp,sp,4
 2006b1c:	f800283a 	ret

02006b20 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
 2006b20:	defffa04 	addi	sp,sp,-24
 2006b24:	dfc00515 	stw	ra,20(sp)
 2006b28:	df000415 	stw	fp,16(sp)
 2006b2c:	df000404 	addi	fp,sp,16
 2006b30:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
 2006b34:	e0bfff17 	ldw	r2,-4(fp)
 2006b38:	1000021e 	bne	r2,zero,2006b44 <uxTaskGetStackHighWaterMark+0x24>
 2006b3c:	d0a06e17 	ldw	r2,-32328(gp)
 2006b40:	00000106 	br	2006b48 <uxTaskGetStackHighWaterMark+0x28>
 2006b44:	e0bfff17 	ldw	r2,-4(fp)
 2006b48:	e0bffc15 	stw	r2,-16(fp)

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 2006b4c:	e0bffc17 	ldw	r2,-16(fp)
 2006b50:	10800c17 	ldw	r2,48(r2)
 2006b54:	e0bffd15 	stw	r2,-12(fp)
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 2006b58:	e13ffd17 	ldw	r4,-12(fp)
 2006b5c:	2006abc0 	call	2006abc <prvTaskCheckFreeStackSpace>
 2006b60:	10bfffcc 	andi	r2,r2,65535
 2006b64:	e0bffe15 	stw	r2,-8(fp)

		return uxReturn;
 2006b68:	e0bffe17 	ldw	r2,-8(fp)
	}
 2006b6c:	e037883a 	mov	sp,fp
 2006b70:	dfc00117 	ldw	ra,4(sp)
 2006b74:	df000017 	ldw	fp,0(sp)
 2006b78:	dec00204 	addi	sp,sp,8
 2006b7c:	f800283a 	ret

02006b80 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 2006b80:	defffd04 	addi	sp,sp,-12
 2006b84:	dfc00215 	stw	ra,8(sp)
 2006b88:	df000115 	stw	fp,4(sp)
 2006b8c:	df000104 	addi	fp,sp,4
 2006b90:	e13fff15 	stw	r4,-4(fp)

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 2006b94:	e0bfff17 	ldw	r2,-4(fp)
 2006b98:	10800c17 	ldw	r2,48(r2)
 2006b9c:	1009883a 	mov	r4,r2
 2006ba0:	20041580 	call	2004158 <vPortFree>
			vPortFree( pxTCB );
 2006ba4:	e13fff17 	ldw	r4,-4(fp)
 2006ba8:	20041580 	call	2004158 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 2006bac:	0001883a 	nop
 2006bb0:	e037883a 	mov	sp,fp
 2006bb4:	dfc00117 	ldw	ra,4(sp)
 2006bb8:	df000017 	ldw	fp,0(sp)
 2006bbc:	dec00204 	addi	sp,sp,8
 2006bc0:	f800283a 	ret

02006bc4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 2006bc4:	defffe04 	addi	sp,sp,-8
 2006bc8:	df000115 	stw	fp,4(sp)
 2006bcc:	df000104 	addi	fp,sp,4
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2006bd0:	d0a06f17 	ldw	r2,-32324(gp)
 2006bd4:	10800017 	ldw	r2,0(r2)
 2006bd8:	1000021e 	bne	r2,zero,2006be4 <prvResetNextTaskUnblockTime+0x20>
 2006bdc:	00800044 	movi	r2,1
 2006be0:	00000106 	br	2006be8 <prvResetNextTaskUnblockTime+0x24>
 2006be4:	0005883a 	mov	r2,zero
 2006be8:	10803fcc 	andi	r2,r2,255
 2006bec:	10000326 	beq	r2,zero,2006bfc <prvResetNextTaskUnblockTime+0x38>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 2006bf0:	00bfffc4 	movi	r2,-1
 2006bf4:	d0a07a15 	stw	r2,-32280(gp)
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 2006bf8:	00000706 	br	2006c18 <prvResetNextTaskUnblockTime+0x54>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2006bfc:	d0a06f17 	ldw	r2,-32324(gp)
 2006c00:	10800317 	ldw	r2,12(r2)
 2006c04:	10800317 	ldw	r2,12(r2)
 2006c08:	e0bfff15 	stw	r2,-4(fp)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 2006c0c:	e0bfff17 	ldw	r2,-4(fp)
 2006c10:	10800117 	ldw	r2,4(r2)
 2006c14:	d0a07a15 	stw	r2,-32280(gp)
	}
}
 2006c18:	0001883a 	nop
 2006c1c:	e037883a 	mov	sp,fp
 2006c20:	df000017 	ldw	fp,0(sp)
 2006c24:	dec00104 	addi	sp,sp,4
 2006c28:	f800283a 	ret

02006c2c <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
 2006c2c:	defffe04 	addi	sp,sp,-8
 2006c30:	df000115 	stw	fp,4(sp)
 2006c34:	df000104 	addi	fp,sp,4
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 2006c38:	d0a06e17 	ldw	r2,-32328(gp)
 2006c3c:	e0bfff15 	stw	r2,-4(fp)

		return xReturn;
 2006c40:	e0bfff17 	ldw	r2,-4(fp)
	}
 2006c44:	e037883a 	mov	sp,fp
 2006c48:	df000017 	ldw	fp,0(sp)
 2006c4c:	dec00104 	addi	sp,sp,4
 2006c50:	f800283a 	ret

02006c54 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 2006c54:	defffb04 	addi	sp,sp,-20
 2006c58:	dfc00415 	stw	ra,16(sp)
 2006c5c:	df000315 	stw	fp,12(sp)
 2006c60:	dc000215 	stw	r16,8(sp)
 2006c64:	df000304 	addi	fp,sp,12
 2006c68:	e13ffe15 	stw	r4,-8(fp)
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 2006c6c:	e0bffe17 	ldw	r2,-8(fp)
 2006c70:	e0bffd15 	stw	r2,-12(fp)

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 2006c74:	e0bffe17 	ldw	r2,-8(fp)
 2006c78:	10004126 	beq	r2,zero,2006d80 <vTaskPriorityInherit+0x12c>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 2006c7c:	e0bffd17 	ldw	r2,-12(fp)
 2006c80:	10c00b17 	ldw	r3,44(r2)
 2006c84:	d0a06e17 	ldw	r2,-32328(gp)
 2006c88:	10800b17 	ldw	r2,44(r2)
 2006c8c:	18803c2e 	bgeu	r3,r2,2006d80 <vTaskPriorityInherit+0x12c>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 2006c90:	e0bffd17 	ldw	r2,-12(fp)
 2006c94:	10800617 	ldw	r2,24(r2)
 2006c98:	10000616 	blt	r2,zero,2006cb4 <vTaskPriorityInherit+0x60>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2006c9c:	d0a06e17 	ldw	r2,-32328(gp)
 2006ca0:	10800b17 	ldw	r2,44(r2)
 2006ca4:	00c00144 	movi	r3,5
 2006ca8:	1887c83a 	sub	r3,r3,r2
 2006cac:	e0bffd17 	ldw	r2,-12(fp)
 2006cb0:	10c00615 	stw	r3,24(r2)
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 2006cb4:	e0bffd17 	ldw	r2,-12(fp)
 2006cb8:	14000517 	ldw	r16,20(r2)
 2006cbc:	e0bffd17 	ldw	r2,-12(fp)
 2006cc0:	10800b17 	ldw	r2,44(r2)
 2006cc4:	01400504 	movi	r5,20
 2006cc8:	1009883a 	mov	r4,r2
 2006ccc:	2009bcc0 	call	2009bcc <__mulsi3>
 2006cd0:	1007883a 	mov	r3,r2
 2006cd4:	0080a074 	movhi	r2,641
 2006cd8:	10914304 	addi	r2,r2,17676
 2006cdc:	1885883a 	add	r2,r3,r2
 2006ce0:	8080021e 	bne	r16,r2,2006cec <vTaskPriorityInherit+0x98>
 2006ce4:	00800044 	movi	r2,1
 2006ce8:	00000106 	br	2006cf0 <vTaskPriorityInherit+0x9c>
 2006cec:	0005883a 	mov	r2,zero
 2006cf0:	10803fcc 	andi	r2,r2,255
 2006cf4:	10001e26 	beq	r2,zero,2006d70 <vTaskPriorityInherit+0x11c>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 2006cf8:	e0bffd17 	ldw	r2,-12(fp)
 2006cfc:	10800104 	addi	r2,r2,4
 2006d00:	1009883a 	mov	r4,r2
 2006d04:	2003a540 	call	2003a54 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 2006d08:	d0a06e17 	ldw	r2,-32328(gp)
 2006d0c:	10c00b17 	ldw	r3,44(r2)
 2006d10:	e0bffd17 	ldw	r2,-12(fp)
 2006d14:	10c00b15 	stw	r3,44(r2)
					prvAddTaskToReadyList( pxTCB );
 2006d18:	e0bffd17 	ldw	r2,-12(fp)
 2006d1c:	10800b17 	ldw	r2,44(r2)
 2006d20:	d0e07417 	ldw	r3,-32304(gp)
 2006d24:	1880032e 	bgeu	r3,r2,2006d34 <vTaskPriorityInherit+0xe0>
 2006d28:	e0bffd17 	ldw	r2,-12(fp)
 2006d2c:	10800b17 	ldw	r2,44(r2)
 2006d30:	d0a07415 	stw	r2,-32304(gp)
 2006d34:	e0bffd17 	ldw	r2,-12(fp)
 2006d38:	10800b17 	ldw	r2,44(r2)
 2006d3c:	01400504 	movi	r5,20
 2006d40:	1009883a 	mov	r4,r2
 2006d44:	2009bcc0 	call	2009bcc <__mulsi3>
 2006d48:	1007883a 	mov	r3,r2
 2006d4c:	0080a074 	movhi	r2,641
 2006d50:	10914304 	addi	r2,r2,17676
 2006d54:	1887883a 	add	r3,r3,r2
 2006d58:	e0bffd17 	ldw	r2,-12(fp)
 2006d5c:	10800104 	addi	r2,r2,4
 2006d60:	100b883a 	mov	r5,r2
 2006d64:	1809883a 	mov	r4,r3
 2006d68:	20038f00 	call	20038f0 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2006d6c:	00000406 	br	2006d80 <vTaskPriorityInherit+0x12c>
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 2006d70:	d0a06e17 	ldw	r2,-32328(gp)
 2006d74:	10c00b17 	ldw	r3,44(r2)
 2006d78:	e0bffd17 	ldw	r2,-12(fp)
 2006d7c:	10c00b15 	stw	r3,44(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2006d80:	0001883a 	nop
 2006d84:	e6ffff04 	addi	sp,fp,-4
 2006d88:	dfc00217 	ldw	ra,8(sp)
 2006d8c:	df000117 	ldw	fp,4(sp)
 2006d90:	dc000017 	ldw	r16,0(sp)
 2006d94:	dec00304 	addi	sp,sp,12
 2006d98:	f800283a 	ret

02006d9c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 2006d9c:	defffb04 	addi	sp,sp,-20
 2006da0:	dfc00415 	stw	ra,16(sp)
 2006da4:	df000315 	stw	fp,12(sp)
 2006da8:	df000304 	addi	fp,sp,12
 2006dac:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 2006db0:	e0bfff17 	ldw	r2,-4(fp)
 2006db4:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
 2006db8:	e03ffd15 	stw	zero,-12(fp)

		if( pxMutexHolder != NULL )
 2006dbc:	e0bfff17 	ldw	r2,-4(fp)
 2006dc0:	10003226 	beq	r2,zero,2006e8c <xTaskPriorityDisinherit+0xf0>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 2006dc4:	e0bffe17 	ldw	r2,-8(fp)
 2006dc8:	10801117 	ldw	r2,68(r2)
 2006dcc:	10ffffc4 	addi	r3,r2,-1
 2006dd0:	e0bffe17 	ldw	r2,-8(fp)
 2006dd4:	10c01115 	stw	r3,68(r2)

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 2006dd8:	e0bffe17 	ldw	r2,-8(fp)
 2006ddc:	10c00b17 	ldw	r3,44(r2)
 2006de0:	e0bffe17 	ldw	r2,-8(fp)
 2006de4:	10801017 	ldw	r2,64(r2)
 2006de8:	18802826 	beq	r3,r2,2006e8c <xTaskPriorityDisinherit+0xf0>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 2006dec:	e0bffe17 	ldw	r2,-8(fp)
 2006df0:	10801117 	ldw	r2,68(r2)
 2006df4:	1000251e 	bne	r2,zero,2006e8c <xTaskPriorityDisinherit+0xf0>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 2006df8:	e0bffe17 	ldw	r2,-8(fp)
 2006dfc:	10800104 	addi	r2,r2,4
 2006e00:	1009883a 	mov	r4,r2
 2006e04:	2003a540 	call	2003a54 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 2006e08:	e0bffe17 	ldw	r2,-8(fp)
 2006e0c:	10c01017 	ldw	r3,64(r2)
 2006e10:	e0bffe17 	ldw	r2,-8(fp)
 2006e14:	10c00b15 	stw	r3,44(r2)

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2006e18:	e0bffe17 	ldw	r2,-8(fp)
 2006e1c:	10800b17 	ldw	r2,44(r2)
 2006e20:	00c00144 	movi	r3,5
 2006e24:	1887c83a 	sub	r3,r3,r2
 2006e28:	e0bffe17 	ldw	r2,-8(fp)
 2006e2c:	10c00615 	stw	r3,24(r2)
					prvAddTaskToReadyList( pxTCB );
 2006e30:	e0bffe17 	ldw	r2,-8(fp)
 2006e34:	10800b17 	ldw	r2,44(r2)
 2006e38:	d0e07417 	ldw	r3,-32304(gp)
 2006e3c:	1880032e 	bgeu	r3,r2,2006e4c <xTaskPriorityDisinherit+0xb0>
 2006e40:	e0bffe17 	ldw	r2,-8(fp)
 2006e44:	10800b17 	ldw	r2,44(r2)
 2006e48:	d0a07415 	stw	r2,-32304(gp)
 2006e4c:	e0bffe17 	ldw	r2,-8(fp)
 2006e50:	10800b17 	ldw	r2,44(r2)
 2006e54:	01400504 	movi	r5,20
 2006e58:	1009883a 	mov	r4,r2
 2006e5c:	2009bcc0 	call	2009bcc <__mulsi3>
 2006e60:	1007883a 	mov	r3,r2
 2006e64:	0080a074 	movhi	r2,641
 2006e68:	10914304 	addi	r2,r2,17676
 2006e6c:	1887883a 	add	r3,r3,r2
 2006e70:	e0bffe17 	ldw	r2,-8(fp)
 2006e74:	10800104 	addi	r2,r2,4
 2006e78:	100b883a 	mov	r5,r2
 2006e7c:	1809883a 	mov	r4,r3
 2006e80:	20038f00 	call	20038f0 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 2006e84:	00800044 	movi	r2,1
 2006e88:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 2006e8c:	e0bffd17 	ldw	r2,-12(fp)
	}
 2006e90:	e037883a 	mov	sp,fp
 2006e94:	dfc00117 	ldw	ra,4(sp)
 2006e98:	df000017 	ldw	fp,0(sp)
 2006e9c:	dec00204 	addi	sp,sp,8
 2006ea0:	f800283a 	ret

02006ea4 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
 2006ea4:	defffe04 	addi	sp,sp,-8
 2006ea8:	df000115 	stw	fp,4(sp)
 2006eac:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2006eb0:	0005303a 	rdctl	r2,status
 2006eb4:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2006eb8:	e0ffff17 	ldw	r3,-4(fp)
 2006ebc:	00bfff84 	movi	r2,-2
 2006ec0:	1884703a 	and	r2,r3,r2
 2006ec4:	1001703a 	wrctl	status,r2
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
 2006ec8:	d0a07517 	ldw	r2,-32300(gp)
 2006ecc:	10000526 	beq	r2,zero,2006ee4 <vTaskEnterCritical+0x40>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
 2006ed0:	d0a06e17 	ldw	r2,-32328(gp)
 2006ed4:	10c00f17 	ldw	r3,60(r2)
 2006ed8:	18c00044 	addi	r3,r3,1
 2006edc:	10c00f15 	stw	r3,60(r2)
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
 2006ee0:	d0a06e17 	ldw	r2,-32328(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2006ee4:	0001883a 	nop
 2006ee8:	e037883a 	mov	sp,fp
 2006eec:	df000017 	ldw	fp,0(sp)
 2006ef0:	dec00104 	addi	sp,sp,4
 2006ef4:	f800283a 	ret

02006ef8 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
 2006ef8:	defffe04 	addi	sp,sp,-8
 2006efc:	df000115 	stw	fp,4(sp)
 2006f00:	df000104 	addi	fp,sp,4
		if( xSchedulerRunning != pdFALSE )
 2006f04:	d0a07517 	ldw	r2,-32300(gp)
 2006f08:	10000e26 	beq	r2,zero,2006f44 <vTaskExitCritical+0x4c>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
 2006f0c:	d0a06e17 	ldw	r2,-32328(gp)
 2006f10:	10800f17 	ldw	r2,60(r2)
 2006f14:	10000b26 	beq	r2,zero,2006f44 <vTaskExitCritical+0x4c>
			{
				( pxCurrentTCB->uxCriticalNesting )--;
 2006f18:	d0a06e17 	ldw	r2,-32328(gp)
 2006f1c:	10c00f17 	ldw	r3,60(r2)
 2006f20:	18ffffc4 	addi	r3,r3,-1
 2006f24:	10c00f15 	stw	r3,60(r2)

				if( pxCurrentTCB->uxCriticalNesting == 0U )
 2006f28:	d0a06e17 	ldw	r2,-32328(gp)
 2006f2c:	10800f17 	ldw	r2,60(r2)
 2006f30:	1000041e 	bne	r2,zero,2006f44 <vTaskExitCritical+0x4c>
 2006f34:	00800044 	movi	r2,1
 2006f38:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2006f3c:	e0bfff17 	ldw	r2,-4(fp)
 2006f40:	1001703a 	wrctl	status,r2
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2006f44:	0001883a 	nop
 2006f48:	e037883a 	mov	sp,fp
 2006f4c:	df000017 	ldw	fp,0(sp)
 2006f50:	dec00104 	addi	sp,sp,4
 2006f54:	f800283a 	ret

02006f58 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 2006f58:	defffe04 	addi	sp,sp,-8
 2006f5c:	df000115 	stw	fp,4(sp)
 2006f60:	df000104 	addi	fp,sp,4
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 2006f64:	d0a06e17 	ldw	r2,-32328(gp)
 2006f68:	10800617 	ldw	r2,24(r2)
 2006f6c:	e0bfff15 	stw	r2,-4(fp)

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2006f70:	d0a06e17 	ldw	r2,-32328(gp)
 2006f74:	d0e06e17 	ldw	r3,-32328(gp)
 2006f78:	18c00b17 	ldw	r3,44(r3)
 2006f7c:	01000144 	movi	r4,5
 2006f80:	20c7c83a 	sub	r3,r4,r3
 2006f84:	10c00615 	stw	r3,24(r2)

	return uxReturn;
 2006f88:	e0bfff17 	ldw	r2,-4(fp)
}
 2006f8c:	e037883a 	mov	sp,fp
 2006f90:	df000017 	ldw	fp,0(sp)
 2006f94:	dec00104 	addi	sp,sp,4
 2006f98:	f800283a 	ret

02006f9c <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
 2006f9c:	deffff04 	addi	sp,sp,-4
 2006fa0:	df000015 	stw	fp,0(sp)
 2006fa4:	d839883a 	mov	fp,sp
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 2006fa8:	d0a06e17 	ldw	r2,-32328(gp)
 2006fac:	10000426 	beq	r2,zero,2006fc0 <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 2006fb0:	d0a06e17 	ldw	r2,-32328(gp)
 2006fb4:	10c01117 	ldw	r3,68(r2)
 2006fb8:	18c00044 	addi	r3,r3,1
 2006fbc:	10c01115 	stw	r3,68(r2)
		}

		return pxCurrentTCB;
 2006fc0:	d0a06e17 	ldw	r2,-32328(gp)
	}
 2006fc4:	e037883a 	mov	sp,fp
 2006fc8:	df000017 	ldw	fp,0(sp)
 2006fcc:	dec00104 	addi	sp,sp,4
 2006fd0:	f800283a 	ret

02006fd4 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
 2006fd4:	defffb04 	addi	sp,sp,-20
 2006fd8:	dfc00415 	stw	ra,16(sp)
 2006fdc:	df000315 	stw	fp,12(sp)
 2006fe0:	df000304 	addi	fp,sp,12
 2006fe4:	e13ffe15 	stw	r4,-8(fp)
 2006fe8:	e17fff15 	stw	r5,-4(fp)
	uint32_t ulReturn;

		taskENTER_CRITICAL();
 2006fec:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 2006ff0:	d0a06e17 	ldw	r2,-32328(gp)
 2006ff4:	10801217 	ldw	r2,72(r2)
 2006ff8:	1000091e 	bne	r2,zero,2007020 <ulTaskNotifyTake+0x4c>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 2006ffc:	d0a06e17 	ldw	r2,-32328(gp)
 2007000:	00c00044 	movi	r3,1
 2007004:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 2007008:	e0bfff17 	ldw	r2,-4(fp)
 200700c:	10000426 	beq	r2,zero,2007020 <ulTaskNotifyTake+0x4c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2007010:	01400044 	movi	r5,1
 2007014:	e13fff17 	ldw	r4,-4(fp)
 2007018:	20076bc0 	call	20076bc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 200701c:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 2007020:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		taskENTER_CRITICAL();
 2007024:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 2007028:	d0a06e17 	ldw	r2,-32328(gp)
 200702c:	10801217 	ldw	r2,72(r2)
 2007030:	e0bffd15 	stw	r2,-12(fp)

			if( ulReturn != 0UL )
 2007034:	e0bffd17 	ldw	r2,-12(fp)
 2007038:	10000926 	beq	r2,zero,2007060 <ulTaskNotifyTake+0x8c>
			{
				if( xClearCountOnExit != pdFALSE )
 200703c:	e0bffe17 	ldw	r2,-8(fp)
 2007040:	10000326 	beq	r2,zero,2007050 <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
 2007044:	d0a06e17 	ldw	r2,-32328(gp)
 2007048:	10001215 	stw	zero,72(r2)
 200704c:	00000406 	br	2007060 <ulTaskNotifyTake+0x8c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
 2007050:	d0a06e17 	ldw	r2,-32328(gp)
 2007054:	e0fffd17 	ldw	r3,-12(fp)
 2007058:	18ffffc4 	addi	r3,r3,-1
 200705c:	10c01215 	stw	r3,72(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 2007060:	d0a06e17 	ldw	r2,-32328(gp)
 2007064:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
 2007068:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		return ulReturn;
 200706c:	e0bffd17 	ldw	r2,-12(fp)
	}
 2007070:	e037883a 	mov	sp,fp
 2007074:	dfc00117 	ldw	ra,4(sp)
 2007078:	df000017 	ldw	fp,0(sp)
 200707c:	dec00204 	addi	sp,sp,8
 2007080:	f800283a 	ret

02007084 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
 2007084:	defff904 	addi	sp,sp,-28
 2007088:	dfc00615 	stw	ra,24(sp)
 200708c:	df000515 	stw	fp,20(sp)
 2007090:	df000504 	addi	fp,sp,20
 2007094:	e13ffc15 	stw	r4,-16(fp)
 2007098:	e17ffd15 	stw	r5,-12(fp)
 200709c:	e1bffe15 	stw	r6,-8(fp)
 20070a0:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xReturn;

		taskENTER_CRITICAL();
 20070a4:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 20070a8:	d0a06e17 	ldw	r2,-32328(gp)
 20070ac:	10801303 	ldbu	r2,76(r2)
 20070b0:	10803fcc 	andi	r2,r2,255
 20070b4:	108000a0 	cmpeqi	r2,r2,2
 20070b8:	10000f1e 	bne	r2,zero,20070f8 <xTaskNotifyWait+0x74>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 20070bc:	d0a06e17 	ldw	r2,-32328(gp)
 20070c0:	11001217 	ldw	r4,72(r2)
 20070c4:	e0fffc17 	ldw	r3,-16(fp)
 20070c8:	00c6303a 	nor	r3,zero,r3
 20070cc:	20c6703a 	and	r3,r4,r3
 20070d0:	10c01215 	stw	r3,72(r2)

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 20070d4:	d0a06e17 	ldw	r2,-32328(gp)
 20070d8:	00c00044 	movi	r3,1
 20070dc:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 20070e0:	e0bfff17 	ldw	r2,-4(fp)
 20070e4:	10000426 	beq	r2,zero,20070f8 <xTaskNotifyWait+0x74>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 20070e8:	01400044 	movi	r5,1
 20070ec:	e13fff17 	ldw	r4,-4(fp)
 20070f0:	20076bc0 	call	20076bc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 20070f4:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 20070f8:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		taskENTER_CRITICAL();
 20070fc:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
 2007100:	e0bffe17 	ldw	r2,-8(fp)
 2007104:	10000426 	beq	r2,zero,2007118 <xTaskNotifyWait+0x94>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 2007108:	d0a06e17 	ldw	r2,-32328(gp)
 200710c:	10c01217 	ldw	r3,72(r2)
 2007110:	e0bffe17 	ldw	r2,-8(fp)
 2007114:	10c00015 	stw	r3,0(r2)

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 2007118:	d0a06e17 	ldw	r2,-32328(gp)
 200711c:	10801303 	ldbu	r2,76(r2)
 2007120:	10803fcc 	andi	r2,r2,255
 2007124:	10800058 	cmpnei	r2,r2,1
 2007128:	1000021e 	bne	r2,zero,2007134 <xTaskNotifyWait+0xb0>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
 200712c:	e03ffb15 	stw	zero,-20(fp)
 2007130:	00000806 	br	2007154 <xTaskNotifyWait+0xd0>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 2007134:	d0a06e17 	ldw	r2,-32328(gp)
 2007138:	11001217 	ldw	r4,72(r2)
 200713c:	e0fffd17 	ldw	r3,-12(fp)
 2007140:	00c6303a 	nor	r3,zero,r3
 2007144:	20c6703a 	and	r3,r4,r3
 2007148:	10c01215 	stw	r3,72(r2)
				xReturn = pdTRUE;
 200714c:	00800044 	movi	r2,1
 2007150:	e0bffb15 	stw	r2,-20(fp)
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 2007154:	d0a06e17 	ldw	r2,-32328(gp)
 2007158:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
 200715c:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		return xReturn;
 2007160:	e0bffb17 	ldw	r2,-20(fp)
	}
 2007164:	e037883a 	mov	sp,fp
 2007168:	dfc00117 	ldw	ra,4(sp)
 200716c:	df000017 	ldw	fp,0(sp)
 2007170:	dec00204 	addi	sp,sp,8
 2007174:	f800283a 	ret

02007178 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 2007178:	defff704 	addi	sp,sp,-36
 200717c:	dfc00815 	stw	ra,32(sp)
 2007180:	df000715 	stw	fp,28(sp)
 2007184:	df000704 	addi	fp,sp,28
 2007188:	e13ffc15 	stw	r4,-16(fp)
 200718c:	e17ffd15 	stw	r5,-12(fp)
 2007190:	e1bffe15 	stw	r6,-8(fp)
 2007194:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
 2007198:	00800044 	movi	r2,1
 200719c:	e0bff915 	stw	r2,-28(fp)
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
 20071a0:	e0bffc17 	ldw	r2,-16(fp)
 20071a4:	e0bffa15 	stw	r2,-24(fp)

		taskENTER_CRITICAL();
 20071a8:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
 20071ac:	e0bfff17 	ldw	r2,-4(fp)
 20071b0:	10000426 	beq	r2,zero,20071c4 <xTaskGenericNotify+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 20071b4:	e0bffa17 	ldw	r2,-24(fp)
 20071b8:	10c01217 	ldw	r3,72(r2)
 20071bc:	e0bfff17 	ldw	r2,-4(fp)
 20071c0:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 20071c4:	e0bffa17 	ldw	r2,-24(fp)
 20071c8:	10801303 	ldbu	r2,76(r2)
 20071cc:	e0bffb05 	stb	r2,-20(fp)

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 20071d0:	e0bffa17 	ldw	r2,-24(fp)
 20071d4:	00c00084 	movi	r3,2
 20071d8:	10c01305 	stb	r3,76(r2)

			switch( eAction )
 20071dc:	e0bffe17 	ldw	r2,-8(fp)
 20071e0:	10800168 	cmpgeui	r2,r2,5
 20071e4:	1000271e 	bne	r2,zero,2007284 <xTaskGenericNotify+0x10c>
 20071e8:	e0bffe17 	ldw	r2,-8(fp)
 20071ec:	100690ba 	slli	r3,r2,2
 20071f0:	00808034 	movhi	r2,512
 20071f4:	109c8104 	addi	r2,r2,29188
 20071f8:	1885883a 	add	r2,r3,r2
 20071fc:	10800017 	ldw	r2,0(r2)
 2007200:	1000683a 	jmp	r2
 2007204:	02007280 	call	200728 <__alt_mem_sdram-0x1dff8d8>
 2007208:	02007218 	cmpnei	r8,zero,456
 200720c:	02007234 	movhi	r8,456
 2007210:	0200724c 	andi	r8,zero,457
 2007214:	0200725c 	xori	r8,zero,457
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 2007218:	e0bffa17 	ldw	r2,-24(fp)
 200721c:	10c01217 	ldw	r3,72(r2)
 2007220:	e0bffd17 	ldw	r2,-12(fp)
 2007224:	1886b03a 	or	r3,r3,r2
 2007228:	e0bffa17 	ldw	r2,-24(fp)
 200722c:	10c01215 	stw	r3,72(r2)
					break;
 2007230:	00001406 	br	2007284 <xTaskGenericNotify+0x10c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 2007234:	e0bffa17 	ldw	r2,-24(fp)
 2007238:	10801217 	ldw	r2,72(r2)
 200723c:	10c00044 	addi	r3,r2,1
 2007240:	e0bffa17 	ldw	r2,-24(fp)
 2007244:	10c01215 	stw	r3,72(r2)
					break;
 2007248:	00000e06 	br	2007284 <xTaskGenericNotify+0x10c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 200724c:	e0bffa17 	ldw	r2,-24(fp)
 2007250:	e0fffd17 	ldw	r3,-12(fp)
 2007254:	10c01215 	stw	r3,72(r2)
					break;
 2007258:	00000a06 	br	2007284 <xTaskGenericNotify+0x10c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 200725c:	e0bffb03 	ldbu	r2,-20(fp)
 2007260:	108000a0 	cmpeqi	r2,r2,2
 2007264:	1000041e 	bne	r2,zero,2007278 <xTaskGenericNotify+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
 2007268:	e0bffa17 	ldw	r2,-24(fp)
 200726c:	e0fffd17 	ldw	r3,-12(fp)
 2007270:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 2007274:	00000306 	br	2007284 <xTaskGenericNotify+0x10c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 2007278:	e03ff915 	stw	zero,-28(fp)
					}
					break;
 200727c:	00000106 	br	2007284 <xTaskGenericNotify+0x10c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
 2007280:	0001883a 	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 2007284:	e0bffb03 	ldbu	r2,-20(fp)
 2007288:	10800058 	cmpnei	r2,r2,1
 200728c:	10001f1e 	bne	r2,zero,200730c <xTaskGenericNotify+0x194>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2007290:	e0bffa17 	ldw	r2,-24(fp)
 2007294:	10800104 	addi	r2,r2,4
 2007298:	1009883a 	mov	r4,r2
 200729c:	2003a540 	call	2003a54 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 20072a0:	e0bffa17 	ldw	r2,-24(fp)
 20072a4:	10800b17 	ldw	r2,44(r2)
 20072a8:	d0e07417 	ldw	r3,-32304(gp)
 20072ac:	1880032e 	bgeu	r3,r2,20072bc <xTaskGenericNotify+0x144>
 20072b0:	e0bffa17 	ldw	r2,-24(fp)
 20072b4:	10800b17 	ldw	r2,44(r2)
 20072b8:	d0a07415 	stw	r2,-32304(gp)
 20072bc:	e0bffa17 	ldw	r2,-24(fp)
 20072c0:	10800b17 	ldw	r2,44(r2)
 20072c4:	01400504 	movi	r5,20
 20072c8:	1009883a 	mov	r4,r2
 20072cc:	2009bcc0 	call	2009bcc <__mulsi3>
 20072d0:	1007883a 	mov	r3,r2
 20072d4:	0080a074 	movhi	r2,641
 20072d8:	10914304 	addi	r2,r2,17676
 20072dc:	1887883a 	add	r3,r3,r2
 20072e0:	e0bffa17 	ldw	r2,-24(fp)
 20072e4:	10800104 	addi	r2,r2,4
 20072e8:	100b883a 	mov	r5,r2
 20072ec:	1809883a 	mov	r4,r3
 20072f0:	20038f00 	call	20038f0 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 20072f4:	e0bffa17 	ldw	r2,-24(fp)
 20072f8:	10800b17 	ldw	r2,44(r2)
 20072fc:	d0e06e17 	ldw	r3,-32328(gp)
 2007300:	18c00b17 	ldw	r3,44(r3)
 2007304:	1880012e 	bgeu	r3,r2,200730c <xTaskGenericNotify+0x194>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
 2007308:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 200730c:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		return xReturn;
 2007310:	e0bff917 	ldw	r2,-28(fp)
	}
 2007314:	e037883a 	mov	sp,fp
 2007318:	dfc00117 	ldw	ra,4(sp)
 200731c:	df000017 	ldw	fp,0(sp)
 2007320:	dec00204 	addi	sp,sp,8
 2007324:	f800283a 	ret

02007328 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
 2007328:	defff604 	addi	sp,sp,-40
 200732c:	dfc00915 	stw	ra,36(sp)
 2007330:	df000815 	stw	fp,32(sp)
 2007334:	df000804 	addi	fp,sp,32
 2007338:	e13ffc15 	stw	r4,-16(fp)
 200733c:	e17ffd15 	stw	r5,-12(fp)
 2007340:	e1bffe15 	stw	r6,-8(fp)
 2007344:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
 2007348:	00800044 	movi	r2,1
 200734c:	e0bff815 	stw	r2,-32(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
 2007350:	e0bffc17 	ldw	r2,-16(fp)
 2007354:	e0bff915 	stw	r2,-28(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2007358:	e03ffa15 	stw	zero,-24(fp)
		{
			if( pulPreviousNotificationValue != NULL )
 200735c:	e0bfff17 	ldw	r2,-4(fp)
 2007360:	10000426 	beq	r2,zero,2007374 <xTaskGenericNotifyFromISR+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 2007364:	e0bff917 	ldw	r2,-28(fp)
 2007368:	10c01217 	ldw	r3,72(r2)
 200736c:	e0bfff17 	ldw	r2,-4(fp)
 2007370:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 2007374:	e0bff917 	ldw	r2,-28(fp)
 2007378:	10801303 	ldbu	r2,76(r2)
 200737c:	e0bffb05 	stb	r2,-20(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 2007380:	e0bff917 	ldw	r2,-28(fp)
 2007384:	00c00084 	movi	r3,2
 2007388:	10c01305 	stb	r3,76(r2)

			switch( eAction )
 200738c:	e0bffe17 	ldw	r2,-8(fp)
 2007390:	10800168 	cmpgeui	r2,r2,5
 2007394:	1000271e 	bne	r2,zero,2007434 <xTaskGenericNotifyFromISR+0x10c>
 2007398:	e0bffe17 	ldw	r2,-8(fp)
 200739c:	100690ba 	slli	r3,r2,2
 20073a0:	00808034 	movhi	r2,512
 20073a4:	109ced04 	addi	r2,r2,29620
 20073a8:	1885883a 	add	r2,r3,r2
 20073ac:	10800017 	ldw	r2,0(r2)
 20073b0:	1000683a 	jmp	r2
 20073b4:	02007430 	cmpltui	r8,zero,464
 20073b8:	020073c8 	cmpgei	r8,zero,463
 20073bc:	020073e4 	muli	r8,zero,463
 20073c0:	020073fc 	xorhi	r8,zero,463
 20073c4:	0200740c 	andi	r8,zero,464
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 20073c8:	e0bff917 	ldw	r2,-28(fp)
 20073cc:	10c01217 	ldw	r3,72(r2)
 20073d0:	e0bffd17 	ldw	r2,-12(fp)
 20073d4:	1886b03a 	or	r3,r3,r2
 20073d8:	e0bff917 	ldw	r2,-28(fp)
 20073dc:	10c01215 	stw	r3,72(r2)
					break;
 20073e0:	00001406 	br	2007434 <xTaskGenericNotifyFromISR+0x10c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 20073e4:	e0bff917 	ldw	r2,-28(fp)
 20073e8:	10801217 	ldw	r2,72(r2)
 20073ec:	10c00044 	addi	r3,r2,1
 20073f0:	e0bff917 	ldw	r2,-28(fp)
 20073f4:	10c01215 	stw	r3,72(r2)
					break;
 20073f8:	00000e06 	br	2007434 <xTaskGenericNotifyFromISR+0x10c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 20073fc:	e0bff917 	ldw	r2,-28(fp)
 2007400:	e0fffd17 	ldw	r3,-12(fp)
 2007404:	10c01215 	stw	r3,72(r2)
					break;
 2007408:	00000a06 	br	2007434 <xTaskGenericNotifyFromISR+0x10c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 200740c:	e0bffb03 	ldbu	r2,-20(fp)
 2007410:	108000a0 	cmpeqi	r2,r2,2
 2007414:	1000041e 	bne	r2,zero,2007428 <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
 2007418:	e0bff917 	ldw	r2,-28(fp)
 200741c:	e0fffd17 	ldw	r3,-12(fp)
 2007420:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 2007424:	00000306 	br	2007434 <xTaskGenericNotifyFromISR+0x10c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 2007428:	e03ff815 	stw	zero,-32(fp)
					}
					break;
 200742c:	00000106 	br	2007434 <xTaskGenericNotifyFromISR+0x10c>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
 2007430:	0001883a 	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 2007434:	e0bffb03 	ldbu	r2,-20(fp)
 2007438:	10800058 	cmpnei	r2,r2,1
 200743c:	10002f1e 	bne	r2,zero,20074fc <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2007440:	d0a07c17 	ldw	r2,-32272(gp)
 2007444:	10001a1e 	bne	r2,zero,20074b0 <xTaskGenericNotifyFromISR+0x188>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2007448:	e0bff917 	ldw	r2,-28(fp)
 200744c:	10800104 	addi	r2,r2,4
 2007450:	1009883a 	mov	r4,r2
 2007454:	2003a540 	call	2003a54 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 2007458:	e0bff917 	ldw	r2,-28(fp)
 200745c:	10800b17 	ldw	r2,44(r2)
 2007460:	d0e07417 	ldw	r3,-32304(gp)
 2007464:	1880032e 	bgeu	r3,r2,2007474 <xTaskGenericNotifyFromISR+0x14c>
 2007468:	e0bff917 	ldw	r2,-28(fp)
 200746c:	10800b17 	ldw	r2,44(r2)
 2007470:	d0a07415 	stw	r2,-32304(gp)
 2007474:	e0bff917 	ldw	r2,-28(fp)
 2007478:	10800b17 	ldw	r2,44(r2)
 200747c:	01400504 	movi	r5,20
 2007480:	1009883a 	mov	r4,r2
 2007484:	2009bcc0 	call	2009bcc <__mulsi3>
 2007488:	1007883a 	mov	r3,r2
 200748c:	0080a074 	movhi	r2,641
 2007490:	10914304 	addi	r2,r2,17676
 2007494:	1887883a 	add	r3,r3,r2
 2007498:	e0bff917 	ldw	r2,-28(fp)
 200749c:	10800104 	addi	r2,r2,4
 20074a0:	100b883a 	mov	r5,r2
 20074a4:	1809883a 	mov	r4,r3
 20074a8:	20038f00 	call	20038f0 <vListInsertEnd>
 20074ac:	00000606 	br	20074c8 <xTaskGenericNotifyFromISR+0x1a0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 20074b0:	e0bff917 	ldw	r2,-28(fp)
 20074b4:	10800604 	addi	r2,r2,24
 20074b8:	100b883a 	mov	r5,r2
 20074bc:	0100a074 	movhi	r4,641
 20074c0:	21116604 	addi	r4,r4,17816
 20074c4:	20038f00 	call	20038f0 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 20074c8:	e0bff917 	ldw	r2,-28(fp)
 20074cc:	10800b17 	ldw	r2,44(r2)
 20074d0:	d0e06e17 	ldw	r3,-32328(gp)
 20074d4:	18c00b17 	ldw	r3,44(r3)
 20074d8:	1880082e 	bgeu	r3,r2,20074fc <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 20074dc:	e0800217 	ldw	r2,8(fp)
 20074e0:	10000426 	beq	r2,zero,20074f4 <xTaskGenericNotifyFromISR+0x1cc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 20074e4:	e0800217 	ldw	r2,8(fp)
 20074e8:	00c00044 	movi	r3,1
 20074ec:	10c00015 	stw	r3,0(r2)
 20074f0:	00000206 	br	20074fc <xTaskGenericNotifyFromISR+0x1d4>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
 20074f4:	00800044 	movi	r2,1
 20074f8:	d0a07715 	stw	r2,-32292(gp)
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
 20074fc:	e0bff817 	ldw	r2,-32(fp)
	}
 2007500:	e037883a 	mov	sp,fp
 2007504:	dfc00117 	ldw	ra,4(sp)
 2007508:	df000017 	ldw	fp,0(sp)
 200750c:	dec00204 	addi	sp,sp,8
 2007510:	f800283a 	ret

02007514 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
 2007514:	defff904 	addi	sp,sp,-28
 2007518:	dfc00615 	stw	ra,24(sp)
 200751c:	df000515 	stw	fp,20(sp)
 2007520:	df000504 	addi	fp,sp,20
 2007524:	e13ffe15 	stw	r4,-8(fp)
 2007528:	e17fff15 	stw	r5,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
 200752c:	e0bffe17 	ldw	r2,-8(fp)
 2007530:	e0bffb15 	stw	r2,-20(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2007534:	e03ffc15 	stw	zero,-16(fp)
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 2007538:	e0bffb17 	ldw	r2,-20(fp)
 200753c:	10801303 	ldbu	r2,76(r2)
 2007540:	e0bffd05 	stb	r2,-12(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 2007544:	e0bffb17 	ldw	r2,-20(fp)
 2007548:	00c00084 	movi	r3,2
 200754c:	10c01305 	stb	r3,76(r2)

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
 2007550:	e0bffb17 	ldw	r2,-20(fp)
 2007554:	10801217 	ldw	r2,72(r2)
 2007558:	10c00044 	addi	r3,r2,1
 200755c:	e0bffb17 	ldw	r2,-20(fp)
 2007560:	10c01215 	stw	r3,72(r2)

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 2007564:	e0bffd03 	ldbu	r2,-12(fp)
 2007568:	10800058 	cmpnei	r2,r2,1
 200756c:	10002f1e 	bne	r2,zero,200762c <vTaskNotifyGiveFromISR+0x118>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2007570:	d0a07c17 	ldw	r2,-32272(gp)
 2007574:	10001a1e 	bne	r2,zero,20075e0 <vTaskNotifyGiveFromISR+0xcc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2007578:	e0bffb17 	ldw	r2,-20(fp)
 200757c:	10800104 	addi	r2,r2,4
 2007580:	1009883a 	mov	r4,r2
 2007584:	2003a540 	call	2003a54 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 2007588:	e0bffb17 	ldw	r2,-20(fp)
 200758c:	10800b17 	ldw	r2,44(r2)
 2007590:	d0e07417 	ldw	r3,-32304(gp)
 2007594:	1880032e 	bgeu	r3,r2,20075a4 <vTaskNotifyGiveFromISR+0x90>
 2007598:	e0bffb17 	ldw	r2,-20(fp)
 200759c:	10800b17 	ldw	r2,44(r2)
 20075a0:	d0a07415 	stw	r2,-32304(gp)
 20075a4:	e0bffb17 	ldw	r2,-20(fp)
 20075a8:	10800b17 	ldw	r2,44(r2)
 20075ac:	01400504 	movi	r5,20
 20075b0:	1009883a 	mov	r4,r2
 20075b4:	2009bcc0 	call	2009bcc <__mulsi3>
 20075b8:	1007883a 	mov	r3,r2
 20075bc:	0080a074 	movhi	r2,641
 20075c0:	10914304 	addi	r2,r2,17676
 20075c4:	1887883a 	add	r3,r3,r2
 20075c8:	e0bffb17 	ldw	r2,-20(fp)
 20075cc:	10800104 	addi	r2,r2,4
 20075d0:	100b883a 	mov	r5,r2
 20075d4:	1809883a 	mov	r4,r3
 20075d8:	20038f00 	call	20038f0 <vListInsertEnd>
 20075dc:	00000606 	br	20075f8 <vTaskNotifyGiveFromISR+0xe4>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 20075e0:	e0bffb17 	ldw	r2,-20(fp)
 20075e4:	10800604 	addi	r2,r2,24
 20075e8:	100b883a 	mov	r5,r2
 20075ec:	0100a074 	movhi	r4,641
 20075f0:	21116604 	addi	r4,r4,17816
 20075f4:	20038f00 	call	20038f0 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 20075f8:	e0bffb17 	ldw	r2,-20(fp)
 20075fc:	10800b17 	ldw	r2,44(r2)
 2007600:	d0e06e17 	ldw	r3,-32328(gp)
 2007604:	18c00b17 	ldw	r3,44(r3)
 2007608:	1880082e 	bgeu	r3,r2,200762c <vTaskNotifyGiveFromISR+0x118>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 200760c:	e0bfff17 	ldw	r2,-4(fp)
 2007610:	10000426 	beq	r2,zero,2007624 <vTaskNotifyGiveFromISR+0x110>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 2007614:	e0bfff17 	ldw	r2,-4(fp)
 2007618:	00c00044 	movi	r3,1
 200761c:	10c00015 	stw	r3,0(r2)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
 2007620:	00000206 	br	200762c <vTaskNotifyGiveFromISR+0x118>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
 2007624:	00800044 	movi	r2,1
 2007628:	d0a07715 	stw	r2,-32292(gp)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
 200762c:	0001883a 	nop
 2007630:	e037883a 	mov	sp,fp
 2007634:	dfc00117 	ldw	ra,4(sp)
 2007638:	df000017 	ldw	fp,0(sp)
 200763c:	dec00204 	addi	sp,sp,8
 2007640:	f800283a 	ret

02007644 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
 2007644:	defffb04 	addi	sp,sp,-20
 2007648:	dfc00415 	stw	ra,16(sp)
 200764c:	df000315 	stw	fp,12(sp)
 2007650:	df000304 	addi	fp,sp,12
 2007654:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
 2007658:	e0bfff17 	ldw	r2,-4(fp)
 200765c:	1000021e 	bne	r2,zero,2007668 <xTaskNotifyStateClear+0x24>
 2007660:	d0a06e17 	ldw	r2,-32328(gp)
 2007664:	00000106 	br	200766c <xTaskNotifyStateClear+0x28>
 2007668:	e0bfff17 	ldw	r2,-4(fp)
 200766c:	e0bffe15 	stw	r2,-8(fp)

		taskENTER_CRITICAL();
 2007670:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 2007674:	e0bffe17 	ldw	r2,-8(fp)
 2007678:	10801303 	ldbu	r2,76(r2)
 200767c:	10803fcc 	andi	r2,r2,255
 2007680:	10800098 	cmpnei	r2,r2,2
 2007684:	1000051e 	bne	r2,zero,200769c <xTaskNotifyStateClear+0x58>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 2007688:	e0bffe17 	ldw	r2,-8(fp)
 200768c:	10001305 	stb	zero,76(r2)
				xReturn = pdPASS;
 2007690:	00800044 	movi	r2,1
 2007694:	e0bffd15 	stw	r2,-12(fp)
 2007698:	00000106 	br	20076a0 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
 200769c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
		taskEXIT_CRITICAL();
 20076a0:	2006ef80 	call	2006ef8 <vTaskExitCritical>

		return xReturn;
 20076a4:	e0bffd17 	ldw	r2,-12(fp)
	}
 20076a8:	e037883a 	mov	sp,fp
 20076ac:	dfc00117 	ldw	ra,4(sp)
 20076b0:	df000017 	ldw	fp,0(sp)
 20076b4:	dec00204 	addi	sp,sp,8
 20076b8:	f800283a 	ret

020076bc <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 20076bc:	defffa04 	addi	sp,sp,-24
 20076c0:	dfc00515 	stw	ra,20(sp)
 20076c4:	df000415 	stw	fp,16(sp)
 20076c8:	df000404 	addi	fp,sp,16
 20076cc:	e13ffe15 	stw	r4,-8(fp)
 20076d0:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 20076d4:	d0a07317 	ldw	r2,-32308(gp)
 20076d8:	e0bffc15 	stw	r2,-16(fp)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 20076dc:	d0a06e17 	ldw	r2,-32328(gp)
 20076e0:	10800104 	addi	r2,r2,4
 20076e4:	1009883a 	mov	r4,r2
 20076e8:	2003a540 	call	2003a54 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 20076ec:	e0bffe17 	ldw	r2,-8(fp)
 20076f0:	10bfffd8 	cmpnei	r2,r2,-1
 20076f4:	1000091e 	bne	r2,zero,200771c <prvAddCurrentTaskToDelayedList+0x60>
 20076f8:	e0bfff17 	ldw	r2,-4(fp)
 20076fc:	10000726 	beq	r2,zero,200771c <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 2007700:	d0a06e17 	ldw	r2,-32328(gp)
 2007704:	10800104 	addi	r2,r2,4
 2007708:	100b883a 	mov	r5,r2
 200770c:	0100a074 	movhi	r4,641
 2007710:	21117004 	addi	r4,r4,17856
 2007714:	20038f00 	call	20038f0 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 2007718:	00001c06 	br	200778c <prvAddCurrentTaskToDelayedList+0xd0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 200771c:	e0fffc17 	ldw	r3,-16(fp)
 2007720:	e0bffe17 	ldw	r2,-8(fp)
 2007724:	1885883a 	add	r2,r3,r2
 2007728:	e0bffd15 	stw	r2,-12(fp)

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 200772c:	d0a06e17 	ldw	r2,-32328(gp)
 2007730:	e0fffd17 	ldw	r3,-12(fp)
 2007734:	10c00115 	stw	r3,4(r2)

			if( xTimeToWake < xConstTickCount )
 2007738:	e0fffd17 	ldw	r3,-12(fp)
 200773c:	e0bffc17 	ldw	r2,-16(fp)
 2007740:	1880072e 	bgeu	r3,r2,2007760 <prvAddCurrentTaskToDelayedList+0xa4>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 2007744:	d0e07017 	ldw	r3,-32320(gp)
 2007748:	d0a06e17 	ldw	r2,-32328(gp)
 200774c:	10800104 	addi	r2,r2,4
 2007750:	100b883a 	mov	r5,r2
 2007754:	1809883a 	mov	r4,r3
 2007758:	200397c0 	call	200397c <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 200775c:	00000b06 	br	200778c <prvAddCurrentTaskToDelayedList+0xd0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 2007760:	d0e06f17 	ldw	r3,-32324(gp)
 2007764:	d0a06e17 	ldw	r2,-32328(gp)
 2007768:	10800104 	addi	r2,r2,4
 200776c:	100b883a 	mov	r5,r2
 2007770:	1809883a 	mov	r4,r3
 2007774:	200397c0 	call	200397c <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 2007778:	d0a07a17 	ldw	r2,-32280(gp)
 200777c:	e0fffd17 	ldw	r3,-12(fp)
 2007780:	1880022e 	bgeu	r3,r2,200778c <prvAddCurrentTaskToDelayedList+0xd0>
				{
					xNextTaskUnblockTime = xTimeToWake;
 2007784:	e0bffd17 	ldw	r2,-12(fp)
 2007788:	d0a07a15 	stw	r2,-32280(gp)

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 200778c:	0001883a 	nop
 2007790:	e037883a 	mov	sp,fp
 2007794:	dfc00117 	ldw	ra,4(sp)
 2007798:	df000017 	ldw	fp,0(sp)
 200779c:	dec00204 	addi	sp,sp,8
 20077a0:	f800283a 	ret

020077a4 <OutputHigh_Din>:
//adress: Direccion de escritura para configuracion o dato 8 bits
// data:  Informacion a enviar para la direccion (adress) seleccionda 8 bits


int OutputHigh_Din(int Portlog) // Salida en alto por el pin DIN enmascarado en  los 32 pines del GPIO
{
 20077a4:	defffe04 	addi	sp,sp,-8
 20077a8:	df000115 	stw	fp,4(sp)
 20077ac:	df000104 	addi	fp,sp,4
 20077b0:	e13fff15 	stw	r4,-4(fp)
	Portlog = Portlog | (1<<PIN_DIN_IDX);
 20077b4:	e0bfff17 	ldw	r2,-4(fp)
 20077b8:	10810014 	ori	r2,r2,1024
 20077bc:	e0bfff15 	stw	r2,-4(fp)

	IOWR(IO_PIO1_BASE, ALT_UP_PARALLEL_PORT_DATA, Portlog); // funcion de la libreria io.h que permite escribir en la direccion del GPIO (PORT_JP1_BASE), la informacion Portlog, ALT_UP_PARALLEL_PORT_DATA es parametro de dicha libreria.
 20077c0:	00810074 	movhi	r2,1025
 20077c4:	10881004 	addi	r2,r2,8256
 20077c8:	e0ffff17 	ldw	r3,-4(fp)
 20077cc:	10c00035 	stwio	r3,0(r2)
	return (Portlog);
 20077d0:	e0bfff17 	ldw	r2,-4(fp)
}
 20077d4:	e037883a 	mov	sp,fp
 20077d8:	df000017 	ldw	fp,0(sp)
 20077dc:	dec00104 	addi	sp,sp,4
 20077e0:	f800283a 	ret

020077e4 <Outputlow_Din>:


int Outputlow_Din(int Portlog)// Salida en bajo por el pin DIN enmascarado en  los 32 pines del GPIO
{
 20077e4:	defffe04 	addi	sp,sp,-8
 20077e8:	df000115 	stw	fp,4(sp)
 20077ec:	df000104 	addi	fp,sp,4
 20077f0:	e13fff15 	stw	r4,-4(fp)
	Portlog = Portlog & ~(1<<PIN_DIN_IDX);
 20077f4:	e0ffff17 	ldw	r3,-4(fp)
 20077f8:	00beffc4 	movi	r2,-1025
 20077fc:	1884703a 	and	r2,r3,r2
 2007800:	e0bfff15 	stw	r2,-4(fp)

	IOWR(IO_PIO1_BASE, ALT_UP_PARALLEL_PORT_DATA, Portlog);
 2007804:	00810074 	movhi	r2,1025
 2007808:	10881004 	addi	r2,r2,8256
 200780c:	e0ffff17 	ldw	r3,-4(fp)
 2007810:	10c00035 	stwio	r3,0(r2)
	return (Portlog);
 2007814:	e0bfff17 	ldw	r2,-4(fp)
}
 2007818:	e037883a 	mov	sp,fp
 200781c:	df000017 	ldw	fp,0(sp)
 2007820:	dec00104 	addi	sp,sp,4
 2007824:	f800283a 	ret

02007828 <Outputlow_clk>:



int Outputlow_clk(int Portlog)
{
 2007828:	defffe04 	addi	sp,sp,-8
 200782c:	df000115 	stw	fp,4(sp)
 2007830:	df000104 	addi	fp,sp,4
 2007834:	e13fff15 	stw	r4,-4(fp)
	Portlog = Portlog & ~(1<<PIN_CLK_IDX);
 2007838:	e0ffff17 	ldw	r3,-4(fp)
 200783c:	00bfbfc4 	movi	r2,-257
 2007840:	1884703a 	and	r2,r3,r2
 2007844:	e0bfff15 	stw	r2,-4(fp)

	IOWR(IO_PIO1_BASE, ALT_UP_PARALLEL_PORT_DATA, Portlog);
 2007848:	00810074 	movhi	r2,1025
 200784c:	10881004 	addi	r2,r2,8256
 2007850:	e0ffff17 	ldw	r3,-4(fp)
 2007854:	10c00035 	stwio	r3,0(r2)
	return (Portlog);
 2007858:	e0bfff17 	ldw	r2,-4(fp)
}
 200785c:	e037883a 	mov	sp,fp
 2007860:	df000017 	ldw	fp,0(sp)
 2007864:	dec00104 	addi	sp,sp,4
 2007868:	f800283a 	ret

0200786c <OutputHigh_clk>:


int OutputHigh_clk(int Portlog)
{
 200786c:	defffe04 	addi	sp,sp,-8
 2007870:	df000115 	stw	fp,4(sp)
 2007874:	df000104 	addi	fp,sp,4
 2007878:	e13fff15 	stw	r4,-4(fp)
	Portlog = Portlog | (1<<PIN_CLK_IDX);
 200787c:	e0bfff17 	ldw	r2,-4(fp)
 2007880:	10804014 	ori	r2,r2,256
 2007884:	e0bfff15 	stw	r2,-4(fp)

	IOWR(IO_PIO1_BASE, ALT_UP_PARALLEL_PORT_DATA, Portlog);
 2007888:	00810074 	movhi	r2,1025
 200788c:	10881004 	addi	r2,r2,8256
 2007890:	e0ffff17 	ldw	r3,-4(fp)
 2007894:	10c00035 	stwio	r3,0(r2)
	return (Portlog);
 2007898:	e0bfff17 	ldw	r2,-4(fp)
}
 200789c:	e037883a 	mov	sp,fp
 20078a0:	df000017 	ldw	fp,0(sp)
 20078a4:	dec00104 	addi	sp,sp,4
 20078a8:	f800283a 	ret

020078ac <Outputlow_cs>:


int Outputlow_cs(int Portlog)
{
 20078ac:	defffe04 	addi	sp,sp,-8
 20078b0:	df000115 	stw	fp,4(sp)
 20078b4:	df000104 	addi	fp,sp,4
 20078b8:	e13fff15 	stw	r4,-4(fp)
	Portlog = Portlog & ~(1<<PIN_CS_IDX);
 20078bc:	e0ffff17 	ldw	r3,-4(fp)
 20078c0:	00bf7fc4 	movi	r2,-513
 20078c4:	1884703a 	and	r2,r3,r2
 20078c8:	e0bfff15 	stw	r2,-4(fp)

	IOWR(IO_PIO1_BASE, ALT_UP_PARALLEL_PORT_DATA, Portlog);
 20078cc:	00810074 	movhi	r2,1025
 20078d0:	10881004 	addi	r2,r2,8256
 20078d4:	e0ffff17 	ldw	r3,-4(fp)
 20078d8:	10c00035 	stwio	r3,0(r2)

	return (Portlog);
 20078dc:	e0bfff17 	ldw	r2,-4(fp)
}
 20078e0:	e037883a 	mov	sp,fp
 20078e4:	df000017 	ldw	fp,0(sp)
 20078e8:	dec00104 	addi	sp,sp,4
 20078ec:	f800283a 	ret

020078f0 <OutputHigh_cs>:
int OutputHigh_cs(int Portlog)
{
 20078f0:	defffe04 	addi	sp,sp,-8
 20078f4:	df000115 	stw	fp,4(sp)
 20078f8:	df000104 	addi	fp,sp,4
 20078fc:	e13fff15 	stw	r4,-4(fp)
	Portlog = Portlog | (1<<PIN_CS_IDX);
 2007900:	e0bfff17 	ldw	r2,-4(fp)
 2007904:	10808014 	ori	r2,r2,512
 2007908:	e0bfff15 	stw	r2,-4(fp)

	IOWR(IO_PIO1_BASE, ALT_UP_PARALLEL_PORT_DATA, Portlog);
 200790c:	00810074 	movhi	r2,1025
 2007910:	10881004 	addi	r2,r2,8256
 2007914:	e0ffff17 	ldw	r3,-4(fp)
 2007918:	10c00035 	stwio	r3,0(r2)

	return (Portlog);
 200791c:	e0bfff17 	ldw	r2,-4(fp)
}
 2007920:	e037883a 	mov	sp,fp
 2007924:	df000017 	ldw	fp,0(sp)
 2007928:	dec00104 	addi	sp,sp,4
 200792c:	f800283a 	ret

02007930 <max7219_int>:



int max7219_int (int datalog) //Condiciones iniciales para empezar comunicacion.
{
 2007930:	defffd04 	addi	sp,sp,-12
 2007934:	dfc00215 	stw	ra,8(sp)
 2007938:	df000115 	stw	fp,4(sp)
 200793c:	df000104 	addi	fp,sp,4
 2007940:	e13fff15 	stw	r4,-4(fp)
	datalog= Outputlow_clk(datalog);
 2007944:	e13fff17 	ldw	r4,-4(fp)
 2007948:	20078280 	call	2007828 <Outputlow_clk>
 200794c:	e0bfff15 	stw	r2,-4(fp)
	datalog= Outputlow_Din(datalog);
 2007950:	e13fff17 	ldw	r4,-4(fp)
 2007954:	20077e40 	call	20077e4 <Outputlow_Din>
 2007958:	e0bfff15 	stw	r2,-4(fp)
	datalog= OutputHigh_cs(datalog);
 200795c:	e13fff17 	ldw	r4,-4(fp)
 2007960:	20078f00 	call	20078f0 <OutputHigh_cs>
 2007964:	e0bfff15 	stw	r2,-4(fp)
	return (datalog);
 2007968:	e0bfff17 	ldw	r2,-4(fp)
}
 200796c:	e037883a 	mov	sp,fp
 2007970:	dfc00117 	ldw	ra,4(sp)
 2007974:	df000017 	ldw	fp,0(sp)
 2007978:	dec00204 	addi	sp,sp,8
 200797c:	f800283a 	ret

02007980 <max7219_senbit>:

int max7219_senbit (int portlog,char bitvalue) //Envio de informacion por pin DIN
{
 2007980:	defffc04 	addi	sp,sp,-16
 2007984:	dfc00315 	stw	ra,12(sp)
 2007988:	df000215 	stw	fp,8(sp)
 200798c:	df000204 	addi	fp,sp,8
 2007990:	e13ffe15 	stw	r4,-8(fp)
 2007994:	2805883a 	mov	r2,r5
 2007998:	e0bfff05 	stb	r2,-4(fp)
	if(bitvalue==1)
 200799c:	e0bfff07 	ldb	r2,-4(fp)
 20079a0:	10800058 	cmpnei	r2,r2,1
 20079a4:	1000041e 	bne	r2,zero,20079b8 <max7219_senbit+0x38>
	{
		portlog=OutputHigh_Din(portlog);
 20079a8:	e13ffe17 	ldw	r4,-8(fp)
 20079ac:	20077a40 	call	20077a4 <OutputHigh_Din>
 20079b0:	e0bffe15 	stw	r2,-8(fp)
 20079b4:	00000306 	br	20079c4 <max7219_senbit+0x44>
	}
	else
	{
		portlog=Outputlow_Din(portlog);
 20079b8:	e13ffe17 	ldw	r4,-8(fp)
 20079bc:	20077e40 	call	20077e4 <Outputlow_Din>
 20079c0:	e0bffe15 	stw	r2,-8(fp)
	}
	usleep(1);
 20079c4:	01000044 	movi	r4,1
 20079c8:	200e6f40 	call	200e6f4 <usleep>
	OutputHigh_clk(portlog); // Comportamiento de seal de Clock que determina el envio de informacion (1 bit).
 20079cc:	e13ffe17 	ldw	r4,-8(fp)
 20079d0:	200786c0 	call	200786c <OutputHigh_clk>
	usleep(1);
 20079d4:	01000044 	movi	r4,1
 20079d8:	200e6f40 	call	200e6f4 <usleep>
	Outputlow_clk(portlog);
 20079dc:	e13ffe17 	ldw	r4,-8(fp)
 20079e0:	20078280 	call	2007828 <Outputlow_clk>

	return portlog;
 20079e4:	e0bffe17 	ldw	r2,-8(fp)
}
 20079e8:	e037883a 	mov	sp,fp
 20079ec:	dfc00117 	ldw	ra,4(sp)
 20079f0:	df000017 	ldw	fp,0(sp)
 20079f4:	dec00204 	addi	sp,sp,8
 20079f8:	f800283a 	ret

020079fc <sen_2_byte_info>:

int  sen_2_byte_info(int portlog, char address, char data)//Envio de palabra de 16 bits, en la cual se encuentra la direccion y dato correspondiente
{
 20079fc:	defffa04 	addi	sp,sp,-24
 2007a00:	dfc00515 	stw	ra,20(sp)
 2007a04:	df000415 	stw	fp,16(sp)
 2007a08:	df000404 	addi	fp,sp,16
 2007a0c:	e13ffd15 	stw	r4,-12(fp)
 2007a10:	2807883a 	mov	r3,r5
 2007a14:	3005883a 	mov	r2,r6
 2007a18:	e0fffe05 	stb	r3,-8(fp)
 2007a1c:	e0bfff05 	stb	r2,-4(fp)
	char i;
	Outputlow_cs(portlog);
 2007a20:	e13ffd17 	ldw	r4,-12(fp)
 2007a24:	20078ac0 	call	20078ac <Outputlow_cs>

	for (i=0;i<8;i++)
 2007a28:	e03ffc05 	stb	zero,-16(fp)
 2007a2c:	00001106 	br	2007a74 <sen_2_byte_info+0x78>
	{
		if ((address & (1<<(7-i))) != 0)
 2007a30:	e0fffe07 	ldb	r3,-8(fp)
 2007a34:	e0bffc07 	ldb	r2,-16(fp)
 2007a38:	010001c4 	movi	r4,7
 2007a3c:	2085c83a 	sub	r2,r4,r2
 2007a40:	1885d83a 	sra	r2,r3,r2
 2007a44:	1080004c 	andi	r2,r2,1
 2007a48:	10000426 	beq	r2,zero,2007a5c <sen_2_byte_info+0x60>
		{
			max7219_senbit(portlog,1);
 2007a4c:	01400044 	movi	r5,1
 2007a50:	e13ffd17 	ldw	r4,-12(fp)
 2007a54:	20079800 	call	2007980 <max7219_senbit>
 2007a58:	00000306 	br	2007a68 <sen_2_byte_info+0x6c>
		}
		else
		{
			max7219_senbit(portlog,0);
 2007a5c:	000b883a 	mov	r5,zero
 2007a60:	e13ffd17 	ldw	r4,-12(fp)
 2007a64:	20079800 	call	2007980 <max7219_senbit>
int  sen_2_byte_info(int portlog, char address, char data)//Envio de palabra de 16 bits, en la cual se encuentra la direccion y dato correspondiente
{
	char i;
	Outputlow_cs(portlog);

	for (i=0;i<8;i++)
 2007a68:	e0bffc03 	ldbu	r2,-16(fp)
 2007a6c:	10800044 	addi	r2,r2,1
 2007a70:	e0bffc05 	stb	r2,-16(fp)
 2007a74:	e0bffc07 	ldb	r2,-16(fp)
 2007a78:	10800210 	cmplti	r2,r2,8
 2007a7c:	103fec1e 	bne	r2,zero,2007a30 <__reset+0xfe006a30>
		else
		{
			max7219_senbit(portlog,0);
		}
	}
	for (i=0;i<8;i++)
 2007a80:	e03ffc05 	stb	zero,-16(fp)
 2007a84:	00001106 	br	2007acc <sen_2_byte_info+0xd0>
	{
		if ((data & (1<<(7-i))) != 0)
 2007a88:	e0ffff07 	ldb	r3,-4(fp)
 2007a8c:	e0bffc07 	ldb	r2,-16(fp)
 2007a90:	010001c4 	movi	r4,7
 2007a94:	2085c83a 	sub	r2,r4,r2
 2007a98:	1885d83a 	sra	r2,r3,r2
 2007a9c:	1080004c 	andi	r2,r2,1
 2007aa0:	10000426 	beq	r2,zero,2007ab4 <sen_2_byte_info+0xb8>
		{
			max7219_senbit(portlog,1);
 2007aa4:	01400044 	movi	r5,1
 2007aa8:	e13ffd17 	ldw	r4,-12(fp)
 2007aac:	20079800 	call	2007980 <max7219_senbit>
 2007ab0:	00000306 	br	2007ac0 <sen_2_byte_info+0xc4>
		}
		else
		{
			max7219_senbit(portlog,0);
 2007ab4:	000b883a 	mov	r5,zero
 2007ab8:	e13ffd17 	ldw	r4,-12(fp)
 2007abc:	20079800 	call	2007980 <max7219_senbit>
		else
		{
			max7219_senbit(portlog,0);
		}
	}
	for (i=0;i<8;i++)
 2007ac0:	e0bffc03 	ldbu	r2,-16(fp)
 2007ac4:	10800044 	addi	r2,r2,1
 2007ac8:	e0bffc05 	stb	r2,-16(fp)
 2007acc:	e0bffc07 	ldb	r2,-16(fp)
 2007ad0:	10800210 	cmplti	r2,r2,8
 2007ad4:	103fec1e 	bne	r2,zero,2007a88 <__reset+0xfe006a88>
		{
			max7219_senbit(portlog,0);
		}

	}
	OutputHigh_cs(portlog);
 2007ad8:	e13ffd17 	ldw	r4,-12(fp)
 2007adc:	20078f00 	call	20078f0 <OutputHigh_cs>
	usleep(1);
 2007ae0:	01000044 	movi	r4,1
 2007ae4:	200e6f40 	call	200e6f4 <usleep>
	return portlog;
 2007ae8:	e0bffd17 	ldw	r2,-12(fp)
}
 2007aec:	e037883a 	mov	sp,fp
 2007af0:	dfc00117 	ldw	ra,4(sp)
 2007af4:	df000017 	ldw	fp,0(sp)
 2007af8:	dec00204 	addi	sp,sp,8
 2007afc:	f800283a 	ret

02007b00 <xSerialPortInitMinimal>:
static void vUARTReceiveHandler( alt_u32 status );
static void vUARTTransmitHandler( alt_u32 status );
/*---------------------------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
 2007b00:	defffb04 	addi	sp,sp,-20
 2007b04:	dfc00415 	stw	ra,16(sp)
 2007b08:	df000315 	stw	fp,12(sp)
 2007b0c:	df000304 	addi	fp,sp,12
 2007b10:	e13ffe15 	stw	r4,-8(fp)
 2007b14:	e17fff15 	stw	r5,-4(fp)
	/* Create the queues used to hold Rx and Tx characters. */
	xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
 2007b18:	000d883a 	mov	r6,zero
 2007b1c:	01400044 	movi	r5,1
 2007b20:	e13fff17 	ldw	r4,-4(fp)
 2007b24:	20044040 	call	2004404 <xQueueGenericCreate>
 2007b28:	d0a07d15 	stw	r2,-32268(gp)
	xCharsForTx = xQueueCreate( uxQueueLength + 1, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
 2007b2c:	e0bfff17 	ldw	r2,-4(fp)
 2007b30:	10800044 	addi	r2,r2,1
 2007b34:	000d883a 	mov	r6,zero
 2007b38:	01400044 	movi	r5,1
 2007b3c:	1009883a 	mov	r4,r2
 2007b40:	20044040 	call	2004404 <xQueueGenericCreate>
 2007b44:	d0a07e15 	stw	r2,-32264(gp)

	/* If the queues were created correctly then setup the serial port hardware. */
	if( ( xRxedChars != serINVALID_QUEUE ) && ( xCharsForTx != serINVALID_QUEUE ) )
 2007b48:	d0a07d17 	ldw	r2,-32268(gp)
 2007b4c:	10001426 	beq	r2,zero,2007ba0 <xSerialPortInitMinimal+0xa0>
 2007b50:	d0a07e17 	ldw	r2,-32264(gp)
 2007b54:	10001226 	beq	r2,zero,2007ba0 <xSerialPortInitMinimal+0xa0>
	{
		portENTER_CRITICAL();
 2007b58:	2006ea40 	call	2006ea4 <vTaskEnterCritical>
		{
			uartControl = ALTERA_AVALON_UART_CONTROL_RTS_MSK | ALTERA_AVALON_UART_CONTROL_RRDY_MSK | ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
 2007b5c:	00832004 	movi	r2,3200
 2007b60:	d0a07f15 	stw	r2,-32260(gp)
			IOWR_ALTERA_AVALON_UART_CONTROL( UART_BASE, uartControl );
 2007b64:	d0a07f17 	ldw	r2,-32260(gp)
 2007b68:	1007883a 	mov	r3,r2
 2007b6c:	00810134 	movhi	r2,1028
 2007b70:	10881304 	addi	r2,r2,8268
 2007b74:	10c00035 	stwio	r3,0(r2)

			/* register the interrupt handler */
			//cjr Jul-1-2010 new API
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
			alt_ic_isr_register(UART_IRQ_INTERRUPT_CONTROLLER_ID, UART_IRQ,
 2007b78:	d8000015 	stw	zero,0(sp)
 2007b7c:	000f883a 	mov	r7,zero
 2007b80:	01808034 	movhi	r6,512
 2007b84:	319f5d04 	addi	r6,r6,32116
 2007b88:	01400144 	movi	r5,5
 2007b8c:	0009883a 	mov	r4,zero
 2007b90:	200e00c0 	call	200e00c <alt_ic_isr_register>
#else
			alt_irq_register ( UART_IRQ, NULL, vUARTInterruptHandler );

#endif
		}
		portEXIT_CRITICAL();
 2007b94:	2006ef80 	call	2006ef8 <vTaskExitCritical>
	}
	else
	{
		return ( xComPortHandle ) 0;
	}
	return ( xComPortHandle ) 1;
 2007b98:	00800044 	movi	r2,1
 2007b9c:	00000106 	br	2007ba4 <xSerialPortInitMinimal+0xa4>
		}
		portEXIT_CRITICAL();
	}
	else
	{
		return ( xComPortHandle ) 0;
 2007ba0:	0005883a 	mov	r2,zero
	}
	return ( xComPortHandle ) 1;
}
 2007ba4:	e037883a 	mov	sp,fp
 2007ba8:	dfc00117 	ldw	ra,4(sp)
 2007bac:	df000017 	ldw	fp,0(sp)
 2007bb0:	dec00204 	addi	sp,sp,8
 2007bb4:	f800283a 	ret

02007bb8 <vSerialClose>:
/*---------------------------------------------------------------------------*/

void vSerialClose( xComPortHandle xPort )
{
 2007bb8:	defffe04 	addi	sp,sp,-8
 2007bbc:	df000115 	stw	fp,4(sp)
 2007bc0:	df000104 	addi	fp,sp,4
 2007bc4:	e13fff15 	stw	r4,-4(fp)
	/* Never used. */
}
 2007bc8:	0001883a 	nop
 2007bcc:	e037883a 	mov	sp,fp
 2007bd0:	df000017 	ldw	fp,0(sp)
 2007bd4:	dec00104 	addi	sp,sp,4
 2007bd8:	f800283a 	ret

02007bdc <xSerialGetChar>:
/*---------------------------------------------------------------------------*/

signed portBASE_TYPE xSerialGetChar( xComPortHandle pxPort, signed char *pcRxedChar, portTickType xBlockTime )
{
 2007bdc:	defffb04 	addi	sp,sp,-20
 2007be0:	dfc00415 	stw	ra,16(sp)
 2007be4:	df000315 	stw	fp,12(sp)
 2007be8:	df000304 	addi	fp,sp,12
 2007bec:	e13ffd15 	stw	r4,-12(fp)
 2007bf0:	e17ffe15 	stw	r5,-8(fp)
 2007bf4:	e1bfff15 	stw	r6,-4(fp)
	( void ) pxPort;


	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
 2007bf8:	d0a07d17 	ldw	r2,-32268(gp)
 2007bfc:	000f883a 	mov	r7,zero
 2007c00:	e1bfff17 	ldw	r6,-4(fp)
 2007c04:	e17ffe17 	ldw	r5,-8(fp)
 2007c08:	1009883a 	mov	r4,r2
 2007c0c:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2007c10:	10000226 	beq	r2,zero,2007c1c <xSerialGetChar+0x40>
	{
		return pdTRUE;
 2007c14:	00800044 	movi	r2,1
 2007c18:	00000906 	br	2007c40 <xSerialGetChar+0x64>
	}
	else
	{
		uartControl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 2007c1c:	d0a07f17 	ldw	r2,-32260(gp)
 2007c20:	10802014 	ori	r2,r2,128
 2007c24:	d0a07f15 	stw	r2,-32260(gp)
		IOWR_ALTERA_AVALON_UART_CONTROL( UART_BASE, uartControl );
 2007c28:	d0a07f17 	ldw	r2,-32260(gp)
 2007c2c:	1007883a 	mov	r3,r2
 2007c30:	00810134 	movhi	r2,1028
 2007c34:	10881304 	addi	r2,r2,8268
 2007c38:	10c00035 	stwio	r3,0(r2)
		return pdFALSE;
 2007c3c:	0005883a 	mov	r2,zero
	}
}
 2007c40:	e037883a 	mov	sp,fp
 2007c44:	dfc00117 	ldw	ra,4(sp)
 2007c48:	df000017 	ldw	fp,0(sp)
 2007c4c:	dec00204 	addi	sp,sp,8
 2007c50:	f800283a 	ret

02007c54 <xSerialPutChar>:
/*---------------------------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, portTickType xBlockTime )
{
 2007c54:	defffa04 	addi	sp,sp,-24
 2007c58:	dfc00515 	stw	ra,20(sp)
 2007c5c:	df000415 	stw	fp,16(sp)
 2007c60:	df000404 	addi	fp,sp,16
 2007c64:	e13ffd15 	stw	r4,-12(fp)
 2007c68:	2805883a 	mov	r2,r5
 2007c6c:	e1bfff15 	stw	r6,-4(fp)
 2007c70:	e0bffe05 	stb	r2,-8(fp)
	signed portBASE_TYPE lReturn = pdPASS;
 2007c74:	00800044 	movi	r2,1
 2007c78:	e0bffc15 	stw	r2,-16(fp)

	/* Place the character in the queue of characters to be transmitted. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) == pdPASS )
 2007c7c:	d0a07e17 	ldw	r2,-32264(gp)
 2007c80:	e0fffe04 	addi	r3,fp,-8
 2007c84:	000f883a 	mov	r7,zero
 2007c88:	e1bfff17 	ldw	r6,-4(fp)
 2007c8c:	180b883a 	mov	r5,r3
 2007c90:	1009883a 	mov	r4,r2
 2007c94:	20047700 	call	2004770 <xQueueGenericSend>
 2007c98:	10800058 	cmpnei	r2,r2,1
 2007c9c:	10000b1e 	bne	r2,zero,2007ccc <xSerialPutChar+0x78>
	{
		/*Triggers an interrupt on every character or (down) when queue is full. */
		uartControl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 2007ca0:	d0a07f17 	ldw	r2,-32260(gp)
 2007ca4:	10801014 	ori	r2,r2,64
 2007ca8:	d0a07f15 	stw	r2,-32260(gp)
		IOWR_ALTERA_AVALON_UART_CONTROL( UART_BASE, uartControl );
 2007cac:	d0a07f17 	ldw	r2,-32260(gp)
 2007cb0:	1007883a 	mov	r3,r2
 2007cb4:	00810134 	movhi	r2,1028
 2007cb8:	10881304 	addi	r2,r2,8268
 2007cbc:	10c00035 	stwio	r3,0(r2)
		lReturn = pdPASS;
 2007cc0:	00800044 	movi	r2,1
 2007cc4:	e0bffc15 	stw	r2,-16(fp)
 2007cc8:	00000106 	br	2007cd0 <xSerialPutChar+0x7c>
	}
	else
	{
		lReturn = pdFAIL;
 2007ccc:	e03ffc15 	stw	zero,-16(fp)
	}
	return lReturn;
 2007cd0:	e0bffc17 	ldw	r2,-16(fp)
}
 2007cd4:	e037883a 	mov	sp,fp
 2007cd8:	dfc00117 	ldw	ra,4(sp)
 2007cdc:	df000017 	ldw	fp,0(sp)
 2007ce0:	dec00204 	addi	sp,sp,8
 2007ce4:	f800283a 	ret

02007ce8 <vSerialPutString>:
/*---------------------------------------------------------------------------*/

void vSerialPutString( xComPortHandle pxPort, const signed char * const pcString, unsigned short usStringLength )
{
 2007ce8:	defffa04 	addi	sp,sp,-24
 2007cec:	dfc00515 	stw	ra,20(sp)
 2007cf0:	df000415 	stw	fp,16(sp)
 2007cf4:	df000404 	addi	fp,sp,16
 2007cf8:	e13ffd15 	stw	r4,-12(fp)
 2007cfc:	e17ffe15 	stw	r5,-8(fp)
 2007d00:	3005883a 	mov	r2,r6
 2007d04:	e0bfff0d 	sth	r2,-4(fp)

	/* The port handle is not required as this driver only supports UART0. */
	( void ) pxPort;

	/* Send each character in the string, one at a time. */
	pxNext = ( signed char * ) pcString;
 2007d08:	e0bffe17 	ldw	r2,-8(fp)
 2007d0c:	e0bffc15 	stw	r2,-16(fp)
	while( *pxNext )
 2007d10:	00000c06 	br	2007d44 <vSerialPutString+0x5c>
	{
		xSerialPutChar( pxPort, *pxNext, serNO_BLOCK );
 2007d14:	e0bffc17 	ldw	r2,-16(fp)
 2007d18:	10800003 	ldbu	r2,0(r2)
 2007d1c:	10803fcc 	andi	r2,r2,255
 2007d20:	1080201c 	xori	r2,r2,128
 2007d24:	10bfe004 	addi	r2,r2,-128
 2007d28:	000d883a 	mov	r6,zero
 2007d2c:	100b883a 	mov	r5,r2
 2007d30:	e13ffd17 	ldw	r4,-12(fp)
 2007d34:	2007c540 	call	2007c54 <xSerialPutChar>
		pxNext++;
 2007d38:	e0bffc17 	ldw	r2,-16(fp)
 2007d3c:	10800044 	addi	r2,r2,1
 2007d40:	e0bffc15 	stw	r2,-16(fp)
	/* The port handle is not required as this driver only supports UART0. */
	( void ) pxPort;

	/* Send each character in the string, one at a time. */
	pxNext = ( signed char * ) pcString;
	while( *pxNext )
 2007d44:	e0bffc17 	ldw	r2,-16(fp)
 2007d48:	10800003 	ldbu	r2,0(r2)
 2007d4c:	10803fcc 	andi	r2,r2,255
 2007d50:	1080201c 	xori	r2,r2,128
 2007d54:	10bfe004 	addi	r2,r2,-128
 2007d58:	103fee1e 	bne	r2,zero,2007d14 <__reset+0xfe006d14>
	{
		xSerialPutChar( pxPort, *pxNext, serNO_BLOCK );
		pxNext++;
	}
}
 2007d5c:	0001883a 	nop
 2007d60:	e037883a 	mov	sp,fp
 2007d64:	dfc00117 	ldw	ra,4(sp)
 2007d68:	df000017 	ldw	fp,0(sp)
 2007d6c:	dec00204 	addi	sp,sp,8
 2007d70:	f800283a 	ret

02007d74 <vUARTInterruptHandler>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void vUARTInterruptHandler(void* context)
#else
static void vUARTInterruptHandler(void* context, alt_u32 id)
#endif
{
 2007d74:	defffc04 	addi	sp,sp,-16
 2007d78:	dfc00315 	stw	ra,12(sp)
 2007d7c:	df000215 	stw	fp,8(sp)
 2007d80:	df000204 	addi	fp,sp,8
 2007d84:	e13fff15 	stw	r4,-4(fp)
	alt_u32 status;

	/* Read the status register in order to determine the cause of the
    interrupt. */
	status = IORD_ALTERA_AVALON_UART_STATUS( UART_BASE );
 2007d88:	00810134 	movhi	r2,1028
 2007d8c:	10881204 	addi	r2,r2,8264
 2007d90:	10800037 	ldwio	r2,0(r2)
 2007d94:	e0bffe15 	stw	r2,-8(fp)

	/* Clear any error flags set at the device */
	IOWR_ALTERA_AVALON_UART_STATUS( UART_BASE, 0 );
 2007d98:	0007883a 	mov	r3,zero
 2007d9c:	00810134 	movhi	r2,1028
 2007da0:	10881204 	addi	r2,r2,8264
 2007da4:	10c00035 	stwio	r3,0(r2)

	/* process a read irq */
	if ( status & ALTERA_AVALON_UART_STATUS_RRDY_MSK )
 2007da8:	e0bffe17 	ldw	r2,-8(fp)
 2007dac:	1080200c 	andi	r2,r2,128
 2007db0:	10000226 	beq	r2,zero,2007dbc <vUARTInterruptHandler+0x48>
	{
		vUARTReceiveHandler( status );
 2007db4:	e13ffe17 	ldw	r4,-8(fp)
 2007db8:	2007de80 	call	2007de8 <vUARTReceiveHandler>
	}

	/* process a write irq */
	if ( status & ( ALTERA_AVALON_UART_STATUS_TRDY_MSK  ) )
 2007dbc:	e0bffe17 	ldw	r2,-8(fp)
 2007dc0:	1080100c 	andi	r2,r2,64
 2007dc4:	10000226 	beq	r2,zero,2007dd0 <vUARTInterruptHandler+0x5c>
	{
		vUARTTransmitHandler( status );
 2007dc8:	e13ffe17 	ldw	r4,-8(fp)
 2007dcc:	2007e8c0 	call	2007e8c <vUARTTransmitHandler>
	}
}
 2007dd0:	0001883a 	nop
 2007dd4:	e037883a 	mov	sp,fp
 2007dd8:	dfc00117 	ldw	ra,4(sp)
 2007ddc:	df000017 	ldw	fp,0(sp)
 2007de0:	dec00204 	addi	sp,sp,8
 2007de4:	f800283a 	ret

02007de8 <vUARTReceiveHandler>:
/*---------------------------------------------------------------------------*/

static void vUARTReceiveHandler( alt_u32 status )
{
 2007de8:	defffb04 	addi	sp,sp,-20
 2007dec:	dfc00415 	stw	ra,16(sp)
 2007df0:	df000315 	stw	fp,12(sp)
 2007df4:	df000304 	addi	fp,sp,12
 2007df8:	e13fff15 	stw	r4,-4(fp)
	signed char cChar;
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 2007dfc:	e03ffe15 	stw	zero,-8(fp)

	/* If there was an error, discard the data */
	if ( status & ( ALTERA_AVALON_UART_STATUS_PE_MSK | ALTERA_AVALON_UART_STATUS_FE_MSK ) )
 2007e00:	e0bfff17 	ldw	r2,-4(fp)
 2007e04:	108000cc 	andi	r2,r2,3
 2007e08:	10000226 	beq	r2,zero,2007e14 <vUARTReceiveHandler+0x2c>
	{
		asm("break");
 2007e0c:	003da03a 	break	0
 2007e10:	00001906 	br	2007e78 <vUARTReceiveHandler+0x90>
		return;
	}

	/* Transfer data from the device to the circular buffer */
	cChar = IORD_ALTERA_AVALON_UART_RXDATA( UART_BASE );
 2007e14:	00810134 	movhi	r2,1028
 2007e18:	10881004 	addi	r2,r2,8256
 2007e1c:	10800037 	ldwio	r2,0(r2)
 2007e20:	e0bffd05 	stb	r2,-12(fp)
	if ( pdTRUE != xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken ) )
 2007e24:	d0a07d17 	ldw	r2,-32268(gp)
 2007e28:	e0fffe04 	addi	r3,fp,-8
 2007e2c:	000f883a 	mov	r7,zero
 2007e30:	180d883a 	mov	r6,r3
 2007e34:	e17ffd04 	addi	r5,fp,-12
 2007e38:	1009883a 	mov	r4,r2
 2007e3c:	20049240 	call	2004924 <xQueueGenericSendFromISR>
 2007e40:	10800060 	cmpeqi	r2,r2,1
 2007e44:	1000091e 	bne	r2,zero,2007e6c <vUARTReceiveHandler+0x84>
	{
		/* If the circular buffer was full, disable interrupts. Interrupts will
        be re-enabled when data is removed from the buffer. */
		uartControl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 2007e48:	d0e07f17 	ldw	r3,-32260(gp)
 2007e4c:	00bfdfc4 	movi	r2,-129
 2007e50:	1884703a 	and	r2,r3,r2
 2007e54:	d0a07f15 	stw	r2,-32260(gp)
		IOWR_ALTERA_AVALON_UART_CONTROL( UART_BASE, uartControl );
 2007e58:	d0a07f17 	ldw	r2,-32260(gp)
 2007e5c:	1007883a 	mov	r3,r2
 2007e60:	00810134 	movhi	r2,1028
 2007e64:	10881304 	addi	r2,r2,8268
 2007e68:	10c00035 	stwio	r3,0(r2)
	}

	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
 2007e6c:	e0bffe17 	ldw	r2,-8(fp)
 2007e70:	10000126 	beq	r2,zero,2007e78 <vUARTReceiveHandler+0x90>
 2007e74:	20064680 	call	2006468 <vTaskSwitchContext>
}
 2007e78:	e037883a 	mov	sp,fp
 2007e7c:	dfc00117 	ldw	ra,4(sp)
 2007e80:	df000017 	ldw	fp,0(sp)
 2007e84:	dec00204 	addi	sp,sp,8
 2007e88:	f800283a 	ret

02007e8c <vUARTTransmitHandler>:
/*---------------------------------------------------------------------------*/

static void vUARTTransmitHandler( alt_u32 status )
{
 2007e8c:	defffb04 	addi	sp,sp,-20
 2007e90:	dfc00415 	stw	ra,16(sp)
 2007e94:	df000315 	stw	fp,12(sp)
 2007e98:	df000304 	addi	fp,sp,12
 2007e9c:	e13fff15 	stw	r4,-4(fp)
	signed char cChar;
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 2007ea0:	e03ffe15 	stw	zero,-8(fp)
	/* Transfer data if there is some ready to be transferred */
	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &xHigherPriorityTaskWoken ) == pdTRUE )
 2007ea4:	d0a07e17 	ldw	r2,-32264(gp)
 2007ea8:	e0fffe04 	addi	r3,fp,-8
 2007eac:	180d883a 	mov	r6,r3
 2007eb0:	e17ffd04 	addi	r5,fp,-12
 2007eb4:	1009883a 	mov	r4,r2
 2007eb8:	2004d1c0 	call	2004d1c <xQueueReceiveFromISR>
 2007ebc:	10800058 	cmpnei	r2,r2,1
 2007ec0:	1000081e 	bne	r2,zero,2007ee4 <vUARTTransmitHandler+0x58>
	{
		IOWR_ALTERA_AVALON_UART_TXDATA( UART_BASE, cChar );
 2007ec4:	e0bffd03 	ldbu	r2,-12(fp)
 2007ec8:	10c03fcc 	andi	r3,r2,255
 2007ecc:	18c0201c 	xori	r3,r3,128
 2007ed0:	18ffe004 	addi	r3,r3,-128
 2007ed4:	00810134 	movhi	r2,1028
 2007ed8:	10881104 	addi	r2,r2,8260
 2007edc:	10c00035 	stwio	r3,0(r2)
 2007ee0:	00000406 	br	2007ef4 <vUARTTransmitHandler+0x68>
	}
	else
	{
		uartControl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 2007ee4:	d0e07f17 	ldw	r3,-32260(gp)
 2007ee8:	00bfefc4 	movi	r2,-65
 2007eec:	1884703a 	and	r2,r3,r2
 2007ef0:	d0a07f15 	stw	r2,-32260(gp)
	}

	IOWR_ALTERA_AVALON_UART_CONTROL( UART_BASE, uartControl );
 2007ef4:	d0a07f17 	ldw	r2,-32260(gp)
 2007ef8:	1007883a 	mov	r3,r2
 2007efc:	00810134 	movhi	r2,1028
 2007f00:	10881304 	addi	r2,r2,8268
 2007f04:	10c00035 	stwio	r3,0(r2)
	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
 2007f08:	e0bffe17 	ldw	r2,-8(fp)
 2007f0c:	10000126 	beq	r2,zero,2007f14 <vUARTTransmitHandler+0x88>
 2007f10:	20064680 	call	2006468 <vTaskSwitchContext>
}
 2007f14:	0001883a 	nop
 2007f18:	e037883a 	mov	sp,fp
 2007f1c:	dfc00117 	ldw	ra,4(sp)
 2007f20:	df000017 	ldw	fp,0(sp)
 2007f24:	dec00204 	addi	sp,sp,8
 2007f28:	f800283a 	ret

02007f2c <main>:

//-----------------------------------------------------------------------
// Main Function
//-----------------------------------------------------------------------
int main()
{
 2007f2c:	defffc04 	addi	sp,sp,-16
 2007f30:	dfc00315 	stw	ra,12(sp)
 2007f34:	df000215 	stw	fp,8(sp)
 2007f38:	df000204 	addi	fp,sp,8
	vParTestInitialise();
 2007f3c:	200371c0 	call	200371c <vParTestInitialise>
	printf("Inicializando programa...\n");
 2007f40:	01008074 	movhi	r4,513
 2007f44:	2108c204 	addi	r4,r4,8968
 2007f48:	200b2680 	call	200b268 <puts>

	//Se escribe 0 por los puertos de PWM
	IOWR(PARALLEL_PORT_0_BASE, ALT_UP_PARALLEL_PORT_DATA, 0);
 2007f4c:	0007883a 	mov	r3,zero
 2007f50:	008100b4 	movhi	r2,1026
 2007f54:	10881004 	addi	r2,r2,8256
 2007f58:	10c00035 	stwio	r3,0(r2)
	IOWR(PARALLEL_PORT_1_BASE, ALT_UP_PARALLEL_PORT_DATA, 0);
 2007f5c:	0007883a 	mov	r3,zero
 2007f60:	008100f4 	movhi	r2,1027
 2007f64:	10881004 	addi	r2,r2,8256
 2007f68:	10c00035 	stwio	r3,0(r2)

	//Se selecciona la direccion de los motores hacia adelante
	portlog = portlog & ~(1<<DIR_IZQ_B);
 2007f6c:	d0e08017 	ldw	r3,-32256(gp)
 2007f70:	00bfff44 	movi	r2,-3
 2007f74:	1884703a 	and	r2,r3,r2
 2007f78:	d0a08015 	stw	r2,-32256(gp)
	portlog = portlog & ~(1<<DIR_DER_A);
 2007f7c:	d0e08017 	ldw	r3,-32256(gp)
 2007f80:	00bfff84 	movi	r2,-2
 2007f84:	1884703a 	and	r2,r3,r2
 2007f88:	d0a08015 	stw	r2,-32256(gp)
	IOWR(IO_PIO1_BASE, ALT_UP_PARALLEL_PORT_DATA, portlog);
 2007f8c:	d0a08017 	ldw	r2,-32256(gp)
 2007f90:	1007883a 	mov	r3,r2
 2007f94:	00810074 	movhi	r2,1025
 2007f98:	10881004 	addi	r2,r2,8256
 2007f9c:	10c00035 	stwio	r3,0(r2)

	//Se crea el semaforo para controlar la escritura sobre los GPIO
	xSemaphore = xSemaphoreCreateMutex();
 2007fa0:	01000044 	movi	r4,1
 2007fa4:	20045880 	call	2004588 <xQueueCreateMutex>
 2007fa8:	d0a08515 	stw	r2,-32236(gp)

	//Creacion de las tareas
	xTaskCreate( TaskRegleta, "Task1", 1200, NULL, TaskRegleta_PRIORITY, NULL );
 2007fac:	d8000115 	stw	zero,4(sp)
 2007fb0:	008000c4 	movi	r2,3
 2007fb4:	d8800015 	stw	r2,0(sp)
 2007fb8:	000f883a 	mov	r7,zero
 2007fbc:	01812c04 	movi	r6,1200
 2007fc0:	01408074 	movhi	r5,513
 2007fc4:	2948c904 	addi	r5,r5,8996
 2007fc8:	01008074 	movhi	r4,513
 2007fcc:	21205d04 	addi	r4,r4,-32396
 2007fd0:	20053c80 	call	20053c8 <xTaskCreate>
	xTaskCreate( TaskSensoresLinea, "Task2", 1200, NULL, TaskSensoresLinea_PRIORITY, NULL );
 2007fd4:	d8000115 	stw	zero,4(sp)
 2007fd8:	008000c4 	movi	r2,3
 2007fdc:	d8800015 	stw	r2,0(sp)
 2007fe0:	000f883a 	mov	r7,zero
 2007fe4:	01812c04 	movi	r6,1200
 2007fe8:	01408074 	movhi	r5,513
 2007fec:	2948cb04 	addi	r5,r5,9004
 2007ff0:	01008074 	movhi	r4,513
 2007ff4:	21218c04 	addi	r4,r4,-31184
 2007ff8:	20053c80 	call	20053c8 <xTaskCreate>
	xTaskCreate( TaskActualizarMatriz, "Task3", 1200, NULL, TaskActualizarMatriz_PRIORITY, NULL );
 2007ffc:	d8000115 	stw	zero,4(sp)
 2008000:	008000c4 	movi	r2,3
 2008004:	d8800015 	stw	r2,0(sp)
 2008008:	000f883a 	mov	r7,zero
 200800c:	01812c04 	movi	r6,1200
 2008010:	01408074 	movhi	r5,513
 2008014:	2948cd04 	addi	r5,r5,9012
 2008018:	01008074 	movhi	r4,513
 200801c:	2121cd04 	addi	r4,r4,-30924
 2008020:	20053c80 	call	20053c8 <xTaskCreate>
	xTaskCreate( TaskParada, "Task4", 2000, NULL, TaskParada_PRIORITY, NULL );
 2008024:	d8000115 	stw	zero,4(sp)
 2008028:	008000c4 	movi	r2,3
 200802c:	d8800015 	stw	r2,0(sp)
 2008030:	000f883a 	mov	r7,zero
 2008034:	0181f404 	movi	r6,2000
 2008038:	01408074 	movhi	r5,513
 200803c:	2948cf04 	addi	r5,r5,9020
 2008040:	01008074 	movhi	r4,513
 2008044:	21229b04 	addi	r4,r4,-30100
 2008048:	20053c80 	call	20053c8 <xTaskCreate>
	xTaskCreate( TaskRESET, "Task5", 1024, NULL, TaskRESET_PRIORITY, NULL );
 200804c:	d8000115 	stw	zero,4(sp)
 2008050:	008000c4 	movi	r2,3
 2008054:	d8800015 	stw	r2,0(sp)
 2008058:	000f883a 	mov	r7,zero
 200805c:	01810004 	movi	r6,1024
 2008060:	01408074 	movhi	r5,513
 2008064:	2948d104 	addi	r5,r5,9028
 2008068:	01008074 	movhi	r4,513
 200806c:	2122bb04 	addi	r4,r4,-29972
 2008070:	20053c80 	call	20053c8 <xTaskCreate>
	xTaskCreate( TaskLEDS, "Task6", 1024, NULL, TaskLEDS_PRIORITY, NULL );
 2008074:	d8000115 	stw	zero,4(sp)
 2008078:	008000c4 	movi	r2,3
 200807c:	d8800015 	stw	r2,0(sp)
 2008080:	000f883a 	mov	r7,zero
 2008084:	01810004 	movi	r6,1024
 2008088:	01408074 	movhi	r5,513
 200808c:	2948d304 	addi	r5,r5,9036
 2008090:	01008074 	movhi	r4,513
 2008094:	2122de04 	addi	r4,r4,-29832
 2008098:	20053c80 	call	20053c8 <xTaskCreate>

	//Se selecciona la direccion (lectura o escritura) de los GPIO
	IOWR_ALT_UP_PARALLEL_PORT_DIRECTION( IO_PIO_BASE, 0x0 );
 200809c:	0007883a 	mov	r3,zero
 20080a0:	00810034 	movhi	r2,1024
 20080a4:	10881104 	addi	r2,r2,8260
 20080a8:	10c00035 	stwio	r3,0(r2)
	IOWR_ALT_UP_PARALLEL_PORT_DIRECTION( IO_PIO1_BASE, 0xFFFFFFFF );
 20080ac:	00ffffc4 	movi	r3,-1
 20080b0:	00810074 	movhi	r2,1025
 20080b4:	10881104 	addi	r2,r2,8260
 20080b8:	10c00035 	stwio	r3,0(r2)

	//Inicializacion de la matriz LED con la libreria
	max7219_int(portlog);
 20080bc:	d0a08017 	ldw	r2,-32256(gp)
 20080c0:	1009883a 	mov	r4,r2
 20080c4:	20079300 	call	2007930 <max7219_int>
	sen_2_byte_info(portlog,ADDR_SHUTDOWN,NORMAL_OPERATION);
 20080c8:	d0a08017 	ldw	r2,-32256(gp)
 20080cc:	01800044 	movi	r6,1
 20080d0:	01400304 	movi	r5,12
 20080d4:	1009883a 	mov	r4,r2
 20080d8:	20079fc0 	call	20079fc <sen_2_byte_info>
	sen_2_byte_info(portlog,ADDR_SCAN_LIMIT,DIS_DIG_0_7);
 20080dc:	d0a08017 	ldw	r2,-32256(gp)
 20080e0:	018001c4 	movi	r6,7
 20080e4:	014002c4 	movi	r5,11
 20080e8:	1009883a 	mov	r4,r2
 20080ec:	20079fc0 	call	20079fc <sen_2_byte_info>
	sen_2_byte_info(portlog,ADDR_INTENSITY,INTENSITY_31_32);
 20080f0:	d0a08017 	ldw	r2,-32256(gp)
 20080f4:	018003c4 	movi	r6,15
 20080f8:	01400284 	movi	r5,10
 20080fc:	1009883a 	mov	r4,r2
 2008100:	20079fc0 	call	20079fc <sen_2_byte_info>
	sen_2_byte_info(portlog,ADDR_DECODE_MODE,NO_DECODE_7_0);
 2008104:	d0a08017 	ldw	r2,-32256(gp)
 2008108:	000d883a 	mov	r6,zero
 200810c:	01400244 	movi	r5,9
 2008110:	1009883a 	mov	r4,r2
 2008114:	20079fc0 	call	20079fc <sen_2_byte_info>
	sen_2_byte_info(portlog,ADDR_DISPLAY_TEST,NORMAL_OPETAION_MODE);
 2008118:	d0a08017 	ldw	r2,-32256(gp)
 200811c:	000d883a 	mov	r6,zero
 2008120:	014003c4 	movi	r5,15
 2008124:	1009883a 	mov	r4,r2
 2008128:	20079fc0 	call	20079fc <sen_2_byte_info>

	//Se incia la matriz en 0
	matriz[0] = numeros[0];
 200812c:	0005883a 	mov	r2,zero
 2008130:	d0a08805 	stb	r2,-32224(gp)
	matriz[1] = numeros[0];
 2008134:	0005883a 	mov	r2,zero
 2008138:	d0a08845 	stb	r2,-32223(gp)
	matriz[2] = numeros[0];
 200813c:	0005883a 	mov	r2,zero
 2008140:	d0a08885 	stb	r2,-32222(gp)
	matriz[3] = numeros[0];
 2008144:	0005883a 	mov	r2,zero
 2008148:	d0a088c5 	stb	r2,-32221(gp)
	matriz[4] = numeros[0];
 200814c:	0005883a 	mov	r2,zero
 2008150:	d0a08905 	stb	r2,-32220(gp)
	matriz[5] = numeros[0];
 2008154:	0005883a 	mov	r2,zero
 2008158:	d0a08945 	stb	r2,-32219(gp)
	matriz[6] = numeros[0];
 200815c:	0005883a 	mov	r2,zero
 2008160:	d0a08985 	stb	r2,-32218(gp)
	matriz[7] = numeros[0];
 2008164:	0005883a 	mov	r2,zero
 2008168:	d0a089c5 	stb	r2,-32217(gp)

	/* Finally start the scheduler. */
	vTaskStartScheduler();
 200816c:	2005f6c0 	call	2005f6c <vTaskStartScheduler>

	/* Will only reach here if there is insufficient heap available to start
	the scheduler. */
	for( ;; );
 2008170:	003fff06 	br	2008170 <__reset+0xfe007170>

02008174 <TaskRegleta>:

	return 0;
}
/*-----------------------------------------------------------*/
static void TaskRegleta( void *pvParameters )
{
 2008174:	deffe204 	addi	sp,sp,-120
 2008178:	dfc01d15 	stw	ra,116(sp)
 200817c:	df001c15 	stw	fp,112(sp)
 2008180:	dc401b15 	stw	r17,108(sp)
 2008184:	dc001a15 	stw	r16,104(sp)
 2008188:	df001c04 	addi	fp,sp,112
 200818c:	e13ffd15 	stw	r4,-12(fp)
	for( ;; )
	{
		//Se leen los datos de la regleta de sensores
		int datosSensores = IORD_ALT_UP_PARALLEL_PORT_DATA(IO_PIO_BASE);
 2008190:	00810034 	movhi	r2,1024
 2008194:	10881004 	addi	r2,r2,8256
 2008198:	10800037 	ldwio	r2,0(r2)
 200819c:	e0bfe615 	stw	r2,-104(fp)
		char buffer[32];//Buffer para convertir los datos a binario
		itoa(datosSensores,buffer,2);//Conversion de los datos a binario
 20081a0:	e0bff504 	addi	r2,fp,-44
 20081a4:	01800084 	movi	r6,2
 20081a8:	100b883a 	mov	r5,r2
 20081ac:	e13fe617 	ldw	r4,-104(fp)
 20081b0:	200af340 	call	200af34 <itoa>

		//Se guardan los datos binarios en la variable de valores de sensores
		sensor_values[0] = buffer[23];
 20081b4:	e0bffac3 	ldbu	r2,-21(fp)
 20081b8:	10c03fcc 	andi	r3,r2,255
 20081bc:	18c0201c 	xori	r3,r3,128
 20081c0:	18ffe004 	addi	r3,r3,-128
 20081c4:	0080a074 	movhi	r2,641
 20081c8:	10917f04 	addi	r2,r2,17916
 20081cc:	10c00015 	stw	r3,0(r2)
		sensor_values[1] = buffer[22];
 20081d0:	e0bffa83 	ldbu	r2,-22(fp)
 20081d4:	10c03fcc 	andi	r3,r2,255
 20081d8:	18c0201c 	xori	r3,r3,128
 20081dc:	18ffe004 	addi	r3,r3,-128
 20081e0:	0080a074 	movhi	r2,641
 20081e4:	10917f04 	addi	r2,r2,17916
 20081e8:	10c00115 	stw	r3,4(r2)
		sensor_values[2] = buffer[21];
 20081ec:	e0bffa43 	ldbu	r2,-23(fp)
 20081f0:	10c03fcc 	andi	r3,r2,255
 20081f4:	18c0201c 	xori	r3,r3,128
 20081f8:	18ffe004 	addi	r3,r3,-128
 20081fc:	0080a074 	movhi	r2,641
 2008200:	10917f04 	addi	r2,r2,17916
 2008204:	10c00215 	stw	r3,8(r2)
		sensor_values[3] = buffer[20];
 2008208:	e0bffa03 	ldbu	r2,-24(fp)
 200820c:	10c03fcc 	andi	r3,r2,255
 2008210:	18c0201c 	xori	r3,r3,128
 2008214:	18ffe004 	addi	r3,r3,-128
 2008218:	0080a074 	movhi	r2,641
 200821c:	10917f04 	addi	r2,r2,17916
 2008220:	10c00315 	stw	r3,12(r2)
		sensor_values[4] = buffer[19];
 2008224:	e0bff9c3 	ldbu	r2,-25(fp)
 2008228:	10c03fcc 	andi	r3,r2,255
 200822c:	18c0201c 	xori	r3,r3,128
 2008230:	18ffe004 	addi	r3,r3,-128
 2008234:	0080a074 	movhi	r2,641
 2008238:	10917f04 	addi	r2,r2,17916
 200823c:	10c00415 	stw	r3,16(r2)
		sensor_values[5] = buffer[18];
 2008240:	e0bff983 	ldbu	r2,-26(fp)
 2008244:	10c03fcc 	andi	r3,r2,255
 2008248:	18c0201c 	xori	r3,r3,128
 200824c:	18ffe004 	addi	r3,r3,-128
 2008250:	0080a074 	movhi	r2,641
 2008254:	10917f04 	addi	r2,r2,17916
 2008258:	10c00515 	stw	r3,20(r2)
		sensor_values[6] = buffer[17];
 200825c:	e0bff943 	ldbu	r2,-27(fp)
 2008260:	10c03fcc 	andi	r3,r2,255
 2008264:	18c0201c 	xori	r3,r3,128
 2008268:	18ffe004 	addi	r3,r3,-128
 200826c:	0080a074 	movhi	r2,641
 2008270:	10917f04 	addi	r2,r2,17916
 2008274:	10c00615 	stw	r3,24(r2)
		sensor_values[7] = buffer[16];
 2008278:	e0bff903 	ldbu	r2,-28(fp)
 200827c:	10c03fcc 	andi	r3,r2,255
 2008280:	18c0201c 	xori	r3,r3,128
 2008284:	18ffe004 	addi	r3,r3,-128
 2008288:	0080a074 	movhi	r2,641
 200828c:	10917f04 	addi	r2,r2,17916
 2008290:	10c00715 	stw	r3,28(r2)


		char bufferprim[20];
		char bufferseg[20];

		itoa(PWM_izq, bufferprim, 10 );
 2008294:	d0a00e17 	ldw	r2,-32712(gp)
 2008298:	e0ffeb04 	addi	r3,fp,-84
 200829c:	01800284 	movi	r6,10
 20082a0:	180b883a 	mov	r5,r3
 20082a4:	1009883a 	mov	r4,r2
 20082a8:	200af340 	call	200af34 <itoa>
		itoa(PWM_izq, bufferseg, 10 );
 20082ac:	d0a00e17 	ldw	r2,-32712(gp)
 20082b0:	e0fff004 	addi	r3,fp,-64
 20082b4:	01800284 	movi	r6,10
 20082b8:	180b883a 	mov	r5,r3
 20082bc:	1009883a 	mov	r4,r2
 20082c0:	200af340 	call	200af34 <itoa>

		for(int i=0;i<strlen(bufferprim);i++)
 20082c4:	e03fe415 	stw	zero,-112(fp)
 20082c8:	00000f06 	br	2008308 <TaskRegleta+0x194>
		{
			IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,bufferprim[i]);
 20082cc:	e0ffeb04 	addi	r3,fp,-84
 20082d0:	e0bfe417 	ldw	r2,-112(fp)
 20082d4:	1885883a 	add	r2,r3,r2
 20082d8:	10800003 	ldbu	r2,0(r2)
 20082dc:	10c03fcc 	andi	r3,r2,255
 20082e0:	18c0201c 	xori	r3,r3,128
 20082e4:	18ffe004 	addi	r3,r3,-128
 20082e8:	00810034 	movhi	r2,1024
 20082ec:	10880104 	addi	r2,r2,8196
 20082f0:	10c00035 	stwio	r3,0(r2)
			usleep(100);
 20082f4:	01001904 	movi	r4,100
 20082f8:	200e6f40 	call	200e6f4 <usleep>
		char bufferseg[20];

		itoa(PWM_izq, bufferprim, 10 );
		itoa(PWM_izq, bufferseg, 10 );

		for(int i=0;i<strlen(bufferprim);i++)
 20082fc:	e0bfe417 	ldw	r2,-112(fp)
 2008300:	10800044 	addi	r2,r2,1
 2008304:	e0bfe415 	stw	r2,-112(fp)
 2008308:	e0bfeb04 	addi	r2,fp,-84
 200830c:	1009883a 	mov	r4,r2
 2008310:	200b3900 	call	200b390 <strlen>
 2008314:	1007883a 	mov	r3,r2
 2008318:	e0bfe417 	ldw	r2,-112(fp)
 200831c:	10ffeb36 	bltu	r2,r3,20082cc <__reset+0xfe0072cc>
		{
			IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,bufferprim[i]);
			usleep(100);
		}

		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,'\t');
 2008320:	00c00244 	movi	r3,9
 2008324:	00810034 	movhi	r2,1024
 2008328:	10880104 	addi	r2,r2,8196
 200832c:	10c00035 	stwio	r3,0(r2)

		for(int i=0;i<strlen(bufferprim);i++)
 2008330:	e03fe515 	stw	zero,-108(fp)
 2008334:	00000f06 	br	2008374 <TaskRegleta+0x200>
		{
			IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,bufferprim[i]);
 2008338:	e0ffeb04 	addi	r3,fp,-84
 200833c:	e0bfe517 	ldw	r2,-108(fp)
 2008340:	1885883a 	add	r2,r3,r2
 2008344:	10800003 	ldbu	r2,0(r2)
 2008348:	10c03fcc 	andi	r3,r2,255
 200834c:	18c0201c 	xori	r3,r3,128
 2008350:	18ffe004 	addi	r3,r3,-128
 2008354:	00810034 	movhi	r2,1024
 2008358:	10880104 	addi	r2,r2,8196
 200835c:	10c00035 	stwio	r3,0(r2)
			usleep(100);
 2008360:	01001904 	movi	r4,100
 2008364:	200e6f40 	call	200e6f4 <usleep>
			usleep(100);
		}

		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,'\t');

		for(int i=0;i<strlen(bufferprim);i++)
 2008368:	e0bfe517 	ldw	r2,-108(fp)
 200836c:	10800044 	addi	r2,r2,1
 2008370:	e0bfe515 	stw	r2,-108(fp)
 2008374:	e0bfeb04 	addi	r2,fp,-84
 2008378:	1009883a 	mov	r4,r2
 200837c:	200b3900 	call	200b390 <strlen>
 2008380:	1007883a 	mov	r3,r2
 2008384:	e0bfe517 	ldw	r2,-108(fp)
 2008388:	10ffeb36 	bltu	r2,r3,2008338 <__reset+0xfe007338>
		{
			IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,bufferprim[i]);
			usleep(100);
		}

		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,'\n');
 200838c:	00c00284 	movi	r3,10
 2008390:	00810034 	movhi	r2,1024
 2008394:	10880104 	addi	r2,r2,8196
 2008398:	10c00035 	stwio	r3,0(r2)

		//CONTROLADOR PID//

		int error = calcularError();//Calculo del error
 200839c:	2008d100 	call	2008d10 <calcularError>
 20083a0:	e0bfe715 	stw	r2,-100(fp)
		double velocidadCalculadaDouble = Kp * error + Kd * (error - errorPasado);//Calculo del ajuste de PWM con el error
 20083a4:	e13fe717 	ldw	r4,-100(fp)
 20083a8:	200ad8c0 	call	200ad8c <__floatsidf>
 20083ac:	1011883a 	mov	r8,r2
 20083b0:	1813883a 	mov	r9,r3
 20083b4:	0005883a 	mov	r2,zero
 20083b8:	00d008f4 	movhi	r3,16419
 20083bc:	100d883a 	mov	r6,r2
 20083c0:	180f883a 	mov	r7,r3
 20083c4:	4009883a 	mov	r4,r8
 20083c8:	480b883a 	mov	r5,r9
 20083cc:	200a4a00 	call	200a4a0 <__muldf3>
 20083d0:	1009883a 	mov	r4,r2
 20083d4:	180b883a 	mov	r5,r3
 20083d8:	2021883a 	mov	r16,r4
 20083dc:	2823883a 	mov	r17,r5
 20083e0:	d0a08217 	ldw	r2,-32248(gp)
 20083e4:	e0ffe717 	ldw	r3,-100(fp)
 20083e8:	1885c83a 	sub	r2,r3,r2
 20083ec:	1009883a 	mov	r4,r2
 20083f0:	200ad8c0 	call	200ad8c <__floatsidf>
 20083f4:	1011883a 	mov	r8,r2
 20083f8:	1813883a 	mov	r9,r3
 20083fc:	0005883a 	mov	r2,zero
 2008400:	00d008b4 	movhi	r3,16418
 2008404:	100d883a 	mov	r6,r2
 2008408:	180f883a 	mov	r7,r3
 200840c:	4009883a 	mov	r4,r8
 2008410:	480b883a 	mov	r5,r9
 2008414:	200a4a00 	call	200a4a0 <__muldf3>
 2008418:	1009883a 	mov	r4,r2
 200841c:	180b883a 	mov	r5,r3
 2008420:	2005883a 	mov	r2,r4
 2008424:	2807883a 	mov	r3,r5
 2008428:	100d883a 	mov	r6,r2
 200842c:	180f883a 	mov	r7,r3
 2008430:	8009883a 	mov	r4,r16
 2008434:	880b883a 	mov	r5,r17
 2008438:	2009bf40 	call	2009bf4 <__adddf3>
 200843c:	1009883a 	mov	r4,r2
 2008440:	180b883a 	mov	r5,r3
 2008444:	e13fe815 	stw	r4,-96(fp)
 2008448:	e17fe915 	stw	r5,-92(fp)
		errorPasado = error;//Se guarda el error (controlador derivativo)
 200844c:	e0bfe717 	ldw	r2,-100(fp)
 2008450:	d0a08215 	stw	r2,-32248(gp)

		int velocidadCalculada = (int) velocidadCalculadaDouble;//Se convierte la velocidad a un numero entero
 2008454:	e13fe817 	ldw	r4,-96(fp)
 2008458:	e17fe917 	ldw	r5,-92(fp)
 200845c:	200ad0c0 	call	200ad0c <__fixdfsi>
 2008460:	e0bfea15 	stw	r2,-88(fp)

		PWM_izq= velocidadBase + velocidadCalculada;//Se ajusta el PWM de la izquierda
 2008464:	00c02804 	movi	r3,160
 2008468:	e0bfea17 	ldw	r2,-88(fp)
 200846c:	1885883a 	add	r2,r3,r2
 2008470:	d0a00e15 	stw	r2,-32712(gp)
		PWM_der = velocidadBase - velocidadCalculada;//Se ajusta el PWM de la derecha
 2008474:	00c02804 	movi	r3,160
 2008478:	e0bfea17 	ldw	r2,-88(fp)
 200847c:	1885c83a 	sub	r2,r3,r2
 2008480:	d0a00f15 	stw	r2,-32708(gp)

		if (PWM_der > velocidadMaxima ) PWM_der = velocidadMaxima;//Se corrije si el PWM es mayor al maximo
 2008484:	d0a00f17 	ldw	r2,-32708(gp)
 2008488:	00c03e44 	movi	r3,249
 200848c:	1880020e 	bge	r3,r2,2008498 <TaskRegleta+0x324>
 2008490:	00803e44 	movi	r2,249
 2008494:	d0a00f15 	stw	r2,-32708(gp)
		if (PWM_izq > velocidadMaxima ) PWM_izq = velocidadMaxima;//Se corrije si el PWM es mayor al maximo
 2008498:	d0a00e17 	ldw	r2,-32712(gp)
 200849c:	00c03e44 	movi	r3,249
 20084a0:	1880020e 	bge	r3,r2,20084ac <TaskRegleta+0x338>
 20084a4:	00803e44 	movi	r2,249
 20084a8:	d0a00e15 	stw	r2,-32712(gp)
		if (PWM_der < 0) PWM_der = 0;//Se corrije si el PWM es menor a 0
 20084ac:	d0a00f17 	ldw	r2,-32708(gp)
 20084b0:	1000010e 	bge	r2,zero,20084b8 <TaskRegleta+0x344>
 20084b4:	d0200f15 	stw	zero,-32708(gp)
		if (PWM_izq < 0) PWM_izq = 0;//Se corrije si el PWM es menor a 0
 20084b8:	d0a00e17 	ldw	r2,-32712(gp)
 20084bc:	1000010e 	bge	r2,zero,20084c4 <TaskRegleta+0x350>
 20084c0:	d0200e15 	stw	zero,-32712(gp)

		//ESCRITURA DE PWM//
		if( xSemaphoreTake( xSemaphore, ( TickType_t ) 50 ) == pdTRUE )//Se intenta obtener permiso para escritura en GPIO
 20084c4:	d0a08517 	ldw	r2,-32236(gp)
 20084c8:	000f883a 	mov	r7,zero
 20084cc:	01800c84 	movi	r6,50
 20084d0:	000b883a 	mov	r5,zero
 20084d4:	1009883a 	mov	r4,r2
 20084d8:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 20084dc:	10800058 	cmpnei	r2,r2,1
 20084e0:	1000501e 	bne	r2,zero,2008624 <TaskRegleta+0x4b0>
		{
			if(!detenerse && !desactivarMotores)//Caso en el que se debe seguir la linea
 20084e4:	d0a08443 	ldbu	r2,-32239(gp)
 20084e8:	1080005c 	xori	r2,r2,1
 20084ec:	10803fcc 	andi	r2,r2,255
 20084f0:	10001a26 	beq	r2,zero,200855c <TaskRegleta+0x3e8>
 20084f4:	d0a08403 	ldbu	r2,-32240(gp)
 20084f8:	1080005c 	xori	r2,r2,1
 20084fc:	10803fcc 	andi	r2,r2,255
 2008500:	10001626 	beq	r2,zero,200855c <TaskRegleta+0x3e8>
			{
				portlog = portlog & ~(1<<DIR_IZQ_B);//Motor izquierdo hacia adelante
 2008504:	d0e08017 	ldw	r3,-32256(gp)
 2008508:	00bfff44 	movi	r2,-3
 200850c:	1884703a 	and	r2,r3,r2
 2008510:	d0a08015 	stw	r2,-32256(gp)
				portlog = portlog & ~(1<<DIR_DER_A);//Motor derecho hacia adelante
 2008514:	d0e08017 	ldw	r3,-32256(gp)
 2008518:	00bfff84 	movi	r2,-2
 200851c:	1884703a 	and	r2,r3,r2
 2008520:	d0a08015 	stw	r2,-32256(gp)

				IOWR(IO_PIO1_BASE, ALT_UP_PARALLEL_PORT_DATA, portlog);//Escritura en el GPIO
 2008524:	d0a08017 	ldw	r2,-32256(gp)
 2008528:	1007883a 	mov	r3,r2
 200852c:	00810074 	movhi	r2,1025
 2008530:	10881004 	addi	r2,r2,8256
 2008534:	10c00035 	stwio	r3,0(r2)

				IOWR(PARALLEL_PORT_0_BASE, ALT_UP_PARALLEL_PORT_DATA, PWM_izq);//Se actualiza el PWM
 2008538:	d0e00e17 	ldw	r3,-32712(gp)
 200853c:	008100b4 	movhi	r2,1026
 2008540:	10881004 	addi	r2,r2,8256
 2008544:	10c00035 	stwio	r3,0(r2)
				IOWR(PARALLEL_PORT_1_BASE, ALT_UP_PARALLEL_PORT_DATA, PWM_der);
 2008548:	d0e00f17 	ldw	r3,-32708(gp)
 200854c:	008100f4 	movhi	r2,1027
 2008550:	10881004 	addi	r2,r2,8256
 2008554:	10c00035 	stwio	r3,0(r2)
 2008558:	00002c06 	br	200860c <TaskRegleta+0x498>
			}
			else if(desactivarMotores)//Caso en el que hay reset
 200855c:	d0a08403 	ldbu	r2,-32240(gp)
 2008560:	10803fcc 	andi	r2,r2,255
 2008564:	10001626 	beq	r2,zero,20085c0 <TaskRegleta+0x44c>
			{
				portlog = portlog & ~(1<<DIR_IZQ_B);//Motores hacia adelante
 2008568:	d0e08017 	ldw	r3,-32256(gp)
 200856c:	00bfff44 	movi	r2,-3
 2008570:	1884703a 	and	r2,r3,r2
 2008574:	d0a08015 	stw	r2,-32256(gp)
				portlog = portlog & ~(1<<DIR_DER_A);
 2008578:	d0e08017 	ldw	r3,-32256(gp)
 200857c:	00bfff84 	movi	r2,-2
 2008580:	1884703a 	and	r2,r3,r2
 2008584:	d0a08015 	stw	r2,-32256(gp)

				IOWR(IO_PIO1_BASE, ALT_UP_PARALLEL_PORT_DATA, portlog);
 2008588:	d0a08017 	ldw	r2,-32256(gp)
 200858c:	1007883a 	mov	r3,r2
 2008590:	00810074 	movhi	r2,1025
 2008594:	10881004 	addi	r2,r2,8256
 2008598:	10c00035 	stwio	r3,0(r2)

				IOWR(PARALLEL_PORT_0_BASE, ALT_UP_PARALLEL_PORT_DATA, 0);//Se escribe 0 en el PWM
 200859c:	0007883a 	mov	r3,zero
 20085a0:	008100b4 	movhi	r2,1026
 20085a4:	10881004 	addi	r2,r2,8256
 20085a8:	10c00035 	stwio	r3,0(r2)
				IOWR(PARALLEL_PORT_1_BASE, ALT_UP_PARALLEL_PORT_DATA, 0);
 20085ac:	0007883a 	mov	r3,zero
 20085b0:	008100f4 	movhi	r2,1027
 20085b4:	10881004 	addi	r2,r2,8256
 20085b8:	10c00035 	stwio	r3,0(r2)
 20085bc:	00001306 	br	200860c <TaskRegleta+0x498>
			}
			else//Caso en el que se debe detener el carro
			{
				portlog = portlog | (1<<DIR_IZQ_B);//Motores hacia atras
 20085c0:	d0a08017 	ldw	r2,-32256(gp)
 20085c4:	10800094 	ori	r2,r2,2
 20085c8:	d0a08015 	stw	r2,-32256(gp)
				portlog = portlog | (1<<DIR_DER_A);
 20085cc:	d0a08017 	ldw	r2,-32256(gp)
 20085d0:	10800054 	ori	r2,r2,1
 20085d4:	d0a08015 	stw	r2,-32256(gp)

				IOWR(IO_PIO1_BASE, ALT_UP_PARALLEL_PORT_DATA, portlog);
 20085d8:	d0a08017 	ldw	r2,-32256(gp)
 20085dc:	1007883a 	mov	r3,r2
 20085e0:	00810074 	movhi	r2,1025
 20085e4:	10881004 	addi	r2,r2,8256
 20085e8:	10c00035 	stwio	r3,0(r2)

				IOWR(PARALLEL_PORT_0_BASE, ALT_UP_PARALLEL_PORT_DATA, 230);//Se escribe un PWM de 249-230 en reversa
 20085ec:	00c03984 	movi	r3,230
 20085f0:	008100b4 	movhi	r2,1026
 20085f4:	10881004 	addi	r2,r2,8256
 20085f8:	10c00035 	stwio	r3,0(r2)
				IOWR(PARALLEL_PORT_1_BASE, ALT_UP_PARALLEL_PORT_DATA, 230);
 20085fc:	00c03984 	movi	r3,230
 2008600:	008100f4 	movhi	r2,1027
 2008604:	10881004 	addi	r2,r2,8256
 2008608:	10c00035 	stwio	r3,0(r2)
			}
			xSemaphoreGive( xSemaphore );//Se devuelve el semaforo para permitir escritura en otras tareas
 200860c:	d0a08517 	ldw	r2,-32236(gp)
 2008610:	000f883a 	mov	r7,zero
 2008614:	000d883a 	mov	r6,zero
 2008618:	000b883a 	mov	r5,zero
 200861c:	1009883a 	mov	r4,r2
 2008620:	20047700 	call	2004770 <xQueueGenericSend>
		}
		vTaskDelay( TaskRegleta_PERIOD / portTICK_PERIOD_MS);//Periodo de la tarea
 2008624:	01000284 	movi	r4,10
 2008628:	20059600 	call	2005960 <vTaskDelay>
	}
 200862c:	003ed806 	br	2008190 <__reset+0xfe007190>

02008630 <TaskSensoresLinea>:
}
/*-----------------------------------------------------------*/
static void TaskSensoresLinea( void *pvParameters )
{
 2008630:	defff304 	addi	sp,sp,-52
 2008634:	dfc00c15 	stw	ra,48(sp)
 2008638:	df000b15 	stw	fp,44(sp)
 200863c:	df000b04 	addi	fp,sp,44
 2008640:	e13fff15 	stw	r4,-4(fp)
	for( ;; )
	{
		int datosSensores = IORD_ALT_UP_PARALLEL_PORT_DATA(IO_PIO_BASE);
 2008644:	00810034 	movhi	r2,1024
 2008648:	10881004 	addi	r2,r2,8256
 200864c:	10800037 	ldwio	r2,0(r2)
 2008650:	e0bff515 	stw	r2,-44(fp)
		char buffer[32];
		itoa(datosSensores,buffer,2);
 2008654:	e0bff684 	addi	r2,fp,-38
 2008658:	01800084 	movi	r6,2
 200865c:	100b883a 	mov	r5,r2
 2008660:	e13ff517 	ldw	r4,-44(fp)
 2008664:	200af340 	call	200af34 <itoa>

		char datoIzquierda = buffer[30];
 2008668:	e0bffe03 	ldbu	r2,-8(fp)
 200866c:	e0bff605 	stb	r2,-40(fp)
		char datoDerecha = buffer[31];
 2008670:	e0bffe43 	ldbu	r2,-7(fp)
 2008674:	e0bff645 	stb	r2,-39(fp)


		if(datoIzquierda==VERDADERO && !izq)
 2008678:	e0fff607 	ldb	r3,-40(fp)
 200867c:	00800c44 	movi	r2,49
 2008680:	10803fcc 	andi	r2,r2,255
 2008684:	18800a1e 	bne	r3,r2,20086b0 <TaskSensoresLinea+0x80>
 2008688:	d0a08783 	ldbu	r2,-32226(gp)
 200868c:	1080005c 	xori	r2,r2,1
 2008690:	10803fcc 	andi	r2,r2,255
 2008694:	10000626 	beq	r2,zero,20086b0 <TaskSensoresLinea+0x80>
		{
			lineasDerecha++;
 2008698:	d0a00d17 	ldw	r2,-32716(gp)
 200869c:	10800044 	addi	r2,r2,1
 20086a0:	d0a00d15 	stw	r2,-32716(gp)
			izq=true;
 20086a4:	00800044 	movi	r2,1
 20086a8:	d0a08785 	stb	r2,-32226(gp)
 20086ac:	00000806 	br	20086d0 <TaskSensoresLinea+0xa0>
		}
		else if(datoIzquierda==FALSO && izq)
 20086b0:	e0fff607 	ldb	r3,-40(fp)
 20086b4:	00800c04 	movi	r2,48
 20086b8:	10803fcc 	andi	r2,r2,255
 20086bc:	1880041e 	bne	r3,r2,20086d0 <TaskSensoresLinea+0xa0>
 20086c0:	d0a08783 	ldbu	r2,-32226(gp)
 20086c4:	10803fcc 	andi	r2,r2,255
 20086c8:	10000126 	beq	r2,zero,20086d0 <TaskSensoresLinea+0xa0>
		{
			izq=false;
 20086cc:	d0208785 	stb	zero,-32226(gp)
		}

		if(datoDerecha==VERDADERO && !der)
 20086d0:	e0fff647 	ldb	r3,-39(fp)
 20086d4:	00800c44 	movi	r2,49
 20086d8:	10803fcc 	andi	r2,r2,255
 20086dc:	18800a1e 	bne	r3,r2,2008708 <TaskSensoresLinea+0xd8>
 20086e0:	d0a087c3 	ldbu	r2,-32225(gp)
 20086e4:	1080005c 	xori	r2,r2,1
 20086e8:	10803fcc 	andi	r2,r2,255
 20086ec:	10000626 	beq	r2,zero,2008708 <TaskSensoresLinea+0xd8>
		{
			lineasIzquierda++;
 20086f0:	d0a00c17 	ldw	r2,-32720(gp)
 20086f4:	10800044 	addi	r2,r2,1
 20086f8:	d0a00c15 	stw	r2,-32720(gp)
			der=true;
 20086fc:	00800044 	movi	r2,1
 2008700:	d0a087c5 	stb	r2,-32225(gp)
 2008704:	00000806 	br	2008728 <TaskSensoresLinea+0xf8>
		}
		else if(datoDerecha==FALSO && der)
 2008708:	e0fff647 	ldb	r3,-39(fp)
 200870c:	00800c04 	movi	r2,48
 2008710:	10803fcc 	andi	r2,r2,255
 2008714:	1880041e 	bne	r3,r2,2008728 <TaskSensoresLinea+0xf8>
 2008718:	d0a087c3 	ldbu	r2,-32225(gp)
 200871c:	10803fcc 	andi	r2,r2,255
 2008720:	10000126 	beq	r2,zero,2008728 <TaskSensoresLinea+0xf8>
		{
			der=false;
 2008724:	d02087c5 	stb	zero,-32225(gp)
		}


		vTaskDelay( TaskSensoresLinea_PERIOD / portTICK_PERIOD_MS);
 2008728:	01000504 	movi	r4,20
 200872c:	20059600 	call	2005960 <vTaskDelay>
	}
 2008730:	003fc406 	br	2008644 <__reset+0xfe007644>

02008734 <TaskActualizarMatriz>:
}
static void TaskActualizarMatriz( void *pvParameters )
{
 2008734:	defffd04 	addi	sp,sp,-12
 2008738:	dfc00215 	stw	ra,8(sp)
 200873c:	df000115 	stw	fp,4(sp)
 2008740:	df000104 	addi	fp,sp,4
 2008744:	e13fff15 	stw	r4,-4(fp)
	for( ;; )
	{
		if(lineasIzquierda>=0)
 2008748:	d0a00c17 	ldw	r2,-32720(gp)
 200874c:	10002c16 	blt	r2,zero,2008800 <TaskActualizarMatriz+0xcc>
		{
			if(lineasIzquierda<9)
 2008750:	d0a00c17 	ldw	r2,-32720(gp)
 2008754:	10800248 	cmpgei	r2,r2,9
 2008758:	10000b1e 	bne	r2,zero,2008788 <TaskActualizarMatriz+0x54>
			{
				matriz[0] = numeros[lineasIzquierda];
 200875c:	d0e00c17 	ldw	r3,-32720(gp)
 2008760:	00808074 	movhi	r2,513
 2008764:	1088bf04 	addi	r2,r2,8956
 2008768:	10c5883a 	add	r2,r2,r3
 200876c:	10800003 	ldbu	r2,0(r2)
 2008770:	d0a08805 	stb	r2,-32224(gp)
				matriz[1] = numeros[0];
 2008774:	0005883a 	mov	r2,zero
 2008778:	d0a08845 	stb	r2,-32223(gp)
				matriz[2] = numeros[0];
 200877c:	0005883a 	mov	r2,zero
 2008780:	d0a08885 	stb	r2,-32222(gp)
 2008784:	00002406 	br	2008818 <TaskActualizarMatriz+0xe4>
			}
			else if(lineasIzquierda<17)
 2008788:	d0a00c17 	ldw	r2,-32720(gp)
 200878c:	10800448 	cmpgei	r2,r2,17
 2008790:	10000c1e 	bne	r2,zero,20087c4 <TaskActualizarMatriz+0x90>
			{
				matriz[0] = numeros[8];
 2008794:	00bfffc4 	movi	r2,-1
 2008798:	d0a08805 	stb	r2,-32224(gp)
				matriz[1] = numeros[lineasIzquierda-8];
 200879c:	d0a00c17 	ldw	r2,-32720(gp)
 20087a0:	10fffe04 	addi	r3,r2,-8
 20087a4:	00808074 	movhi	r2,513
 20087a8:	1088bf04 	addi	r2,r2,8956
 20087ac:	10c5883a 	add	r2,r2,r3
 20087b0:	10800003 	ldbu	r2,0(r2)
 20087b4:	d0a08845 	stb	r2,-32223(gp)
				matriz[2] = numeros[0];
 20087b8:	0005883a 	mov	r2,zero
 20087bc:	d0a08885 	stb	r2,-32222(gp)
 20087c0:	00001506 	br	2008818 <TaskActualizarMatriz+0xe4>
			}
			else if(lineasIzquierda<25)
 20087c4:	d0a00c17 	ldw	r2,-32720(gp)
 20087c8:	10800648 	cmpgei	r2,r2,25
 20087cc:	1000121e 	bne	r2,zero,2008818 <TaskActualizarMatriz+0xe4>
			{
				matriz[0] = numeros[8];
 20087d0:	00bfffc4 	movi	r2,-1
 20087d4:	d0a08805 	stb	r2,-32224(gp)
				matriz[1] = numeros[8];
 20087d8:	00bfffc4 	movi	r2,-1
 20087dc:	d0a08845 	stb	r2,-32223(gp)
				matriz[2] = numeros[lineasIzquierda-16];
 20087e0:	d0a00c17 	ldw	r2,-32720(gp)
 20087e4:	10fffc04 	addi	r3,r2,-16
 20087e8:	00808074 	movhi	r2,513
 20087ec:	1088bf04 	addi	r2,r2,8956
 20087f0:	10c5883a 	add	r2,r2,r3
 20087f4:	10800003 	ldbu	r2,0(r2)
 20087f8:	d0a08885 	stb	r2,-32222(gp)
 20087fc:	00000606 	br	2008818 <TaskActualizarMatriz+0xe4>
			}
		}
		else
		{
			matriz[0] = numeros[0];
 2008800:	0005883a 	mov	r2,zero
 2008804:	d0a08805 	stb	r2,-32224(gp)
			matriz[1] = numeros[0];
 2008808:	0005883a 	mov	r2,zero
 200880c:	d0a08845 	stb	r2,-32223(gp)
			matriz[2] = numeros[0];
 2008810:	0005883a 	mov	r2,zero
 2008814:	d0a08885 	stb	r2,-32222(gp)
		}

		if(lineasDerecha>=0)
 2008818:	d0a00d17 	ldw	r2,-32716(gp)
 200881c:	10002c16 	blt	r2,zero,20088d0 <TaskActualizarMatriz+0x19c>
		{
			if(lineasDerecha<9)
 2008820:	d0a00d17 	ldw	r2,-32716(gp)
 2008824:	10800248 	cmpgei	r2,r2,9
 2008828:	10000b1e 	bne	r2,zero,2008858 <TaskActualizarMatriz+0x124>
			{
				matriz[6] = numeros[0];
 200882c:	0005883a 	mov	r2,zero
 2008830:	d0a08985 	stb	r2,-32218(gp)
				matriz[7] = numeros[lineasDerecha];
 2008834:	d0e00d17 	ldw	r3,-32716(gp)
 2008838:	00808074 	movhi	r2,513
 200883c:	1088bf04 	addi	r2,r2,8956
 2008840:	10c5883a 	add	r2,r2,r3
 2008844:	10800003 	ldbu	r2,0(r2)
 2008848:	d0a089c5 	stb	r2,-32217(gp)
				matriz[5] = numeros[0];
 200884c:	0005883a 	mov	r2,zero
 2008850:	d0a08945 	stb	r2,-32219(gp)
 2008854:	00002406 	br	20088e8 <TaskActualizarMatriz+0x1b4>
			}
			else if(lineasDerecha<17)
 2008858:	d0a00d17 	ldw	r2,-32716(gp)
 200885c:	10800448 	cmpgei	r2,r2,17
 2008860:	10000c1e 	bne	r2,zero,2008894 <TaskActualizarMatriz+0x160>
			{
				matriz[7] = numeros[8];
 2008864:	00bfffc4 	movi	r2,-1
 2008868:	d0a089c5 	stb	r2,-32217(gp)
				matriz[6] = numeros[lineasDerecha-8];
 200886c:	d0a00d17 	ldw	r2,-32716(gp)
 2008870:	10fffe04 	addi	r3,r2,-8
 2008874:	00808074 	movhi	r2,513
 2008878:	1088bf04 	addi	r2,r2,8956
 200887c:	10c5883a 	add	r2,r2,r3
 2008880:	10800003 	ldbu	r2,0(r2)
 2008884:	d0a08985 	stb	r2,-32218(gp)
				matriz[5] = numeros[0];
 2008888:	0005883a 	mov	r2,zero
 200888c:	d0a08945 	stb	r2,-32219(gp)
 2008890:	00001506 	br	20088e8 <TaskActualizarMatriz+0x1b4>
			}
			else if(lineasDerecha<25)
 2008894:	d0a00d17 	ldw	r2,-32716(gp)
 2008898:	10800648 	cmpgei	r2,r2,25
 200889c:	1000121e 	bne	r2,zero,20088e8 <TaskActualizarMatriz+0x1b4>
			{
				matriz[7] = numeros[8];
 20088a0:	00bfffc4 	movi	r2,-1
 20088a4:	d0a089c5 	stb	r2,-32217(gp)
				matriz[6] = numeros[8];
 20088a8:	00bfffc4 	movi	r2,-1
 20088ac:	d0a08985 	stb	r2,-32218(gp)
				matriz[5] = numeros[lineasDerecha-16];
 20088b0:	d0a00d17 	ldw	r2,-32716(gp)
 20088b4:	10fffc04 	addi	r3,r2,-16
 20088b8:	00808074 	movhi	r2,513
 20088bc:	1088bf04 	addi	r2,r2,8956
 20088c0:	10c5883a 	add	r2,r2,r3
 20088c4:	10800003 	ldbu	r2,0(r2)
 20088c8:	d0a08945 	stb	r2,-32219(gp)
 20088cc:	00000606 	br	20088e8 <TaskActualizarMatriz+0x1b4>
			}
		}
		else
		{
			matriz[5] = numeros[0];
 20088d0:	0005883a 	mov	r2,zero
 20088d4:	d0a08945 	stb	r2,-32219(gp)
			matriz[6] = numeros[0];
 20088d8:	0005883a 	mov	r2,zero
 20088dc:	d0a08985 	stb	r2,-32218(gp)
			matriz[7] = numeros[0];
 20088e0:	0005883a 	mov	r2,zero
 20088e4:	d0a089c5 	stb	r2,-32217(gp)
		}

		// envio figura
		if(xSemaphoreTake( xSemaphore, ( TickType_t ) 100 ) == pdTRUE)
 20088e8:	d0a08517 	ldw	r2,-32236(gp)
 20088ec:	000f883a 	mov	r7,zero
 20088f0:	01801904 	movi	r6,100
 20088f4:	000b883a 	mov	r5,zero
 20088f8:	1009883a 	mov	r4,r2
 20088fc:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2008900:	10800058 	cmpnei	r2,r2,1
 2008904:	1000561e 	bne	r2,zero,2008a60 <TaskActualizarMatriz+0x32c>
		{
			sen_2_byte_info(portlog,ADDR_DIG_0,matriz[0]);
 2008908:	d0a08017 	ldw	r2,-32256(gp)
 200890c:	1007883a 	mov	r3,r2
 2008910:	d0a08803 	ldbu	r2,-32224(gp)
 2008914:	10803fcc 	andi	r2,r2,255
 2008918:	1080201c 	xori	r2,r2,128
 200891c:	10bfe004 	addi	r2,r2,-128
 2008920:	100d883a 	mov	r6,r2
 2008924:	01400044 	movi	r5,1
 2008928:	1809883a 	mov	r4,r3
 200892c:	20079fc0 	call	20079fc <sen_2_byte_info>
			sen_2_byte_info(portlog,ADDR_DIG_1,matriz[1]);
 2008930:	d0a08017 	ldw	r2,-32256(gp)
 2008934:	1007883a 	mov	r3,r2
 2008938:	d0a08843 	ldbu	r2,-32223(gp)
 200893c:	10803fcc 	andi	r2,r2,255
 2008940:	1080201c 	xori	r2,r2,128
 2008944:	10bfe004 	addi	r2,r2,-128
 2008948:	100d883a 	mov	r6,r2
 200894c:	01400084 	movi	r5,2
 2008950:	1809883a 	mov	r4,r3
 2008954:	20079fc0 	call	20079fc <sen_2_byte_info>
			sen_2_byte_info(portlog,ADDR_DIG_2,matriz[2]);
 2008958:	d0a08017 	ldw	r2,-32256(gp)
 200895c:	1007883a 	mov	r3,r2
 2008960:	d0a08883 	ldbu	r2,-32222(gp)
 2008964:	10803fcc 	andi	r2,r2,255
 2008968:	1080201c 	xori	r2,r2,128
 200896c:	10bfe004 	addi	r2,r2,-128
 2008970:	100d883a 	mov	r6,r2
 2008974:	014000c4 	movi	r5,3
 2008978:	1809883a 	mov	r4,r3
 200897c:	20079fc0 	call	20079fc <sen_2_byte_info>
			sen_2_byte_info(portlog,ADDR_DIG_3,matriz[3]);
 2008980:	d0a08017 	ldw	r2,-32256(gp)
 2008984:	1007883a 	mov	r3,r2
 2008988:	d0a088c3 	ldbu	r2,-32221(gp)
 200898c:	10803fcc 	andi	r2,r2,255
 2008990:	1080201c 	xori	r2,r2,128
 2008994:	10bfe004 	addi	r2,r2,-128
 2008998:	100d883a 	mov	r6,r2
 200899c:	01400104 	movi	r5,4
 20089a0:	1809883a 	mov	r4,r3
 20089a4:	20079fc0 	call	20079fc <sen_2_byte_info>
			sen_2_byte_info(portlog,ADDR_DIG_4,matriz[4]);
 20089a8:	d0a08017 	ldw	r2,-32256(gp)
 20089ac:	1007883a 	mov	r3,r2
 20089b0:	d0a08903 	ldbu	r2,-32220(gp)
 20089b4:	10803fcc 	andi	r2,r2,255
 20089b8:	1080201c 	xori	r2,r2,128
 20089bc:	10bfe004 	addi	r2,r2,-128
 20089c0:	100d883a 	mov	r6,r2
 20089c4:	01400144 	movi	r5,5
 20089c8:	1809883a 	mov	r4,r3
 20089cc:	20079fc0 	call	20079fc <sen_2_byte_info>
			sen_2_byte_info(portlog,ADDR_DIG_5,matriz[5]);
 20089d0:	d0a08017 	ldw	r2,-32256(gp)
 20089d4:	1007883a 	mov	r3,r2
 20089d8:	d0a08943 	ldbu	r2,-32219(gp)
 20089dc:	10803fcc 	andi	r2,r2,255
 20089e0:	1080201c 	xori	r2,r2,128
 20089e4:	10bfe004 	addi	r2,r2,-128
 20089e8:	100d883a 	mov	r6,r2
 20089ec:	01400184 	movi	r5,6
 20089f0:	1809883a 	mov	r4,r3
 20089f4:	20079fc0 	call	20079fc <sen_2_byte_info>
			sen_2_byte_info(portlog,ADDR_DIG_6,matriz[6]);
 20089f8:	d0a08017 	ldw	r2,-32256(gp)
 20089fc:	1007883a 	mov	r3,r2
 2008a00:	d0a08983 	ldbu	r2,-32218(gp)
 2008a04:	10803fcc 	andi	r2,r2,255
 2008a08:	1080201c 	xori	r2,r2,128
 2008a0c:	10bfe004 	addi	r2,r2,-128
 2008a10:	100d883a 	mov	r6,r2
 2008a14:	014001c4 	movi	r5,7
 2008a18:	1809883a 	mov	r4,r3
 2008a1c:	20079fc0 	call	20079fc <sen_2_byte_info>
			sen_2_byte_info(portlog,ADDR_DIG_7,matriz[7]);
 2008a20:	d0a08017 	ldw	r2,-32256(gp)
 2008a24:	1007883a 	mov	r3,r2
 2008a28:	d0a089c3 	ldbu	r2,-32217(gp)
 2008a2c:	10803fcc 	andi	r2,r2,255
 2008a30:	1080201c 	xori	r2,r2,128
 2008a34:	10bfe004 	addi	r2,r2,-128
 2008a38:	100d883a 	mov	r6,r2
 2008a3c:	01400204 	movi	r5,8
 2008a40:	1809883a 	mov	r4,r3
 2008a44:	20079fc0 	call	20079fc <sen_2_byte_info>

			xSemaphoreGive( xSemaphore );
 2008a48:	d0a08517 	ldw	r2,-32236(gp)
 2008a4c:	000f883a 	mov	r7,zero
 2008a50:	000d883a 	mov	r6,zero
 2008a54:	000b883a 	mov	r5,zero
 2008a58:	1009883a 	mov	r4,r2
 2008a5c:	20047700 	call	2004770 <xQueueGenericSend>
		}

		vTaskDelay( TaskActualizarMatriz_PERIOD / portTICK_PERIOD_MS);
 2008a60:	01001904 	movi	r4,100
 2008a64:	20059600 	call	2005960 <vTaskDelay>

	}
 2008a68:	003f3706 	br	2008748 <__reset+0xfe007748>

02008a6c <TaskParada>:
}
static void TaskParada( void *pvParameters )
{
 2008a6c:	defffd04 	addi	sp,sp,-12
 2008a70:	dfc00215 	stw	ra,8(sp)
 2008a74:	df000115 	stw	fp,4(sp)
 2008a78:	df000104 	addi	fp,sp,4
 2008a7c:	e13fff15 	stw	r4,-4(fp)
		//char datoIzquierda = buffer[28];
		//char datoDerecha = buffer[29];

		//(datoDerecha==VERDADERO && datoIzquierda==VERDADERO ) ||
		//!dobleLinea
		if(dobleLineaRegleta)
 2008a80:	d0a08143 	ldbu	r2,-32251(gp)
 2008a84:	10803fcc 	andi	r2,r2,255
 2008a88:	10001426 	beq	r2,zero,2008adc <TaskParada+0x70>
		{
			if(!dobleLinea)
 2008a8c:	d0a08103 	ldbu	r2,-32252(gp)
 2008a90:	1080005c 	xori	r2,r2,1
 2008a94:	10803fcc 	andi	r2,r2,255
 2008a98:	10000d26 	beq	r2,zero,2008ad0 <TaskParada+0x64>
			{
				vecesLineaNegra++;
 2008a9c:	d0a08317 	ldw	r2,-32244(gp)
 2008aa0:	10800044 	addi	r2,r2,1
 2008aa4:	d0a08315 	stw	r2,-32244(gp)
				if(vecesLineaNegra==2)
 2008aa8:	d0a08317 	ldw	r2,-32244(gp)
 2008aac:	10800098 	cmpnei	r2,r2,2
 2008ab0:	1000031e 	bne	r2,zero,2008ac0 <TaskParada+0x54>
				{
					escribirXBee();
 2008ab4:	2008f980 	call	2008f98 <escribirXBee>
					detenerse = true;
 2008ab8:	00800044 	movi	r2,1
 2008abc:	d0a08445 	stb	r2,-32239(gp)
				}
				if(vecesLineaNegra==1)
 2008ac0:	d0a08317 	ldw	r2,-32244(gp)
 2008ac4:	10800058 	cmpnei	r2,r2,1
 2008ac8:	1000011e 	bne	r2,zero,2008ad0 <TaskParada+0x64>
				{
					analizarPixy();
 2008acc:	20095500 	call	2009550 <analizarPixy>
				}
			}
			dobleLinea = true;
 2008ad0:	00800044 	movi	r2,1
 2008ad4:	d0a08105 	stb	r2,-32252(gp)
 2008ad8:	00000106 	br	2008ae0 <TaskParada+0x74>
		}
		else
		{
			dobleLinea = false;
 2008adc:	d0208105 	stb	zero,-32252(gp)
		}

		vTaskDelay( TaskParada_PERIOD / portTICK_PERIOD_MS);
 2008ae0:	01000c84 	movi	r4,50
 2008ae4:	20059600 	call	2005960 <vTaskDelay>
	}
 2008ae8:	003fe506 	br	2008a80 <__reset+0xfe007a80>

02008aec <TaskRESET>:
}
static void TaskRESET( void *pvParameters )
{
 2008aec:	defff304 	addi	sp,sp,-52
 2008af0:	dfc00c15 	stw	ra,48(sp)
 2008af4:	df000b15 	stw	fp,44(sp)
 2008af8:	df000b04 	addi	fp,sp,44
 2008afc:	e13fff15 	stw	r4,-4(fp)
	for( ;; )
	{
		int datosSensores = IORD_ALT_UP_PARALLEL_PORT_DATA(IO_PIO_BASE);
 2008b00:	00810034 	movhi	r2,1024
 2008b04:	10881004 	addi	r2,r2,8256
 2008b08:	10800037 	ldwio	r2,0(r2)
 2008b0c:	e0bff515 	stw	r2,-44(fp)
		char buffer[32];
		itoa(datosSensores,buffer,2);
 2008b10:	e0bff644 	addi	r2,fp,-39
 2008b14:	01800084 	movi	r6,2
 2008b18:	100b883a 	mov	r5,r2
 2008b1c:	e13ff517 	ldw	r4,-44(fp)
 2008b20:	200af340 	call	200af34 <itoa>

		char datoRESET = buffer[27];
 2008b24:	e0bffd03 	ldbu	r2,-12(fp)
 2008b28:	e0bff605 	stb	r2,-40(fp)

		if(datoRESET==FALSO)
 2008b2c:	e0fff607 	ldb	r3,-40(fp)
 2008b30:	00800c04 	movi	r2,48
 2008b34:	10803fcc 	andi	r2,r2,255
 2008b38:	18800b1e 	bne	r3,r2,2008b68 <TaskRESET+0x7c>
		{
			lineasIzquierda = -1;
 2008b3c:	00bfffc4 	movi	r2,-1
 2008b40:	d0a00c15 	stw	r2,-32720(gp)
			lineasDerecha = -1;
 2008b44:	00bfffc4 	movi	r2,-1
 2008b48:	d0a00d15 	stw	r2,-32716(gp)
			vecesLineaNegra = 0;
 2008b4c:	d0208315 	stw	zero,-32244(gp)
			desactivarMotores = true;
 2008b50:	00800044 	movi	r2,1
 2008b54:	d0a08405 	stb	r2,-32240(gp)
			detenerse = false;
 2008b58:	d0208445 	stb	zero,-32239(gp)
			envioXbeeFinalizado = false;
 2008b5c:	d0208705 	stb	zero,-32228(gp)
			lecturaPixyFinalizada = false;
 2008b60:	d0208745 	stb	zero,-32227(gp)
 2008b64:	00000106 	br	2008b6c <TaskRESET+0x80>

		}
		else
		{
			desactivarMotores = false;
 2008b68:	d0208405 	stb	zero,-32240(gp)
		}



		vTaskDelay( TaskRESET_PERIOD / portTICK_PERIOD_MS);
 2008b6c:	0100fa04 	movi	r4,1000
 2008b70:	20059600 	call	2005960 <vTaskDelay>
	}
 2008b74:	003fe206 	br	2008b00 <__reset+0xfe007b00>

02008b78 <TaskLEDS>:
}
static void TaskLEDS( void *pvParameters )
{
 2008b78:	defffb04 	addi	sp,sp,-20
 2008b7c:	dfc00415 	stw	ra,16(sp)
 2008b80:	df000315 	stw	fp,12(sp)
 2008b84:	df000304 	addi	fp,sp,12
 2008b88:	e13fff15 	stw	r4,-4(fp)
	for( ;; )
	{

		if(xSemaphoreTake( xSemaphore, ( TickType_t ) 200 ) == pdTRUE)
 2008b8c:	d0a08517 	ldw	r2,-32236(gp)
 2008b90:	000f883a 	mov	r7,zero
 2008b94:	01803204 	movi	r6,200
 2008b98:	000b883a 	mov	r5,zero
 2008b9c:	1009883a 	mov	r4,r2
 2008ba0:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 2008ba4:	10800058 	cmpnei	r2,r2,1
 2008ba8:	1000561e 	bne	r2,zero,2008d04 <TaskLEDS+0x18c>
		{
			if(envioXbeeFinalizado)
 2008bac:	d0a08703 	ldbu	r2,-32228(gp)
 2008bb0:	10803fcc 	andi	r2,r2,255
 2008bb4:	10000426 	beq	r2,zero,2008bc8 <TaskLEDS+0x50>
				portlog = portlog | (1<<DIR_LED1);
 2008bb8:	d0a08017 	ldw	r2,-32256(gp)
 2008bbc:	10800114 	ori	r2,r2,4
 2008bc0:	d0a08015 	stw	r2,-32256(gp)
 2008bc4:	00000406 	br	2008bd8 <TaskLEDS+0x60>
			else
				portlog = portlog & ~(1<<DIR_LED1);
 2008bc8:	d0e08017 	ldw	r3,-32256(gp)
 2008bcc:	00bffec4 	movi	r2,-5
 2008bd0:	1884703a 	and	r2,r3,r2
 2008bd4:	d0a08015 	stw	r2,-32256(gp)

			if(lecturaPixyFinalizada)
 2008bd8:	d0a08743 	ldbu	r2,-32227(gp)
 2008bdc:	10803fcc 	andi	r2,r2,255
 2008be0:	10000426 	beq	r2,zero,2008bf4 <TaskLEDS+0x7c>
				portlog = portlog | (1<<DIR_LED2);
 2008be4:	d0a08017 	ldw	r2,-32256(gp)
 2008be8:	10800214 	ori	r2,r2,8
 2008bec:	d0a08015 	stw	r2,-32256(gp)
 2008bf0:	00000406 	br	2008c04 <TaskLEDS+0x8c>
			else
				portlog = portlog & ~(1<<DIR_LED2);
 2008bf4:	d0e08017 	ldw	r3,-32256(gp)
 2008bf8:	00bffdc4 	movi	r2,-9
 2008bfc:	1884703a 	and	r2,r3,r2
 2008c00:	d0a08015 	stw	r2,-32256(gp)

			if(izq)
 2008c04:	d0a08783 	ldbu	r2,-32226(gp)
 2008c08:	10803fcc 	andi	r2,r2,255
 2008c0c:	10000426 	beq	r2,zero,2008c20 <TaskLEDS+0xa8>
			{
				portlog = portlog | (1<<DIR_LED4);
 2008c10:	d0a08017 	ldw	r2,-32256(gp)
 2008c14:	10800814 	ori	r2,r2,32
 2008c18:	d0a08015 	stw	r2,-32256(gp)
 2008c1c:	00000406 	br	2008c30 <TaskLEDS+0xb8>
			}
			else
			{
				portlog = portlog & ~(1<<DIR_LED4);
 2008c20:	d0e08017 	ldw	r3,-32256(gp)
 2008c24:	00bff7c4 	movi	r2,-33
 2008c28:	1884703a 	and	r2,r3,r2
 2008c2c:	d0a08015 	stw	r2,-32256(gp)
			}
			if(der)
 2008c30:	d0a087c3 	ldbu	r2,-32225(gp)
 2008c34:	10803fcc 	andi	r2,r2,255
 2008c38:	10000426 	beq	r2,zero,2008c4c <TaskLEDS+0xd4>
			{
				portlog = portlog | (1<<DIR_LED3);
 2008c3c:	d0a08017 	ldw	r2,-32256(gp)
 2008c40:	10800414 	ori	r2,r2,16
 2008c44:	d0a08015 	stw	r2,-32256(gp)
 2008c48:	00000406 	br	2008c5c <TaskLEDS+0xe4>
			}
			else
			{
				portlog = portlog & ~(1<<DIR_LED3);
 2008c4c:	d0e08017 	ldw	r3,-32256(gp)
 2008c50:	00bffbc4 	movi	r2,-17
 2008c54:	1884703a 	and	r2,r3,r2
 2008c58:	d0a08015 	stw	r2,-32256(gp)
			}

			int LEDlog = 0;
 2008c5c:	e03ffd15 	stw	zero,-12(fp)

			for(int p=0;p<8;p++)
 2008c60:	e03ffe15 	stw	zero,-8(fp)
 2008c64:	00001506 	br	2008cbc <TaskLEDS+0x144>
			{
				if(sensor_values[7-p]==VERDADERO)
 2008c68:	00c001c4 	movi	r3,7
 2008c6c:	e0bffe17 	ldw	r2,-8(fp)
 2008c70:	1887c83a 	sub	r3,r3,r2
 2008c74:	0080a074 	movhi	r2,641
 2008c78:	10917f04 	addi	r2,r2,17916
 2008c7c:	18c7883a 	add	r3,r3,r3
 2008c80:	18c7883a 	add	r3,r3,r3
 2008c84:	10c5883a 	add	r2,r2,r3
 2008c88:	10c00017 	ldw	r3,0(r2)
 2008c8c:	00800c44 	movi	r2,49
 2008c90:	10803fcc 	andi	r2,r2,255
 2008c94:	1880061e 	bne	r3,r2,2008cb0 <TaskLEDS+0x138>
					LEDlog = LEDlog | (1<<(p));
 2008c98:	00c00044 	movi	r3,1
 2008c9c:	e0bffe17 	ldw	r2,-8(fp)
 2008ca0:	1884983a 	sll	r2,r3,r2
 2008ca4:	e0fffd17 	ldw	r3,-12(fp)
 2008ca8:	1884b03a 	or	r2,r3,r2
 2008cac:	e0bffd15 	stw	r2,-12(fp)
				portlog = portlog & ~(1<<DIR_LED3);
			}

			int LEDlog = 0;

			for(int p=0;p<8;p++)
 2008cb0:	e0bffe17 	ldw	r2,-8(fp)
 2008cb4:	10800044 	addi	r2,r2,1
 2008cb8:	e0bffe15 	stw	r2,-8(fp)
 2008cbc:	e0bffe17 	ldw	r2,-8(fp)
 2008cc0:	10800210 	cmplti	r2,r2,8
 2008cc4:	103fe81e 	bne	r2,zero,2008c68 <__reset+0xfe007c68>
				if(sensor_values[7-p]==VERDADERO)
					LEDlog = LEDlog | (1<<(p));
			}


			IOWR(LED_PIO_BASE, ALT_UP_PARALLEL_PORT_DATA, LEDlog);
 2008cc8:	00810034 	movhi	r2,1024
 2008ccc:	10882004 	addi	r2,r2,8320
 2008cd0:	e0fffd17 	ldw	r3,-12(fp)
 2008cd4:	10c00035 	stwio	r3,0(r2)

			IOWR(IO_PIO1_BASE, ALT_UP_PARALLEL_PORT_DATA, portlog);
 2008cd8:	d0a08017 	ldw	r2,-32256(gp)
 2008cdc:	1007883a 	mov	r3,r2
 2008ce0:	00810074 	movhi	r2,1025
 2008ce4:	10881004 	addi	r2,r2,8256
 2008ce8:	10c00035 	stwio	r3,0(r2)
			xSemaphoreGive( xSemaphore );
 2008cec:	d0a08517 	ldw	r2,-32236(gp)
 2008cf0:	000f883a 	mov	r7,zero
 2008cf4:	000d883a 	mov	r6,zero
 2008cf8:	000b883a 	mov	r5,zero
 2008cfc:	1009883a 	mov	r4,r2
 2008d00:	20047700 	call	2004770 <xQueueGenericSend>
		}


		vTaskDelay( TaskLEDS_PERIOD / portTICK_PERIOD_MS);
 2008d04:	01003e84 	movi	r4,250
 2008d08:	20059600 	call	2005960 <vTaskDelay>
	}
 2008d0c:	003f9f06 	br	2008b8c <__reset+0xfe007b8c>

02008d10 <calcularError>:
}
int calcularError( )
{
 2008d10:	defff404 	addi	sp,sp,-48
 2008d14:	dfc00b15 	stw	ra,44(sp)
 2008d18:	df000a15 	stw	fp,40(sp)
 2008d1c:	dc000915 	stw	r16,36(sp)
 2008d20:	df000a04 	addi	fp,sp,40
	int s0 = sensor_values[0] - 48;
 2008d24:	0080a074 	movhi	r2,641
 2008d28:	10917f04 	addi	r2,r2,17916
 2008d2c:	10800017 	ldw	r2,0(r2)
 2008d30:	10bff404 	addi	r2,r2,-48
 2008d34:	e0bff615 	stw	r2,-40(fp)
	int s1 = sensor_values[1] - 48;
 2008d38:	0080a074 	movhi	r2,641
 2008d3c:	10917f04 	addi	r2,r2,17916
 2008d40:	10800117 	ldw	r2,4(r2)
 2008d44:	10bff404 	addi	r2,r2,-48
 2008d48:	e0bff715 	stw	r2,-36(fp)
	int s2 = sensor_values[2] - 48;
 2008d4c:	0080a074 	movhi	r2,641
 2008d50:	10917f04 	addi	r2,r2,17916
 2008d54:	10800217 	ldw	r2,8(r2)
 2008d58:	10bff404 	addi	r2,r2,-48
 2008d5c:	e0bff815 	stw	r2,-32(fp)
	int s3 = sensor_values[3] - 48;
 2008d60:	0080a074 	movhi	r2,641
 2008d64:	10917f04 	addi	r2,r2,17916
 2008d68:	10800317 	ldw	r2,12(r2)
 2008d6c:	10bff404 	addi	r2,r2,-48
 2008d70:	e0bff915 	stw	r2,-28(fp)
	int s4 = sensor_values[4] - 48;
 2008d74:	0080a074 	movhi	r2,641
 2008d78:	10917f04 	addi	r2,r2,17916
 2008d7c:	10800417 	ldw	r2,16(r2)
 2008d80:	10bff404 	addi	r2,r2,-48
 2008d84:	e0bffa15 	stw	r2,-24(fp)
	int s5 = sensor_values[5] - 48;
 2008d88:	0080a074 	movhi	r2,641
 2008d8c:	10917f04 	addi	r2,r2,17916
 2008d90:	10800517 	ldw	r2,20(r2)
 2008d94:	10bff404 	addi	r2,r2,-48
 2008d98:	e0bffb15 	stw	r2,-20(fp)
	int s6 = sensor_values[6] - 48;
 2008d9c:	0080a074 	movhi	r2,641
 2008da0:	10917f04 	addi	r2,r2,17916
 2008da4:	10800617 	ldw	r2,24(r2)
 2008da8:	10bff404 	addi	r2,r2,-48
 2008dac:	e0bffc15 	stw	r2,-16(fp)
	int s7 = sensor_values[7] - 48;
 2008db0:	0080a074 	movhi	r2,641
 2008db4:	10917f04 	addi	r2,r2,17916
 2008db8:	10800717 	ldw	r2,28(r2)
 2008dbc:	10bff404 	addi	r2,r2,-48
 2008dc0:	e0bffd15 	stw	r2,-12(fp)

	//printf("%d %d %d %d %d %d %d %d \n",s0,s1,s2,s3,s4,s5,s6,s7);

	int posicion = 10*s1+20*s2+30*s3+40*s4+50*s5+60*s6+70*s7;
 2008dc4:	01400284 	movi	r5,10
 2008dc8:	e13ff717 	ldw	r4,-36(fp)
 2008dcc:	2009bcc0 	call	2009bcc <__mulsi3>
 2008dd0:	1021883a 	mov	r16,r2
 2008dd4:	01400504 	movi	r5,20
 2008dd8:	e13ff817 	ldw	r4,-32(fp)
 2008ddc:	2009bcc0 	call	2009bcc <__mulsi3>
 2008de0:	80a1883a 	add	r16,r16,r2
 2008de4:	01400784 	movi	r5,30
 2008de8:	e13ff917 	ldw	r4,-28(fp)
 2008dec:	2009bcc0 	call	2009bcc <__mulsi3>
 2008df0:	80a1883a 	add	r16,r16,r2
 2008df4:	01400a04 	movi	r5,40
 2008df8:	e13ffa17 	ldw	r4,-24(fp)
 2008dfc:	2009bcc0 	call	2009bcc <__mulsi3>
 2008e00:	80a1883a 	add	r16,r16,r2
 2008e04:	01400c84 	movi	r5,50
 2008e08:	e13ffb17 	ldw	r4,-20(fp)
 2008e0c:	2009bcc0 	call	2009bcc <__mulsi3>
 2008e10:	80a1883a 	add	r16,r16,r2
 2008e14:	01400f04 	movi	r5,60
 2008e18:	e13ffc17 	ldw	r4,-16(fp)
 2008e1c:	2009bcc0 	call	2009bcc <__mulsi3>
 2008e20:	80a1883a 	add	r16,r16,r2
 2008e24:	01401184 	movi	r5,70
 2008e28:	e13ffd17 	ldw	r4,-12(fp)
 2008e2c:	2009bcc0 	call	2009bcc <__mulsi3>
 2008e30:	8085883a 	add	r2,r16,r2
 2008e34:	e0bffe15 	stw	r2,-8(fp)

	posicion = posicion / (s0+s1+s2+s3+s4+s5+s6+s7);
 2008e38:	e0fff617 	ldw	r3,-40(fp)
 2008e3c:	e0bff717 	ldw	r2,-36(fp)
 2008e40:	1887883a 	add	r3,r3,r2
 2008e44:	e0bff817 	ldw	r2,-32(fp)
 2008e48:	1887883a 	add	r3,r3,r2
 2008e4c:	e0bff917 	ldw	r2,-28(fp)
 2008e50:	1887883a 	add	r3,r3,r2
 2008e54:	e0bffa17 	ldw	r2,-24(fp)
 2008e58:	1887883a 	add	r3,r3,r2
 2008e5c:	e0bffb17 	ldw	r2,-20(fp)
 2008e60:	1887883a 	add	r3,r3,r2
 2008e64:	e0bffc17 	ldw	r2,-16(fp)
 2008e68:	1887883a 	add	r3,r3,r2
 2008e6c:	e0bffd17 	ldw	r2,-12(fp)
 2008e70:	1885883a 	add	r2,r3,r2
 2008e74:	100b883a 	mov	r5,r2
 2008e78:	e13ffe17 	ldw	r4,-8(fp)
 2008e7c:	2009a180 	call	2009a18 <__divsi3>
 2008e80:	e0bffe15 	stw	r2,-8(fp)

	posicion = posicion - 35;
 2008e84:	e0bffe17 	ldw	r2,-8(fp)
 2008e88:	10bff744 	addi	r2,r2,-35
 2008e8c:	e0bffe15 	stw	r2,-8(fp)

	if((s0+s1+s2+s3+s4+s5+s6+s7)>6)
 2008e90:	e0fff617 	ldw	r3,-40(fp)
 2008e94:	e0bff717 	ldw	r2,-36(fp)
 2008e98:	1887883a 	add	r3,r3,r2
 2008e9c:	e0bff817 	ldw	r2,-32(fp)
 2008ea0:	1887883a 	add	r3,r3,r2
 2008ea4:	e0bff917 	ldw	r2,-28(fp)
 2008ea8:	1887883a 	add	r3,r3,r2
 2008eac:	e0bffa17 	ldw	r2,-24(fp)
 2008eb0:	1887883a 	add	r3,r3,r2
 2008eb4:	e0bffb17 	ldw	r2,-20(fp)
 2008eb8:	1887883a 	add	r3,r3,r2
 2008ebc:	e0bffc17 	ldw	r2,-16(fp)
 2008ec0:	1887883a 	add	r3,r3,r2
 2008ec4:	e0bffd17 	ldw	r2,-12(fp)
 2008ec8:	1885883a 	add	r2,r3,r2
 2008ecc:	108001d0 	cmplti	r2,r2,7
 2008ed0:	1000041e 	bne	r2,zero,2008ee4 <calcularError+0x1d4>
	{
		dobleLineaRegleta = true;
 2008ed4:	00800044 	movi	r2,1
 2008ed8:	d0a08145 	stb	r2,-32251(gp)
		return errorPasado;
 2008edc:	d0a08217 	ldw	r2,-32248(gp)
 2008ee0:	00002706 	br	2008f80 <calcularError+0x270>
	}

	dobleLineaRegleta = false;
 2008ee4:	d0208145 	stb	zero,-32251(gp)

	if((s0+s1+s2+s3+s4+s5+s6+s7)==0) return errorPasado;
 2008ee8:	e0fff617 	ldw	r3,-40(fp)
 2008eec:	e0bff717 	ldw	r2,-36(fp)
 2008ef0:	1887883a 	add	r3,r3,r2
 2008ef4:	e0bff817 	ldw	r2,-32(fp)
 2008ef8:	1887883a 	add	r3,r3,r2
 2008efc:	e0bff917 	ldw	r2,-28(fp)
 2008f00:	1887883a 	add	r3,r3,r2
 2008f04:	e0bffa17 	ldw	r2,-24(fp)
 2008f08:	1887883a 	add	r3,r3,r2
 2008f0c:	e0bffb17 	ldw	r2,-20(fp)
 2008f10:	1887883a 	add	r3,r3,r2
 2008f14:	e0bffc17 	ldw	r2,-16(fp)
 2008f18:	1887883a 	add	r3,r3,r2
 2008f1c:	e0bffd17 	ldw	r2,-12(fp)
 2008f20:	1885883a 	add	r2,r3,r2
 2008f24:	1000021e 	bne	r2,zero,2008f30 <calcularError+0x220>
 2008f28:	d0a08217 	ldw	r2,-32248(gp)
 2008f2c:	00001406 	br	2008f80 <calcularError+0x270>

	if((s0+s1+s2+s3+s4+s5+s6+s7)>2) return errorPasado;
 2008f30:	e0fff617 	ldw	r3,-40(fp)
 2008f34:	e0bff717 	ldw	r2,-36(fp)
 2008f38:	1887883a 	add	r3,r3,r2
 2008f3c:	e0bff817 	ldw	r2,-32(fp)
 2008f40:	1887883a 	add	r3,r3,r2
 2008f44:	e0bff917 	ldw	r2,-28(fp)
 2008f48:	1887883a 	add	r3,r3,r2
 2008f4c:	e0bffa17 	ldw	r2,-24(fp)
 2008f50:	1887883a 	add	r3,r3,r2
 2008f54:	e0bffb17 	ldw	r2,-20(fp)
 2008f58:	1887883a 	add	r3,r3,r2
 2008f5c:	e0bffc17 	ldw	r2,-16(fp)
 2008f60:	1887883a 	add	r3,r3,r2
 2008f64:	e0bffd17 	ldw	r2,-12(fp)
 2008f68:	1885883a 	add	r2,r3,r2
 2008f6c:	108000d0 	cmplti	r2,r2,3
 2008f70:	1000021e 	bne	r2,zero,2008f7c <calcularError+0x26c>
 2008f74:	d0a08217 	ldw	r2,-32248(gp)
 2008f78:	00000106 	br	2008f80 <calcularError+0x270>

	return posicion;
 2008f7c:	e0bffe17 	ldw	r2,-8(fp)
}
 2008f80:	e6ffff04 	addi	sp,fp,-4
 2008f84:	dfc00217 	ldw	ra,8(sp)
 2008f88:	df000117 	ldw	fp,4(sp)
 2008f8c:	dc000017 	ldw	r16,0(sp)
 2008f90:	dec00304 	addi	sp,sp,12
 2008f94:	f800283a 	ret

02008f98 <escribirXBee>:

void escribirXBee()
{
 2008f98:	deff5804 	addi	sp,sp,-672
 2008f9c:	dfc0a715 	stw	ra,668(sp)
 2008fa0:	df00a615 	stw	fp,664(sp)
 2008fa4:	df00a604 	addi	fp,sp,664
	//LINEAS

	char bufferprim[20];
	char bufferseg[20];

	itoa(lineasIzquierda, bufferprim, 10 );
 2008fa8:	d0a00c17 	ldw	r2,-32720(gp)
 2008fac:	e0ff6704 	addi	r3,fp,-612
 2008fb0:	01800284 	movi	r6,10
 2008fb4:	180b883a 	mov	r5,r3
 2008fb8:	1009883a 	mov	r4,r2
 2008fbc:	200af340 	call	200af34 <itoa>
	itoa(lineasDerecha, bufferseg, 10 );
 2008fc0:	d0a00d17 	ldw	r2,-32716(gp)
 2008fc4:	e0ff6c04 	addi	r3,fp,-592
 2008fc8:	01800284 	movi	r6,10
 2008fcc:	180b883a 	mov	r5,r3
 2008fd0:	1009883a 	mov	r4,r2
 2008fd4:	200af340 	call	200af34 <itoa>

	char primerEnvio[200] = "Lineas Izquierda = ";
 2008fd8:	00995bb4 	movhi	r2,25966
 2008fdc:	109a5304 	addi	r2,r2,26956
 2008fe0:	e0bf7115 	stw	r2,-572(fp)
 2008fe4:	00924834 	movhi	r2,18720
 2008fe8:	109cd844 	addi	r2,r2,29537
 2008fec:	e0bf7215 	stw	r2,-568(fp)
 2008ff0:	009a5d74 	movhi	r2,26997
 2008ff4:	109c5e84 	addi	r2,r2,29050
 2008ff8:	e0bf7315 	stw	r2,-564(fp)
 2008ffc:	00985934 	movhi	r2,24932
 2009000:	109c9944 	addi	r2,r2,29285
 2009004:	e0bf7415 	stw	r2,-560(fp)
 2009008:	00800834 	movhi	r2,32
 200900c:	108f4804 	addi	r2,r2,15648
 2009010:	e0bf7515 	stw	r2,-556(fp)
 2009014:	e0bf7604 	addi	r2,fp,-552
 2009018:	00c02d04 	movi	r3,180
 200901c:	180d883a 	mov	r6,r3
 2009020:	000b883a 	mov	r5,zero
 2009024:	1009883a 	mov	r4,r2
 2009028:	200b0800 	call	200b080 <memset>
	strcat(primerEnvio,bufferprim);
 200902c:	e0ff6704 	addi	r3,fp,-612
 2009030:	e0bf7104 	addi	r2,fp,-572
 2009034:	180b883a 	mov	r5,r3
 2009038:	1009883a 	mov	r4,r2
 200903c:	200b27c0 	call	200b27c <strcat>

	char segundoEnvio[40] = "\t Lineas Derecha = ";
 2009040:	009a5334 	movhi	r2,26956
 2009044:	10880244 	addi	r2,r2,8201
 2009048:	e0bfa315 	stw	r2,-372(fp)
 200904c:	009cd874 	movhi	r2,29537
 2009050:	10995b84 	addi	r2,r2,25966
 2009054:	e0bfa415 	stw	r2,-368(fp)
 2009058:	009c9974 	movhi	r2,29285
 200905c:	10910804 	addi	r2,r2,17440
 2009060:	e0bfa515 	stw	r2,-364(fp)
 2009064:	00985a34 	movhi	r2,24936
 2009068:	1098d944 	addi	r2,r2,25445
 200906c:	e0bfa615 	stw	r2,-360(fp)
 2009070:	00800834 	movhi	r2,32
 2009074:	108f4804 	addi	r2,r2,15648
 2009078:	e0bfa715 	stw	r2,-356(fp)
 200907c:	e03fa815 	stw	zero,-352(fp)
 2009080:	e03fa915 	stw	zero,-348(fp)
 2009084:	e03faa15 	stw	zero,-344(fp)
 2009088:	e03fab15 	stw	zero,-340(fp)
 200908c:	e03fac15 	stw	zero,-336(fp)
	strcat(primerEnvio, segundoEnvio);
 2009090:	e0ffa304 	addi	r3,fp,-372
 2009094:	e0bf7104 	addi	r2,fp,-572
 2009098:	180b883a 	mov	r5,r3
 200909c:	1009883a 	mov	r4,r2
 20090a0:	200b27c0 	call	200b27c <strcat>
	strcat(primerEnvio,bufferseg);
 20090a4:	e0ff6c04 	addi	r3,fp,-592
 20090a8:	e0bf7104 	addi	r2,fp,-572
 20090ac:	180b883a 	mov	r5,r3
 20090b0:	1009883a 	mov	r4,r2
 20090b4:	200b27c0 	call	200b27c <strcat>

	for(int i=0;i<strlen(primerEnvio);i++)
 20090b8:	e03f5a15 	stw	zero,-664(fp)
 20090bc:	00000f06 	br	20090fc <escribirXBee+0x164>
	{
		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,primerEnvio[i]);
 20090c0:	e0ff7104 	addi	r3,fp,-572
 20090c4:	e0bf5a17 	ldw	r2,-664(fp)
 20090c8:	1885883a 	add	r2,r3,r2
 20090cc:	10800003 	ldbu	r2,0(r2)
 20090d0:	10c03fcc 	andi	r3,r2,255
 20090d4:	18c0201c 	xori	r3,r3,128
 20090d8:	18ffe004 	addi	r3,r3,-128
 20090dc:	00810034 	movhi	r2,1024
 20090e0:	10880104 	addi	r2,r2,8196
 20090e4:	10c00035 	stwio	r3,0(r2)
		usleep(100);
 20090e8:	01001904 	movi	r4,100
 20090ec:	200e6f40 	call	200e6f4 <usleep>

	char segundoEnvio[40] = "\t Lineas Derecha = ";
	strcat(primerEnvio, segundoEnvio);
	strcat(primerEnvio,bufferseg);

	for(int i=0;i<strlen(primerEnvio);i++)
 20090f0:	e0bf5a17 	ldw	r2,-664(fp)
 20090f4:	10800044 	addi	r2,r2,1
 20090f8:	e0bf5a15 	stw	r2,-664(fp)
 20090fc:	e0bf7104 	addi	r2,fp,-572
 2009100:	1009883a 	mov	r4,r2
 2009104:	200b3900 	call	200b390 <strlen>
 2009108:	1007883a 	mov	r3,r2
 200910c:	e0bf5a17 	ldw	r2,-664(fp)
 2009110:	10ffeb36 	bltu	r2,r3,20090c0 <__reset+0xfe0080c0>
	{
		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,primerEnvio[i]);
		usleep(100);
	}

	IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,'\n');
 2009114:	00c00284 	movi	r3,10
 2009118:	00810034 	movhi	r2,1024
 200911c:	10880104 	addi	r2,r2,8196
 2009120:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,'\n');
 2009124:	00c00284 	movi	r3,10
 2009128:	00810034 	movhi	r2,1024
 200912c:	10880104 	addi	r2,r2,8196
 2009130:	10c00035 	stwio	r3,0(r2)

	//COLORES

	int Color1Cantidad = 0;
 2009134:	e03f5b15 	stw	zero,-660(fp)
	int Color2Cantidad = 0;
 2009138:	e03f5c15 	stw	zero,-656(fp)
	int Color3Cantidad = 0;
 200913c:	e03f5d15 	stw	zero,-652(fp)
	int Color4Cantidad = 0;
 2009140:	e03f5e15 	stw	zero,-648(fp)
	int Color5Cantidad = 0;
 2009144:	e03f5f15 	stw	zero,-644(fp)

	for(int u=0;u<8;u++)
 2009148:	e03f6015 	stw	zero,-640(fp)
 200914c:	00004306 	br	200925c <escribirXBee+0x2c4>
	{
		if(ColoresEncontrados[u] == 1)
 2009150:	0080a074 	movhi	r2,641
 2009154:	10918704 	addi	r2,r2,17948
 2009158:	e0ff6017 	ldw	r3,-640(fp)
 200915c:	18c7883a 	add	r3,r3,r3
 2009160:	18c7883a 	add	r3,r3,r3
 2009164:	10c5883a 	add	r2,r2,r3
 2009168:	10800017 	ldw	r2,0(r2)
 200916c:	10800058 	cmpnei	r2,r2,1
 2009170:	1000041e 	bne	r2,zero,2009184 <escribirXBee+0x1ec>
			Color1Cantidad++;
 2009174:	e0bf5b17 	ldw	r2,-660(fp)
 2009178:	10800044 	addi	r2,r2,1
 200917c:	e0bf5b15 	stw	r2,-660(fp)
 2009180:	00003306 	br	2009250 <escribirXBee+0x2b8>
		else if(ColoresEncontrados[u] == 2)
 2009184:	0080a074 	movhi	r2,641
 2009188:	10918704 	addi	r2,r2,17948
 200918c:	e0ff6017 	ldw	r3,-640(fp)
 2009190:	18c7883a 	add	r3,r3,r3
 2009194:	18c7883a 	add	r3,r3,r3
 2009198:	10c5883a 	add	r2,r2,r3
 200919c:	10800017 	ldw	r2,0(r2)
 20091a0:	10800098 	cmpnei	r2,r2,2
 20091a4:	1000041e 	bne	r2,zero,20091b8 <escribirXBee+0x220>
			Color2Cantidad++;
 20091a8:	e0bf5c17 	ldw	r2,-656(fp)
 20091ac:	10800044 	addi	r2,r2,1
 20091b0:	e0bf5c15 	stw	r2,-656(fp)
 20091b4:	00002606 	br	2009250 <escribirXBee+0x2b8>
		else if(ColoresEncontrados[u] == 3)
 20091b8:	0080a074 	movhi	r2,641
 20091bc:	10918704 	addi	r2,r2,17948
 20091c0:	e0ff6017 	ldw	r3,-640(fp)
 20091c4:	18c7883a 	add	r3,r3,r3
 20091c8:	18c7883a 	add	r3,r3,r3
 20091cc:	10c5883a 	add	r2,r2,r3
 20091d0:	10800017 	ldw	r2,0(r2)
 20091d4:	108000d8 	cmpnei	r2,r2,3
 20091d8:	1000041e 	bne	r2,zero,20091ec <escribirXBee+0x254>
			Color3Cantidad++;
 20091dc:	e0bf5d17 	ldw	r2,-652(fp)
 20091e0:	10800044 	addi	r2,r2,1
 20091e4:	e0bf5d15 	stw	r2,-652(fp)
 20091e8:	00001906 	br	2009250 <escribirXBee+0x2b8>
		else if(ColoresEncontrados[u] == 4)
 20091ec:	0080a074 	movhi	r2,641
 20091f0:	10918704 	addi	r2,r2,17948
 20091f4:	e0ff6017 	ldw	r3,-640(fp)
 20091f8:	18c7883a 	add	r3,r3,r3
 20091fc:	18c7883a 	add	r3,r3,r3
 2009200:	10c5883a 	add	r2,r2,r3
 2009204:	10800017 	ldw	r2,0(r2)
 2009208:	10800118 	cmpnei	r2,r2,4
 200920c:	1000041e 	bne	r2,zero,2009220 <escribirXBee+0x288>
			Color4Cantidad++;
 2009210:	e0bf5e17 	ldw	r2,-648(fp)
 2009214:	10800044 	addi	r2,r2,1
 2009218:	e0bf5e15 	stw	r2,-648(fp)
 200921c:	00000c06 	br	2009250 <escribirXBee+0x2b8>
		else if(ColoresEncontrados[u] == 5)
 2009220:	0080a074 	movhi	r2,641
 2009224:	10918704 	addi	r2,r2,17948
 2009228:	e0ff6017 	ldw	r3,-640(fp)
 200922c:	18c7883a 	add	r3,r3,r3
 2009230:	18c7883a 	add	r3,r3,r3
 2009234:	10c5883a 	add	r2,r2,r3
 2009238:	10800017 	ldw	r2,0(r2)
 200923c:	10800158 	cmpnei	r2,r2,5
 2009240:	1000031e 	bne	r2,zero,2009250 <escribirXBee+0x2b8>
			Color5Cantidad++;
 2009244:	e0bf5f17 	ldw	r2,-644(fp)
 2009248:	10800044 	addi	r2,r2,1
 200924c:	e0bf5f15 	stw	r2,-644(fp)
	int Color2Cantidad = 0;
	int Color3Cantidad = 0;
	int Color4Cantidad = 0;
	int Color5Cantidad = 0;

	for(int u=0;u<8;u++)
 2009250:	e0bf6017 	ldw	r2,-640(fp)
 2009254:	10800044 	addi	r2,r2,1
 2009258:	e0bf6015 	stw	r2,-640(fp)
 200925c:	e0bf6017 	ldw	r2,-640(fp)
 2009260:	10800210 	cmplti	r2,r2,8
 2009264:	103fba1e 	bne	r2,zero,2009150 <__reset+0xfe008150>
			Color4Cantidad++;
		else if(ColoresEncontrados[u] == 5)
			Color5Cantidad++;
	}

	int Color1 = Color2Cantidad+Color3Cantidad+Color4Cantidad;
 2009268:	e0ff5c17 	ldw	r3,-656(fp)
 200926c:	e0bf5d17 	ldw	r2,-652(fp)
 2009270:	1887883a 	add	r3,r3,r2
 2009274:	e0bf5e17 	ldw	r2,-648(fp)
 2009278:	1885883a 	add	r2,r3,r2
 200927c:	e0bf6415 	stw	r2,-624(fp)
	int Color2 = 8;
 2009280:	00800204 	movi	r2,8
 2009284:	e0bf6515 	stw	r2,-620(fp)
	int Color3 = Color1Cantidad+Color5Cantidad;
 2009288:	e0ff5b17 	ldw	r3,-660(fp)
 200928c:	e0bf5f17 	ldw	r2,-644(fp)
 2009290:	1885883a 	add	r2,r3,r2
 2009294:	e0bf6615 	stw	r2,-616(fp)

	char bufferC1[10];
	char bufferC2[10];
	char bufferC3[10];

	itoa(Color1, bufferC1, 10 );
 2009298:	e0bfad04 	addi	r2,fp,-332
 200929c:	01800284 	movi	r6,10
 20092a0:	100b883a 	mov	r5,r2
 20092a4:	e13f6417 	ldw	r4,-624(fp)
 20092a8:	200af340 	call	200af34 <itoa>
	itoa(Color2, bufferC2, 10 );
 20092ac:	e0bfaf84 	addi	r2,fp,-322
 20092b0:	01800284 	movi	r6,10
 20092b4:	100b883a 	mov	r5,r2
 20092b8:	e13f6517 	ldw	r4,-620(fp)
 20092bc:	200af340 	call	200af34 <itoa>
	itoa(Color3, bufferC3, 10 );
 20092c0:	e0bfb204 	addi	r2,fp,-312
 20092c4:	01800284 	movi	r6,10
 20092c8:	100b883a 	mov	r5,r2
 20092cc:	e13f6617 	ldw	r4,-616(fp)
 20092d0:	200af340 	call	200af34 <itoa>

	char Color1Char[100] = "Maduro = ";
 20092d4:	00985344 	movi	r2,24909
 20092d8:	e0bfb48d 	sth	r2,-302(fp)
 20092dc:	009d5904 	movi	r2,30052
 20092e0:	e0bfb50d 	sth	r2,-300(fp)
 20092e4:	009bdc84 	movi	r2,28530
 20092e8:	e0bfb58d 	sth	r2,-298(fp)
 20092ec:	008f4804 	movi	r2,15648
 20092f0:	e0bfb60d 	sth	r2,-296(fp)
 20092f4:	00800804 	movi	r2,32
 20092f8:	e0bfb68d 	sth	r2,-294(fp)
 20092fc:	e03fb70d 	sth	zero,-292(fp)
 2009300:	e0bfb784 	addi	r2,fp,-290
 2009304:	00c01604 	movi	r3,88
 2009308:	180d883a 	mov	r6,r3
 200930c:	000b883a 	mov	r5,zero
 2009310:	1009883a 	mov	r4,r2
 2009314:	200b0800 	call	200b080 <memset>
	char Color2Char[100] = "Verde = ";
 2009318:	00995584 	movi	r2,25942
 200931c:	e0bfcd8d 	sth	r2,-202(fp)
 2009320:	00991c84 	movi	r2,25714
 2009324:	e0bfce0d 	sth	r2,-200(fp)
 2009328:	00881944 	movi	r2,8293
 200932c:	e0bfce8d 	sth	r2,-198(fp)
 2009330:	00880f44 	movi	r2,8253
 2009334:	e0bfcf0d 	sth	r2,-196(fp)
 2009338:	e03fcf8d 	sth	zero,-194(fp)
 200933c:	e03fd00d 	sth	zero,-192(fp)
 2009340:	e0bfd084 	addi	r2,fp,-190
 2009344:	00c01604 	movi	r3,88
 2009348:	180d883a 	mov	r6,r3
 200934c:	000b883a 	mov	r5,zero
 2009350:	1009883a 	mov	r4,r2
 2009354:	200b0800 	call	200b080 <memset>
	char Color3Char[100] = "Sobre maduro = ";
 2009358:	009bd4c4 	movi	r2,28499
 200935c:	e0bfe68d 	sth	r2,-102(fp)
 2009360:	009c9884 	movi	r2,29282
 2009364:	e0bfe70d 	sth	r2,-100(fp)
 2009368:	00881944 	movi	r2,8293
 200936c:	e0bfe78d 	sth	r2,-98(fp)
 2009370:	00985b44 	movi	r2,24941
 2009374:	e0bfe80d 	sth	r2,-96(fp)
 2009378:	009d5904 	movi	r2,30052
 200937c:	e0bfe88d 	sth	r2,-94(fp)
 2009380:	009bdc84 	movi	r2,28530
 2009384:	e0bfe90d 	sth	r2,-92(fp)
 2009388:	008f4804 	movi	r2,15648
 200938c:	e0bfe98d 	sth	r2,-90(fp)
 2009390:	00800804 	movi	r2,32
 2009394:	e0bfea0d 	sth	r2,-88(fp)
 2009398:	e0bfea84 	addi	r2,fp,-86
 200939c:	00c01504 	movi	r3,84
 20093a0:	180d883a 	mov	r6,r3
 20093a4:	000b883a 	mov	r5,zero
 20093a8:	1009883a 	mov	r4,r2
 20093ac:	200b0800 	call	200b080 <memset>

	strcat(Color1Char,bufferC1);
 20093b0:	e0ffad04 	addi	r3,fp,-332
 20093b4:	e0bfb484 	addi	r2,fp,-302
 20093b8:	180b883a 	mov	r5,r3
 20093bc:	1009883a 	mov	r4,r2
 20093c0:	200b27c0 	call	200b27c <strcat>
	strcat(Color2Char,bufferC2);
 20093c4:	e0ffaf84 	addi	r3,fp,-322
 20093c8:	e0bfcd84 	addi	r2,fp,-202
 20093cc:	180b883a 	mov	r5,r3
 20093d0:	1009883a 	mov	r4,r2
 20093d4:	200b27c0 	call	200b27c <strcat>
	strcat(Color3Char,bufferC3);
 20093d8:	e0ffb204 	addi	r3,fp,-312
 20093dc:	e0bfe684 	addi	r2,fp,-102
 20093e0:	180b883a 	mov	r5,r3
 20093e4:	1009883a 	mov	r4,r2
 20093e8:	200b27c0 	call	200b27c <strcat>

	for(int i=0;i<strlen(Color1Char);i++)
 20093ec:	e03f6115 	stw	zero,-636(fp)
 20093f0:	00000f06 	br	2009430 <escribirXBee+0x498>
	{
		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,Color1Char[i]);
 20093f4:	e0ffb484 	addi	r3,fp,-302
 20093f8:	e0bf6117 	ldw	r2,-636(fp)
 20093fc:	1885883a 	add	r2,r3,r2
 2009400:	10800003 	ldbu	r2,0(r2)
 2009404:	10c03fcc 	andi	r3,r2,255
 2009408:	18c0201c 	xori	r3,r3,128
 200940c:	18ffe004 	addi	r3,r3,-128
 2009410:	00810034 	movhi	r2,1024
 2009414:	10880104 	addi	r2,r2,8196
 2009418:	10c00035 	stwio	r3,0(r2)
		usleep(100);
 200941c:	01001904 	movi	r4,100
 2009420:	200e6f40 	call	200e6f4 <usleep>

	strcat(Color1Char,bufferC1);
	strcat(Color2Char,bufferC2);
	strcat(Color3Char,bufferC3);

	for(int i=0;i<strlen(Color1Char);i++)
 2009424:	e0bf6117 	ldw	r2,-636(fp)
 2009428:	10800044 	addi	r2,r2,1
 200942c:	e0bf6115 	stw	r2,-636(fp)
 2009430:	e0bfb484 	addi	r2,fp,-302
 2009434:	1009883a 	mov	r4,r2
 2009438:	200b3900 	call	200b390 <strlen>
 200943c:	1007883a 	mov	r3,r2
 2009440:	e0bf6117 	ldw	r2,-636(fp)
 2009444:	10ffeb36 	bltu	r2,r3,20093f4 <__reset+0xfe0083f4>
	{
		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,Color1Char[i]);
		usleep(100);
	}
	IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,'\n');
 2009448:	00c00284 	movi	r3,10
 200944c:	00810034 	movhi	r2,1024
 2009450:	10880104 	addi	r2,r2,8196
 2009454:	10c00035 	stwio	r3,0(r2)

	for(int i=0;i<strlen(Color2Char);i++)
 2009458:	e03f6215 	stw	zero,-632(fp)
 200945c:	00000f06 	br	200949c <escribirXBee+0x504>
	{
		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,Color2Char[i]);
 2009460:	e0ffcd84 	addi	r3,fp,-202
 2009464:	e0bf6217 	ldw	r2,-632(fp)
 2009468:	1885883a 	add	r2,r3,r2
 200946c:	10800003 	ldbu	r2,0(r2)
 2009470:	10c03fcc 	andi	r3,r2,255
 2009474:	18c0201c 	xori	r3,r3,128
 2009478:	18ffe004 	addi	r3,r3,-128
 200947c:	00810034 	movhi	r2,1024
 2009480:	10880104 	addi	r2,r2,8196
 2009484:	10c00035 	stwio	r3,0(r2)
		usleep(100);
 2009488:	01001904 	movi	r4,100
 200948c:	200e6f40 	call	200e6f4 <usleep>
		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,Color1Char[i]);
		usleep(100);
	}
	IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,'\n');

	for(int i=0;i<strlen(Color2Char);i++)
 2009490:	e0bf6217 	ldw	r2,-632(fp)
 2009494:	10800044 	addi	r2,r2,1
 2009498:	e0bf6215 	stw	r2,-632(fp)
 200949c:	e0bfcd84 	addi	r2,fp,-202
 20094a0:	1009883a 	mov	r4,r2
 20094a4:	200b3900 	call	200b390 <strlen>
 20094a8:	1007883a 	mov	r3,r2
 20094ac:	e0bf6217 	ldw	r2,-632(fp)
 20094b0:	10ffeb36 	bltu	r2,r3,2009460 <__reset+0xfe008460>
	{
		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,Color2Char[i]);
		usleep(100);
	}
	IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,'\n');
 20094b4:	00c00284 	movi	r3,10
 20094b8:	00810034 	movhi	r2,1024
 20094bc:	10880104 	addi	r2,r2,8196
 20094c0:	10c00035 	stwio	r3,0(r2)

	for(int i=0;i<strlen(Color3Char);i++)
 20094c4:	e03f6315 	stw	zero,-628(fp)
 20094c8:	00000f06 	br	2009508 <escribirXBee+0x570>
	{
		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,Color3Char[i]);
 20094cc:	e0ffe684 	addi	r3,fp,-102
 20094d0:	e0bf6317 	ldw	r2,-628(fp)
 20094d4:	1885883a 	add	r2,r3,r2
 20094d8:	10800003 	ldbu	r2,0(r2)
 20094dc:	10c03fcc 	andi	r3,r2,255
 20094e0:	18c0201c 	xori	r3,r3,128
 20094e4:	18ffe004 	addi	r3,r3,-128
 20094e8:	00810034 	movhi	r2,1024
 20094ec:	10880104 	addi	r2,r2,8196
 20094f0:	10c00035 	stwio	r3,0(r2)
		usleep(100);
 20094f4:	01001904 	movi	r4,100
 20094f8:	200e6f40 	call	200e6f4 <usleep>
		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,Color2Char[i]);
		usleep(100);
	}
	IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,'\n');

	for(int i=0;i<strlen(Color3Char);i++)
 20094fc:	e0bf6317 	ldw	r2,-628(fp)
 2009500:	10800044 	addi	r2,r2,1
 2009504:	e0bf6315 	stw	r2,-628(fp)
 2009508:	e0bfe684 	addi	r2,fp,-102
 200950c:	1009883a 	mov	r4,r2
 2009510:	200b3900 	call	200b390 <strlen>
 2009514:	1007883a 	mov	r3,r2
 2009518:	e0bf6317 	ldw	r2,-628(fp)
 200951c:	10ffeb36 	bltu	r2,r3,20094cc <__reset+0xfe0084cc>
	{
		IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,Color3Char[i]);
		usleep(100);
	}
	IOWR_ALTERA_AVALON_UART_TXDATA(UART_BASE,'\n');
 2009520:	00c00284 	movi	r3,10
 2009524:	00810034 	movhi	r2,1024
 2009528:	10880104 	addi	r2,r2,8196
 200952c:	10c00035 	stwio	r3,0(r2)

	envioXbeeFinalizado = true;
 2009530:	00800044 	movi	r2,1
 2009534:	d0a08705 	stb	r2,-32228(gp)

}
 2009538:	0001883a 	nop
 200953c:	e037883a 	mov	sp,fp
 2009540:	dfc00117 	ldw	ra,4(sp)
 2009544:	df000017 	ldw	fp,0(sp)
 2009548:	dec00204 	addi	sp,sp,8
 200954c:	f800283a 	ret

02009550 <analizarPixy>:
void analizarPixy()
{
 2009550:	defff504 	addi	sp,sp,-44
 2009554:	dfc00a15 	stw	ra,40(sp)
 2009558:	df000915 	stw	fp,36(sp)
 200955c:	df000904 	addi	fp,sp,36
	//INICIO UART PIXY

	xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
 2009560:	d0a01017 	ldw	r2,-32704(gp)
 2009564:	000d883a 	mov	r6,zero
 2009568:	01400044 	movi	r5,1
 200956c:	1009883a 	mov	r4,r2
 2009570:	20044040 	call	2004404 <xQueueGenericCreate>
 2009574:	d0a08615 	stw	r2,-32232(gp)
	uartControl = ALTERA_AVALON_UART_CONTROL_RTS_MSK | ALTERA_AVALON_UART_CONTROL_RRDY_MSK | ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
 2009578:	00832004 	movi	r2,3200
 200957c:	d0a07f15 	stw	r2,-32260(gp)
	IOWR_ALTERA_AVALON_UART_CONTROL( UART_2_BASE, uartControl );
 2009580:	d0a07f17 	ldw	r2,-32260(gp)
 2009584:	1007883a 	mov	r3,r2
 2009588:	00810134 	movhi	r2,1028
 200958c:	10881304 	addi	r2,r2,8268
 2009590:	10c00035 	stwio	r3,0(r2)
	alt_ic_isr_register(UART_2_IRQ_INTERRUPT_CONTROLLER_ID, UART_2_IRQ,
 2009594:	d8000015 	stw	zero,0(sp)
 2009598:	000f883a 	mov	r7,zero
 200959c:	01808074 	movhi	r6,513
 20095a0:	31a62704 	addi	r6,r6,-26468
 20095a4:	01400144 	movi	r5,5
 20095a8:	0009883a 	mov	r4,zero
 20095ac:	200e00c0 	call	200e00c <alt_ic_isr_register>
			vUARTInterruptHandler, NULL, 0x0);

	//FIN UART PIXY

	bool terminoAnalisis=false;
 20095b0:	e03ff805 	stb	zero,-32(fp)

	bool encontroPrimer55=false;
 20095b4:	e03ff845 	stb	zero,-31(fp)
	bool encontroPrimerAA=false;
 20095b8:	e03ff885 	stb	zero,-30(fp)
	bool encontroSegundo55=false;
 20095bc:	e03ff8c5 	stb	zero,-29(fp)
	bool encontroSegundoAA=false;
 20095c0:	e03ff905 	stb	zero,-28(fp)

	bool encontroSecuencia=false;
 20095c4:	e03ff945 	stb	zero,-27(fp)

	bool repitioSecuencia=false;
 20095c8:	e03ff985 	stb	zero,-26(fp)

	memset(ColoresEncontrados, 0, sizeof(ColoresEncontrados));
 20095cc:	01803204 	movi	r6,200
 20095d0:	000b883a 	mov	r5,zero
 20095d4:	0100a074 	movhi	r4,641
 20095d8:	21118704 	addi	r4,r4,17948
 20095dc:	200b0800 	call	200b080 <memset>
	int cantidadColoresObtenidos = 0;
 20095e0:	e03ffa15 	stw	zero,-24(fp)
	bool primerFlagColor = false;
 20095e4:	e03ffb05 	stb	zero,-20(fp)
	int charsDesdeFlagColor = 0;
 20095e8:	e03ffc15 	stw	zero,-16(fp)

	while(!terminoAnalisis)
 20095ec:	00009906 	br	2009854 <analizarPixy+0x304>
	{
		//INICIO RECEPCION DE PALABRA
		signed char hola = 'A';
 20095f0:	00801044 	movi	r2,65
 20095f4:	e0bfff05 	stb	r2,-4(fp)
		signed char * datoObtenido = &hola;
 20095f8:	e0bfff04 	addi	r2,fp,-4
 20095fc:	e0bffd15 	stw	r2,-12(fp)

		signed portBASE_TYPE obtuvo = obtenerChar( ( xComPortHandle ) NULL, datoObtenido, ( TickType_t ) 200 );
 2009600:	01803204 	movi	r6,200
 2009604:	e17ffd17 	ldw	r5,-12(fp)
 2009608:	0009883a 	mov	r4,zero
 200960c:	20099a00 	call	20099a0 <obtenerChar>
 2009610:	e0bffe15 	stw	r2,-8(fp)

		//printf("%x \n", *datoObtenido);

		if(obtuvo == pdTRUE)
 2009614:	e0bffe17 	ldw	r2,-8(fp)
 2009618:	10800058 	cmpnei	r2,r2,1
 200961c:	10008d1e 	bne	r2,zero,2009854 <analizarPixy+0x304>
		{
			if(*datoObtenido == dobleA && encontroSegundo55)
 2009620:	e0bffd17 	ldw	r2,-12(fp)
 2009624:	10c00003 	ldbu	r3,0(r2)
 2009628:	00bfea84 	movi	r2,-86
 200962c:	18c03fcc 	andi	r3,r3,255
 2009630:	18c0201c 	xori	r3,r3,128
 2009634:	18ffe004 	addi	r3,r3,-128
 2009638:	10803fcc 	andi	r2,r2,255
 200963c:	1080201c 	xori	r2,r2,128
 2009640:	10bfe004 	addi	r2,r2,-128
 2009644:	1880051e 	bne	r3,r2,200965c <analizarPixy+0x10c>
 2009648:	e0bff8c3 	ldbu	r2,-29(fp)
 200964c:	10000326 	beq	r2,zero,200965c <analizarPixy+0x10c>
			{
				encontroSegundoAA=true;
 2009650:	00800044 	movi	r2,1
 2009654:	e0bff905 	stb	r2,-28(fp)
 2009658:	00002f06 	br	2009718 <analizarPixy+0x1c8>
			}
			else if(*datoObtenido == doble5 && encontroPrimerAA)
 200965c:	e0bffd17 	ldw	r2,-12(fp)
 2009660:	10c00003 	ldbu	r3,0(r2)
 2009664:	00801544 	movi	r2,85
 2009668:	18c03fcc 	andi	r3,r3,255
 200966c:	18c0201c 	xori	r3,r3,128
 2009670:	18ffe004 	addi	r3,r3,-128
 2009674:	10803fcc 	andi	r2,r2,255
 2009678:	1080201c 	xori	r2,r2,128
 200967c:	10bfe004 	addi	r2,r2,-128
 2009680:	1880051e 	bne	r3,r2,2009698 <analizarPixy+0x148>
 2009684:	e0bff883 	ldbu	r2,-30(fp)
 2009688:	10000326 	beq	r2,zero,2009698 <analizarPixy+0x148>
			{
				encontroSegundo55=true;
 200968c:	00800044 	movi	r2,1
 2009690:	e0bff8c5 	stb	r2,-29(fp)
 2009694:	00002006 	br	2009718 <analizarPixy+0x1c8>
			}
			else if(*datoObtenido == dobleA && encontroPrimer55)
 2009698:	e0bffd17 	ldw	r2,-12(fp)
 200969c:	10c00003 	ldbu	r3,0(r2)
 20096a0:	00bfea84 	movi	r2,-86
 20096a4:	18c03fcc 	andi	r3,r3,255
 20096a8:	18c0201c 	xori	r3,r3,128
 20096ac:	18ffe004 	addi	r3,r3,-128
 20096b0:	10803fcc 	andi	r2,r2,255
 20096b4:	1080201c 	xori	r2,r2,128
 20096b8:	10bfe004 	addi	r2,r2,-128
 20096bc:	1880051e 	bne	r3,r2,20096d4 <analizarPixy+0x184>
 20096c0:	e0bff843 	ldbu	r2,-31(fp)
 20096c4:	10000326 	beq	r2,zero,20096d4 <analizarPixy+0x184>
			{
				encontroPrimerAA=true;
 20096c8:	00800044 	movi	r2,1
 20096cc:	e0bff885 	stb	r2,-30(fp)
 20096d0:	00001106 	br	2009718 <analizarPixy+0x1c8>
			}
			else if(*datoObtenido == doble5)
 20096d4:	e0bffd17 	ldw	r2,-12(fp)
 20096d8:	10c00003 	ldbu	r3,0(r2)
 20096dc:	00801544 	movi	r2,85
 20096e0:	18c03fcc 	andi	r3,r3,255
 20096e4:	18c0201c 	xori	r3,r3,128
 20096e8:	18ffe004 	addi	r3,r3,-128
 20096ec:	10803fcc 	andi	r2,r2,255
 20096f0:	1080201c 	xori	r2,r2,128
 20096f4:	10bfe004 	addi	r2,r2,-128
 20096f8:	1880031e 	bne	r3,r2,2009708 <analizarPixy+0x1b8>
			{
				encontroPrimer55 = true;
 20096fc:	00800044 	movi	r2,1
 2009700:	e0bff845 	stb	r2,-31(fp)
 2009704:	00000406 	br	2009718 <analizarPixy+0x1c8>
			}
			else
			{
				encontroPrimer55=false;
 2009708:	e03ff845 	stb	zero,-31(fp)
				encontroPrimerAA=false;
 200970c:	e03ff885 	stb	zero,-30(fp)
				encontroSegundo55=false;
 2009710:	e03ff8c5 	stb	zero,-29(fp)
				encontroSegundoAA=false;
 2009714:	e03ff905 	stb	zero,-28(fp)
			}
			if(encontroPrimer55&&encontroPrimerAA&&encontroSegundo55&&encontroSegundoAA&&encontroSecuencia)
 2009718:	e0bff843 	ldbu	r2,-31(fp)
 200971c:	10000c26 	beq	r2,zero,2009750 <analizarPixy+0x200>
 2009720:	e0bff883 	ldbu	r2,-30(fp)
 2009724:	10000a26 	beq	r2,zero,2009750 <analizarPixy+0x200>
 2009728:	e0bff8c3 	ldbu	r2,-29(fp)
 200972c:	10000826 	beq	r2,zero,2009750 <analizarPixy+0x200>
 2009730:	e0bff903 	ldbu	r2,-28(fp)
 2009734:	10000626 	beq	r2,zero,2009750 <analizarPixy+0x200>
 2009738:	e0bff943 	ldbu	r2,-27(fp)
 200973c:	10000426 	beq	r2,zero,2009750 <analizarPixy+0x200>
			{
				terminoAnalisis = true;
 2009740:	00800044 	movi	r2,1
 2009744:	e0bff805 	stb	r2,-32(fp)
				repitioSecuencia  = true;
 2009748:	00800044 	movi	r2,1
 200974c:	e0bff985 	stb	r2,-26(fp)
			}
			if(encontroPrimer55&&encontroPrimerAA&&encontroSegundo55&&encontroSegundoAA)
 2009750:	e0bff843 	ldbu	r2,-31(fp)
 2009754:	10000826 	beq	r2,zero,2009778 <analizarPixy+0x228>
 2009758:	e0bff883 	ldbu	r2,-30(fp)
 200975c:	10000626 	beq	r2,zero,2009778 <analizarPixy+0x228>
 2009760:	e0bff8c3 	ldbu	r2,-29(fp)
 2009764:	10000426 	beq	r2,zero,2009778 <analizarPixy+0x228>
 2009768:	e0bff903 	ldbu	r2,-28(fp)
 200976c:	10000226 	beq	r2,zero,2009778 <analizarPixy+0x228>
				encontroSecuencia=true;
 2009770:	00800044 	movi	r2,1
 2009774:	e0bff945 	stb	r2,-27(fp)

			if(encontroSecuencia && !repitioSecuencia)
 2009778:	e0bff943 	ldbu	r2,-27(fp)
 200977c:	10003526 	beq	r2,zero,2009854 <analizarPixy+0x304>
 2009780:	e0bff983 	ldbu	r2,-26(fp)
 2009784:	1080005c 	xori	r2,r2,1
 2009788:	10803fcc 	andi	r2,r2,255
 200978c:	10003126 	beq	r2,zero,2009854 <analizarPixy+0x304>
			{
				//CONTEO DE COLORES
				charsDesdeFlagColor++;
 2009790:	e0bffc17 	ldw	r2,-16(fp)
 2009794:	10800044 	addi	r2,r2,1
 2009798:	e0bffc15 	stw	r2,-16(fp)
				if(charsDesdeFlagColor == 4)
 200979c:	e0bffc17 	ldw	r2,-16(fp)
 20097a0:	10800118 	cmpnei	r2,r2,4
 20097a4:	10000f1e 	bne	r2,zero,20097e4 <analizarPixy+0x294>
				{
					ColoresEncontrados[cantidadColoresObtenidos] = *datoObtenido;
 20097a8:	e0bffd17 	ldw	r2,-12(fp)
 20097ac:	10800003 	ldbu	r2,0(r2)
 20097b0:	11003fcc 	andi	r4,r2,255
 20097b4:	2100201c 	xori	r4,r4,128
 20097b8:	213fe004 	addi	r4,r4,-128
 20097bc:	0080a074 	movhi	r2,641
 20097c0:	10918704 	addi	r2,r2,17948
 20097c4:	e0fffa17 	ldw	r3,-24(fp)
 20097c8:	18c7883a 	add	r3,r3,r3
 20097cc:	18c7883a 	add	r3,r3,r3
 20097d0:	10c5883a 	add	r2,r2,r3
 20097d4:	11000015 	stw	r4,0(r2)
					cantidadColoresObtenidos++;
 20097d8:	e0bffa17 	ldw	r2,-24(fp)
 20097dc:	10800044 	addi	r2,r2,1
 20097e0:	e0bffa15 	stw	r2,-24(fp)
				}
				//Mas colores
				if(*datoObtenido == dobleA && primerFlagColor)
 20097e4:	e0bffd17 	ldw	r2,-12(fp)
 20097e8:	10c00003 	ldbu	r3,0(r2)
 20097ec:	00bfea84 	movi	r2,-86
 20097f0:	18c03fcc 	andi	r3,r3,255
 20097f4:	18c0201c 	xori	r3,r3,128
 20097f8:	18ffe004 	addi	r3,r3,-128
 20097fc:	10803fcc 	andi	r2,r2,255
 2009800:	1080201c 	xori	r2,r2,128
 2009804:	10bfe004 	addi	r2,r2,-128
 2009808:	1880041e 	bne	r3,r2,200981c <analizarPixy+0x2cc>
 200980c:	e0bffb03 	ldbu	r2,-20(fp)
 2009810:	10000226 	beq	r2,zero,200981c <analizarPixy+0x2cc>
					charsDesdeFlagColor = 1;
 2009814:	00800044 	movi	r2,1
 2009818:	e0bffc15 	stw	r2,-16(fp)
				if(*datoObtenido == doble5)
 200981c:	e0bffd17 	ldw	r2,-12(fp)
 2009820:	10c00003 	ldbu	r3,0(r2)
 2009824:	00801544 	movi	r2,85
 2009828:	18c03fcc 	andi	r3,r3,255
 200982c:	18c0201c 	xori	r3,r3,128
 2009830:	18ffe004 	addi	r3,r3,-128
 2009834:	10803fcc 	andi	r2,r2,255
 2009838:	1080201c 	xori	r2,r2,128
 200983c:	10bfe004 	addi	r2,r2,-128
 2009840:	1880031e 	bne	r3,r2,2009850 <analizarPixy+0x300>
					primerFlagColor = true;
 2009844:	00800044 	movi	r2,1
 2009848:	e0bffb05 	stb	r2,-20(fp)
 200984c:	00000106 	br	2009854 <analizarPixy+0x304>
				else
					primerFlagColor = false;
 2009850:	e03ffb05 	stb	zero,-20(fp)
	memset(ColoresEncontrados, 0, sizeof(ColoresEncontrados));
	int cantidadColoresObtenidos = 0;
	bool primerFlagColor = false;
	int charsDesdeFlagColor = 0;

	while(!terminoAnalisis)
 2009854:	e0bff803 	ldbu	r2,-32(fp)
 2009858:	1080005c 	xori	r2,r2,1
 200985c:	10803fcc 	andi	r2,r2,255
 2009860:	103f631e 	bne	r2,zero,20095f0 <__reset+0xfe0085f0>
					primerFlagColor = false;
			}
		}
	}

	lecturaPixyFinalizada = true;
 2009864:	00800044 	movi	r2,1
 2009868:	d0a08745 	stb	r2,-32227(gp)
	lineasIzquierda--;
 200986c:	d0a00c17 	ldw	r2,-32720(gp)
 2009870:	10bfffc4 	addi	r2,r2,-1
 2009874:	d0a00c15 	stw	r2,-32720(gp)
	lineasDerecha--;
 2009878:	d0a00d17 	ldw	r2,-32716(gp)
 200987c:	10bfffc4 	addi	r2,r2,-1
 2009880:	d0a00d15 	stw	r2,-32716(gp)


}
 2009884:	0001883a 	nop
 2009888:	e037883a 	mov	sp,fp
 200988c:	dfc00117 	ldw	ra,4(sp)
 2009890:	df000017 	ldw	fp,0(sp)
 2009894:	dec00204 	addi	sp,sp,8
 2009898:	f800283a 	ret

0200989c <vUARTInterruptHandler>:
static void vUARTInterruptHandler(void* context)
{
 200989c:	defffc04 	addi	sp,sp,-16
 20098a0:	dfc00315 	stw	ra,12(sp)
 20098a4:	df000215 	stw	fp,8(sp)
 20098a8:	df000204 	addi	fp,sp,8
 20098ac:	e13fff15 	stw	r4,-4(fp)
	alt_u32 status;

	/* Read the status register in order to determine the cause of the
    interrupt. */
	status = IORD_ALTERA_AVALON_UART_STATUS( UART_2_BASE );
 20098b0:	00810134 	movhi	r2,1028
 20098b4:	10881204 	addi	r2,r2,8264
 20098b8:	10800037 	ldwio	r2,0(r2)
 20098bc:	e0bffe15 	stw	r2,-8(fp)

	/* Clear any error flags set at the device */
	IOWR_ALTERA_AVALON_UART_STATUS( UART_2_BASE, 0 );
 20098c0:	0007883a 	mov	r3,zero
 20098c4:	00810134 	movhi	r2,1028
 20098c8:	10881204 	addi	r2,r2,8264
 20098cc:	10c00035 	stwio	r3,0(r2)

	/* process a read irq */
	if ( status & ALTERA_AVALON_UART_STATUS_RRDY_MSK )
 20098d0:	e0bffe17 	ldw	r2,-8(fp)
 20098d4:	1080200c 	andi	r2,r2,128
 20098d8:	10000226 	beq	r2,zero,20098e4 <vUARTInterruptHandler+0x48>
	{
		vUARTReceiveHandler( status );
 20098dc:	e13ffe17 	ldw	r4,-8(fp)
 20098e0:	20098fc0 	call	20098fc <vUARTReceiveHandler>
	}

}
 20098e4:	0001883a 	nop
 20098e8:	e037883a 	mov	sp,fp
 20098ec:	dfc00117 	ldw	ra,4(sp)
 20098f0:	df000017 	ldw	fp,0(sp)
 20098f4:	dec00204 	addi	sp,sp,8
 20098f8:	f800283a 	ret

020098fc <vUARTReceiveHandler>:
static void vUARTReceiveHandler( alt_u32 status )
{
 20098fc:	defffb04 	addi	sp,sp,-20
 2009900:	dfc00415 	stw	ra,16(sp)
 2009904:	df000315 	stw	fp,12(sp)
 2009908:	df000304 	addi	fp,sp,12
 200990c:	e13fff15 	stw	r4,-4(fp)
	char cChar;
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 2009910:	e03ffe15 	stw	zero,-8(fp)

	/* If there was an error, discard the data */

	if ( status & ( ALTERA_AVALON_UART_STATUS_PE_MSK | ALTERA_AVALON_UART_STATUS_FE_MSK ) )
 2009914:	e0bfff17 	ldw	r2,-4(fp)
 2009918:	108000cc 	andi	r2,r2,3
 200991c:	10001a1e 	bne	r2,zero,2009988 <vUARTReceiveHandler+0x8c>
	{
		return;
	}

	/* Transfer data from the device to the circular buffer */
	cChar = IORD_ALTERA_AVALON_UART_RXDATA( UART_2_BASE );
 2009920:	00810134 	movhi	r2,1028
 2009924:	10881004 	addi	r2,r2,8256
 2009928:	10800037 	ldwio	r2,0(r2)
 200992c:	e0bffd05 	stb	r2,-12(fp)

	if ( pdTRUE != xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken ) )
 2009930:	d0a08617 	ldw	r2,-32232(gp)
 2009934:	e0fffe04 	addi	r3,fp,-8
 2009938:	000f883a 	mov	r7,zero
 200993c:	180d883a 	mov	r6,r3
 2009940:	e17ffd04 	addi	r5,fp,-12
 2009944:	1009883a 	mov	r4,r2
 2009948:	20049240 	call	2004924 <xQueueGenericSendFromISR>
 200994c:	10800060 	cmpeqi	r2,r2,1
 2009950:	1000091e 	bne	r2,zero,2009978 <vUARTReceiveHandler+0x7c>
	{
		/* If the circular buffer was full, disable interrupts. Interrupts will
        be re-enabled when data is removed from the buffer. */
		uartControl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 2009954:	d0e07f17 	ldw	r3,-32260(gp)
 2009958:	00bfdfc4 	movi	r2,-129
 200995c:	1884703a 	and	r2,r3,r2
 2009960:	d0a07f15 	stw	r2,-32260(gp)
		IOWR_ALTERA_AVALON_UART_CONTROL( UART_2_BASE, uartControl );
 2009964:	d0a07f17 	ldw	r2,-32260(gp)
 2009968:	1007883a 	mov	r3,r2
 200996c:	00810134 	movhi	r2,1028
 2009970:	10881304 	addi	r2,r2,8268
 2009974:	10c00035 	stwio	r3,0(r2)
	}

	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
 2009978:	e0bffe17 	ldw	r2,-8(fp)
 200997c:	10000326 	beq	r2,zero,200998c <vUARTReceiveHandler+0x90>
 2009980:	20064680 	call	2006468 <vTaskSwitchContext>
 2009984:	00000106 	br	200998c <vUARTReceiveHandler+0x90>

	/* If there was an error, discard the data */

	if ( status & ( ALTERA_AVALON_UART_STATUS_PE_MSK | ALTERA_AVALON_UART_STATUS_FE_MSK ) )
	{
		return;
 2009988:	0001883a 	nop
		uartControl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
		IOWR_ALTERA_AVALON_UART_CONTROL( UART_2_BASE, uartControl );
	}

	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
}
 200998c:	e037883a 	mov	sp,fp
 2009990:	dfc00117 	ldw	ra,4(sp)
 2009994:	df000017 	ldw	fp,0(sp)
 2009998:	dec00204 	addi	sp,sp,8
 200999c:	f800283a 	ret

020099a0 <obtenerChar>:

signed portBASE_TYPE obtenerChar( xComPortHandle pxPort, signed char *pcRxedChar, portTickType xBlockTime )
{
 20099a0:	defffb04 	addi	sp,sp,-20
 20099a4:	dfc00415 	stw	ra,16(sp)
 20099a8:	df000315 	stw	fp,12(sp)
 20099ac:	df000304 	addi	fp,sp,12
 20099b0:	e13ffd15 	stw	r4,-12(fp)
 20099b4:	e17ffe15 	stw	r5,-8(fp)
 20099b8:	e1bfff15 	stw	r6,-4(fp)
	( void ) pxPort;


	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
 20099bc:	d0a08617 	ldw	r2,-32232(gp)
 20099c0:	000f883a 	mov	r7,zero
 20099c4:	e1bfff17 	ldw	r6,-4(fp)
 20099c8:	e17ffe17 	ldw	r5,-8(fp)
 20099cc:	1009883a 	mov	r4,r2
 20099d0:	2004ae80 	call	2004ae8 <xQueueGenericReceive>
 20099d4:	10000226 	beq	r2,zero,20099e0 <obtenerChar+0x40>
	{
		return pdTRUE;
 20099d8:	00800044 	movi	r2,1
 20099dc:	00000906 	br	2009a04 <obtenerChar+0x64>
	}
	else
	{
		uartControl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 20099e0:	d0a07f17 	ldw	r2,-32260(gp)
 20099e4:	10802014 	ori	r2,r2,128
 20099e8:	d0a07f15 	stw	r2,-32260(gp)
		IOWR_ALTERA_AVALON_UART_CONTROL( UART_2_BASE, uartControl );
 20099ec:	d0a07f17 	ldw	r2,-32260(gp)
 20099f0:	1007883a 	mov	r3,r2
 20099f4:	00810134 	movhi	r2,1028
 20099f8:	10881304 	addi	r2,r2,8268
 20099fc:	10c00035 	stwio	r3,0(r2)
		return pdFALSE;
 2009a00:	0005883a 	mov	r2,zero
	}
}
 2009a04:	e037883a 	mov	sp,fp
 2009a08:	dfc00117 	ldw	ra,4(sp)
 2009a0c:	df000017 	ldw	fp,0(sp)
 2009a10:	dec00204 	addi	sp,sp,8
 2009a14:	f800283a 	ret

02009a18 <__divsi3>:
 2009a18:	20001b16 	blt	r4,zero,2009a88 <__divsi3+0x70>
 2009a1c:	000f883a 	mov	r7,zero
 2009a20:	28001616 	blt	r5,zero,2009a7c <__divsi3+0x64>
 2009a24:	200d883a 	mov	r6,r4
 2009a28:	29001a2e 	bgeu	r5,r4,2009a94 <__divsi3+0x7c>
 2009a2c:	00800804 	movi	r2,32
 2009a30:	00c00044 	movi	r3,1
 2009a34:	00000106 	br	2009a3c <__divsi3+0x24>
 2009a38:	10000d26 	beq	r2,zero,2009a70 <__divsi3+0x58>
 2009a3c:	294b883a 	add	r5,r5,r5
 2009a40:	10bfffc4 	addi	r2,r2,-1
 2009a44:	18c7883a 	add	r3,r3,r3
 2009a48:	293ffb36 	bltu	r5,r4,2009a38 <__reset+0xfe008a38>
 2009a4c:	0005883a 	mov	r2,zero
 2009a50:	18000726 	beq	r3,zero,2009a70 <__divsi3+0x58>
 2009a54:	0005883a 	mov	r2,zero
 2009a58:	31400236 	bltu	r6,r5,2009a64 <__divsi3+0x4c>
 2009a5c:	314dc83a 	sub	r6,r6,r5
 2009a60:	10c4b03a 	or	r2,r2,r3
 2009a64:	1806d07a 	srli	r3,r3,1
 2009a68:	280ad07a 	srli	r5,r5,1
 2009a6c:	183ffa1e 	bne	r3,zero,2009a58 <__reset+0xfe008a58>
 2009a70:	38000126 	beq	r7,zero,2009a78 <__divsi3+0x60>
 2009a74:	0085c83a 	sub	r2,zero,r2
 2009a78:	f800283a 	ret
 2009a7c:	014bc83a 	sub	r5,zero,r5
 2009a80:	39c0005c 	xori	r7,r7,1
 2009a84:	003fe706 	br	2009a24 <__reset+0xfe008a24>
 2009a88:	0109c83a 	sub	r4,zero,r4
 2009a8c:	01c00044 	movi	r7,1
 2009a90:	003fe306 	br	2009a20 <__reset+0xfe008a20>
 2009a94:	00c00044 	movi	r3,1
 2009a98:	003fee06 	br	2009a54 <__reset+0xfe008a54>

02009a9c <__modsi3>:
 2009a9c:	20001716 	blt	r4,zero,2009afc <__modsi3+0x60>
 2009aa0:	000f883a 	mov	r7,zero
 2009aa4:	2005883a 	mov	r2,r4
 2009aa8:	28001216 	blt	r5,zero,2009af4 <__modsi3+0x58>
 2009aac:	2900162e 	bgeu	r5,r4,2009b08 <__modsi3+0x6c>
 2009ab0:	01800804 	movi	r6,32
 2009ab4:	00c00044 	movi	r3,1
 2009ab8:	00000106 	br	2009ac0 <__modsi3+0x24>
 2009abc:	30000a26 	beq	r6,zero,2009ae8 <__modsi3+0x4c>
 2009ac0:	294b883a 	add	r5,r5,r5
 2009ac4:	31bfffc4 	addi	r6,r6,-1
 2009ac8:	18c7883a 	add	r3,r3,r3
 2009acc:	293ffb36 	bltu	r5,r4,2009abc <__reset+0xfe008abc>
 2009ad0:	18000526 	beq	r3,zero,2009ae8 <__modsi3+0x4c>
 2009ad4:	1806d07a 	srli	r3,r3,1
 2009ad8:	11400136 	bltu	r2,r5,2009ae0 <__modsi3+0x44>
 2009adc:	1145c83a 	sub	r2,r2,r5
 2009ae0:	280ad07a 	srli	r5,r5,1
 2009ae4:	183ffb1e 	bne	r3,zero,2009ad4 <__reset+0xfe008ad4>
 2009ae8:	38000126 	beq	r7,zero,2009af0 <__modsi3+0x54>
 2009aec:	0085c83a 	sub	r2,zero,r2
 2009af0:	f800283a 	ret
 2009af4:	014bc83a 	sub	r5,zero,r5
 2009af8:	003fec06 	br	2009aac <__reset+0xfe008aac>
 2009afc:	0109c83a 	sub	r4,zero,r4
 2009b00:	01c00044 	movi	r7,1
 2009b04:	003fe706 	br	2009aa4 <__reset+0xfe008aa4>
 2009b08:	00c00044 	movi	r3,1
 2009b0c:	003ff106 	br	2009ad4 <__reset+0xfe008ad4>

02009b10 <__udivsi3>:
 2009b10:	200d883a 	mov	r6,r4
 2009b14:	2900152e 	bgeu	r5,r4,2009b6c <__udivsi3+0x5c>
 2009b18:	28001416 	blt	r5,zero,2009b6c <__udivsi3+0x5c>
 2009b1c:	00800804 	movi	r2,32
 2009b20:	00c00044 	movi	r3,1
 2009b24:	00000206 	br	2009b30 <__udivsi3+0x20>
 2009b28:	10000e26 	beq	r2,zero,2009b64 <__udivsi3+0x54>
 2009b2c:	28000516 	blt	r5,zero,2009b44 <__udivsi3+0x34>
 2009b30:	294b883a 	add	r5,r5,r5
 2009b34:	10bfffc4 	addi	r2,r2,-1
 2009b38:	18c7883a 	add	r3,r3,r3
 2009b3c:	293ffa36 	bltu	r5,r4,2009b28 <__reset+0xfe008b28>
 2009b40:	18000826 	beq	r3,zero,2009b64 <__udivsi3+0x54>
 2009b44:	0005883a 	mov	r2,zero
 2009b48:	31400236 	bltu	r6,r5,2009b54 <__udivsi3+0x44>
 2009b4c:	314dc83a 	sub	r6,r6,r5
 2009b50:	10c4b03a 	or	r2,r2,r3
 2009b54:	1806d07a 	srli	r3,r3,1
 2009b58:	280ad07a 	srli	r5,r5,1
 2009b5c:	183ffa1e 	bne	r3,zero,2009b48 <__reset+0xfe008b48>
 2009b60:	f800283a 	ret
 2009b64:	0005883a 	mov	r2,zero
 2009b68:	f800283a 	ret
 2009b6c:	00c00044 	movi	r3,1
 2009b70:	003ff406 	br	2009b44 <__reset+0xfe008b44>

02009b74 <__umodsi3>:
 2009b74:	2005883a 	mov	r2,r4
 2009b78:	2900122e 	bgeu	r5,r4,2009bc4 <__umodsi3+0x50>
 2009b7c:	28001116 	blt	r5,zero,2009bc4 <__umodsi3+0x50>
 2009b80:	01800804 	movi	r6,32
 2009b84:	00c00044 	movi	r3,1
 2009b88:	00000206 	br	2009b94 <__umodsi3+0x20>
 2009b8c:	30000c26 	beq	r6,zero,2009bc0 <__umodsi3+0x4c>
 2009b90:	28000516 	blt	r5,zero,2009ba8 <__umodsi3+0x34>
 2009b94:	294b883a 	add	r5,r5,r5
 2009b98:	31bfffc4 	addi	r6,r6,-1
 2009b9c:	18c7883a 	add	r3,r3,r3
 2009ba0:	293ffa36 	bltu	r5,r4,2009b8c <__reset+0xfe008b8c>
 2009ba4:	18000626 	beq	r3,zero,2009bc0 <__umodsi3+0x4c>
 2009ba8:	1806d07a 	srli	r3,r3,1
 2009bac:	11400136 	bltu	r2,r5,2009bb4 <__umodsi3+0x40>
 2009bb0:	1145c83a 	sub	r2,r2,r5
 2009bb4:	280ad07a 	srli	r5,r5,1
 2009bb8:	183ffb1e 	bne	r3,zero,2009ba8 <__reset+0xfe008ba8>
 2009bbc:	f800283a 	ret
 2009bc0:	f800283a 	ret
 2009bc4:	00c00044 	movi	r3,1
 2009bc8:	003ff706 	br	2009ba8 <__reset+0xfe008ba8>

02009bcc <__mulsi3>:
 2009bcc:	0005883a 	mov	r2,zero
 2009bd0:	20000726 	beq	r4,zero,2009bf0 <__mulsi3+0x24>
 2009bd4:	20c0004c 	andi	r3,r4,1
 2009bd8:	2008d07a 	srli	r4,r4,1
 2009bdc:	18000126 	beq	r3,zero,2009be4 <__mulsi3+0x18>
 2009be0:	1145883a 	add	r2,r2,r5
 2009be4:	294b883a 	add	r5,r5,r5
 2009be8:	203ffa1e 	bne	r4,zero,2009bd4 <__reset+0xfe008bd4>
 2009bec:	f800283a 	ret
 2009bf0:	f800283a 	ret

02009bf4 <__adddf3>:
 2009bf4:	02c00434 	movhi	r11,16
 2009bf8:	5affffc4 	addi	r11,r11,-1
 2009bfc:	2806d7fa 	srli	r3,r5,31
 2009c00:	2ad4703a 	and	r10,r5,r11
 2009c04:	3ad2703a 	and	r9,r7,r11
 2009c08:	3804d53a 	srli	r2,r7,20
 2009c0c:	3018d77a 	srli	r12,r6,29
 2009c10:	280ad53a 	srli	r5,r5,20
 2009c14:	501490fa 	slli	r10,r10,3
 2009c18:	2010d77a 	srli	r8,r4,29
 2009c1c:	481290fa 	slli	r9,r9,3
 2009c20:	380ed7fa 	srli	r7,r7,31
 2009c24:	defffb04 	addi	sp,sp,-20
 2009c28:	dc800215 	stw	r18,8(sp)
 2009c2c:	dc400115 	stw	r17,4(sp)
 2009c30:	dc000015 	stw	r16,0(sp)
 2009c34:	dfc00415 	stw	ra,16(sp)
 2009c38:	dcc00315 	stw	r19,12(sp)
 2009c3c:	1c803fcc 	andi	r18,r3,255
 2009c40:	2c01ffcc 	andi	r16,r5,2047
 2009c44:	5210b03a 	or	r8,r10,r8
 2009c48:	202290fa 	slli	r17,r4,3
 2009c4c:	1081ffcc 	andi	r2,r2,2047
 2009c50:	4b12b03a 	or	r9,r9,r12
 2009c54:	300c90fa 	slli	r6,r6,3
 2009c58:	91c07526 	beq	r18,r7,2009e30 <__adddf3+0x23c>
 2009c5c:	8087c83a 	sub	r3,r16,r2
 2009c60:	00c0ab0e 	bge	zero,r3,2009f10 <__adddf3+0x31c>
 2009c64:	10002a1e 	bne	r2,zero,2009d10 <__adddf3+0x11c>
 2009c68:	4984b03a 	or	r2,r9,r6
 2009c6c:	1000961e 	bne	r2,zero,2009ec8 <__adddf3+0x2d4>
 2009c70:	888001cc 	andi	r2,r17,7
 2009c74:	10000726 	beq	r2,zero,2009c94 <__adddf3+0xa0>
 2009c78:	888003cc 	andi	r2,r17,15
 2009c7c:	00c00104 	movi	r3,4
 2009c80:	10c00426 	beq	r2,r3,2009c94 <__adddf3+0xa0>
 2009c84:	88c7883a 	add	r3,r17,r3
 2009c88:	1c63803a 	cmpltu	r17,r3,r17
 2009c8c:	4451883a 	add	r8,r8,r17
 2009c90:	1823883a 	mov	r17,r3
 2009c94:	4080202c 	andhi	r2,r8,128
 2009c98:	10005926 	beq	r2,zero,2009e00 <__adddf3+0x20c>
 2009c9c:	84000044 	addi	r16,r16,1
 2009ca0:	0081ffc4 	movi	r2,2047
 2009ca4:	8080ba26 	beq	r16,r2,2009f90 <__adddf3+0x39c>
 2009ca8:	00bfe034 	movhi	r2,65408
 2009cac:	10bfffc4 	addi	r2,r2,-1
 2009cb0:	4090703a 	and	r8,r8,r2
 2009cb4:	4004977a 	slli	r2,r8,29
 2009cb8:	4010927a 	slli	r8,r8,9
 2009cbc:	8822d0fa 	srli	r17,r17,3
 2009cc0:	8401ffcc 	andi	r16,r16,2047
 2009cc4:	4010d33a 	srli	r8,r8,12
 2009cc8:	9007883a 	mov	r3,r18
 2009ccc:	1444b03a 	or	r2,r2,r17
 2009cd0:	8401ffcc 	andi	r16,r16,2047
 2009cd4:	8020953a 	slli	r16,r16,20
 2009cd8:	18c03fcc 	andi	r3,r3,255
 2009cdc:	01000434 	movhi	r4,16
 2009ce0:	213fffc4 	addi	r4,r4,-1
 2009ce4:	180697fa 	slli	r3,r3,31
 2009ce8:	4110703a 	and	r8,r8,r4
 2009cec:	4410b03a 	or	r8,r8,r16
 2009cf0:	40c6b03a 	or	r3,r8,r3
 2009cf4:	dfc00417 	ldw	ra,16(sp)
 2009cf8:	dcc00317 	ldw	r19,12(sp)
 2009cfc:	dc800217 	ldw	r18,8(sp)
 2009d00:	dc400117 	ldw	r17,4(sp)
 2009d04:	dc000017 	ldw	r16,0(sp)
 2009d08:	dec00504 	addi	sp,sp,20
 2009d0c:	f800283a 	ret
 2009d10:	0081ffc4 	movi	r2,2047
 2009d14:	80bfd626 	beq	r16,r2,2009c70 <__reset+0xfe008c70>
 2009d18:	4a402034 	orhi	r9,r9,128
 2009d1c:	00800e04 	movi	r2,56
 2009d20:	10c09f16 	blt	r2,r3,2009fa0 <__adddf3+0x3ac>
 2009d24:	008007c4 	movi	r2,31
 2009d28:	10c0c216 	blt	r2,r3,200a034 <__adddf3+0x440>
 2009d2c:	00800804 	movi	r2,32
 2009d30:	10c5c83a 	sub	r2,r2,r3
 2009d34:	488a983a 	sll	r5,r9,r2
 2009d38:	30c8d83a 	srl	r4,r6,r3
 2009d3c:	3084983a 	sll	r2,r6,r2
 2009d40:	48c6d83a 	srl	r3,r9,r3
 2009d44:	290cb03a 	or	r6,r5,r4
 2009d48:	1004c03a 	cmpne	r2,r2,zero
 2009d4c:	308cb03a 	or	r6,r6,r2
 2009d50:	898dc83a 	sub	r6,r17,r6
 2009d54:	89a3803a 	cmpltu	r17,r17,r6
 2009d58:	40d1c83a 	sub	r8,r8,r3
 2009d5c:	4451c83a 	sub	r8,r8,r17
 2009d60:	3023883a 	mov	r17,r6
 2009d64:	4080202c 	andhi	r2,r8,128
 2009d68:	10002326 	beq	r2,zero,2009df8 <__adddf3+0x204>
 2009d6c:	04c02034 	movhi	r19,128
 2009d70:	9cffffc4 	addi	r19,r19,-1
 2009d74:	44e6703a 	and	r19,r8,r19
 2009d78:	98007626 	beq	r19,zero,2009f54 <__adddf3+0x360>
 2009d7c:	9809883a 	mov	r4,r19
 2009d80:	200ae680 	call	200ae68 <__clzsi2>
 2009d84:	10fffe04 	addi	r3,r2,-8
 2009d88:	010007c4 	movi	r4,31
 2009d8c:	20c07716 	blt	r4,r3,2009f6c <__adddf3+0x378>
 2009d90:	00800804 	movi	r2,32
 2009d94:	10c5c83a 	sub	r2,r2,r3
 2009d98:	8884d83a 	srl	r2,r17,r2
 2009d9c:	98d0983a 	sll	r8,r19,r3
 2009da0:	88e2983a 	sll	r17,r17,r3
 2009da4:	1204b03a 	or	r2,r2,r8
 2009da8:	1c007416 	blt	r3,r16,2009f7c <__adddf3+0x388>
 2009dac:	1c21c83a 	sub	r16,r3,r16
 2009db0:	82000044 	addi	r8,r16,1
 2009db4:	00c007c4 	movi	r3,31
 2009db8:	1a009116 	blt	r3,r8,200a000 <__adddf3+0x40c>
 2009dbc:	00c00804 	movi	r3,32
 2009dc0:	1a07c83a 	sub	r3,r3,r8
 2009dc4:	8a08d83a 	srl	r4,r17,r8
 2009dc8:	88e2983a 	sll	r17,r17,r3
 2009dcc:	10c6983a 	sll	r3,r2,r3
 2009dd0:	1210d83a 	srl	r8,r2,r8
 2009dd4:	8804c03a 	cmpne	r2,r17,zero
 2009dd8:	1906b03a 	or	r3,r3,r4
 2009ddc:	18a2b03a 	or	r17,r3,r2
 2009de0:	0021883a 	mov	r16,zero
 2009de4:	003fa206 	br	2009c70 <__reset+0xfe008c70>
 2009de8:	1890b03a 	or	r8,r3,r2
 2009dec:	40017d26 	beq	r8,zero,200a3e4 <__adddf3+0x7f0>
 2009df0:	1011883a 	mov	r8,r2
 2009df4:	1823883a 	mov	r17,r3
 2009df8:	888001cc 	andi	r2,r17,7
 2009dfc:	103f9e1e 	bne	r2,zero,2009c78 <__reset+0xfe008c78>
 2009e00:	4004977a 	slli	r2,r8,29
 2009e04:	8822d0fa 	srli	r17,r17,3
 2009e08:	4010d0fa 	srli	r8,r8,3
 2009e0c:	9007883a 	mov	r3,r18
 2009e10:	1444b03a 	or	r2,r2,r17
 2009e14:	0101ffc4 	movi	r4,2047
 2009e18:	81002426 	beq	r16,r4,2009eac <__adddf3+0x2b8>
 2009e1c:	8120703a 	and	r16,r16,r4
 2009e20:	01000434 	movhi	r4,16
 2009e24:	213fffc4 	addi	r4,r4,-1
 2009e28:	4110703a 	and	r8,r8,r4
 2009e2c:	003fa806 	br	2009cd0 <__reset+0xfe008cd0>
 2009e30:	8089c83a 	sub	r4,r16,r2
 2009e34:	01005e0e 	bge	zero,r4,2009fb0 <__adddf3+0x3bc>
 2009e38:	10002b26 	beq	r2,zero,2009ee8 <__adddf3+0x2f4>
 2009e3c:	0081ffc4 	movi	r2,2047
 2009e40:	80bf8b26 	beq	r16,r2,2009c70 <__reset+0xfe008c70>
 2009e44:	4a402034 	orhi	r9,r9,128
 2009e48:	00800e04 	movi	r2,56
 2009e4c:	1100a40e 	bge	r2,r4,200a0e0 <__adddf3+0x4ec>
 2009e50:	498cb03a 	or	r6,r9,r6
 2009e54:	300ac03a 	cmpne	r5,r6,zero
 2009e58:	0013883a 	mov	r9,zero
 2009e5c:	2c4b883a 	add	r5,r5,r17
 2009e60:	2c63803a 	cmpltu	r17,r5,r17
 2009e64:	4a11883a 	add	r8,r9,r8
 2009e68:	8a11883a 	add	r8,r17,r8
 2009e6c:	2823883a 	mov	r17,r5
 2009e70:	4080202c 	andhi	r2,r8,128
 2009e74:	103fe026 	beq	r2,zero,2009df8 <__reset+0xfe008df8>
 2009e78:	84000044 	addi	r16,r16,1
 2009e7c:	0081ffc4 	movi	r2,2047
 2009e80:	8080d226 	beq	r16,r2,200a1cc <__adddf3+0x5d8>
 2009e84:	00bfe034 	movhi	r2,65408
 2009e88:	10bfffc4 	addi	r2,r2,-1
 2009e8c:	4090703a 	and	r8,r8,r2
 2009e90:	880ad07a 	srli	r5,r17,1
 2009e94:	400897fa 	slli	r4,r8,31
 2009e98:	88c0004c 	andi	r3,r17,1
 2009e9c:	28e2b03a 	or	r17,r5,r3
 2009ea0:	4010d07a 	srli	r8,r8,1
 2009ea4:	2462b03a 	or	r17,r4,r17
 2009ea8:	003f7106 	br	2009c70 <__reset+0xfe008c70>
 2009eac:	4088b03a 	or	r4,r8,r2
 2009eb0:	20014526 	beq	r4,zero,200a3c8 <__adddf3+0x7d4>
 2009eb4:	01000434 	movhi	r4,16
 2009eb8:	42000234 	orhi	r8,r8,8
 2009ebc:	213fffc4 	addi	r4,r4,-1
 2009ec0:	4110703a 	and	r8,r8,r4
 2009ec4:	003f8206 	br	2009cd0 <__reset+0xfe008cd0>
 2009ec8:	18ffffc4 	addi	r3,r3,-1
 2009ecc:	1800491e 	bne	r3,zero,2009ff4 <__adddf3+0x400>
 2009ed0:	898bc83a 	sub	r5,r17,r6
 2009ed4:	8963803a 	cmpltu	r17,r17,r5
 2009ed8:	4251c83a 	sub	r8,r8,r9
 2009edc:	4451c83a 	sub	r8,r8,r17
 2009ee0:	2823883a 	mov	r17,r5
 2009ee4:	003f9f06 	br	2009d64 <__reset+0xfe008d64>
 2009ee8:	4984b03a 	or	r2,r9,r6
 2009eec:	103f6026 	beq	r2,zero,2009c70 <__reset+0xfe008c70>
 2009ef0:	213fffc4 	addi	r4,r4,-1
 2009ef4:	2000931e 	bne	r4,zero,200a144 <__adddf3+0x550>
 2009ef8:	898d883a 	add	r6,r17,r6
 2009efc:	3463803a 	cmpltu	r17,r6,r17
 2009f00:	4251883a 	add	r8,r8,r9
 2009f04:	8a11883a 	add	r8,r17,r8
 2009f08:	3023883a 	mov	r17,r6
 2009f0c:	003fd806 	br	2009e70 <__reset+0xfe008e70>
 2009f10:	1800541e 	bne	r3,zero,200a064 <__adddf3+0x470>
 2009f14:	80800044 	addi	r2,r16,1
 2009f18:	1081ffcc 	andi	r2,r2,2047
 2009f1c:	00c00044 	movi	r3,1
 2009f20:	1880a00e 	bge	r3,r2,200a1a4 <__adddf3+0x5b0>
 2009f24:	8989c83a 	sub	r4,r17,r6
 2009f28:	8905803a 	cmpltu	r2,r17,r4
 2009f2c:	4267c83a 	sub	r19,r8,r9
 2009f30:	98a7c83a 	sub	r19,r19,r2
 2009f34:	9880202c 	andhi	r2,r19,128
 2009f38:	10006326 	beq	r2,zero,200a0c8 <__adddf3+0x4d4>
 2009f3c:	3463c83a 	sub	r17,r6,r17
 2009f40:	4a07c83a 	sub	r3,r9,r8
 2009f44:	344d803a 	cmpltu	r6,r6,r17
 2009f48:	19a7c83a 	sub	r19,r3,r6
 2009f4c:	3825883a 	mov	r18,r7
 2009f50:	983f8a1e 	bne	r19,zero,2009d7c <__reset+0xfe008d7c>
 2009f54:	8809883a 	mov	r4,r17
 2009f58:	200ae680 	call	200ae68 <__clzsi2>
 2009f5c:	10800804 	addi	r2,r2,32
 2009f60:	10fffe04 	addi	r3,r2,-8
 2009f64:	010007c4 	movi	r4,31
 2009f68:	20ff890e 	bge	r4,r3,2009d90 <__reset+0xfe008d90>
 2009f6c:	10bff604 	addi	r2,r2,-40
 2009f70:	8884983a 	sll	r2,r17,r2
 2009f74:	0023883a 	mov	r17,zero
 2009f78:	1c3f8c0e 	bge	r3,r16,2009dac <__reset+0xfe008dac>
 2009f7c:	023fe034 	movhi	r8,65408
 2009f80:	423fffc4 	addi	r8,r8,-1
 2009f84:	80e1c83a 	sub	r16,r16,r3
 2009f88:	1210703a 	and	r8,r2,r8
 2009f8c:	003f3806 	br	2009c70 <__reset+0xfe008c70>
 2009f90:	9007883a 	mov	r3,r18
 2009f94:	0011883a 	mov	r8,zero
 2009f98:	0005883a 	mov	r2,zero
 2009f9c:	003f4c06 	br	2009cd0 <__reset+0xfe008cd0>
 2009fa0:	498cb03a 	or	r6,r9,r6
 2009fa4:	300cc03a 	cmpne	r6,r6,zero
 2009fa8:	0007883a 	mov	r3,zero
 2009fac:	003f6806 	br	2009d50 <__reset+0xfe008d50>
 2009fb0:	20009c1e 	bne	r4,zero,200a224 <__adddf3+0x630>
 2009fb4:	80800044 	addi	r2,r16,1
 2009fb8:	1141ffcc 	andi	r5,r2,2047
 2009fbc:	01000044 	movi	r4,1
 2009fc0:	2140670e 	bge	r4,r5,200a160 <__adddf3+0x56c>
 2009fc4:	0101ffc4 	movi	r4,2047
 2009fc8:	11007f26 	beq	r2,r4,200a1c8 <__adddf3+0x5d4>
 2009fcc:	898d883a 	add	r6,r17,r6
 2009fd0:	4247883a 	add	r3,r8,r9
 2009fd4:	3451803a 	cmpltu	r8,r6,r17
 2009fd8:	40d1883a 	add	r8,r8,r3
 2009fdc:	402297fa 	slli	r17,r8,31
 2009fe0:	300cd07a 	srli	r6,r6,1
 2009fe4:	4010d07a 	srli	r8,r8,1
 2009fe8:	1021883a 	mov	r16,r2
 2009fec:	89a2b03a 	or	r17,r17,r6
 2009ff0:	003f1f06 	br	2009c70 <__reset+0xfe008c70>
 2009ff4:	0081ffc4 	movi	r2,2047
 2009ff8:	80bf481e 	bne	r16,r2,2009d1c <__reset+0xfe008d1c>
 2009ffc:	003f1c06 	br	2009c70 <__reset+0xfe008c70>
 200a000:	843ff844 	addi	r16,r16,-31
 200a004:	01000804 	movi	r4,32
 200a008:	1406d83a 	srl	r3,r2,r16
 200a00c:	41005026 	beq	r8,r4,200a150 <__adddf3+0x55c>
 200a010:	01001004 	movi	r4,64
 200a014:	2211c83a 	sub	r8,r4,r8
 200a018:	1204983a 	sll	r2,r2,r8
 200a01c:	88a2b03a 	or	r17,r17,r2
 200a020:	8822c03a 	cmpne	r17,r17,zero
 200a024:	1c62b03a 	or	r17,r3,r17
 200a028:	0011883a 	mov	r8,zero
 200a02c:	0021883a 	mov	r16,zero
 200a030:	003f7106 	br	2009df8 <__reset+0xfe008df8>
 200a034:	193ff804 	addi	r4,r3,-32
 200a038:	00800804 	movi	r2,32
 200a03c:	4908d83a 	srl	r4,r9,r4
 200a040:	18804526 	beq	r3,r2,200a158 <__adddf3+0x564>
 200a044:	00801004 	movi	r2,64
 200a048:	10c5c83a 	sub	r2,r2,r3
 200a04c:	4886983a 	sll	r3,r9,r2
 200a050:	198cb03a 	or	r6,r3,r6
 200a054:	300cc03a 	cmpne	r6,r6,zero
 200a058:	218cb03a 	or	r6,r4,r6
 200a05c:	0007883a 	mov	r3,zero
 200a060:	003f3b06 	br	2009d50 <__reset+0xfe008d50>
 200a064:	80002a26 	beq	r16,zero,200a110 <__adddf3+0x51c>
 200a068:	0101ffc4 	movi	r4,2047
 200a06c:	11006826 	beq	r2,r4,200a210 <__adddf3+0x61c>
 200a070:	00c7c83a 	sub	r3,zero,r3
 200a074:	42002034 	orhi	r8,r8,128
 200a078:	01000e04 	movi	r4,56
 200a07c:	20c07c16 	blt	r4,r3,200a270 <__adddf3+0x67c>
 200a080:	010007c4 	movi	r4,31
 200a084:	20c0da16 	blt	r4,r3,200a3f0 <__adddf3+0x7fc>
 200a088:	01000804 	movi	r4,32
 200a08c:	20c9c83a 	sub	r4,r4,r3
 200a090:	4114983a 	sll	r10,r8,r4
 200a094:	88cad83a 	srl	r5,r17,r3
 200a098:	8908983a 	sll	r4,r17,r4
 200a09c:	40c6d83a 	srl	r3,r8,r3
 200a0a0:	5162b03a 	or	r17,r10,r5
 200a0a4:	2008c03a 	cmpne	r4,r4,zero
 200a0a8:	8922b03a 	or	r17,r17,r4
 200a0ac:	3463c83a 	sub	r17,r6,r17
 200a0b0:	48c7c83a 	sub	r3,r9,r3
 200a0b4:	344d803a 	cmpltu	r6,r6,r17
 200a0b8:	1991c83a 	sub	r8,r3,r6
 200a0bc:	1021883a 	mov	r16,r2
 200a0c0:	3825883a 	mov	r18,r7
 200a0c4:	003f2706 	br	2009d64 <__reset+0xfe008d64>
 200a0c8:	24d0b03a 	or	r8,r4,r19
 200a0cc:	40001b1e 	bne	r8,zero,200a13c <__adddf3+0x548>
 200a0d0:	0005883a 	mov	r2,zero
 200a0d4:	0007883a 	mov	r3,zero
 200a0d8:	0021883a 	mov	r16,zero
 200a0dc:	003f4d06 	br	2009e14 <__reset+0xfe008e14>
 200a0e0:	008007c4 	movi	r2,31
 200a0e4:	11003c16 	blt	r2,r4,200a1d8 <__adddf3+0x5e4>
 200a0e8:	00800804 	movi	r2,32
 200a0ec:	1105c83a 	sub	r2,r2,r4
 200a0f0:	488e983a 	sll	r7,r9,r2
 200a0f4:	310ad83a 	srl	r5,r6,r4
 200a0f8:	3084983a 	sll	r2,r6,r2
 200a0fc:	4912d83a 	srl	r9,r9,r4
 200a100:	394ab03a 	or	r5,r7,r5
 200a104:	1004c03a 	cmpne	r2,r2,zero
 200a108:	288ab03a 	or	r5,r5,r2
 200a10c:	003f5306 	br	2009e5c <__reset+0xfe008e5c>
 200a110:	4448b03a 	or	r4,r8,r17
 200a114:	20003e26 	beq	r4,zero,200a210 <__adddf3+0x61c>
 200a118:	00c6303a 	nor	r3,zero,r3
 200a11c:	18003a1e 	bne	r3,zero,200a208 <__adddf3+0x614>
 200a120:	3463c83a 	sub	r17,r6,r17
 200a124:	4a07c83a 	sub	r3,r9,r8
 200a128:	344d803a 	cmpltu	r6,r6,r17
 200a12c:	1991c83a 	sub	r8,r3,r6
 200a130:	1021883a 	mov	r16,r2
 200a134:	3825883a 	mov	r18,r7
 200a138:	003f0a06 	br	2009d64 <__reset+0xfe008d64>
 200a13c:	2023883a 	mov	r17,r4
 200a140:	003f0d06 	br	2009d78 <__reset+0xfe008d78>
 200a144:	0081ffc4 	movi	r2,2047
 200a148:	80bf3f1e 	bne	r16,r2,2009e48 <__reset+0xfe008e48>
 200a14c:	003ec806 	br	2009c70 <__reset+0xfe008c70>
 200a150:	0005883a 	mov	r2,zero
 200a154:	003fb106 	br	200a01c <__reset+0xfe00901c>
 200a158:	0007883a 	mov	r3,zero
 200a15c:	003fbc06 	br	200a050 <__reset+0xfe009050>
 200a160:	4444b03a 	or	r2,r8,r17
 200a164:	8000871e 	bne	r16,zero,200a384 <__adddf3+0x790>
 200a168:	1000ba26 	beq	r2,zero,200a454 <__adddf3+0x860>
 200a16c:	4984b03a 	or	r2,r9,r6
 200a170:	103ebf26 	beq	r2,zero,2009c70 <__reset+0xfe008c70>
 200a174:	8985883a 	add	r2,r17,r6
 200a178:	4247883a 	add	r3,r8,r9
 200a17c:	1451803a 	cmpltu	r8,r2,r17
 200a180:	40d1883a 	add	r8,r8,r3
 200a184:	40c0202c 	andhi	r3,r8,128
 200a188:	1023883a 	mov	r17,r2
 200a18c:	183f1a26 	beq	r3,zero,2009df8 <__reset+0xfe008df8>
 200a190:	00bfe034 	movhi	r2,65408
 200a194:	10bfffc4 	addi	r2,r2,-1
 200a198:	2021883a 	mov	r16,r4
 200a19c:	4090703a 	and	r8,r8,r2
 200a1a0:	003eb306 	br	2009c70 <__reset+0xfe008c70>
 200a1a4:	4444b03a 	or	r2,r8,r17
 200a1a8:	8000291e 	bne	r16,zero,200a250 <__adddf3+0x65c>
 200a1ac:	10004b1e 	bne	r2,zero,200a2dc <__adddf3+0x6e8>
 200a1b0:	4990b03a 	or	r8,r9,r6
 200a1b4:	40008b26 	beq	r8,zero,200a3e4 <__adddf3+0x7f0>
 200a1b8:	4811883a 	mov	r8,r9
 200a1bc:	3023883a 	mov	r17,r6
 200a1c0:	3825883a 	mov	r18,r7
 200a1c4:	003eaa06 	br	2009c70 <__reset+0xfe008c70>
 200a1c8:	1021883a 	mov	r16,r2
 200a1cc:	0011883a 	mov	r8,zero
 200a1d0:	0005883a 	mov	r2,zero
 200a1d4:	003f0f06 	br	2009e14 <__reset+0xfe008e14>
 200a1d8:	217ff804 	addi	r5,r4,-32
 200a1dc:	00800804 	movi	r2,32
 200a1e0:	494ad83a 	srl	r5,r9,r5
 200a1e4:	20807d26 	beq	r4,r2,200a3dc <__adddf3+0x7e8>
 200a1e8:	00801004 	movi	r2,64
 200a1ec:	1109c83a 	sub	r4,r2,r4
 200a1f0:	4912983a 	sll	r9,r9,r4
 200a1f4:	498cb03a 	or	r6,r9,r6
 200a1f8:	300cc03a 	cmpne	r6,r6,zero
 200a1fc:	298ab03a 	or	r5,r5,r6
 200a200:	0013883a 	mov	r9,zero
 200a204:	003f1506 	br	2009e5c <__reset+0xfe008e5c>
 200a208:	0101ffc4 	movi	r4,2047
 200a20c:	113f9a1e 	bne	r2,r4,200a078 <__reset+0xfe009078>
 200a210:	4811883a 	mov	r8,r9
 200a214:	3023883a 	mov	r17,r6
 200a218:	1021883a 	mov	r16,r2
 200a21c:	3825883a 	mov	r18,r7
 200a220:	003e9306 	br	2009c70 <__reset+0xfe008c70>
 200a224:	8000161e 	bne	r16,zero,200a280 <__adddf3+0x68c>
 200a228:	444ab03a 	or	r5,r8,r17
 200a22c:	28005126 	beq	r5,zero,200a374 <__adddf3+0x780>
 200a230:	0108303a 	nor	r4,zero,r4
 200a234:	20004d1e 	bne	r4,zero,200a36c <__adddf3+0x778>
 200a238:	89a3883a 	add	r17,r17,r6
 200a23c:	4253883a 	add	r9,r8,r9
 200a240:	898d803a 	cmpltu	r6,r17,r6
 200a244:	3251883a 	add	r8,r6,r9
 200a248:	1021883a 	mov	r16,r2
 200a24c:	003f0806 	br	2009e70 <__reset+0xfe008e70>
 200a250:	1000301e 	bne	r2,zero,200a314 <__adddf3+0x720>
 200a254:	4984b03a 	or	r2,r9,r6
 200a258:	10007126 	beq	r2,zero,200a420 <__adddf3+0x82c>
 200a25c:	4811883a 	mov	r8,r9
 200a260:	3023883a 	mov	r17,r6
 200a264:	3825883a 	mov	r18,r7
 200a268:	0401ffc4 	movi	r16,2047
 200a26c:	003e8006 	br	2009c70 <__reset+0xfe008c70>
 200a270:	4462b03a 	or	r17,r8,r17
 200a274:	8822c03a 	cmpne	r17,r17,zero
 200a278:	0007883a 	mov	r3,zero
 200a27c:	003f8b06 	br	200a0ac <__reset+0xfe0090ac>
 200a280:	0141ffc4 	movi	r5,2047
 200a284:	11403b26 	beq	r2,r5,200a374 <__adddf3+0x780>
 200a288:	0109c83a 	sub	r4,zero,r4
 200a28c:	42002034 	orhi	r8,r8,128
 200a290:	01400e04 	movi	r5,56
 200a294:	29006716 	blt	r5,r4,200a434 <__adddf3+0x840>
 200a298:	014007c4 	movi	r5,31
 200a29c:	29007016 	blt	r5,r4,200a460 <__adddf3+0x86c>
 200a2a0:	01400804 	movi	r5,32
 200a2a4:	290bc83a 	sub	r5,r5,r4
 200a2a8:	4154983a 	sll	r10,r8,r5
 200a2ac:	890ed83a 	srl	r7,r17,r4
 200a2b0:	894a983a 	sll	r5,r17,r5
 200a2b4:	4108d83a 	srl	r4,r8,r4
 200a2b8:	51e2b03a 	or	r17,r10,r7
 200a2bc:	280ac03a 	cmpne	r5,r5,zero
 200a2c0:	8962b03a 	or	r17,r17,r5
 200a2c4:	89a3883a 	add	r17,r17,r6
 200a2c8:	2253883a 	add	r9,r4,r9
 200a2cc:	898d803a 	cmpltu	r6,r17,r6
 200a2d0:	3251883a 	add	r8,r6,r9
 200a2d4:	1021883a 	mov	r16,r2
 200a2d8:	003ee506 	br	2009e70 <__reset+0xfe008e70>
 200a2dc:	4984b03a 	or	r2,r9,r6
 200a2e0:	103e6326 	beq	r2,zero,2009c70 <__reset+0xfe008c70>
 200a2e4:	8987c83a 	sub	r3,r17,r6
 200a2e8:	88c9803a 	cmpltu	r4,r17,r3
 200a2ec:	4245c83a 	sub	r2,r8,r9
 200a2f0:	1105c83a 	sub	r2,r2,r4
 200a2f4:	1100202c 	andhi	r4,r2,128
 200a2f8:	203ebb26 	beq	r4,zero,2009de8 <__reset+0xfe008de8>
 200a2fc:	3463c83a 	sub	r17,r6,r17
 200a300:	4a07c83a 	sub	r3,r9,r8
 200a304:	344d803a 	cmpltu	r6,r6,r17
 200a308:	1991c83a 	sub	r8,r3,r6
 200a30c:	3825883a 	mov	r18,r7
 200a310:	003e5706 	br	2009c70 <__reset+0xfe008c70>
 200a314:	4984b03a 	or	r2,r9,r6
 200a318:	10002e26 	beq	r2,zero,200a3d4 <__adddf3+0x7e0>
 200a31c:	4004d0fa 	srli	r2,r8,3
 200a320:	8822d0fa 	srli	r17,r17,3
 200a324:	4010977a 	slli	r8,r8,29
 200a328:	10c0022c 	andhi	r3,r2,8
 200a32c:	4462b03a 	or	r17,r8,r17
 200a330:	18000826 	beq	r3,zero,200a354 <__adddf3+0x760>
 200a334:	4808d0fa 	srli	r4,r9,3
 200a338:	20c0022c 	andhi	r3,r4,8
 200a33c:	1800051e 	bne	r3,zero,200a354 <__adddf3+0x760>
 200a340:	300cd0fa 	srli	r6,r6,3
 200a344:	4806977a 	slli	r3,r9,29
 200a348:	2005883a 	mov	r2,r4
 200a34c:	3825883a 	mov	r18,r7
 200a350:	19a2b03a 	or	r17,r3,r6
 200a354:	8810d77a 	srli	r8,r17,29
 200a358:	100490fa 	slli	r2,r2,3
 200a35c:	882290fa 	slli	r17,r17,3
 200a360:	0401ffc4 	movi	r16,2047
 200a364:	4090b03a 	or	r8,r8,r2
 200a368:	003e4106 	br	2009c70 <__reset+0xfe008c70>
 200a36c:	0141ffc4 	movi	r5,2047
 200a370:	117fc71e 	bne	r2,r5,200a290 <__reset+0xfe009290>
 200a374:	4811883a 	mov	r8,r9
 200a378:	3023883a 	mov	r17,r6
 200a37c:	1021883a 	mov	r16,r2
 200a380:	003e3b06 	br	2009c70 <__reset+0xfe008c70>
 200a384:	10002f26 	beq	r2,zero,200a444 <__adddf3+0x850>
 200a388:	4984b03a 	or	r2,r9,r6
 200a38c:	10001126 	beq	r2,zero,200a3d4 <__adddf3+0x7e0>
 200a390:	4004d0fa 	srli	r2,r8,3
 200a394:	8822d0fa 	srli	r17,r17,3
 200a398:	4010977a 	slli	r8,r8,29
 200a39c:	10c0022c 	andhi	r3,r2,8
 200a3a0:	4462b03a 	or	r17,r8,r17
 200a3a4:	183feb26 	beq	r3,zero,200a354 <__reset+0xfe009354>
 200a3a8:	4808d0fa 	srli	r4,r9,3
 200a3ac:	20c0022c 	andhi	r3,r4,8
 200a3b0:	183fe81e 	bne	r3,zero,200a354 <__reset+0xfe009354>
 200a3b4:	300cd0fa 	srli	r6,r6,3
 200a3b8:	4806977a 	slli	r3,r9,29
 200a3bc:	2005883a 	mov	r2,r4
 200a3c0:	19a2b03a 	or	r17,r3,r6
 200a3c4:	003fe306 	br	200a354 <__reset+0xfe009354>
 200a3c8:	0011883a 	mov	r8,zero
 200a3cc:	0005883a 	mov	r2,zero
 200a3d0:	003e3f06 	br	2009cd0 <__reset+0xfe008cd0>
 200a3d4:	0401ffc4 	movi	r16,2047
 200a3d8:	003e2506 	br	2009c70 <__reset+0xfe008c70>
 200a3dc:	0013883a 	mov	r9,zero
 200a3e0:	003f8406 	br	200a1f4 <__reset+0xfe0091f4>
 200a3e4:	0005883a 	mov	r2,zero
 200a3e8:	0007883a 	mov	r3,zero
 200a3ec:	003e8906 	br	2009e14 <__reset+0xfe008e14>
 200a3f0:	197ff804 	addi	r5,r3,-32
 200a3f4:	01000804 	movi	r4,32
 200a3f8:	414ad83a 	srl	r5,r8,r5
 200a3fc:	19002426 	beq	r3,r4,200a490 <__adddf3+0x89c>
 200a400:	01001004 	movi	r4,64
 200a404:	20c7c83a 	sub	r3,r4,r3
 200a408:	40c6983a 	sll	r3,r8,r3
 200a40c:	1c46b03a 	or	r3,r3,r17
 200a410:	1806c03a 	cmpne	r3,r3,zero
 200a414:	28e2b03a 	or	r17,r5,r3
 200a418:	0007883a 	mov	r3,zero
 200a41c:	003f2306 	br	200a0ac <__reset+0xfe0090ac>
 200a420:	0007883a 	mov	r3,zero
 200a424:	5811883a 	mov	r8,r11
 200a428:	00bfffc4 	movi	r2,-1
 200a42c:	0401ffc4 	movi	r16,2047
 200a430:	003e7806 	br	2009e14 <__reset+0xfe008e14>
 200a434:	4462b03a 	or	r17,r8,r17
 200a438:	8822c03a 	cmpne	r17,r17,zero
 200a43c:	0009883a 	mov	r4,zero
 200a440:	003fa006 	br	200a2c4 <__reset+0xfe0092c4>
 200a444:	4811883a 	mov	r8,r9
 200a448:	3023883a 	mov	r17,r6
 200a44c:	0401ffc4 	movi	r16,2047
 200a450:	003e0706 	br	2009c70 <__reset+0xfe008c70>
 200a454:	4811883a 	mov	r8,r9
 200a458:	3023883a 	mov	r17,r6
 200a45c:	003e0406 	br	2009c70 <__reset+0xfe008c70>
 200a460:	21fff804 	addi	r7,r4,-32
 200a464:	01400804 	movi	r5,32
 200a468:	41ced83a 	srl	r7,r8,r7
 200a46c:	21400a26 	beq	r4,r5,200a498 <__adddf3+0x8a4>
 200a470:	01401004 	movi	r5,64
 200a474:	2909c83a 	sub	r4,r5,r4
 200a478:	4108983a 	sll	r4,r8,r4
 200a47c:	2448b03a 	or	r4,r4,r17
 200a480:	2008c03a 	cmpne	r4,r4,zero
 200a484:	3922b03a 	or	r17,r7,r4
 200a488:	0009883a 	mov	r4,zero
 200a48c:	003f8d06 	br	200a2c4 <__reset+0xfe0092c4>
 200a490:	0007883a 	mov	r3,zero
 200a494:	003fdd06 	br	200a40c <__reset+0xfe00940c>
 200a498:	0009883a 	mov	r4,zero
 200a49c:	003ff706 	br	200a47c <__reset+0xfe00947c>

0200a4a0 <__muldf3>:
 200a4a0:	deffee04 	addi	sp,sp,-72
 200a4a4:	dd000c15 	stw	r20,48(sp)
 200a4a8:	2828d53a 	srli	r20,r5,20
 200a4ac:	ddc00f15 	stw	r23,60(sp)
 200a4b0:	282ed7fa 	srli	r23,r5,31
 200a4b4:	dc000815 	stw	r16,32(sp)
 200a4b8:	04000434 	movhi	r16,16
 200a4bc:	dcc00b15 	stw	r19,44(sp)
 200a4c0:	843fffc4 	addi	r16,r16,-1
 200a4c4:	dfc01115 	stw	ra,68(sp)
 200a4c8:	df001015 	stw	fp,64(sp)
 200a4cc:	dd800e15 	stw	r22,56(sp)
 200a4d0:	dd400d15 	stw	r21,52(sp)
 200a4d4:	dc800a15 	stw	r18,40(sp)
 200a4d8:	dc400915 	stw	r17,36(sp)
 200a4dc:	a501ffcc 	andi	r20,r20,2047
 200a4e0:	2c20703a 	and	r16,r5,r16
 200a4e4:	b827883a 	mov	r19,r23
 200a4e8:	ba403fcc 	andi	r9,r23,255
 200a4ec:	a0006026 	beq	r20,zero,200a670 <__muldf3+0x1d0>
 200a4f0:	0081ffc4 	movi	r2,2047
 200a4f4:	202d883a 	mov	r22,r4
 200a4f8:	a0803626 	beq	r20,r2,200a5d4 <__muldf3+0x134>
 200a4fc:	84000434 	orhi	r16,r16,16
 200a500:	200ad77a 	srli	r5,r4,29
 200a504:	800490fa 	slli	r2,r16,3
 200a508:	202c90fa 	slli	r22,r4,3
 200a50c:	a53f0044 	addi	r20,r20,-1023
 200a510:	28a0b03a 	or	r16,r5,r2
 200a514:	002b883a 	mov	r21,zero
 200a518:	000b883a 	mov	r5,zero
 200a51c:	3804d53a 	srli	r2,r7,20
 200a520:	3838d7fa 	srli	fp,r7,31
 200a524:	04400434 	movhi	r17,16
 200a528:	8c7fffc4 	addi	r17,r17,-1
 200a52c:	1081ffcc 	andi	r2,r2,2047
 200a530:	3025883a 	mov	r18,r6
 200a534:	3c62703a 	and	r17,r7,r17
 200a538:	e2803fcc 	andi	r10,fp,255
 200a53c:	10006d26 	beq	r2,zero,200a6f4 <__muldf3+0x254>
 200a540:	00c1ffc4 	movi	r3,2047
 200a544:	10c06526 	beq	r2,r3,200a6dc <__muldf3+0x23c>
 200a548:	8c400434 	orhi	r17,r17,16
 200a54c:	300ed77a 	srli	r7,r6,29
 200a550:	880690fa 	slli	r3,r17,3
 200a554:	302490fa 	slli	r18,r6,3
 200a558:	10bf0044 	addi	r2,r2,-1023
 200a55c:	38e2b03a 	or	r17,r7,r3
 200a560:	000f883a 	mov	r7,zero
 200a564:	a087883a 	add	r3,r20,r2
 200a568:	010003c4 	movi	r4,15
 200a56c:	3d44b03a 	or	r2,r7,r21
 200a570:	e5ccf03a 	xor	r6,fp,r23
 200a574:	1a000044 	addi	r8,r3,1
 200a578:	20809b36 	bltu	r4,r2,200a7e8 <__muldf3+0x348>
 200a57c:	100490ba 	slli	r2,r2,2
 200a580:	01008074 	movhi	r4,513
 200a584:	21296504 	addi	r4,r4,-23148
 200a588:	1105883a 	add	r2,r2,r4
 200a58c:	10800017 	ldw	r2,0(r2)
 200a590:	1000683a 	jmp	r2
 200a594:	0200a7e8 	cmpgeui	r8,zero,671
 200a598:	0200a5f4 	movhi	r8,663
 200a59c:	0200a5f4 	movhi	r8,663
 200a5a0:	0200a5f0 	cmpltui	r8,zero,663
 200a5a4:	0200a7c4 	movi	r8,671
 200a5a8:	0200a7c4 	movi	r8,671
 200a5ac:	0200a7ac 	andhi	r8,zero,670
 200a5b0:	0200a5f0 	cmpltui	r8,zero,663
 200a5b4:	0200a7c4 	movi	r8,671
 200a5b8:	0200a7ac 	andhi	r8,zero,670
 200a5bc:	0200a7c4 	movi	r8,671
 200a5c0:	0200a5f0 	cmpltui	r8,zero,663
 200a5c4:	0200a7d4 	movui	r8,671
 200a5c8:	0200a7d4 	movui	r8,671
 200a5cc:	0200a7d4 	movui	r8,671
 200a5d0:	0200ab34 	movhi	r8,684
 200a5d4:	2404b03a 	or	r2,r4,r16
 200a5d8:	1000711e 	bne	r2,zero,200a7a0 <__muldf3+0x300>
 200a5dc:	05400204 	movi	r21,8
 200a5e0:	0021883a 	mov	r16,zero
 200a5e4:	002d883a 	mov	r22,zero
 200a5e8:	01400084 	movi	r5,2
 200a5ec:	003fcb06 	br	200a51c <__reset+0xfe00951c>
 200a5f0:	500d883a 	mov	r6,r10
 200a5f4:	00800084 	movi	r2,2
 200a5f8:	38805926 	beq	r7,r2,200a760 <__muldf3+0x2c0>
 200a5fc:	008000c4 	movi	r2,3
 200a600:	3881bb26 	beq	r7,r2,200acf0 <__muldf3+0x850>
 200a604:	00800044 	movi	r2,1
 200a608:	3881961e 	bne	r7,r2,200ac64 <__muldf3+0x7c4>
 200a60c:	3027883a 	mov	r19,r6
 200a610:	0005883a 	mov	r2,zero
 200a614:	0021883a 	mov	r16,zero
 200a618:	002d883a 	mov	r22,zero
 200a61c:	1004953a 	slli	r2,r2,20
 200a620:	98c03fcc 	andi	r3,r19,255
 200a624:	04400434 	movhi	r17,16
 200a628:	8c7fffc4 	addi	r17,r17,-1
 200a62c:	180697fa 	slli	r3,r3,31
 200a630:	8460703a 	and	r16,r16,r17
 200a634:	80a0b03a 	or	r16,r16,r2
 200a638:	80c6b03a 	or	r3,r16,r3
 200a63c:	b005883a 	mov	r2,r22
 200a640:	dfc01117 	ldw	ra,68(sp)
 200a644:	df001017 	ldw	fp,64(sp)
 200a648:	ddc00f17 	ldw	r23,60(sp)
 200a64c:	dd800e17 	ldw	r22,56(sp)
 200a650:	dd400d17 	ldw	r21,52(sp)
 200a654:	dd000c17 	ldw	r20,48(sp)
 200a658:	dcc00b17 	ldw	r19,44(sp)
 200a65c:	dc800a17 	ldw	r18,40(sp)
 200a660:	dc400917 	ldw	r17,36(sp)
 200a664:	dc000817 	ldw	r16,32(sp)
 200a668:	dec01204 	addi	sp,sp,72
 200a66c:	f800283a 	ret
 200a670:	2404b03a 	or	r2,r4,r16
 200a674:	202b883a 	mov	r21,r4
 200a678:	10004426 	beq	r2,zero,200a78c <__muldf3+0x2ec>
 200a67c:	80015126 	beq	r16,zero,200abc4 <__muldf3+0x724>
 200a680:	8009883a 	mov	r4,r16
 200a684:	d9800715 	stw	r6,28(sp)
 200a688:	d9c00215 	stw	r7,8(sp)
 200a68c:	da400415 	stw	r9,16(sp)
 200a690:	200ae680 	call	200ae68 <__clzsi2>
 200a694:	d9800717 	ldw	r6,28(sp)
 200a698:	d9c00217 	ldw	r7,8(sp)
 200a69c:	da400417 	ldw	r9,16(sp)
 200a6a0:	113ffd44 	addi	r4,r2,-11
 200a6a4:	00c00704 	movi	r3,28
 200a6a8:	19014216 	blt	r3,r4,200abb4 <__muldf3+0x714>
 200a6ac:	00c00744 	movi	r3,29
 200a6b0:	15bffe04 	addi	r22,r2,-8
 200a6b4:	1907c83a 	sub	r3,r3,r4
 200a6b8:	85a0983a 	sll	r16,r16,r22
 200a6bc:	a8c6d83a 	srl	r3,r21,r3
 200a6c0:	adac983a 	sll	r22,r21,r22
 200a6c4:	1c20b03a 	or	r16,r3,r16
 200a6c8:	1080fcc4 	addi	r2,r2,1011
 200a6cc:	00a9c83a 	sub	r20,zero,r2
 200a6d0:	002b883a 	mov	r21,zero
 200a6d4:	000b883a 	mov	r5,zero
 200a6d8:	003f9006 	br	200a51c <__reset+0xfe00951c>
 200a6dc:	3446b03a 	or	r3,r6,r17
 200a6e0:	1800281e 	bne	r3,zero,200a784 <__muldf3+0x2e4>
 200a6e4:	0023883a 	mov	r17,zero
 200a6e8:	0025883a 	mov	r18,zero
 200a6ec:	01c00084 	movi	r7,2
 200a6f0:	003f9c06 	br	200a564 <__reset+0xfe009564>
 200a6f4:	3446b03a 	or	r3,r6,r17
 200a6f8:	18001e26 	beq	r3,zero,200a774 <__muldf3+0x2d4>
 200a6fc:	88012126 	beq	r17,zero,200ab84 <__muldf3+0x6e4>
 200a700:	8809883a 	mov	r4,r17
 200a704:	d9400215 	stw	r5,8(sp)
 200a708:	d9800715 	stw	r6,28(sp)
 200a70c:	da400415 	stw	r9,16(sp)
 200a710:	da800315 	stw	r10,12(sp)
 200a714:	200ae680 	call	200ae68 <__clzsi2>
 200a718:	d9400217 	ldw	r5,8(sp)
 200a71c:	d9800717 	ldw	r6,28(sp)
 200a720:	da400417 	ldw	r9,16(sp)
 200a724:	da800317 	ldw	r10,12(sp)
 200a728:	113ffd44 	addi	r4,r2,-11
 200a72c:	00c00704 	movi	r3,28
 200a730:	19011016 	blt	r3,r4,200ab74 <__muldf3+0x6d4>
 200a734:	00c00744 	movi	r3,29
 200a738:	14bffe04 	addi	r18,r2,-8
 200a73c:	1907c83a 	sub	r3,r3,r4
 200a740:	8ca2983a 	sll	r17,r17,r18
 200a744:	30c6d83a 	srl	r3,r6,r3
 200a748:	34a4983a 	sll	r18,r6,r18
 200a74c:	1c62b03a 	or	r17,r3,r17
 200a750:	1080fcc4 	addi	r2,r2,1011
 200a754:	0085c83a 	sub	r2,zero,r2
 200a758:	000f883a 	mov	r7,zero
 200a75c:	003f8106 	br	200a564 <__reset+0xfe009564>
 200a760:	3027883a 	mov	r19,r6
 200a764:	0081ffc4 	movi	r2,2047
 200a768:	0021883a 	mov	r16,zero
 200a76c:	002d883a 	mov	r22,zero
 200a770:	003faa06 	br	200a61c <__reset+0xfe00961c>
 200a774:	0023883a 	mov	r17,zero
 200a778:	0025883a 	mov	r18,zero
 200a77c:	01c00044 	movi	r7,1
 200a780:	003f7806 	br	200a564 <__reset+0xfe009564>
 200a784:	01c000c4 	movi	r7,3
 200a788:	003f7606 	br	200a564 <__reset+0xfe009564>
 200a78c:	05400104 	movi	r21,4
 200a790:	0021883a 	mov	r16,zero
 200a794:	002d883a 	mov	r22,zero
 200a798:	01400044 	movi	r5,1
 200a79c:	003f5f06 	br	200a51c <__reset+0xfe00951c>
 200a7a0:	05400304 	movi	r21,12
 200a7a4:	014000c4 	movi	r5,3
 200a7a8:	003f5c06 	br	200a51c <__reset+0xfe00951c>
 200a7ac:	04000434 	movhi	r16,16
 200a7b0:	0027883a 	mov	r19,zero
 200a7b4:	843fffc4 	addi	r16,r16,-1
 200a7b8:	05bfffc4 	movi	r22,-1
 200a7bc:	0081ffc4 	movi	r2,2047
 200a7c0:	003f9606 	br	200a61c <__reset+0xfe00961c>
 200a7c4:	8023883a 	mov	r17,r16
 200a7c8:	b025883a 	mov	r18,r22
 200a7cc:	280f883a 	mov	r7,r5
 200a7d0:	003f8806 	br	200a5f4 <__reset+0xfe0095f4>
 200a7d4:	8023883a 	mov	r17,r16
 200a7d8:	b025883a 	mov	r18,r22
 200a7dc:	480d883a 	mov	r6,r9
 200a7e0:	280f883a 	mov	r7,r5
 200a7e4:	003f8306 	br	200a5f4 <__reset+0xfe0095f4>
 200a7e8:	b026d43a 	srli	r19,r22,16
 200a7ec:	902ed43a 	srli	r23,r18,16
 200a7f0:	b5bfffcc 	andi	r22,r22,65535
 200a7f4:	94bfffcc 	andi	r18,r18,65535
 200a7f8:	b00b883a 	mov	r5,r22
 200a7fc:	9009883a 	mov	r4,r18
 200a800:	d8c00515 	stw	r3,20(sp)
 200a804:	d9800715 	stw	r6,28(sp)
 200a808:	da000615 	stw	r8,24(sp)
 200a80c:	2009bcc0 	call	2009bcc <__mulsi3>
 200a810:	980b883a 	mov	r5,r19
 200a814:	9009883a 	mov	r4,r18
 200a818:	1029883a 	mov	r20,r2
 200a81c:	2009bcc0 	call	2009bcc <__mulsi3>
 200a820:	b80b883a 	mov	r5,r23
 200a824:	9809883a 	mov	r4,r19
 200a828:	102b883a 	mov	r21,r2
 200a82c:	2009bcc0 	call	2009bcc <__mulsi3>
 200a830:	b809883a 	mov	r4,r23
 200a834:	b00b883a 	mov	r5,r22
 200a838:	1039883a 	mov	fp,r2
 200a83c:	2009bcc0 	call	2009bcc <__mulsi3>
 200a840:	a008d43a 	srli	r4,r20,16
 200a844:	1545883a 	add	r2,r2,r21
 200a848:	d8c00517 	ldw	r3,20(sp)
 200a84c:	2085883a 	add	r2,r4,r2
 200a850:	d9800717 	ldw	r6,28(sp)
 200a854:	da000617 	ldw	r8,24(sp)
 200a858:	1540022e 	bgeu	r2,r21,200a864 <__muldf3+0x3c4>
 200a85c:	01000074 	movhi	r4,1
 200a860:	e139883a 	add	fp,fp,r4
 200a864:	100e943a 	slli	r7,r2,16
 200a868:	1004d43a 	srli	r2,r2,16
 200a86c:	882ad43a 	srli	r21,r17,16
 200a870:	a53fffcc 	andi	r20,r20,65535
 200a874:	8c7fffcc 	andi	r17,r17,65535
 200a878:	3d29883a 	add	r20,r7,r20
 200a87c:	b00b883a 	mov	r5,r22
 200a880:	8809883a 	mov	r4,r17
 200a884:	d8c00515 	stw	r3,20(sp)
 200a888:	d9800715 	stw	r6,28(sp)
 200a88c:	da000615 	stw	r8,24(sp)
 200a890:	dd000115 	stw	r20,4(sp)
 200a894:	d8800015 	stw	r2,0(sp)
 200a898:	2009bcc0 	call	2009bcc <__mulsi3>
 200a89c:	980b883a 	mov	r5,r19
 200a8a0:	8809883a 	mov	r4,r17
 200a8a4:	d8800215 	stw	r2,8(sp)
 200a8a8:	2009bcc0 	call	2009bcc <__mulsi3>
 200a8ac:	9809883a 	mov	r4,r19
 200a8b0:	a80b883a 	mov	r5,r21
 200a8b4:	1029883a 	mov	r20,r2
 200a8b8:	2009bcc0 	call	2009bcc <__mulsi3>
 200a8bc:	b00b883a 	mov	r5,r22
 200a8c0:	a809883a 	mov	r4,r21
 200a8c4:	d8800415 	stw	r2,16(sp)
 200a8c8:	2009bcc0 	call	2009bcc <__mulsi3>
 200a8cc:	d9c00217 	ldw	r7,8(sp)
 200a8d0:	1505883a 	add	r2,r2,r20
 200a8d4:	d8c00517 	ldw	r3,20(sp)
 200a8d8:	3826d43a 	srli	r19,r7,16
 200a8dc:	d9800717 	ldw	r6,28(sp)
 200a8e0:	da000617 	ldw	r8,24(sp)
 200a8e4:	9885883a 	add	r2,r19,r2
 200a8e8:	da400417 	ldw	r9,16(sp)
 200a8ec:	1500022e 	bgeu	r2,r20,200a8f8 <__muldf3+0x458>
 200a8f0:	01000074 	movhi	r4,1
 200a8f4:	4913883a 	add	r9,r9,r4
 200a8f8:	1028d43a 	srli	r20,r2,16
 200a8fc:	1004943a 	slli	r2,r2,16
 200a900:	802cd43a 	srli	r22,r16,16
 200a904:	843fffcc 	andi	r16,r16,65535
 200a908:	3cffffcc 	andi	r19,r7,65535
 200a90c:	9009883a 	mov	r4,r18
 200a910:	800b883a 	mov	r5,r16
 200a914:	a269883a 	add	r20,r20,r9
 200a918:	d8c00515 	stw	r3,20(sp)
 200a91c:	d9800715 	stw	r6,28(sp)
 200a920:	da000615 	stw	r8,24(sp)
 200a924:	14e7883a 	add	r19,r2,r19
 200a928:	2009bcc0 	call	2009bcc <__mulsi3>
 200a92c:	9009883a 	mov	r4,r18
 200a930:	b00b883a 	mov	r5,r22
 200a934:	d8800315 	stw	r2,12(sp)
 200a938:	2009bcc0 	call	2009bcc <__mulsi3>
 200a93c:	b809883a 	mov	r4,r23
 200a940:	b00b883a 	mov	r5,r22
 200a944:	d8800215 	stw	r2,8(sp)
 200a948:	2009bcc0 	call	2009bcc <__mulsi3>
 200a94c:	b80b883a 	mov	r5,r23
 200a950:	8009883a 	mov	r4,r16
 200a954:	d8800415 	stw	r2,16(sp)
 200a958:	2009bcc0 	call	2009bcc <__mulsi3>
 200a95c:	da800317 	ldw	r10,12(sp)
 200a960:	d9c00217 	ldw	r7,8(sp)
 200a964:	d9000017 	ldw	r4,0(sp)
 200a968:	502ed43a 	srli	r23,r10,16
 200a96c:	11c5883a 	add	r2,r2,r7
 200a970:	24e5883a 	add	r18,r4,r19
 200a974:	b885883a 	add	r2,r23,r2
 200a978:	d8c00517 	ldw	r3,20(sp)
 200a97c:	d9800717 	ldw	r6,28(sp)
 200a980:	da000617 	ldw	r8,24(sp)
 200a984:	da400417 	ldw	r9,16(sp)
 200a988:	11c0022e 	bgeu	r2,r7,200a994 <__muldf3+0x4f4>
 200a98c:	01000074 	movhi	r4,1
 200a990:	4913883a 	add	r9,r9,r4
 200a994:	100ed43a 	srli	r7,r2,16
 200a998:	1004943a 	slli	r2,r2,16
 200a99c:	55ffffcc 	andi	r23,r10,65535
 200a9a0:	3a53883a 	add	r9,r7,r9
 200a9a4:	8809883a 	mov	r4,r17
 200a9a8:	800b883a 	mov	r5,r16
 200a9ac:	d8c00515 	stw	r3,20(sp)
 200a9b0:	d9800715 	stw	r6,28(sp)
 200a9b4:	da000615 	stw	r8,24(sp)
 200a9b8:	da400415 	stw	r9,16(sp)
 200a9bc:	15ef883a 	add	r23,r2,r23
 200a9c0:	2009bcc0 	call	2009bcc <__mulsi3>
 200a9c4:	8809883a 	mov	r4,r17
 200a9c8:	b00b883a 	mov	r5,r22
 200a9cc:	d8800215 	stw	r2,8(sp)
 200a9d0:	2009bcc0 	call	2009bcc <__mulsi3>
 200a9d4:	b00b883a 	mov	r5,r22
 200a9d8:	a809883a 	mov	r4,r21
 200a9dc:	d8800315 	stw	r2,12(sp)
 200a9e0:	2009bcc0 	call	2009bcc <__mulsi3>
 200a9e4:	8009883a 	mov	r4,r16
 200a9e8:	a80b883a 	mov	r5,r21
 200a9ec:	1023883a 	mov	r17,r2
 200a9f0:	2009bcc0 	call	2009bcc <__mulsi3>
 200a9f4:	d9c00217 	ldw	r7,8(sp)
 200a9f8:	da800317 	ldw	r10,12(sp)
 200a9fc:	d8c00517 	ldw	r3,20(sp)
 200aa00:	3808d43a 	srli	r4,r7,16
 200aa04:	1285883a 	add	r2,r2,r10
 200aa08:	d9800717 	ldw	r6,28(sp)
 200aa0c:	2085883a 	add	r2,r4,r2
 200aa10:	da000617 	ldw	r8,24(sp)
 200aa14:	da400417 	ldw	r9,16(sp)
 200aa18:	1280022e 	bgeu	r2,r10,200aa24 <__muldf3+0x584>
 200aa1c:	01000074 	movhi	r4,1
 200aa20:	8923883a 	add	r17,r17,r4
 200aa24:	1008943a 	slli	r4,r2,16
 200aa28:	39ffffcc 	andi	r7,r7,65535
 200aa2c:	e4b9883a 	add	fp,fp,r18
 200aa30:	21cf883a 	add	r7,r4,r7
 200aa34:	e4e7803a 	cmpltu	r19,fp,r19
 200aa38:	3d0f883a 	add	r7,r7,r20
 200aa3c:	bf39883a 	add	fp,r23,fp
 200aa40:	99c9883a 	add	r4,r19,r7
 200aa44:	e5ef803a 	cmpltu	r23,fp,r23
 200aa48:	490b883a 	add	r5,r9,r4
 200aa4c:	1004d43a 	srli	r2,r2,16
 200aa50:	b965883a 	add	r18,r23,r5
 200aa54:	24c9803a 	cmpltu	r4,r4,r19
 200aa58:	3d29803a 	cmpltu	r20,r7,r20
 200aa5c:	a128b03a 	or	r20,r20,r4
 200aa60:	95ef803a 	cmpltu	r23,r18,r23
 200aa64:	2a53803a 	cmpltu	r9,r5,r9
 200aa68:	a0a9883a 	add	r20,r20,r2
 200aa6c:	4deeb03a 	or	r23,r9,r23
 200aa70:	a5ef883a 	add	r23,r20,r23
 200aa74:	bc63883a 	add	r17,r23,r17
 200aa78:	e004927a 	slli	r2,fp,9
 200aa7c:	d9000117 	ldw	r4,4(sp)
 200aa80:	882e927a 	slli	r23,r17,9
 200aa84:	9022d5fa 	srli	r17,r18,23
 200aa88:	e038d5fa 	srli	fp,fp,23
 200aa8c:	1104b03a 	or	r2,r2,r4
 200aa90:	9024927a 	slli	r18,r18,9
 200aa94:	1004c03a 	cmpne	r2,r2,zero
 200aa98:	bc62b03a 	or	r17,r23,r17
 200aa9c:	1738b03a 	or	fp,r2,fp
 200aaa0:	8880402c 	andhi	r2,r17,256
 200aaa4:	e4a4b03a 	or	r18,fp,r18
 200aaa8:	10000726 	beq	r2,zero,200aac8 <__muldf3+0x628>
 200aaac:	9006d07a 	srli	r3,r18,1
 200aab0:	880497fa 	slli	r2,r17,31
 200aab4:	9480004c 	andi	r18,r18,1
 200aab8:	8822d07a 	srli	r17,r17,1
 200aabc:	1ca4b03a 	or	r18,r3,r18
 200aac0:	14a4b03a 	or	r18,r2,r18
 200aac4:	4007883a 	mov	r3,r8
 200aac8:	1880ffc4 	addi	r2,r3,1023
 200aacc:	0080460e 	bge	zero,r2,200abe8 <__muldf3+0x748>
 200aad0:	910001cc 	andi	r4,r18,7
 200aad4:	20000726 	beq	r4,zero,200aaf4 <__muldf3+0x654>
 200aad8:	910003cc 	andi	r4,r18,15
 200aadc:	01400104 	movi	r5,4
 200aae0:	21400426 	beq	r4,r5,200aaf4 <__muldf3+0x654>
 200aae4:	9149883a 	add	r4,r18,r5
 200aae8:	24a5803a 	cmpltu	r18,r4,r18
 200aaec:	8ca3883a 	add	r17,r17,r18
 200aaf0:	2025883a 	mov	r18,r4
 200aaf4:	8900402c 	andhi	r4,r17,256
 200aaf8:	20000426 	beq	r4,zero,200ab0c <__muldf3+0x66c>
 200aafc:	18810004 	addi	r2,r3,1024
 200ab00:	00ffc034 	movhi	r3,65280
 200ab04:	18ffffc4 	addi	r3,r3,-1
 200ab08:	88e2703a 	and	r17,r17,r3
 200ab0c:	00c1ff84 	movi	r3,2046
 200ab10:	18bf1316 	blt	r3,r2,200a760 <__reset+0xfe009760>
 200ab14:	882c977a 	slli	r22,r17,29
 200ab18:	9024d0fa 	srli	r18,r18,3
 200ab1c:	8822927a 	slli	r17,r17,9
 200ab20:	1081ffcc 	andi	r2,r2,2047
 200ab24:	b4acb03a 	or	r22,r22,r18
 200ab28:	8820d33a 	srli	r16,r17,12
 200ab2c:	3027883a 	mov	r19,r6
 200ab30:	003eba06 	br	200a61c <__reset+0xfe00961c>
 200ab34:	8080022c 	andhi	r2,r16,8
 200ab38:	10000926 	beq	r2,zero,200ab60 <__muldf3+0x6c0>
 200ab3c:	8880022c 	andhi	r2,r17,8
 200ab40:	1000071e 	bne	r2,zero,200ab60 <__muldf3+0x6c0>
 200ab44:	00800434 	movhi	r2,16
 200ab48:	8c000234 	orhi	r16,r17,8
 200ab4c:	10bfffc4 	addi	r2,r2,-1
 200ab50:	e027883a 	mov	r19,fp
 200ab54:	80a0703a 	and	r16,r16,r2
 200ab58:	902d883a 	mov	r22,r18
 200ab5c:	003f1706 	br	200a7bc <__reset+0xfe0097bc>
 200ab60:	00800434 	movhi	r2,16
 200ab64:	84000234 	orhi	r16,r16,8
 200ab68:	10bfffc4 	addi	r2,r2,-1
 200ab6c:	80a0703a 	and	r16,r16,r2
 200ab70:	003f1206 	br	200a7bc <__reset+0xfe0097bc>
 200ab74:	147ff604 	addi	r17,r2,-40
 200ab78:	3462983a 	sll	r17,r6,r17
 200ab7c:	0025883a 	mov	r18,zero
 200ab80:	003ef306 	br	200a750 <__reset+0xfe009750>
 200ab84:	3009883a 	mov	r4,r6
 200ab88:	d9400215 	stw	r5,8(sp)
 200ab8c:	d9800715 	stw	r6,28(sp)
 200ab90:	da400415 	stw	r9,16(sp)
 200ab94:	da800315 	stw	r10,12(sp)
 200ab98:	200ae680 	call	200ae68 <__clzsi2>
 200ab9c:	10800804 	addi	r2,r2,32
 200aba0:	da800317 	ldw	r10,12(sp)
 200aba4:	da400417 	ldw	r9,16(sp)
 200aba8:	d9800717 	ldw	r6,28(sp)
 200abac:	d9400217 	ldw	r5,8(sp)
 200abb0:	003edd06 	br	200a728 <__reset+0xfe009728>
 200abb4:	143ff604 	addi	r16,r2,-40
 200abb8:	ac20983a 	sll	r16,r21,r16
 200abbc:	002d883a 	mov	r22,zero
 200abc0:	003ec106 	br	200a6c8 <__reset+0xfe0096c8>
 200abc4:	d9800715 	stw	r6,28(sp)
 200abc8:	d9c00215 	stw	r7,8(sp)
 200abcc:	da400415 	stw	r9,16(sp)
 200abd0:	200ae680 	call	200ae68 <__clzsi2>
 200abd4:	10800804 	addi	r2,r2,32
 200abd8:	da400417 	ldw	r9,16(sp)
 200abdc:	d9c00217 	ldw	r7,8(sp)
 200abe0:	d9800717 	ldw	r6,28(sp)
 200abe4:	003eae06 	br	200a6a0 <__reset+0xfe0096a0>
 200abe8:	00c00044 	movi	r3,1
 200abec:	1887c83a 	sub	r3,r3,r2
 200abf0:	01000e04 	movi	r4,56
 200abf4:	20fe8516 	blt	r4,r3,200a60c <__reset+0xfe00960c>
 200abf8:	010007c4 	movi	r4,31
 200abfc:	20c01b16 	blt	r4,r3,200ac6c <__muldf3+0x7cc>
 200ac00:	00800804 	movi	r2,32
 200ac04:	10c5c83a 	sub	r2,r2,r3
 200ac08:	888a983a 	sll	r5,r17,r2
 200ac0c:	90c8d83a 	srl	r4,r18,r3
 200ac10:	9084983a 	sll	r2,r18,r2
 200ac14:	88e2d83a 	srl	r17,r17,r3
 200ac18:	2906b03a 	or	r3,r5,r4
 200ac1c:	1004c03a 	cmpne	r2,r2,zero
 200ac20:	1886b03a 	or	r3,r3,r2
 200ac24:	188001cc 	andi	r2,r3,7
 200ac28:	10000726 	beq	r2,zero,200ac48 <__muldf3+0x7a8>
 200ac2c:	188003cc 	andi	r2,r3,15
 200ac30:	01000104 	movi	r4,4
 200ac34:	11000426 	beq	r2,r4,200ac48 <__muldf3+0x7a8>
 200ac38:	1805883a 	mov	r2,r3
 200ac3c:	10c00104 	addi	r3,r2,4
 200ac40:	1885803a 	cmpltu	r2,r3,r2
 200ac44:	88a3883a 	add	r17,r17,r2
 200ac48:	8880202c 	andhi	r2,r17,128
 200ac4c:	10001c26 	beq	r2,zero,200acc0 <__muldf3+0x820>
 200ac50:	3027883a 	mov	r19,r6
 200ac54:	00800044 	movi	r2,1
 200ac58:	0021883a 	mov	r16,zero
 200ac5c:	002d883a 	mov	r22,zero
 200ac60:	003e6e06 	br	200a61c <__reset+0xfe00961c>
 200ac64:	4007883a 	mov	r3,r8
 200ac68:	003f9706 	br	200aac8 <__reset+0xfe009ac8>
 200ac6c:	017ff844 	movi	r5,-31
 200ac70:	2885c83a 	sub	r2,r5,r2
 200ac74:	888ad83a 	srl	r5,r17,r2
 200ac78:	00800804 	movi	r2,32
 200ac7c:	18801a26 	beq	r3,r2,200ace8 <__muldf3+0x848>
 200ac80:	01001004 	movi	r4,64
 200ac84:	20c7c83a 	sub	r3,r4,r3
 200ac88:	88e2983a 	sll	r17,r17,r3
 200ac8c:	8ca4b03a 	or	r18,r17,r18
 200ac90:	9004c03a 	cmpne	r2,r18,zero
 200ac94:	2884b03a 	or	r2,r5,r2
 200ac98:	144001cc 	andi	r17,r2,7
 200ac9c:	88000d1e 	bne	r17,zero,200acd4 <__muldf3+0x834>
 200aca0:	0021883a 	mov	r16,zero
 200aca4:	102cd0fa 	srli	r22,r2,3
 200aca8:	3027883a 	mov	r19,r6
 200acac:	0005883a 	mov	r2,zero
 200acb0:	b46cb03a 	or	r22,r22,r17
 200acb4:	003e5906 	br	200a61c <__reset+0xfe00961c>
 200acb8:	1007883a 	mov	r3,r2
 200acbc:	0023883a 	mov	r17,zero
 200acc0:	8820927a 	slli	r16,r17,9
 200acc4:	1805883a 	mov	r2,r3
 200acc8:	8822977a 	slli	r17,r17,29
 200accc:	8020d33a 	srli	r16,r16,12
 200acd0:	003ff406 	br	200aca4 <__reset+0xfe009ca4>
 200acd4:	10c003cc 	andi	r3,r2,15
 200acd8:	01000104 	movi	r4,4
 200acdc:	193ff626 	beq	r3,r4,200acb8 <__reset+0xfe009cb8>
 200ace0:	0023883a 	mov	r17,zero
 200ace4:	003fd506 	br	200ac3c <__reset+0xfe009c3c>
 200ace8:	0023883a 	mov	r17,zero
 200acec:	003fe706 	br	200ac8c <__reset+0xfe009c8c>
 200acf0:	00800434 	movhi	r2,16
 200acf4:	8c000234 	orhi	r16,r17,8
 200acf8:	10bfffc4 	addi	r2,r2,-1
 200acfc:	3027883a 	mov	r19,r6
 200ad00:	80a0703a 	and	r16,r16,r2
 200ad04:	902d883a 	mov	r22,r18
 200ad08:	003eac06 	br	200a7bc <__reset+0xfe0097bc>

0200ad0c <__fixdfsi>:
 200ad0c:	280cd53a 	srli	r6,r5,20
 200ad10:	00c00434 	movhi	r3,16
 200ad14:	18ffffc4 	addi	r3,r3,-1
 200ad18:	3181ffcc 	andi	r6,r6,2047
 200ad1c:	01c0ff84 	movi	r7,1022
 200ad20:	28c6703a 	and	r3,r5,r3
 200ad24:	280ad7fa 	srli	r5,r5,31
 200ad28:	3980120e 	bge	r7,r6,200ad74 <__fixdfsi+0x68>
 200ad2c:	00810744 	movi	r2,1053
 200ad30:	11800c16 	blt	r2,r6,200ad64 <__fixdfsi+0x58>
 200ad34:	00810cc4 	movi	r2,1075
 200ad38:	1185c83a 	sub	r2,r2,r6
 200ad3c:	01c007c4 	movi	r7,31
 200ad40:	18c00434 	orhi	r3,r3,16
 200ad44:	38800d16 	blt	r7,r2,200ad7c <__fixdfsi+0x70>
 200ad48:	31befb44 	addi	r6,r6,-1043
 200ad4c:	2084d83a 	srl	r2,r4,r2
 200ad50:	1986983a 	sll	r3,r3,r6
 200ad54:	1884b03a 	or	r2,r3,r2
 200ad58:	28000726 	beq	r5,zero,200ad78 <__fixdfsi+0x6c>
 200ad5c:	0085c83a 	sub	r2,zero,r2
 200ad60:	f800283a 	ret
 200ad64:	00a00034 	movhi	r2,32768
 200ad68:	10bfffc4 	addi	r2,r2,-1
 200ad6c:	2885883a 	add	r2,r5,r2
 200ad70:	f800283a 	ret
 200ad74:	0005883a 	mov	r2,zero
 200ad78:	f800283a 	ret
 200ad7c:	008104c4 	movi	r2,1043
 200ad80:	1185c83a 	sub	r2,r2,r6
 200ad84:	1884d83a 	srl	r2,r3,r2
 200ad88:	003ff306 	br	200ad58 <__reset+0xfe009d58>

0200ad8c <__floatsidf>:
 200ad8c:	defffd04 	addi	sp,sp,-12
 200ad90:	dfc00215 	stw	ra,8(sp)
 200ad94:	dc400115 	stw	r17,4(sp)
 200ad98:	dc000015 	stw	r16,0(sp)
 200ad9c:	20002b26 	beq	r4,zero,200ae4c <__floatsidf+0xc0>
 200ada0:	2023883a 	mov	r17,r4
 200ada4:	2020d7fa 	srli	r16,r4,31
 200ada8:	20002d16 	blt	r4,zero,200ae60 <__floatsidf+0xd4>
 200adac:	8809883a 	mov	r4,r17
 200adb0:	200ae680 	call	200ae68 <__clzsi2>
 200adb4:	01410784 	movi	r5,1054
 200adb8:	288bc83a 	sub	r5,r5,r2
 200adbc:	01010cc4 	movi	r4,1075
 200adc0:	2149c83a 	sub	r4,r4,r5
 200adc4:	00c007c4 	movi	r3,31
 200adc8:	1900160e 	bge	r3,r4,200ae24 <__floatsidf+0x98>
 200adcc:	00c104c4 	movi	r3,1043
 200add0:	1947c83a 	sub	r3,r3,r5
 200add4:	88c6983a 	sll	r3,r17,r3
 200add8:	00800434 	movhi	r2,16
 200addc:	10bfffc4 	addi	r2,r2,-1
 200ade0:	1886703a 	and	r3,r3,r2
 200ade4:	2941ffcc 	andi	r5,r5,2047
 200ade8:	800d883a 	mov	r6,r16
 200adec:	0005883a 	mov	r2,zero
 200adf0:	280a953a 	slli	r5,r5,20
 200adf4:	31803fcc 	andi	r6,r6,255
 200adf8:	01000434 	movhi	r4,16
 200adfc:	300c97fa 	slli	r6,r6,31
 200ae00:	213fffc4 	addi	r4,r4,-1
 200ae04:	1906703a 	and	r3,r3,r4
 200ae08:	1946b03a 	or	r3,r3,r5
 200ae0c:	1986b03a 	or	r3,r3,r6
 200ae10:	dfc00217 	ldw	ra,8(sp)
 200ae14:	dc400117 	ldw	r17,4(sp)
 200ae18:	dc000017 	ldw	r16,0(sp)
 200ae1c:	dec00304 	addi	sp,sp,12
 200ae20:	f800283a 	ret
 200ae24:	00c002c4 	movi	r3,11
 200ae28:	1887c83a 	sub	r3,r3,r2
 200ae2c:	88c6d83a 	srl	r3,r17,r3
 200ae30:	8904983a 	sll	r2,r17,r4
 200ae34:	01000434 	movhi	r4,16
 200ae38:	213fffc4 	addi	r4,r4,-1
 200ae3c:	2941ffcc 	andi	r5,r5,2047
 200ae40:	1906703a 	and	r3,r3,r4
 200ae44:	800d883a 	mov	r6,r16
 200ae48:	003fe906 	br	200adf0 <__reset+0xfe009df0>
 200ae4c:	000d883a 	mov	r6,zero
 200ae50:	000b883a 	mov	r5,zero
 200ae54:	0007883a 	mov	r3,zero
 200ae58:	0005883a 	mov	r2,zero
 200ae5c:	003fe406 	br	200adf0 <__reset+0xfe009df0>
 200ae60:	0123c83a 	sub	r17,zero,r4
 200ae64:	003fd106 	br	200adac <__reset+0xfe009dac>

0200ae68 <__clzsi2>:
 200ae68:	00bfffd4 	movui	r2,65535
 200ae6c:	11000536 	bltu	r2,r4,200ae84 <__clzsi2+0x1c>
 200ae70:	00803fc4 	movi	r2,255
 200ae74:	11000f36 	bltu	r2,r4,200aeb4 <__clzsi2+0x4c>
 200ae78:	00800804 	movi	r2,32
 200ae7c:	0007883a 	mov	r3,zero
 200ae80:	00000506 	br	200ae98 <__clzsi2+0x30>
 200ae84:	00804034 	movhi	r2,256
 200ae88:	10bfffc4 	addi	r2,r2,-1
 200ae8c:	11000c2e 	bgeu	r2,r4,200aec0 <__clzsi2+0x58>
 200ae90:	00800204 	movi	r2,8
 200ae94:	00c00604 	movi	r3,24
 200ae98:	20c8d83a 	srl	r4,r4,r3
 200ae9c:	00c08074 	movhi	r3,513
 200aea0:	18c8d484 	addi	r3,r3,9042
 200aea4:	1909883a 	add	r4,r3,r4
 200aea8:	20c00003 	ldbu	r3,0(r4)
 200aeac:	10c5c83a 	sub	r2,r2,r3
 200aeb0:	f800283a 	ret
 200aeb4:	00800604 	movi	r2,24
 200aeb8:	00c00204 	movi	r3,8
 200aebc:	003ff606 	br	200ae98 <__reset+0xfe009e98>
 200aec0:	00800404 	movi	r2,16
 200aec4:	1007883a 	mov	r3,r2
 200aec8:	003ff306 	br	200ae98 <__reset+0xfe009e98>

0200aecc <__itoa>:
 200aecc:	30bfff84 	addi	r2,r6,-2
 200aed0:	00c00884 	movi	r3,34
 200aed4:	18801436 	bltu	r3,r2,200af28 <__itoa+0x5c>
 200aed8:	defffe04 	addi	sp,sp,-8
 200aedc:	dfc00115 	stw	ra,4(sp)
 200aee0:	dc000015 	stw	r16,0(sp)
 200aee4:	00800284 	movi	r2,10
 200aee8:	30800926 	beq	r6,r2,200af10 <__itoa+0x44>
 200aeec:	0005883a 	mov	r2,zero
 200aef0:	2821883a 	mov	r16,r5
 200aef4:	288b883a 	add	r5,r5,r2
 200aef8:	200b4280 	call	200b428 <__utoa>
 200aefc:	8005883a 	mov	r2,r16
 200af00:	dfc00117 	ldw	ra,4(sp)
 200af04:	dc000017 	ldw	r16,0(sp)
 200af08:	dec00204 	addi	sp,sp,8
 200af0c:	f800283a 	ret
 200af10:	203ff60e 	bge	r4,zero,200aeec <__reset+0xfe009eec>
 200af14:	00800b44 	movi	r2,45
 200af18:	28800005 	stb	r2,0(r5)
 200af1c:	0109c83a 	sub	r4,zero,r4
 200af20:	00800044 	movi	r2,1
 200af24:	003ff206 	br	200aef0 <__reset+0xfe009ef0>
 200af28:	28000005 	stb	zero,0(r5)
 200af2c:	0005883a 	mov	r2,zero
 200af30:	f800283a 	ret

0200af34 <itoa>:
 200af34:	200aecc1 	jmpi	200aecc <__itoa>

0200af38 <memcpy>:
 200af38:	defffd04 	addi	sp,sp,-12
 200af3c:	dfc00215 	stw	ra,8(sp)
 200af40:	dc400115 	stw	r17,4(sp)
 200af44:	dc000015 	stw	r16,0(sp)
 200af48:	00c003c4 	movi	r3,15
 200af4c:	2005883a 	mov	r2,r4
 200af50:	1980452e 	bgeu	r3,r6,200b068 <memcpy+0x130>
 200af54:	2906b03a 	or	r3,r5,r4
 200af58:	18c000cc 	andi	r3,r3,3
 200af5c:	1800441e 	bne	r3,zero,200b070 <memcpy+0x138>
 200af60:	347ffc04 	addi	r17,r6,-16
 200af64:	8822d13a 	srli	r17,r17,4
 200af68:	28c00104 	addi	r3,r5,4
 200af6c:	23400104 	addi	r13,r4,4
 200af70:	8820913a 	slli	r16,r17,4
 200af74:	2b000204 	addi	r12,r5,8
 200af78:	22c00204 	addi	r11,r4,8
 200af7c:	84000504 	addi	r16,r16,20
 200af80:	2a800304 	addi	r10,r5,12
 200af84:	22400304 	addi	r9,r4,12
 200af88:	2c21883a 	add	r16,r5,r16
 200af8c:	2811883a 	mov	r8,r5
 200af90:	200f883a 	mov	r7,r4
 200af94:	41000017 	ldw	r4,0(r8)
 200af98:	1fc00017 	ldw	ra,0(r3)
 200af9c:	63c00017 	ldw	r15,0(r12)
 200afa0:	39000015 	stw	r4,0(r7)
 200afa4:	53800017 	ldw	r14,0(r10)
 200afa8:	6fc00015 	stw	ra,0(r13)
 200afac:	5bc00015 	stw	r15,0(r11)
 200afb0:	4b800015 	stw	r14,0(r9)
 200afb4:	18c00404 	addi	r3,r3,16
 200afb8:	39c00404 	addi	r7,r7,16
 200afbc:	42000404 	addi	r8,r8,16
 200afc0:	6b400404 	addi	r13,r13,16
 200afc4:	63000404 	addi	r12,r12,16
 200afc8:	5ac00404 	addi	r11,r11,16
 200afcc:	52800404 	addi	r10,r10,16
 200afd0:	4a400404 	addi	r9,r9,16
 200afd4:	1c3fef1e 	bne	r3,r16,200af94 <__reset+0xfe009f94>
 200afd8:	89c00044 	addi	r7,r17,1
 200afdc:	380e913a 	slli	r7,r7,4
 200afe0:	310003cc 	andi	r4,r6,15
 200afe4:	02c000c4 	movi	r11,3
 200afe8:	11c7883a 	add	r3,r2,r7
 200afec:	29cb883a 	add	r5,r5,r7
 200aff0:	5900212e 	bgeu	r11,r4,200b078 <memcpy+0x140>
 200aff4:	1813883a 	mov	r9,r3
 200aff8:	2811883a 	mov	r8,r5
 200affc:	200f883a 	mov	r7,r4
 200b000:	42800017 	ldw	r10,0(r8)
 200b004:	4a400104 	addi	r9,r9,4
 200b008:	39ffff04 	addi	r7,r7,-4
 200b00c:	4abfff15 	stw	r10,-4(r9)
 200b010:	42000104 	addi	r8,r8,4
 200b014:	59fffa36 	bltu	r11,r7,200b000 <__reset+0xfe00a000>
 200b018:	213fff04 	addi	r4,r4,-4
 200b01c:	2008d0ba 	srli	r4,r4,2
 200b020:	318000cc 	andi	r6,r6,3
 200b024:	21000044 	addi	r4,r4,1
 200b028:	2109883a 	add	r4,r4,r4
 200b02c:	2109883a 	add	r4,r4,r4
 200b030:	1907883a 	add	r3,r3,r4
 200b034:	290b883a 	add	r5,r5,r4
 200b038:	30000626 	beq	r6,zero,200b054 <memcpy+0x11c>
 200b03c:	198d883a 	add	r6,r3,r6
 200b040:	29c00003 	ldbu	r7,0(r5)
 200b044:	18c00044 	addi	r3,r3,1
 200b048:	29400044 	addi	r5,r5,1
 200b04c:	19ffffc5 	stb	r7,-1(r3)
 200b050:	19bffb1e 	bne	r3,r6,200b040 <__reset+0xfe00a040>
 200b054:	dfc00217 	ldw	ra,8(sp)
 200b058:	dc400117 	ldw	r17,4(sp)
 200b05c:	dc000017 	ldw	r16,0(sp)
 200b060:	dec00304 	addi	sp,sp,12
 200b064:	f800283a 	ret
 200b068:	2007883a 	mov	r3,r4
 200b06c:	003ff206 	br	200b038 <__reset+0xfe00a038>
 200b070:	2007883a 	mov	r3,r4
 200b074:	003ff106 	br	200b03c <__reset+0xfe00a03c>
 200b078:	200d883a 	mov	r6,r4
 200b07c:	003fee06 	br	200b038 <__reset+0xfe00a038>

0200b080 <memset>:
 200b080:	20c000cc 	andi	r3,r4,3
 200b084:	2005883a 	mov	r2,r4
 200b088:	18004426 	beq	r3,zero,200b19c <memset+0x11c>
 200b08c:	31ffffc4 	addi	r7,r6,-1
 200b090:	30004026 	beq	r6,zero,200b194 <memset+0x114>
 200b094:	2813883a 	mov	r9,r5
 200b098:	200d883a 	mov	r6,r4
 200b09c:	2007883a 	mov	r3,r4
 200b0a0:	00000406 	br	200b0b4 <memset+0x34>
 200b0a4:	3a3fffc4 	addi	r8,r7,-1
 200b0a8:	31800044 	addi	r6,r6,1
 200b0ac:	38003926 	beq	r7,zero,200b194 <memset+0x114>
 200b0b0:	400f883a 	mov	r7,r8
 200b0b4:	18c00044 	addi	r3,r3,1
 200b0b8:	32400005 	stb	r9,0(r6)
 200b0bc:	1a0000cc 	andi	r8,r3,3
 200b0c0:	403ff81e 	bne	r8,zero,200b0a4 <__reset+0xfe00a0a4>
 200b0c4:	010000c4 	movi	r4,3
 200b0c8:	21c02d2e 	bgeu	r4,r7,200b180 <memset+0x100>
 200b0cc:	29003fcc 	andi	r4,r5,255
 200b0d0:	200c923a 	slli	r6,r4,8
 200b0d4:	3108b03a 	or	r4,r6,r4
 200b0d8:	200c943a 	slli	r6,r4,16
 200b0dc:	218cb03a 	or	r6,r4,r6
 200b0e0:	010003c4 	movi	r4,15
 200b0e4:	21c0182e 	bgeu	r4,r7,200b148 <memset+0xc8>
 200b0e8:	3b3ffc04 	addi	r12,r7,-16
 200b0ec:	6018d13a 	srli	r12,r12,4
 200b0f0:	1a000104 	addi	r8,r3,4
 200b0f4:	1ac00204 	addi	r11,r3,8
 200b0f8:	6008913a 	slli	r4,r12,4
 200b0fc:	1a800304 	addi	r10,r3,12
 200b100:	1813883a 	mov	r9,r3
 200b104:	21000504 	addi	r4,r4,20
 200b108:	1909883a 	add	r4,r3,r4
 200b10c:	49800015 	stw	r6,0(r9)
 200b110:	41800015 	stw	r6,0(r8)
 200b114:	59800015 	stw	r6,0(r11)
 200b118:	51800015 	stw	r6,0(r10)
 200b11c:	42000404 	addi	r8,r8,16
 200b120:	4a400404 	addi	r9,r9,16
 200b124:	5ac00404 	addi	r11,r11,16
 200b128:	52800404 	addi	r10,r10,16
 200b12c:	413ff71e 	bne	r8,r4,200b10c <__reset+0xfe00a10c>
 200b130:	63000044 	addi	r12,r12,1
 200b134:	6018913a 	slli	r12,r12,4
 200b138:	39c003cc 	andi	r7,r7,15
 200b13c:	010000c4 	movi	r4,3
 200b140:	1b07883a 	add	r3,r3,r12
 200b144:	21c00e2e 	bgeu	r4,r7,200b180 <memset+0x100>
 200b148:	1813883a 	mov	r9,r3
 200b14c:	3811883a 	mov	r8,r7
 200b150:	010000c4 	movi	r4,3
 200b154:	49800015 	stw	r6,0(r9)
 200b158:	423fff04 	addi	r8,r8,-4
 200b15c:	4a400104 	addi	r9,r9,4
 200b160:	223ffc36 	bltu	r4,r8,200b154 <__reset+0xfe00a154>
 200b164:	393fff04 	addi	r4,r7,-4
 200b168:	2008d0ba 	srli	r4,r4,2
 200b16c:	39c000cc 	andi	r7,r7,3
 200b170:	21000044 	addi	r4,r4,1
 200b174:	2109883a 	add	r4,r4,r4
 200b178:	2109883a 	add	r4,r4,r4
 200b17c:	1907883a 	add	r3,r3,r4
 200b180:	38000526 	beq	r7,zero,200b198 <memset+0x118>
 200b184:	19cf883a 	add	r7,r3,r7
 200b188:	19400005 	stb	r5,0(r3)
 200b18c:	18c00044 	addi	r3,r3,1
 200b190:	38fffd1e 	bne	r7,r3,200b188 <__reset+0xfe00a188>
 200b194:	f800283a 	ret
 200b198:	f800283a 	ret
 200b19c:	2007883a 	mov	r3,r4
 200b1a0:	300f883a 	mov	r7,r6
 200b1a4:	003fc706 	br	200b0c4 <__reset+0xfe00a0c4>

0200b1a8 <_puts_r>:
 200b1a8:	defff604 	addi	sp,sp,-40
 200b1ac:	dc000715 	stw	r16,28(sp)
 200b1b0:	2021883a 	mov	r16,r4
 200b1b4:	2809883a 	mov	r4,r5
 200b1b8:	dc400815 	stw	r17,32(sp)
 200b1bc:	dfc00915 	stw	ra,36(sp)
 200b1c0:	2823883a 	mov	r17,r5
 200b1c4:	200b3900 	call	200b390 <strlen>
 200b1c8:	10c00044 	addi	r3,r2,1
 200b1cc:	d8800115 	stw	r2,4(sp)
 200b1d0:	00808074 	movhi	r2,513
 200b1d4:	10891504 	addi	r2,r2,9300
 200b1d8:	d8800215 	stw	r2,8(sp)
 200b1dc:	00800044 	movi	r2,1
 200b1e0:	d8800315 	stw	r2,12(sp)
 200b1e4:	00800084 	movi	r2,2
 200b1e8:	dc400015 	stw	r17,0(sp)
 200b1ec:	d8c00615 	stw	r3,24(sp)
 200b1f0:	dec00415 	stw	sp,16(sp)
 200b1f4:	d8800515 	stw	r2,20(sp)
 200b1f8:	80000226 	beq	r16,zero,200b204 <_puts_r+0x5c>
 200b1fc:	80800e17 	ldw	r2,56(r16)
 200b200:	10001426 	beq	r2,zero,200b254 <_puts_r+0xac>
 200b204:	81400217 	ldw	r5,8(r16)
 200b208:	2880030b 	ldhu	r2,12(r5)
 200b20c:	10c8000c 	andi	r3,r2,8192
 200b210:	1800061e 	bne	r3,zero,200b22c <_puts_r+0x84>
 200b214:	29001917 	ldw	r4,100(r5)
 200b218:	00f7ffc4 	movi	r3,-8193
 200b21c:	10880014 	ori	r2,r2,8192
 200b220:	20c6703a 	and	r3,r4,r3
 200b224:	2880030d 	sth	r2,12(r5)
 200b228:	28c01915 	stw	r3,100(r5)
 200b22c:	d9800404 	addi	r6,sp,16
 200b230:	8009883a 	mov	r4,r16
 200b234:	200b9340 	call	200b934 <__sfvwrite_r>
 200b238:	1000091e 	bne	r2,zero,200b260 <_puts_r+0xb8>
 200b23c:	00800284 	movi	r2,10
 200b240:	dfc00917 	ldw	ra,36(sp)
 200b244:	dc400817 	ldw	r17,32(sp)
 200b248:	dc000717 	ldw	r16,28(sp)
 200b24c:	dec00a04 	addi	sp,sp,40
 200b250:	f800283a 	ret
 200b254:	8009883a 	mov	r4,r16
 200b258:	200b8e40 	call	200b8e4 <__sinit>
 200b25c:	003fe906 	br	200b204 <__reset+0xfe00a204>
 200b260:	00bfffc4 	movi	r2,-1
 200b264:	003ff606 	br	200b240 <__reset+0xfe00a240>

0200b268 <puts>:
 200b268:	00808074 	movhi	r2,513
 200b26c:	1090b904 	addi	r2,r2,17124
 200b270:	200b883a 	mov	r5,r4
 200b274:	11000017 	ldw	r4,0(r2)
 200b278:	200b1a81 	jmpi	200b1a8 <_puts_r>

0200b27c <strcat>:
 200b27c:	defffe04 	addi	sp,sp,-8
 200b280:	dc000015 	stw	r16,0(sp)
 200b284:	dfc00115 	stw	ra,4(sp)
 200b288:	208000cc 	andi	r2,r4,3
 200b28c:	2021883a 	mov	r16,r4
 200b290:	1000131e 	bne	r2,zero,200b2e0 <strcat+0x64>
 200b294:	20800017 	ldw	r2,0(r4)
 200b298:	01ffbff4 	movhi	r7,65279
 200b29c:	39ffbfc4 	addi	r7,r7,-257
 200b2a0:	0086303a 	nor	r3,zero,r2
 200b2a4:	01a02074 	movhi	r6,32897
 200b2a8:	11c5883a 	add	r2,r2,r7
 200b2ac:	31a02004 	addi	r6,r6,-32640
 200b2b0:	10c4703a 	and	r2,r2,r3
 200b2b4:	1184703a 	and	r2,r2,r6
 200b2b8:	1000091e 	bne	r2,zero,200b2e0 <strcat+0x64>
 200b2bc:	21000104 	addi	r4,r4,4
 200b2c0:	20800017 	ldw	r2,0(r4)
 200b2c4:	11c7883a 	add	r3,r2,r7
 200b2c8:	0084303a 	nor	r2,zero,r2
 200b2cc:	1884703a 	and	r2,r3,r2
 200b2d0:	1184703a 	and	r2,r2,r6
 200b2d4:	103ff926 	beq	r2,zero,200b2bc <__reset+0xfe00a2bc>
 200b2d8:	00000106 	br	200b2e0 <strcat+0x64>
 200b2dc:	21000044 	addi	r4,r4,1
 200b2e0:	20800007 	ldb	r2,0(r4)
 200b2e4:	103ffd1e 	bne	r2,zero,200b2dc <__reset+0xfe00a2dc>
 200b2e8:	200b3000 	call	200b300 <strcpy>
 200b2ec:	8005883a 	mov	r2,r16
 200b2f0:	dfc00117 	ldw	ra,4(sp)
 200b2f4:	dc000017 	ldw	r16,0(sp)
 200b2f8:	dec00204 	addi	sp,sp,8
 200b2fc:	f800283a 	ret

0200b300 <strcpy>:
 200b300:	2906b03a 	or	r3,r5,r4
 200b304:	18c000cc 	andi	r3,r3,3
 200b308:	2005883a 	mov	r2,r4
 200b30c:	1800161e 	bne	r3,zero,200b368 <strcpy+0x68>
 200b310:	29c00017 	ldw	r7,0(r5)
 200b314:	02ffbff4 	movhi	r11,65279
 200b318:	5affbfc4 	addi	r11,r11,-257
 200b31c:	02a02074 	movhi	r10,32897
 200b320:	01c6303a 	nor	r3,zero,r7
 200b324:	3ac9883a 	add	r4,r7,r11
 200b328:	52a02004 	addi	r10,r10,-32640
 200b32c:	20c6703a 	and	r3,r4,r3
 200b330:	1a86703a 	and	r3,r3,r10
 200b334:	18000c1e 	bne	r3,zero,200b368 <strcpy+0x68>
 200b338:	1011883a 	mov	r8,r2
 200b33c:	41c00015 	stw	r7,0(r8)
 200b340:	29400104 	addi	r5,r5,4
 200b344:	29c00017 	ldw	r7,0(r5)
 200b348:	41800104 	addi	r6,r8,4
 200b34c:	3011883a 	mov	r8,r6
 200b350:	3ad3883a 	add	r9,r7,r11
 200b354:	01c6303a 	nor	r3,zero,r7
 200b358:	48c6703a 	and	r3,r9,r3
 200b35c:	1a86703a 	and	r3,r3,r10
 200b360:	183ff626 	beq	r3,zero,200b33c <__reset+0xfe00a33c>
 200b364:	00000106 	br	200b36c <strcpy+0x6c>
 200b368:	100d883a 	mov	r6,r2
 200b36c:	28c00003 	ldbu	r3,0(r5)
 200b370:	31800044 	addi	r6,r6,1
 200b374:	29400044 	addi	r5,r5,1
 200b378:	30ffffc5 	stb	r3,-1(r6)
 200b37c:	18c03fcc 	andi	r3,r3,255
 200b380:	18c0201c 	xori	r3,r3,128
 200b384:	18ffe004 	addi	r3,r3,-128
 200b388:	183ff81e 	bne	r3,zero,200b36c <__reset+0xfe00a36c>
 200b38c:	f800283a 	ret

0200b390 <strlen>:
 200b390:	208000cc 	andi	r2,r4,3
 200b394:	10002026 	beq	r2,zero,200b418 <strlen+0x88>
 200b398:	20800007 	ldb	r2,0(r4)
 200b39c:	10002026 	beq	r2,zero,200b420 <strlen+0x90>
 200b3a0:	2005883a 	mov	r2,r4
 200b3a4:	00000206 	br	200b3b0 <strlen+0x20>
 200b3a8:	10c00007 	ldb	r3,0(r2)
 200b3ac:	18001826 	beq	r3,zero,200b410 <strlen+0x80>
 200b3b0:	10800044 	addi	r2,r2,1
 200b3b4:	10c000cc 	andi	r3,r2,3
 200b3b8:	183ffb1e 	bne	r3,zero,200b3a8 <__reset+0xfe00a3a8>
 200b3bc:	10c00017 	ldw	r3,0(r2)
 200b3c0:	01ffbff4 	movhi	r7,65279
 200b3c4:	39ffbfc4 	addi	r7,r7,-257
 200b3c8:	00ca303a 	nor	r5,zero,r3
 200b3cc:	01a02074 	movhi	r6,32897
 200b3d0:	19c7883a 	add	r3,r3,r7
 200b3d4:	31a02004 	addi	r6,r6,-32640
 200b3d8:	1946703a 	and	r3,r3,r5
 200b3dc:	1986703a 	and	r3,r3,r6
 200b3e0:	1800091e 	bne	r3,zero,200b408 <strlen+0x78>
 200b3e4:	10800104 	addi	r2,r2,4
 200b3e8:	10c00017 	ldw	r3,0(r2)
 200b3ec:	19cb883a 	add	r5,r3,r7
 200b3f0:	00c6303a 	nor	r3,zero,r3
 200b3f4:	28c6703a 	and	r3,r5,r3
 200b3f8:	1986703a 	and	r3,r3,r6
 200b3fc:	183ff926 	beq	r3,zero,200b3e4 <__reset+0xfe00a3e4>
 200b400:	00000106 	br	200b408 <strlen+0x78>
 200b404:	10800044 	addi	r2,r2,1
 200b408:	10c00007 	ldb	r3,0(r2)
 200b40c:	183ffd1e 	bne	r3,zero,200b404 <__reset+0xfe00a404>
 200b410:	1105c83a 	sub	r2,r2,r4
 200b414:	f800283a 	ret
 200b418:	2005883a 	mov	r2,r4
 200b41c:	003fe706 	br	200b3bc <__reset+0xfe00a3bc>
 200b420:	0005883a 	mov	r2,zero
 200b424:	f800283a 	ret

0200b428 <__utoa>:
 200b428:	008cccb4 	movhi	r2,13106
 200b42c:	defff004 	addi	sp,sp,-64
 200b430:	108c4c04 	addi	r2,r2,12592
 200b434:	d8800015 	stw	r2,0(sp)
 200b438:	008dcdb4 	movhi	r2,14134
 200b43c:	108d4d04 	addi	r2,r2,13620
 200b440:	d8800115 	stw	r2,4(sp)
 200b444:	00989874 	movhi	r2,25185
 200b448:	108e4e04 	addi	r2,r2,14648
 200b44c:	d8800215 	stw	r2,8(sp)
 200b450:	00999974 	movhi	r2,26213
 200b454:	109918c4 	addi	r2,r2,25699
 200b458:	d8800315 	stw	r2,12(sp)
 200b45c:	009a9a74 	movhi	r2,27241
 200b460:	109a19c4 	addi	r2,r2,26727
 200b464:	d8800415 	stw	r2,16(sp)
 200b468:	009b9b74 	movhi	r2,28269
 200b46c:	109b1ac4 	addi	r2,r2,27755
 200b470:	d8800515 	stw	r2,20(sp)
 200b474:	009c9c74 	movhi	r2,29297
 200b478:	109c1bc4 	addi	r2,r2,28783
 200b47c:	d8800615 	stw	r2,24(sp)
 200b480:	009d9d74 	movhi	r2,30325
 200b484:	109d1cc4 	addi	r2,r2,29811
 200b488:	d8800715 	stw	r2,28(sp)
 200b48c:	009e9e74 	movhi	r2,31353
 200b490:	109e1dc4 	addi	r2,r2,30839
 200b494:	dd000e15 	stw	r20,56(sp)
 200b498:	d8800815 	stw	r2,32(sp)
 200b49c:	dfc00f15 	stw	ra,60(sp)
 200b4a0:	dcc00d15 	stw	r19,52(sp)
 200b4a4:	dc800c15 	stw	r18,48(sp)
 200b4a8:	dc400b15 	stw	r17,44(sp)
 200b4ac:	dc000a15 	stw	r16,40(sp)
 200b4b0:	d8000905 	stb	zero,36(sp)
 200b4b4:	30bfff84 	addi	r2,r6,-2
 200b4b8:	00c00884 	movi	r3,34
 200b4bc:	2829883a 	mov	r20,r5
 200b4c0:	18802c36 	bltu	r3,r2,200b574 <__utoa+0x14c>
 200b4c4:	3027883a 	mov	r19,r6
 200b4c8:	2023883a 	mov	r17,r4
 200b4cc:	2825883a 	mov	r18,r5
 200b4d0:	0021883a 	mov	r16,zero
 200b4d4:	00000106 	br	200b4dc <__utoa+0xb4>
 200b4d8:	1821883a 	mov	r16,r3
 200b4dc:	8809883a 	mov	r4,r17
 200b4e0:	980b883a 	mov	r5,r19
 200b4e4:	2009b740 	call	2009b74 <__umodsi3>
 200b4e8:	d885883a 	add	r2,sp,r2
 200b4ec:	10800003 	ldbu	r2,0(r2)
 200b4f0:	8809883a 	mov	r4,r17
 200b4f4:	980b883a 	mov	r5,r19
 200b4f8:	90800005 	stb	r2,0(r18)
 200b4fc:	2009b100 	call	2009b10 <__udivsi3>
 200b500:	1023883a 	mov	r17,r2
 200b504:	80c00044 	addi	r3,r16,1
 200b508:	94800044 	addi	r18,r18,1
 200b50c:	103ff21e 	bne	r2,zero,200b4d8 <__reset+0xfe00a4d8>
 200b510:	a0c7883a 	add	r3,r20,r3
 200b514:	18000005 	stb	zero,0(r3)
 200b518:	80000d26 	beq	r16,zero,200b550 <__utoa+0x128>
 200b51c:	01c00044 	movi	r7,1
 200b520:	a409883a 	add	r4,r20,r16
 200b524:	a007883a 	mov	r3,r20
 200b528:	3d0fc83a 	sub	r7,r7,r20
 200b52c:	21800003 	ldbu	r6,0(r4)
 200b530:	19400003 	ldbu	r5,0(r3)
 200b534:	38c5883a 	add	r2,r7,r3
 200b538:	19800005 	stb	r6,0(r3)
 200b53c:	21400005 	stb	r5,0(r4)
 200b540:	843fffc4 	addi	r16,r16,-1
 200b544:	18c00044 	addi	r3,r3,1
 200b548:	213fffc4 	addi	r4,r4,-1
 200b54c:	143ff716 	blt	r2,r16,200b52c <__reset+0xfe00a52c>
 200b550:	a005883a 	mov	r2,r20
 200b554:	dfc00f17 	ldw	ra,60(sp)
 200b558:	dd000e17 	ldw	r20,56(sp)
 200b55c:	dcc00d17 	ldw	r19,52(sp)
 200b560:	dc800c17 	ldw	r18,48(sp)
 200b564:	dc400b17 	ldw	r17,44(sp)
 200b568:	dc000a17 	ldw	r16,40(sp)
 200b56c:	dec01004 	addi	sp,sp,64
 200b570:	f800283a 	ret
 200b574:	28000005 	stb	zero,0(r5)
 200b578:	0005883a 	mov	r2,zero
 200b57c:	003ff506 	br	200b554 <__reset+0xfe00a554>

0200b580 <utoa>:
 200b580:	200b4281 	jmpi	200b428 <__utoa>

0200b584 <__fp_unlock>:
 200b584:	0005883a 	mov	r2,zero
 200b588:	f800283a 	ret

0200b58c <_cleanup_r>:
 200b58c:	01408074 	movhi	r5,513
 200b590:	2974b304 	addi	r5,r5,-11572
 200b594:	200bec01 	jmpi	200bec0 <_fwalk_reent>

0200b598 <__sinit.part.1>:
 200b598:	defff704 	addi	sp,sp,-36
 200b59c:	00c08074 	movhi	r3,513
 200b5a0:	dfc00815 	stw	ra,32(sp)
 200b5a4:	ddc00715 	stw	r23,28(sp)
 200b5a8:	dd800615 	stw	r22,24(sp)
 200b5ac:	dd400515 	stw	r21,20(sp)
 200b5b0:	dd000415 	stw	r20,16(sp)
 200b5b4:	dcc00315 	stw	r19,12(sp)
 200b5b8:	dc800215 	stw	r18,8(sp)
 200b5bc:	dc400115 	stw	r17,4(sp)
 200b5c0:	dc000015 	stw	r16,0(sp)
 200b5c4:	18ed6304 	addi	r3,r3,-19060
 200b5c8:	24000117 	ldw	r16,4(r4)
 200b5cc:	20c00f15 	stw	r3,60(r4)
 200b5d0:	2080bb04 	addi	r2,r4,748
 200b5d4:	00c000c4 	movi	r3,3
 200b5d8:	20c0b915 	stw	r3,740(r4)
 200b5dc:	2080ba15 	stw	r2,744(r4)
 200b5e0:	2000b815 	stw	zero,736(r4)
 200b5e4:	05c00204 	movi	r23,8
 200b5e8:	00800104 	movi	r2,4
 200b5ec:	2025883a 	mov	r18,r4
 200b5f0:	b80d883a 	mov	r6,r23
 200b5f4:	81001704 	addi	r4,r16,92
 200b5f8:	000b883a 	mov	r5,zero
 200b5fc:	80000015 	stw	zero,0(r16)
 200b600:	80000115 	stw	zero,4(r16)
 200b604:	80000215 	stw	zero,8(r16)
 200b608:	8080030d 	sth	r2,12(r16)
 200b60c:	80001915 	stw	zero,100(r16)
 200b610:	8000038d 	sth	zero,14(r16)
 200b614:	80000415 	stw	zero,16(r16)
 200b618:	80000515 	stw	zero,20(r16)
 200b61c:	80000615 	stw	zero,24(r16)
 200b620:	200b0800 	call	200b080 <memset>
 200b624:	05808074 	movhi	r22,513
 200b628:	94400217 	ldw	r17,8(r18)
 200b62c:	05408074 	movhi	r21,513
 200b630:	05008074 	movhi	r20,513
 200b634:	04c08074 	movhi	r19,513
 200b638:	b5b3e204 	addi	r22,r22,-12408
 200b63c:	ad73f904 	addi	r21,r21,-12316
 200b640:	a5341804 	addi	r20,r20,-12192
 200b644:	9cf42f04 	addi	r19,r19,-12100
 200b648:	85800815 	stw	r22,32(r16)
 200b64c:	85400915 	stw	r21,36(r16)
 200b650:	85000a15 	stw	r20,40(r16)
 200b654:	84c00b15 	stw	r19,44(r16)
 200b658:	84000715 	stw	r16,28(r16)
 200b65c:	00800284 	movi	r2,10
 200b660:	8880030d 	sth	r2,12(r17)
 200b664:	00800044 	movi	r2,1
 200b668:	b80d883a 	mov	r6,r23
 200b66c:	89001704 	addi	r4,r17,92
 200b670:	000b883a 	mov	r5,zero
 200b674:	88000015 	stw	zero,0(r17)
 200b678:	88000115 	stw	zero,4(r17)
 200b67c:	88000215 	stw	zero,8(r17)
 200b680:	88001915 	stw	zero,100(r17)
 200b684:	8880038d 	sth	r2,14(r17)
 200b688:	88000415 	stw	zero,16(r17)
 200b68c:	88000515 	stw	zero,20(r17)
 200b690:	88000615 	stw	zero,24(r17)
 200b694:	200b0800 	call	200b080 <memset>
 200b698:	94000317 	ldw	r16,12(r18)
 200b69c:	00800484 	movi	r2,18
 200b6a0:	8c400715 	stw	r17,28(r17)
 200b6a4:	8d800815 	stw	r22,32(r17)
 200b6a8:	8d400915 	stw	r21,36(r17)
 200b6ac:	8d000a15 	stw	r20,40(r17)
 200b6b0:	8cc00b15 	stw	r19,44(r17)
 200b6b4:	8080030d 	sth	r2,12(r16)
 200b6b8:	00800084 	movi	r2,2
 200b6bc:	80000015 	stw	zero,0(r16)
 200b6c0:	80000115 	stw	zero,4(r16)
 200b6c4:	80000215 	stw	zero,8(r16)
 200b6c8:	80001915 	stw	zero,100(r16)
 200b6cc:	8080038d 	sth	r2,14(r16)
 200b6d0:	80000415 	stw	zero,16(r16)
 200b6d4:	80000515 	stw	zero,20(r16)
 200b6d8:	80000615 	stw	zero,24(r16)
 200b6dc:	b80d883a 	mov	r6,r23
 200b6e0:	000b883a 	mov	r5,zero
 200b6e4:	81001704 	addi	r4,r16,92
 200b6e8:	200b0800 	call	200b080 <memset>
 200b6ec:	00800044 	movi	r2,1
 200b6f0:	84000715 	stw	r16,28(r16)
 200b6f4:	85800815 	stw	r22,32(r16)
 200b6f8:	85400915 	stw	r21,36(r16)
 200b6fc:	85000a15 	stw	r20,40(r16)
 200b700:	84c00b15 	stw	r19,44(r16)
 200b704:	90800e15 	stw	r2,56(r18)
 200b708:	dfc00817 	ldw	ra,32(sp)
 200b70c:	ddc00717 	ldw	r23,28(sp)
 200b710:	dd800617 	ldw	r22,24(sp)
 200b714:	dd400517 	ldw	r21,20(sp)
 200b718:	dd000417 	ldw	r20,16(sp)
 200b71c:	dcc00317 	ldw	r19,12(sp)
 200b720:	dc800217 	ldw	r18,8(sp)
 200b724:	dc400117 	ldw	r17,4(sp)
 200b728:	dc000017 	ldw	r16,0(sp)
 200b72c:	dec00904 	addi	sp,sp,36
 200b730:	f800283a 	ret

0200b734 <__fp_lock>:
 200b734:	0005883a 	mov	r2,zero
 200b738:	f800283a 	ret

0200b73c <__sfmoreglue>:
 200b73c:	defffc04 	addi	sp,sp,-16
 200b740:	dc800215 	stw	r18,8(sp)
 200b744:	2825883a 	mov	r18,r5
 200b748:	dc000015 	stw	r16,0(sp)
 200b74c:	01401a04 	movi	r5,104
 200b750:	2021883a 	mov	r16,r4
 200b754:	913fffc4 	addi	r4,r18,-1
 200b758:	dfc00315 	stw	ra,12(sp)
 200b75c:	dc400115 	stw	r17,4(sp)
 200b760:	2009bcc0 	call	2009bcc <__mulsi3>
 200b764:	8009883a 	mov	r4,r16
 200b768:	11401d04 	addi	r5,r2,116
 200b76c:	1023883a 	mov	r17,r2
 200b770:	200bf840 	call	200bf84 <_malloc_r>
 200b774:	1021883a 	mov	r16,r2
 200b778:	10000726 	beq	r2,zero,200b798 <__sfmoreglue+0x5c>
 200b77c:	11000304 	addi	r4,r2,12
 200b780:	10000015 	stw	zero,0(r2)
 200b784:	14800115 	stw	r18,4(r2)
 200b788:	11000215 	stw	r4,8(r2)
 200b78c:	89801a04 	addi	r6,r17,104
 200b790:	000b883a 	mov	r5,zero
 200b794:	200b0800 	call	200b080 <memset>
 200b798:	8005883a 	mov	r2,r16
 200b79c:	dfc00317 	ldw	ra,12(sp)
 200b7a0:	dc800217 	ldw	r18,8(sp)
 200b7a4:	dc400117 	ldw	r17,4(sp)
 200b7a8:	dc000017 	ldw	r16,0(sp)
 200b7ac:	dec00404 	addi	sp,sp,16
 200b7b0:	f800283a 	ret

0200b7b4 <__sfp>:
 200b7b4:	defffb04 	addi	sp,sp,-20
 200b7b8:	dc000015 	stw	r16,0(sp)
 200b7bc:	04008074 	movhi	r16,513
 200b7c0:	8410b804 	addi	r16,r16,17120
 200b7c4:	dcc00315 	stw	r19,12(sp)
 200b7c8:	2027883a 	mov	r19,r4
 200b7cc:	81000017 	ldw	r4,0(r16)
 200b7d0:	dfc00415 	stw	ra,16(sp)
 200b7d4:	dc800215 	stw	r18,8(sp)
 200b7d8:	20800e17 	ldw	r2,56(r4)
 200b7dc:	dc400115 	stw	r17,4(sp)
 200b7e0:	1000021e 	bne	r2,zero,200b7ec <__sfp+0x38>
 200b7e4:	200b5980 	call	200b598 <__sinit.part.1>
 200b7e8:	81000017 	ldw	r4,0(r16)
 200b7ec:	2480b804 	addi	r18,r4,736
 200b7f0:	047fffc4 	movi	r17,-1
 200b7f4:	91000117 	ldw	r4,4(r18)
 200b7f8:	94000217 	ldw	r16,8(r18)
 200b7fc:	213fffc4 	addi	r4,r4,-1
 200b800:	20000a16 	blt	r4,zero,200b82c <__sfp+0x78>
 200b804:	8080030f 	ldh	r2,12(r16)
 200b808:	10000c26 	beq	r2,zero,200b83c <__sfp+0x88>
 200b80c:	80c01d04 	addi	r3,r16,116
 200b810:	00000206 	br	200b81c <__sfp+0x68>
 200b814:	18bfe60f 	ldh	r2,-104(r3)
 200b818:	10000826 	beq	r2,zero,200b83c <__sfp+0x88>
 200b81c:	213fffc4 	addi	r4,r4,-1
 200b820:	1c3ffd04 	addi	r16,r3,-12
 200b824:	18c01a04 	addi	r3,r3,104
 200b828:	247ffa1e 	bne	r4,r17,200b814 <__reset+0xfe00a814>
 200b82c:	90800017 	ldw	r2,0(r18)
 200b830:	10001d26 	beq	r2,zero,200b8a8 <__sfp+0xf4>
 200b834:	1025883a 	mov	r18,r2
 200b838:	003fee06 	br	200b7f4 <__reset+0xfe00a7f4>
 200b83c:	00bfffc4 	movi	r2,-1
 200b840:	8080038d 	sth	r2,14(r16)
 200b844:	00800044 	movi	r2,1
 200b848:	8080030d 	sth	r2,12(r16)
 200b84c:	80001915 	stw	zero,100(r16)
 200b850:	80000015 	stw	zero,0(r16)
 200b854:	80000215 	stw	zero,8(r16)
 200b858:	80000115 	stw	zero,4(r16)
 200b85c:	80000415 	stw	zero,16(r16)
 200b860:	80000515 	stw	zero,20(r16)
 200b864:	80000615 	stw	zero,24(r16)
 200b868:	01800204 	movi	r6,8
 200b86c:	000b883a 	mov	r5,zero
 200b870:	81001704 	addi	r4,r16,92
 200b874:	200b0800 	call	200b080 <memset>
 200b878:	8005883a 	mov	r2,r16
 200b87c:	80000c15 	stw	zero,48(r16)
 200b880:	80000d15 	stw	zero,52(r16)
 200b884:	80001115 	stw	zero,68(r16)
 200b888:	80001215 	stw	zero,72(r16)
 200b88c:	dfc00417 	ldw	ra,16(sp)
 200b890:	dcc00317 	ldw	r19,12(sp)
 200b894:	dc800217 	ldw	r18,8(sp)
 200b898:	dc400117 	ldw	r17,4(sp)
 200b89c:	dc000017 	ldw	r16,0(sp)
 200b8a0:	dec00504 	addi	sp,sp,20
 200b8a4:	f800283a 	ret
 200b8a8:	01400104 	movi	r5,4
 200b8ac:	9809883a 	mov	r4,r19
 200b8b0:	200b73c0 	call	200b73c <__sfmoreglue>
 200b8b4:	90800015 	stw	r2,0(r18)
 200b8b8:	103fde1e 	bne	r2,zero,200b834 <__reset+0xfe00a834>
 200b8bc:	00800304 	movi	r2,12
 200b8c0:	98800015 	stw	r2,0(r19)
 200b8c4:	0005883a 	mov	r2,zero
 200b8c8:	003ff006 	br	200b88c <__reset+0xfe00a88c>

0200b8cc <_cleanup>:
 200b8cc:	00808074 	movhi	r2,513
 200b8d0:	1090b804 	addi	r2,r2,17120
 200b8d4:	11000017 	ldw	r4,0(r2)
 200b8d8:	01408074 	movhi	r5,513
 200b8dc:	2974b304 	addi	r5,r5,-11572
 200b8e0:	200bec01 	jmpi	200bec0 <_fwalk_reent>

0200b8e4 <__sinit>:
 200b8e4:	20800e17 	ldw	r2,56(r4)
 200b8e8:	10000126 	beq	r2,zero,200b8f0 <__sinit+0xc>
 200b8ec:	f800283a 	ret
 200b8f0:	200b5981 	jmpi	200b598 <__sinit.part.1>

0200b8f4 <__sfp_lock_acquire>:
 200b8f4:	f800283a 	ret

0200b8f8 <__sfp_lock_release>:
 200b8f8:	f800283a 	ret

0200b8fc <__sinit_lock_acquire>:
 200b8fc:	f800283a 	ret

0200b900 <__sinit_lock_release>:
 200b900:	f800283a 	ret

0200b904 <__fp_lock_all>:
 200b904:	00808074 	movhi	r2,513
 200b908:	1090b904 	addi	r2,r2,17124
 200b90c:	11000017 	ldw	r4,0(r2)
 200b910:	01408074 	movhi	r5,513
 200b914:	296dcd04 	addi	r5,r5,-18636
 200b918:	200bdfc1 	jmpi	200bdfc <_fwalk>

0200b91c <__fp_unlock_all>:
 200b91c:	00808074 	movhi	r2,513
 200b920:	1090b904 	addi	r2,r2,17124
 200b924:	11000017 	ldw	r4,0(r2)
 200b928:	01408074 	movhi	r5,513
 200b92c:	296d6104 	addi	r5,r5,-19068
 200b930:	200bdfc1 	jmpi	200bdfc <_fwalk>

0200b934 <__sfvwrite_r>:
 200b934:	30800217 	ldw	r2,8(r6)
 200b938:	10006726 	beq	r2,zero,200bad8 <__sfvwrite_r+0x1a4>
 200b93c:	28c0030b 	ldhu	r3,12(r5)
 200b940:	defff404 	addi	sp,sp,-48
 200b944:	dd400715 	stw	r21,28(sp)
 200b948:	dd000615 	stw	r20,24(sp)
 200b94c:	dc000215 	stw	r16,8(sp)
 200b950:	dfc00b15 	stw	ra,44(sp)
 200b954:	df000a15 	stw	fp,40(sp)
 200b958:	ddc00915 	stw	r23,36(sp)
 200b95c:	dd800815 	stw	r22,32(sp)
 200b960:	dcc00515 	stw	r19,20(sp)
 200b964:	dc800415 	stw	r18,16(sp)
 200b968:	dc400315 	stw	r17,12(sp)
 200b96c:	1880020c 	andi	r2,r3,8
 200b970:	2821883a 	mov	r16,r5
 200b974:	202b883a 	mov	r21,r4
 200b978:	3029883a 	mov	r20,r6
 200b97c:	10002726 	beq	r2,zero,200ba1c <__sfvwrite_r+0xe8>
 200b980:	28800417 	ldw	r2,16(r5)
 200b984:	10002526 	beq	r2,zero,200ba1c <__sfvwrite_r+0xe8>
 200b988:	1880008c 	andi	r2,r3,2
 200b98c:	a4400017 	ldw	r17,0(r20)
 200b990:	10002a26 	beq	r2,zero,200ba3c <__sfvwrite_r+0x108>
 200b994:	05a00034 	movhi	r22,32768
 200b998:	0027883a 	mov	r19,zero
 200b99c:	0025883a 	mov	r18,zero
 200b9a0:	b5bf0004 	addi	r22,r22,-1024
 200b9a4:	980d883a 	mov	r6,r19
 200b9a8:	a809883a 	mov	r4,r21
 200b9ac:	90004626 	beq	r18,zero,200bac8 <__sfvwrite_r+0x194>
 200b9b0:	900f883a 	mov	r7,r18
 200b9b4:	b480022e 	bgeu	r22,r18,200b9c0 <__sfvwrite_r+0x8c>
 200b9b8:	01e00034 	movhi	r7,32768
 200b9bc:	39ff0004 	addi	r7,r7,-1024
 200b9c0:	80800917 	ldw	r2,36(r16)
 200b9c4:	81400717 	ldw	r5,28(r16)
 200b9c8:	103ee83a 	callr	r2
 200b9cc:	00805a0e 	bge	zero,r2,200bb38 <__sfvwrite_r+0x204>
 200b9d0:	a0c00217 	ldw	r3,8(r20)
 200b9d4:	98a7883a 	add	r19,r19,r2
 200b9d8:	90a5c83a 	sub	r18,r18,r2
 200b9dc:	1885c83a 	sub	r2,r3,r2
 200b9e0:	a0800215 	stw	r2,8(r20)
 200b9e4:	103fef1e 	bne	r2,zero,200b9a4 <__reset+0xfe00a9a4>
 200b9e8:	0005883a 	mov	r2,zero
 200b9ec:	dfc00b17 	ldw	ra,44(sp)
 200b9f0:	df000a17 	ldw	fp,40(sp)
 200b9f4:	ddc00917 	ldw	r23,36(sp)
 200b9f8:	dd800817 	ldw	r22,32(sp)
 200b9fc:	dd400717 	ldw	r21,28(sp)
 200ba00:	dd000617 	ldw	r20,24(sp)
 200ba04:	dcc00517 	ldw	r19,20(sp)
 200ba08:	dc800417 	ldw	r18,16(sp)
 200ba0c:	dc400317 	ldw	r17,12(sp)
 200ba10:	dc000217 	ldw	r16,8(sp)
 200ba14:	dec00c04 	addi	sp,sp,48
 200ba18:	f800283a 	ret
 200ba1c:	800b883a 	mov	r5,r16
 200ba20:	a809883a 	mov	r4,r21
 200ba24:	200d1240 	call	200d124 <__swsetup_r>
 200ba28:	1000ee1e 	bne	r2,zero,200bde4 <__sfvwrite_r+0x4b0>
 200ba2c:	80c0030b 	ldhu	r3,12(r16)
 200ba30:	a4400017 	ldw	r17,0(r20)
 200ba34:	1880008c 	andi	r2,r3,2
 200ba38:	103fd61e 	bne	r2,zero,200b994 <__reset+0xfe00a994>
 200ba3c:	1880004c 	andi	r2,r3,1
 200ba40:	1000421e 	bne	r2,zero,200bb4c <__sfvwrite_r+0x218>
 200ba44:	0039883a 	mov	fp,zero
 200ba48:	0025883a 	mov	r18,zero
 200ba4c:	90001a26 	beq	r18,zero,200bab8 <__sfvwrite_r+0x184>
 200ba50:	1880800c 	andi	r2,r3,512
 200ba54:	84c00217 	ldw	r19,8(r16)
 200ba58:	10002126 	beq	r2,zero,200bae0 <__sfvwrite_r+0x1ac>
 200ba5c:	982f883a 	mov	r23,r19
 200ba60:	94c09636 	bltu	r18,r19,200bcbc <__sfvwrite_r+0x388>
 200ba64:	1881200c 	andi	r2,r3,1152
 200ba68:	1000a11e 	bne	r2,zero,200bcf0 <__sfvwrite_r+0x3bc>
 200ba6c:	81000017 	ldw	r4,0(r16)
 200ba70:	b80d883a 	mov	r6,r23
 200ba74:	e00b883a 	mov	r5,fp
 200ba78:	200c8740 	call	200c874 <memmove>
 200ba7c:	80c00217 	ldw	r3,8(r16)
 200ba80:	81000017 	ldw	r4,0(r16)
 200ba84:	9005883a 	mov	r2,r18
 200ba88:	1ce7c83a 	sub	r19,r3,r19
 200ba8c:	25cf883a 	add	r7,r4,r23
 200ba90:	84c00215 	stw	r19,8(r16)
 200ba94:	81c00015 	stw	r7,0(r16)
 200ba98:	a0c00217 	ldw	r3,8(r20)
 200ba9c:	e0b9883a 	add	fp,fp,r2
 200baa0:	90a5c83a 	sub	r18,r18,r2
 200baa4:	18a7c83a 	sub	r19,r3,r2
 200baa8:	a4c00215 	stw	r19,8(r20)
 200baac:	983fce26 	beq	r19,zero,200b9e8 <__reset+0xfe00a9e8>
 200bab0:	80c0030b 	ldhu	r3,12(r16)
 200bab4:	903fe61e 	bne	r18,zero,200ba50 <__reset+0xfe00aa50>
 200bab8:	8f000017 	ldw	fp,0(r17)
 200babc:	8c800117 	ldw	r18,4(r17)
 200bac0:	8c400204 	addi	r17,r17,8
 200bac4:	003fe106 	br	200ba4c <__reset+0xfe00aa4c>
 200bac8:	8cc00017 	ldw	r19,0(r17)
 200bacc:	8c800117 	ldw	r18,4(r17)
 200bad0:	8c400204 	addi	r17,r17,8
 200bad4:	003fb306 	br	200b9a4 <__reset+0xfe00a9a4>
 200bad8:	0005883a 	mov	r2,zero
 200badc:	f800283a 	ret
 200bae0:	81000017 	ldw	r4,0(r16)
 200bae4:	80800417 	ldw	r2,16(r16)
 200bae8:	11005a36 	bltu	r2,r4,200bc54 <__sfvwrite_r+0x320>
 200baec:	85c00517 	ldw	r23,20(r16)
 200baf0:	95c05836 	bltu	r18,r23,200bc54 <__sfvwrite_r+0x320>
 200baf4:	00a00034 	movhi	r2,32768
 200baf8:	10bfffc4 	addi	r2,r2,-1
 200bafc:	9009883a 	mov	r4,r18
 200bb00:	1480012e 	bgeu	r2,r18,200bb08 <__sfvwrite_r+0x1d4>
 200bb04:	1009883a 	mov	r4,r2
 200bb08:	b80b883a 	mov	r5,r23
 200bb0c:	2009a180 	call	2009a18 <__divsi3>
 200bb10:	b80b883a 	mov	r5,r23
 200bb14:	1009883a 	mov	r4,r2
 200bb18:	2009bcc0 	call	2009bcc <__mulsi3>
 200bb1c:	81400717 	ldw	r5,28(r16)
 200bb20:	80c00917 	ldw	r3,36(r16)
 200bb24:	100f883a 	mov	r7,r2
 200bb28:	e00d883a 	mov	r6,fp
 200bb2c:	a809883a 	mov	r4,r21
 200bb30:	183ee83a 	callr	r3
 200bb34:	00bfd816 	blt	zero,r2,200ba98 <__reset+0xfe00aa98>
 200bb38:	8080030b 	ldhu	r2,12(r16)
 200bb3c:	10801014 	ori	r2,r2,64
 200bb40:	8080030d 	sth	r2,12(r16)
 200bb44:	00bfffc4 	movi	r2,-1
 200bb48:	003fa806 	br	200b9ec <__reset+0xfe00a9ec>
 200bb4c:	0027883a 	mov	r19,zero
 200bb50:	0011883a 	mov	r8,zero
 200bb54:	0039883a 	mov	fp,zero
 200bb58:	0025883a 	mov	r18,zero
 200bb5c:	90001f26 	beq	r18,zero,200bbdc <__sfvwrite_r+0x2a8>
 200bb60:	40005a26 	beq	r8,zero,200bccc <__sfvwrite_r+0x398>
 200bb64:	982d883a 	mov	r22,r19
 200bb68:	94c0012e 	bgeu	r18,r19,200bb70 <__sfvwrite_r+0x23c>
 200bb6c:	902d883a 	mov	r22,r18
 200bb70:	81000017 	ldw	r4,0(r16)
 200bb74:	80800417 	ldw	r2,16(r16)
 200bb78:	b02f883a 	mov	r23,r22
 200bb7c:	81c00517 	ldw	r7,20(r16)
 200bb80:	1100032e 	bgeu	r2,r4,200bb90 <__sfvwrite_r+0x25c>
 200bb84:	80c00217 	ldw	r3,8(r16)
 200bb88:	38c7883a 	add	r3,r7,r3
 200bb8c:	1d801816 	blt	r3,r22,200bbf0 <__sfvwrite_r+0x2bc>
 200bb90:	b1c03e16 	blt	r22,r7,200bc8c <__sfvwrite_r+0x358>
 200bb94:	80800917 	ldw	r2,36(r16)
 200bb98:	81400717 	ldw	r5,28(r16)
 200bb9c:	e00d883a 	mov	r6,fp
 200bba0:	da000115 	stw	r8,4(sp)
 200bba4:	a809883a 	mov	r4,r21
 200bba8:	103ee83a 	callr	r2
 200bbac:	102f883a 	mov	r23,r2
 200bbb0:	da000117 	ldw	r8,4(sp)
 200bbb4:	00bfe00e 	bge	zero,r2,200bb38 <__reset+0xfe00ab38>
 200bbb8:	9de7c83a 	sub	r19,r19,r23
 200bbbc:	98001f26 	beq	r19,zero,200bc3c <__sfvwrite_r+0x308>
 200bbc0:	a0800217 	ldw	r2,8(r20)
 200bbc4:	e5f9883a 	add	fp,fp,r23
 200bbc8:	95e5c83a 	sub	r18,r18,r23
 200bbcc:	15efc83a 	sub	r23,r2,r23
 200bbd0:	a5c00215 	stw	r23,8(r20)
 200bbd4:	b83f8426 	beq	r23,zero,200b9e8 <__reset+0xfe00a9e8>
 200bbd8:	903fe11e 	bne	r18,zero,200bb60 <__reset+0xfe00ab60>
 200bbdc:	8f000017 	ldw	fp,0(r17)
 200bbe0:	8c800117 	ldw	r18,4(r17)
 200bbe4:	0011883a 	mov	r8,zero
 200bbe8:	8c400204 	addi	r17,r17,8
 200bbec:	003fdb06 	br	200bb5c <__reset+0xfe00ab5c>
 200bbf0:	180d883a 	mov	r6,r3
 200bbf4:	e00b883a 	mov	r5,fp
 200bbf8:	da000115 	stw	r8,4(sp)
 200bbfc:	d8c00015 	stw	r3,0(sp)
 200bc00:	200c8740 	call	200c874 <memmove>
 200bc04:	d8c00017 	ldw	r3,0(sp)
 200bc08:	80800017 	ldw	r2,0(r16)
 200bc0c:	800b883a 	mov	r5,r16
 200bc10:	a809883a 	mov	r4,r21
 200bc14:	10c5883a 	add	r2,r2,r3
 200bc18:	80800015 	stw	r2,0(r16)
 200bc1c:	d8c00015 	stw	r3,0(sp)
 200bc20:	200d5ec0 	call	200d5ec <_fflush_r>
 200bc24:	d8c00017 	ldw	r3,0(sp)
 200bc28:	da000117 	ldw	r8,4(sp)
 200bc2c:	103fc21e 	bne	r2,zero,200bb38 <__reset+0xfe00ab38>
 200bc30:	182f883a 	mov	r23,r3
 200bc34:	9de7c83a 	sub	r19,r19,r23
 200bc38:	983fe11e 	bne	r19,zero,200bbc0 <__reset+0xfe00abc0>
 200bc3c:	800b883a 	mov	r5,r16
 200bc40:	a809883a 	mov	r4,r21
 200bc44:	200d5ec0 	call	200d5ec <_fflush_r>
 200bc48:	103fbb1e 	bne	r2,zero,200bb38 <__reset+0xfe00ab38>
 200bc4c:	0011883a 	mov	r8,zero
 200bc50:	003fdb06 	br	200bbc0 <__reset+0xfe00abc0>
 200bc54:	94c0012e 	bgeu	r18,r19,200bc5c <__sfvwrite_r+0x328>
 200bc58:	9027883a 	mov	r19,r18
 200bc5c:	980d883a 	mov	r6,r19
 200bc60:	e00b883a 	mov	r5,fp
 200bc64:	200c8740 	call	200c874 <memmove>
 200bc68:	80800217 	ldw	r2,8(r16)
 200bc6c:	80c00017 	ldw	r3,0(r16)
 200bc70:	14c5c83a 	sub	r2,r2,r19
 200bc74:	1cc7883a 	add	r3,r3,r19
 200bc78:	80800215 	stw	r2,8(r16)
 200bc7c:	80c00015 	stw	r3,0(r16)
 200bc80:	10004326 	beq	r2,zero,200bd90 <__sfvwrite_r+0x45c>
 200bc84:	9805883a 	mov	r2,r19
 200bc88:	003f8306 	br	200ba98 <__reset+0xfe00aa98>
 200bc8c:	b00d883a 	mov	r6,r22
 200bc90:	e00b883a 	mov	r5,fp
 200bc94:	da000115 	stw	r8,4(sp)
 200bc98:	200c8740 	call	200c874 <memmove>
 200bc9c:	80800217 	ldw	r2,8(r16)
 200bca0:	80c00017 	ldw	r3,0(r16)
 200bca4:	da000117 	ldw	r8,4(sp)
 200bca8:	1585c83a 	sub	r2,r2,r22
 200bcac:	1dad883a 	add	r22,r3,r22
 200bcb0:	80800215 	stw	r2,8(r16)
 200bcb4:	85800015 	stw	r22,0(r16)
 200bcb8:	003fbf06 	br	200bbb8 <__reset+0xfe00abb8>
 200bcbc:	81000017 	ldw	r4,0(r16)
 200bcc0:	9027883a 	mov	r19,r18
 200bcc4:	902f883a 	mov	r23,r18
 200bcc8:	003f6906 	br	200ba70 <__reset+0xfe00aa70>
 200bccc:	900d883a 	mov	r6,r18
 200bcd0:	01400284 	movi	r5,10
 200bcd4:	e009883a 	mov	r4,fp
 200bcd8:	200c7900 	call	200c790 <memchr>
 200bcdc:	10003e26 	beq	r2,zero,200bdd8 <__sfvwrite_r+0x4a4>
 200bce0:	10800044 	addi	r2,r2,1
 200bce4:	1727c83a 	sub	r19,r2,fp
 200bce8:	02000044 	movi	r8,1
 200bcec:	003f9d06 	br	200bb64 <__reset+0xfe00ab64>
 200bcf0:	80800517 	ldw	r2,20(r16)
 200bcf4:	81400417 	ldw	r5,16(r16)
 200bcf8:	81c00017 	ldw	r7,0(r16)
 200bcfc:	10a7883a 	add	r19,r2,r2
 200bd00:	9885883a 	add	r2,r19,r2
 200bd04:	1026d7fa 	srli	r19,r2,31
 200bd08:	396dc83a 	sub	r22,r7,r5
 200bd0c:	b1000044 	addi	r4,r22,1
 200bd10:	9885883a 	add	r2,r19,r2
 200bd14:	1027d07a 	srai	r19,r2,1
 200bd18:	2485883a 	add	r2,r4,r18
 200bd1c:	980d883a 	mov	r6,r19
 200bd20:	9880022e 	bgeu	r19,r2,200bd2c <__sfvwrite_r+0x3f8>
 200bd24:	1027883a 	mov	r19,r2
 200bd28:	100d883a 	mov	r6,r2
 200bd2c:	18c1000c 	andi	r3,r3,1024
 200bd30:	18001c26 	beq	r3,zero,200bda4 <__sfvwrite_r+0x470>
 200bd34:	300b883a 	mov	r5,r6
 200bd38:	a809883a 	mov	r4,r21
 200bd3c:	200bf840 	call	200bf84 <_malloc_r>
 200bd40:	102f883a 	mov	r23,r2
 200bd44:	10002926 	beq	r2,zero,200bdec <__sfvwrite_r+0x4b8>
 200bd48:	81400417 	ldw	r5,16(r16)
 200bd4c:	b00d883a 	mov	r6,r22
 200bd50:	1009883a 	mov	r4,r2
 200bd54:	200af380 	call	200af38 <memcpy>
 200bd58:	8080030b 	ldhu	r2,12(r16)
 200bd5c:	00fedfc4 	movi	r3,-1153
 200bd60:	10c4703a 	and	r2,r2,r3
 200bd64:	10802014 	ori	r2,r2,128
 200bd68:	8080030d 	sth	r2,12(r16)
 200bd6c:	bd89883a 	add	r4,r23,r22
 200bd70:	9d8fc83a 	sub	r7,r19,r22
 200bd74:	85c00415 	stw	r23,16(r16)
 200bd78:	84c00515 	stw	r19,20(r16)
 200bd7c:	81000015 	stw	r4,0(r16)
 200bd80:	9027883a 	mov	r19,r18
 200bd84:	81c00215 	stw	r7,8(r16)
 200bd88:	902f883a 	mov	r23,r18
 200bd8c:	003f3806 	br	200ba70 <__reset+0xfe00aa70>
 200bd90:	800b883a 	mov	r5,r16
 200bd94:	a809883a 	mov	r4,r21
 200bd98:	200d5ec0 	call	200d5ec <_fflush_r>
 200bd9c:	103fb926 	beq	r2,zero,200bc84 <__reset+0xfe00ac84>
 200bda0:	003f6506 	br	200bb38 <__reset+0xfe00ab38>
 200bda4:	a809883a 	mov	r4,r21
 200bda8:	200c9d00 	call	200c9d0 <_realloc_r>
 200bdac:	102f883a 	mov	r23,r2
 200bdb0:	103fee1e 	bne	r2,zero,200bd6c <__reset+0xfe00ad6c>
 200bdb4:	81400417 	ldw	r5,16(r16)
 200bdb8:	a809883a 	mov	r4,r21
 200bdbc:	200d79c0 	call	200d79c <_free_r>
 200bdc0:	8080030b 	ldhu	r2,12(r16)
 200bdc4:	00ffdfc4 	movi	r3,-129
 200bdc8:	1884703a 	and	r2,r3,r2
 200bdcc:	00c00304 	movi	r3,12
 200bdd0:	a8c00015 	stw	r3,0(r21)
 200bdd4:	003f5906 	br	200bb3c <__reset+0xfe00ab3c>
 200bdd8:	94c00044 	addi	r19,r18,1
 200bddc:	02000044 	movi	r8,1
 200bde0:	003f6006 	br	200bb64 <__reset+0xfe00ab64>
 200bde4:	00bfffc4 	movi	r2,-1
 200bde8:	003f0006 	br	200b9ec <__reset+0xfe00a9ec>
 200bdec:	00800304 	movi	r2,12
 200bdf0:	a8800015 	stw	r2,0(r21)
 200bdf4:	8080030b 	ldhu	r2,12(r16)
 200bdf8:	003f5006 	br	200bb3c <__reset+0xfe00ab3c>

0200bdfc <_fwalk>:
 200bdfc:	defff704 	addi	sp,sp,-36
 200be00:	dd000415 	stw	r20,16(sp)
 200be04:	dfc00815 	stw	ra,32(sp)
 200be08:	ddc00715 	stw	r23,28(sp)
 200be0c:	dd800615 	stw	r22,24(sp)
 200be10:	dd400515 	stw	r21,20(sp)
 200be14:	dcc00315 	stw	r19,12(sp)
 200be18:	dc800215 	stw	r18,8(sp)
 200be1c:	dc400115 	stw	r17,4(sp)
 200be20:	dc000015 	stw	r16,0(sp)
 200be24:	2500b804 	addi	r20,r4,736
 200be28:	a0002326 	beq	r20,zero,200beb8 <_fwalk+0xbc>
 200be2c:	282b883a 	mov	r21,r5
 200be30:	002f883a 	mov	r23,zero
 200be34:	05800044 	movi	r22,1
 200be38:	04ffffc4 	movi	r19,-1
 200be3c:	a4400117 	ldw	r17,4(r20)
 200be40:	a4800217 	ldw	r18,8(r20)
 200be44:	8c7fffc4 	addi	r17,r17,-1
 200be48:	88000d16 	blt	r17,zero,200be80 <_fwalk+0x84>
 200be4c:	94000304 	addi	r16,r18,12
 200be50:	94800384 	addi	r18,r18,14
 200be54:	8080000b 	ldhu	r2,0(r16)
 200be58:	8c7fffc4 	addi	r17,r17,-1
 200be5c:	813ffd04 	addi	r4,r16,-12
 200be60:	b080042e 	bgeu	r22,r2,200be74 <_fwalk+0x78>
 200be64:	9080000f 	ldh	r2,0(r18)
 200be68:	14c00226 	beq	r2,r19,200be74 <_fwalk+0x78>
 200be6c:	a83ee83a 	callr	r21
 200be70:	b8aeb03a 	or	r23,r23,r2
 200be74:	84001a04 	addi	r16,r16,104
 200be78:	94801a04 	addi	r18,r18,104
 200be7c:	8cfff51e 	bne	r17,r19,200be54 <__reset+0xfe00ae54>
 200be80:	a5000017 	ldw	r20,0(r20)
 200be84:	a03fed1e 	bne	r20,zero,200be3c <__reset+0xfe00ae3c>
 200be88:	b805883a 	mov	r2,r23
 200be8c:	dfc00817 	ldw	ra,32(sp)
 200be90:	ddc00717 	ldw	r23,28(sp)
 200be94:	dd800617 	ldw	r22,24(sp)
 200be98:	dd400517 	ldw	r21,20(sp)
 200be9c:	dd000417 	ldw	r20,16(sp)
 200bea0:	dcc00317 	ldw	r19,12(sp)
 200bea4:	dc800217 	ldw	r18,8(sp)
 200bea8:	dc400117 	ldw	r17,4(sp)
 200beac:	dc000017 	ldw	r16,0(sp)
 200beb0:	dec00904 	addi	sp,sp,36
 200beb4:	f800283a 	ret
 200beb8:	002f883a 	mov	r23,zero
 200bebc:	003ff206 	br	200be88 <__reset+0xfe00ae88>

0200bec0 <_fwalk_reent>:
 200bec0:	defff704 	addi	sp,sp,-36
 200bec4:	dd000415 	stw	r20,16(sp)
 200bec8:	dfc00815 	stw	ra,32(sp)
 200becc:	ddc00715 	stw	r23,28(sp)
 200bed0:	dd800615 	stw	r22,24(sp)
 200bed4:	dd400515 	stw	r21,20(sp)
 200bed8:	dcc00315 	stw	r19,12(sp)
 200bedc:	dc800215 	stw	r18,8(sp)
 200bee0:	dc400115 	stw	r17,4(sp)
 200bee4:	dc000015 	stw	r16,0(sp)
 200bee8:	2500b804 	addi	r20,r4,736
 200beec:	a0002326 	beq	r20,zero,200bf7c <_fwalk_reent+0xbc>
 200bef0:	282b883a 	mov	r21,r5
 200bef4:	2027883a 	mov	r19,r4
 200bef8:	002f883a 	mov	r23,zero
 200befc:	05800044 	movi	r22,1
 200bf00:	04bfffc4 	movi	r18,-1
 200bf04:	a4400117 	ldw	r17,4(r20)
 200bf08:	a4000217 	ldw	r16,8(r20)
 200bf0c:	8c7fffc4 	addi	r17,r17,-1
 200bf10:	88000c16 	blt	r17,zero,200bf44 <_fwalk_reent+0x84>
 200bf14:	84000304 	addi	r16,r16,12
 200bf18:	8080000b 	ldhu	r2,0(r16)
 200bf1c:	8c7fffc4 	addi	r17,r17,-1
 200bf20:	817ffd04 	addi	r5,r16,-12
 200bf24:	b080052e 	bgeu	r22,r2,200bf3c <_fwalk_reent+0x7c>
 200bf28:	8080008f 	ldh	r2,2(r16)
 200bf2c:	9809883a 	mov	r4,r19
 200bf30:	14800226 	beq	r2,r18,200bf3c <_fwalk_reent+0x7c>
 200bf34:	a83ee83a 	callr	r21
 200bf38:	b8aeb03a 	or	r23,r23,r2
 200bf3c:	84001a04 	addi	r16,r16,104
 200bf40:	8cbff51e 	bne	r17,r18,200bf18 <__reset+0xfe00af18>
 200bf44:	a5000017 	ldw	r20,0(r20)
 200bf48:	a03fee1e 	bne	r20,zero,200bf04 <__reset+0xfe00af04>
 200bf4c:	b805883a 	mov	r2,r23
 200bf50:	dfc00817 	ldw	ra,32(sp)
 200bf54:	ddc00717 	ldw	r23,28(sp)
 200bf58:	dd800617 	ldw	r22,24(sp)
 200bf5c:	dd400517 	ldw	r21,20(sp)
 200bf60:	dd000417 	ldw	r20,16(sp)
 200bf64:	dcc00317 	ldw	r19,12(sp)
 200bf68:	dc800217 	ldw	r18,8(sp)
 200bf6c:	dc400117 	ldw	r17,4(sp)
 200bf70:	dc000017 	ldw	r16,0(sp)
 200bf74:	dec00904 	addi	sp,sp,36
 200bf78:	f800283a 	ret
 200bf7c:	002f883a 	mov	r23,zero
 200bf80:	003ff206 	br	200bf4c <__reset+0xfe00af4c>

0200bf84 <_malloc_r>:
 200bf84:	defff504 	addi	sp,sp,-44
 200bf88:	dc800315 	stw	r18,12(sp)
 200bf8c:	dfc00a15 	stw	ra,40(sp)
 200bf90:	df000915 	stw	fp,36(sp)
 200bf94:	ddc00815 	stw	r23,32(sp)
 200bf98:	dd800715 	stw	r22,28(sp)
 200bf9c:	dd400615 	stw	r21,24(sp)
 200bfa0:	dd000515 	stw	r20,20(sp)
 200bfa4:	dcc00415 	stw	r19,16(sp)
 200bfa8:	dc400215 	stw	r17,8(sp)
 200bfac:	dc000115 	stw	r16,4(sp)
 200bfb0:	288002c4 	addi	r2,r5,11
 200bfb4:	00c00584 	movi	r3,22
 200bfb8:	2025883a 	mov	r18,r4
 200bfbc:	18807f2e 	bgeu	r3,r2,200c1bc <_malloc_r+0x238>
 200bfc0:	047ffe04 	movi	r17,-8
 200bfc4:	1462703a 	and	r17,r2,r17
 200bfc8:	8800a316 	blt	r17,zero,200c258 <_malloc_r+0x2d4>
 200bfcc:	8940a236 	bltu	r17,r5,200c258 <_malloc_r+0x2d4>
 200bfd0:	200e4380 	call	200e438 <__malloc_lock>
 200bfd4:	00807dc4 	movi	r2,503
 200bfd8:	1441e92e 	bgeu	r2,r17,200c780 <_malloc_r+0x7fc>
 200bfdc:	8804d27a 	srli	r2,r17,9
 200bfe0:	1000a126 	beq	r2,zero,200c268 <_malloc_r+0x2e4>
 200bfe4:	00c00104 	movi	r3,4
 200bfe8:	18811e36 	bltu	r3,r2,200c464 <_malloc_r+0x4e0>
 200bfec:	8804d1ba 	srli	r2,r17,6
 200bff0:	12000e44 	addi	r8,r2,57
 200bff4:	11c00e04 	addi	r7,r2,56
 200bff8:	4209883a 	add	r4,r8,r8
 200bffc:	04c08074 	movhi	r19,513
 200c000:	2109883a 	add	r4,r4,r4
 200c004:	9cca4c04 	addi	r19,r19,10544
 200c008:	2109883a 	add	r4,r4,r4
 200c00c:	9909883a 	add	r4,r19,r4
 200c010:	24000117 	ldw	r16,4(r4)
 200c014:	213ffe04 	addi	r4,r4,-8
 200c018:	24009726 	beq	r4,r16,200c278 <_malloc_r+0x2f4>
 200c01c:	80800117 	ldw	r2,4(r16)
 200c020:	01bfff04 	movi	r6,-4
 200c024:	014003c4 	movi	r5,15
 200c028:	1184703a 	and	r2,r2,r6
 200c02c:	1447c83a 	sub	r3,r2,r17
 200c030:	28c00716 	blt	r5,r3,200c050 <_malloc_r+0xcc>
 200c034:	1800920e 	bge	r3,zero,200c280 <_malloc_r+0x2fc>
 200c038:	84000317 	ldw	r16,12(r16)
 200c03c:	24008e26 	beq	r4,r16,200c278 <_malloc_r+0x2f4>
 200c040:	80800117 	ldw	r2,4(r16)
 200c044:	1184703a 	and	r2,r2,r6
 200c048:	1447c83a 	sub	r3,r2,r17
 200c04c:	28fff90e 	bge	r5,r3,200c034 <__reset+0xfe00b034>
 200c050:	3809883a 	mov	r4,r7
 200c054:	01808074 	movhi	r6,513
 200c058:	9c000417 	ldw	r16,16(r19)
 200c05c:	318a4c04 	addi	r6,r6,10544
 200c060:	32000204 	addi	r8,r6,8
 200c064:	82013426 	beq	r16,r8,200c538 <_malloc_r+0x5b4>
 200c068:	80c00117 	ldw	r3,4(r16)
 200c06c:	00bfff04 	movi	r2,-4
 200c070:	188e703a 	and	r7,r3,r2
 200c074:	3c45c83a 	sub	r2,r7,r17
 200c078:	00c003c4 	movi	r3,15
 200c07c:	18811f16 	blt	r3,r2,200c4fc <_malloc_r+0x578>
 200c080:	32000515 	stw	r8,20(r6)
 200c084:	32000415 	stw	r8,16(r6)
 200c088:	10007f0e 	bge	r2,zero,200c288 <_malloc_r+0x304>
 200c08c:	00807fc4 	movi	r2,511
 200c090:	11c0fd36 	bltu	r2,r7,200c488 <_malloc_r+0x504>
 200c094:	3806d0fa 	srli	r3,r7,3
 200c098:	01c00044 	movi	r7,1
 200c09c:	30800117 	ldw	r2,4(r6)
 200c0a0:	19400044 	addi	r5,r3,1
 200c0a4:	294b883a 	add	r5,r5,r5
 200c0a8:	1807d0ba 	srai	r3,r3,2
 200c0ac:	294b883a 	add	r5,r5,r5
 200c0b0:	294b883a 	add	r5,r5,r5
 200c0b4:	298b883a 	add	r5,r5,r6
 200c0b8:	38c6983a 	sll	r3,r7,r3
 200c0bc:	29c00017 	ldw	r7,0(r5)
 200c0c0:	2a7ffe04 	addi	r9,r5,-8
 200c0c4:	1886b03a 	or	r3,r3,r2
 200c0c8:	82400315 	stw	r9,12(r16)
 200c0cc:	81c00215 	stw	r7,8(r16)
 200c0d0:	30c00115 	stw	r3,4(r6)
 200c0d4:	2c000015 	stw	r16,0(r5)
 200c0d8:	3c000315 	stw	r16,12(r7)
 200c0dc:	2005d0ba 	srai	r2,r4,2
 200c0e0:	01400044 	movi	r5,1
 200c0e4:	288a983a 	sll	r5,r5,r2
 200c0e8:	19406f36 	bltu	r3,r5,200c2a8 <_malloc_r+0x324>
 200c0ec:	28c4703a 	and	r2,r5,r3
 200c0f0:	10000a1e 	bne	r2,zero,200c11c <_malloc_r+0x198>
 200c0f4:	00bfff04 	movi	r2,-4
 200c0f8:	294b883a 	add	r5,r5,r5
 200c0fc:	2088703a 	and	r4,r4,r2
 200c100:	28c4703a 	and	r2,r5,r3
 200c104:	21000104 	addi	r4,r4,4
 200c108:	1000041e 	bne	r2,zero,200c11c <_malloc_r+0x198>
 200c10c:	294b883a 	add	r5,r5,r5
 200c110:	28c4703a 	and	r2,r5,r3
 200c114:	21000104 	addi	r4,r4,4
 200c118:	103ffc26 	beq	r2,zero,200c10c <__reset+0xfe00b10c>
 200c11c:	02bfff04 	movi	r10,-4
 200c120:	024003c4 	movi	r9,15
 200c124:	21800044 	addi	r6,r4,1
 200c128:	318d883a 	add	r6,r6,r6
 200c12c:	318d883a 	add	r6,r6,r6
 200c130:	318d883a 	add	r6,r6,r6
 200c134:	998d883a 	add	r6,r19,r6
 200c138:	333ffe04 	addi	r12,r6,-8
 200c13c:	2017883a 	mov	r11,r4
 200c140:	31800104 	addi	r6,r6,4
 200c144:	34000017 	ldw	r16,0(r6)
 200c148:	31fffd04 	addi	r7,r6,-12
 200c14c:	81c0041e 	bne	r16,r7,200c160 <_malloc_r+0x1dc>
 200c150:	0000fb06 	br	200c540 <_malloc_r+0x5bc>
 200c154:	1801030e 	bge	r3,zero,200c564 <_malloc_r+0x5e0>
 200c158:	84000317 	ldw	r16,12(r16)
 200c15c:	81c0f826 	beq	r16,r7,200c540 <_malloc_r+0x5bc>
 200c160:	80800117 	ldw	r2,4(r16)
 200c164:	1284703a 	and	r2,r2,r10
 200c168:	1447c83a 	sub	r3,r2,r17
 200c16c:	48fff90e 	bge	r9,r3,200c154 <__reset+0xfe00b154>
 200c170:	80800317 	ldw	r2,12(r16)
 200c174:	81000217 	ldw	r4,8(r16)
 200c178:	89400054 	ori	r5,r17,1
 200c17c:	81400115 	stw	r5,4(r16)
 200c180:	20800315 	stw	r2,12(r4)
 200c184:	11000215 	stw	r4,8(r2)
 200c188:	8463883a 	add	r17,r16,r17
 200c18c:	9c400515 	stw	r17,20(r19)
 200c190:	9c400415 	stw	r17,16(r19)
 200c194:	18800054 	ori	r2,r3,1
 200c198:	88800115 	stw	r2,4(r17)
 200c19c:	8a000315 	stw	r8,12(r17)
 200c1a0:	8a000215 	stw	r8,8(r17)
 200c1a4:	88e3883a 	add	r17,r17,r3
 200c1a8:	88c00015 	stw	r3,0(r17)
 200c1ac:	9009883a 	mov	r4,r18
 200c1b0:	200e45c0 	call	200e45c <__malloc_unlock>
 200c1b4:	80800204 	addi	r2,r16,8
 200c1b8:	00001b06 	br	200c228 <_malloc_r+0x2a4>
 200c1bc:	04400404 	movi	r17,16
 200c1c0:	89402536 	bltu	r17,r5,200c258 <_malloc_r+0x2d4>
 200c1c4:	200e4380 	call	200e438 <__malloc_lock>
 200c1c8:	00800184 	movi	r2,6
 200c1cc:	01000084 	movi	r4,2
 200c1d0:	04c08074 	movhi	r19,513
 200c1d4:	1085883a 	add	r2,r2,r2
 200c1d8:	9cca4c04 	addi	r19,r19,10544
 200c1dc:	1085883a 	add	r2,r2,r2
 200c1e0:	9885883a 	add	r2,r19,r2
 200c1e4:	14000117 	ldw	r16,4(r2)
 200c1e8:	10fffe04 	addi	r3,r2,-8
 200c1ec:	80c0d926 	beq	r16,r3,200c554 <_malloc_r+0x5d0>
 200c1f0:	80c00117 	ldw	r3,4(r16)
 200c1f4:	81000317 	ldw	r4,12(r16)
 200c1f8:	00bfff04 	movi	r2,-4
 200c1fc:	1884703a 	and	r2,r3,r2
 200c200:	81400217 	ldw	r5,8(r16)
 200c204:	8085883a 	add	r2,r16,r2
 200c208:	10c00117 	ldw	r3,4(r2)
 200c20c:	29000315 	stw	r4,12(r5)
 200c210:	21400215 	stw	r5,8(r4)
 200c214:	18c00054 	ori	r3,r3,1
 200c218:	10c00115 	stw	r3,4(r2)
 200c21c:	9009883a 	mov	r4,r18
 200c220:	200e45c0 	call	200e45c <__malloc_unlock>
 200c224:	80800204 	addi	r2,r16,8
 200c228:	dfc00a17 	ldw	ra,40(sp)
 200c22c:	df000917 	ldw	fp,36(sp)
 200c230:	ddc00817 	ldw	r23,32(sp)
 200c234:	dd800717 	ldw	r22,28(sp)
 200c238:	dd400617 	ldw	r21,24(sp)
 200c23c:	dd000517 	ldw	r20,20(sp)
 200c240:	dcc00417 	ldw	r19,16(sp)
 200c244:	dc800317 	ldw	r18,12(sp)
 200c248:	dc400217 	ldw	r17,8(sp)
 200c24c:	dc000117 	ldw	r16,4(sp)
 200c250:	dec00b04 	addi	sp,sp,44
 200c254:	f800283a 	ret
 200c258:	00800304 	movi	r2,12
 200c25c:	90800015 	stw	r2,0(r18)
 200c260:	0005883a 	mov	r2,zero
 200c264:	003ff006 	br	200c228 <__reset+0xfe00b228>
 200c268:	01002004 	movi	r4,128
 200c26c:	02001004 	movi	r8,64
 200c270:	01c00fc4 	movi	r7,63
 200c274:	003f6106 	br	200bffc <__reset+0xfe00affc>
 200c278:	4009883a 	mov	r4,r8
 200c27c:	003f7506 	br	200c054 <__reset+0xfe00b054>
 200c280:	81000317 	ldw	r4,12(r16)
 200c284:	003fde06 	br	200c200 <__reset+0xfe00b200>
 200c288:	81c5883a 	add	r2,r16,r7
 200c28c:	11400117 	ldw	r5,4(r2)
 200c290:	9009883a 	mov	r4,r18
 200c294:	29400054 	ori	r5,r5,1
 200c298:	11400115 	stw	r5,4(r2)
 200c29c:	200e45c0 	call	200e45c <__malloc_unlock>
 200c2a0:	80800204 	addi	r2,r16,8
 200c2a4:	003fe006 	br	200c228 <__reset+0xfe00b228>
 200c2a8:	9c000217 	ldw	r16,8(r19)
 200c2ac:	00bfff04 	movi	r2,-4
 200c2b0:	85800117 	ldw	r22,4(r16)
 200c2b4:	b0ac703a 	and	r22,r22,r2
 200c2b8:	b4400336 	bltu	r22,r17,200c2c8 <_malloc_r+0x344>
 200c2bc:	b445c83a 	sub	r2,r22,r17
 200c2c0:	00c003c4 	movi	r3,15
 200c2c4:	18805d16 	blt	r3,r2,200c43c <_malloc_r+0x4b8>
 200c2c8:	05c08074 	movhi	r23,513
 200c2cc:	00808074 	movhi	r2,513
 200c2d0:	10913304 	addi	r2,r2,17612
 200c2d4:	bdd0ba04 	addi	r23,r23,17128
 200c2d8:	15400017 	ldw	r21,0(r2)
 200c2dc:	b8c00017 	ldw	r3,0(r23)
 200c2e0:	00bfffc4 	movi	r2,-1
 200c2e4:	858d883a 	add	r6,r16,r22
 200c2e8:	8d6b883a 	add	r21,r17,r21
 200c2ec:	1880ea26 	beq	r3,r2,200c698 <_malloc_r+0x714>
 200c2f0:	ad4403c4 	addi	r21,r21,4111
 200c2f4:	00bc0004 	movi	r2,-4096
 200c2f8:	a8aa703a 	and	r21,r21,r2
 200c2fc:	a80b883a 	mov	r5,r21
 200c300:	9009883a 	mov	r4,r18
 200c304:	d9800015 	stw	r6,0(sp)
 200c308:	200cf340 	call	200cf34 <_sbrk_r>
 200c30c:	1029883a 	mov	r20,r2
 200c310:	00bfffc4 	movi	r2,-1
 200c314:	d9800017 	ldw	r6,0(sp)
 200c318:	a080e826 	beq	r20,r2,200c6bc <_malloc_r+0x738>
 200c31c:	a180a636 	bltu	r20,r6,200c5b8 <_malloc_r+0x634>
 200c320:	0700a074 	movhi	fp,641
 200c324:	e7117504 	addi	fp,fp,17876
 200c328:	e0800017 	ldw	r2,0(fp)
 200c32c:	a887883a 	add	r3,r21,r2
 200c330:	e0c00015 	stw	r3,0(fp)
 200c334:	3500e626 	beq	r6,r20,200c6d0 <_malloc_r+0x74c>
 200c338:	b9000017 	ldw	r4,0(r23)
 200c33c:	00bfffc4 	movi	r2,-1
 200c340:	2080ee26 	beq	r4,r2,200c6fc <_malloc_r+0x778>
 200c344:	a185c83a 	sub	r2,r20,r6
 200c348:	10c5883a 	add	r2,r2,r3
 200c34c:	e0800015 	stw	r2,0(fp)
 200c350:	a0c001cc 	andi	r3,r20,7
 200c354:	1800bc26 	beq	r3,zero,200c648 <_malloc_r+0x6c4>
 200c358:	a0e9c83a 	sub	r20,r20,r3
 200c35c:	00840204 	movi	r2,4104
 200c360:	a5000204 	addi	r20,r20,8
 200c364:	10c7c83a 	sub	r3,r2,r3
 200c368:	a545883a 	add	r2,r20,r21
 200c36c:	1083ffcc 	andi	r2,r2,4095
 200c370:	18abc83a 	sub	r21,r3,r2
 200c374:	a80b883a 	mov	r5,r21
 200c378:	9009883a 	mov	r4,r18
 200c37c:	200cf340 	call	200cf34 <_sbrk_r>
 200c380:	00ffffc4 	movi	r3,-1
 200c384:	10c0e126 	beq	r2,r3,200c70c <_malloc_r+0x788>
 200c388:	1505c83a 	sub	r2,r2,r20
 200c38c:	1545883a 	add	r2,r2,r21
 200c390:	10800054 	ori	r2,r2,1
 200c394:	e0c00017 	ldw	r3,0(fp)
 200c398:	9d000215 	stw	r20,8(r19)
 200c39c:	a0800115 	stw	r2,4(r20)
 200c3a0:	a8c7883a 	add	r3,r21,r3
 200c3a4:	e0c00015 	stw	r3,0(fp)
 200c3a8:	84c00e26 	beq	r16,r19,200c3e4 <_malloc_r+0x460>
 200c3ac:	018003c4 	movi	r6,15
 200c3b0:	3580a72e 	bgeu	r6,r22,200c650 <_malloc_r+0x6cc>
 200c3b4:	81400117 	ldw	r5,4(r16)
 200c3b8:	013ffe04 	movi	r4,-8
 200c3bc:	b0bffd04 	addi	r2,r22,-12
 200c3c0:	1104703a 	and	r2,r2,r4
 200c3c4:	2900004c 	andi	r4,r5,1
 200c3c8:	2088b03a 	or	r4,r4,r2
 200c3cc:	81000115 	stw	r4,4(r16)
 200c3d0:	01400144 	movi	r5,5
 200c3d4:	8089883a 	add	r4,r16,r2
 200c3d8:	21400115 	stw	r5,4(r4)
 200c3dc:	21400215 	stw	r5,8(r4)
 200c3e0:	3080cd36 	bltu	r6,r2,200c718 <_malloc_r+0x794>
 200c3e4:	00808074 	movhi	r2,513
 200c3e8:	10913204 	addi	r2,r2,17608
 200c3ec:	11000017 	ldw	r4,0(r2)
 200c3f0:	20c0012e 	bgeu	r4,r3,200c3f8 <_malloc_r+0x474>
 200c3f4:	10c00015 	stw	r3,0(r2)
 200c3f8:	00808074 	movhi	r2,513
 200c3fc:	10913104 	addi	r2,r2,17604
 200c400:	11000017 	ldw	r4,0(r2)
 200c404:	9c000217 	ldw	r16,8(r19)
 200c408:	20c0012e 	bgeu	r4,r3,200c410 <_malloc_r+0x48c>
 200c40c:	10c00015 	stw	r3,0(r2)
 200c410:	80c00117 	ldw	r3,4(r16)
 200c414:	00bfff04 	movi	r2,-4
 200c418:	1886703a 	and	r3,r3,r2
 200c41c:	1c45c83a 	sub	r2,r3,r17
 200c420:	1c400236 	bltu	r3,r17,200c42c <_malloc_r+0x4a8>
 200c424:	00c003c4 	movi	r3,15
 200c428:	18800416 	blt	r3,r2,200c43c <_malloc_r+0x4b8>
 200c42c:	9009883a 	mov	r4,r18
 200c430:	200e45c0 	call	200e45c <__malloc_unlock>
 200c434:	0005883a 	mov	r2,zero
 200c438:	003f7b06 	br	200c228 <__reset+0xfe00b228>
 200c43c:	88c00054 	ori	r3,r17,1
 200c440:	80c00115 	stw	r3,4(r16)
 200c444:	8463883a 	add	r17,r16,r17
 200c448:	10800054 	ori	r2,r2,1
 200c44c:	9c400215 	stw	r17,8(r19)
 200c450:	88800115 	stw	r2,4(r17)
 200c454:	9009883a 	mov	r4,r18
 200c458:	200e45c0 	call	200e45c <__malloc_unlock>
 200c45c:	80800204 	addi	r2,r16,8
 200c460:	003f7106 	br	200c228 <__reset+0xfe00b228>
 200c464:	00c00504 	movi	r3,20
 200c468:	18804a2e 	bgeu	r3,r2,200c594 <_malloc_r+0x610>
 200c46c:	00c01504 	movi	r3,84
 200c470:	18806e36 	bltu	r3,r2,200c62c <_malloc_r+0x6a8>
 200c474:	8804d33a 	srli	r2,r17,12
 200c478:	12001bc4 	addi	r8,r2,111
 200c47c:	11c01b84 	addi	r7,r2,110
 200c480:	4209883a 	add	r4,r8,r8
 200c484:	003edd06 	br	200bffc <__reset+0xfe00affc>
 200c488:	3804d27a 	srli	r2,r7,9
 200c48c:	00c00104 	movi	r3,4
 200c490:	1880442e 	bgeu	r3,r2,200c5a4 <_malloc_r+0x620>
 200c494:	00c00504 	movi	r3,20
 200c498:	18808136 	bltu	r3,r2,200c6a0 <_malloc_r+0x71c>
 200c49c:	11401704 	addi	r5,r2,92
 200c4a0:	10c016c4 	addi	r3,r2,91
 200c4a4:	294b883a 	add	r5,r5,r5
 200c4a8:	294b883a 	add	r5,r5,r5
 200c4ac:	294b883a 	add	r5,r5,r5
 200c4b0:	994b883a 	add	r5,r19,r5
 200c4b4:	28800017 	ldw	r2,0(r5)
 200c4b8:	01808074 	movhi	r6,513
 200c4bc:	297ffe04 	addi	r5,r5,-8
 200c4c0:	318a4c04 	addi	r6,r6,10544
 200c4c4:	28806526 	beq	r5,r2,200c65c <_malloc_r+0x6d8>
 200c4c8:	01bfff04 	movi	r6,-4
 200c4cc:	10c00117 	ldw	r3,4(r2)
 200c4d0:	1986703a 	and	r3,r3,r6
 200c4d4:	38c0022e 	bgeu	r7,r3,200c4e0 <_malloc_r+0x55c>
 200c4d8:	10800217 	ldw	r2,8(r2)
 200c4dc:	28bffb1e 	bne	r5,r2,200c4cc <__reset+0xfe00b4cc>
 200c4e0:	11400317 	ldw	r5,12(r2)
 200c4e4:	98c00117 	ldw	r3,4(r19)
 200c4e8:	81400315 	stw	r5,12(r16)
 200c4ec:	80800215 	stw	r2,8(r16)
 200c4f0:	2c000215 	stw	r16,8(r5)
 200c4f4:	14000315 	stw	r16,12(r2)
 200c4f8:	003ef806 	br	200c0dc <__reset+0xfe00b0dc>
 200c4fc:	88c00054 	ori	r3,r17,1
 200c500:	80c00115 	stw	r3,4(r16)
 200c504:	8463883a 	add	r17,r16,r17
 200c508:	34400515 	stw	r17,20(r6)
 200c50c:	34400415 	stw	r17,16(r6)
 200c510:	10c00054 	ori	r3,r2,1
 200c514:	8a000315 	stw	r8,12(r17)
 200c518:	8a000215 	stw	r8,8(r17)
 200c51c:	88c00115 	stw	r3,4(r17)
 200c520:	88a3883a 	add	r17,r17,r2
 200c524:	88800015 	stw	r2,0(r17)
 200c528:	9009883a 	mov	r4,r18
 200c52c:	200e45c0 	call	200e45c <__malloc_unlock>
 200c530:	80800204 	addi	r2,r16,8
 200c534:	003f3c06 	br	200c228 <__reset+0xfe00b228>
 200c538:	30c00117 	ldw	r3,4(r6)
 200c53c:	003ee706 	br	200c0dc <__reset+0xfe00b0dc>
 200c540:	5ac00044 	addi	r11,r11,1
 200c544:	588000cc 	andi	r2,r11,3
 200c548:	31800204 	addi	r6,r6,8
 200c54c:	103efd1e 	bne	r2,zero,200c144 <__reset+0xfe00b144>
 200c550:	00002406 	br	200c5e4 <_malloc_r+0x660>
 200c554:	14000317 	ldw	r16,12(r2)
 200c558:	143f251e 	bne	r2,r16,200c1f0 <__reset+0xfe00b1f0>
 200c55c:	21000084 	addi	r4,r4,2
 200c560:	003ebc06 	br	200c054 <__reset+0xfe00b054>
 200c564:	8085883a 	add	r2,r16,r2
 200c568:	10c00117 	ldw	r3,4(r2)
 200c56c:	81000317 	ldw	r4,12(r16)
 200c570:	81400217 	ldw	r5,8(r16)
 200c574:	18c00054 	ori	r3,r3,1
 200c578:	10c00115 	stw	r3,4(r2)
 200c57c:	29000315 	stw	r4,12(r5)
 200c580:	21400215 	stw	r5,8(r4)
 200c584:	9009883a 	mov	r4,r18
 200c588:	200e45c0 	call	200e45c <__malloc_unlock>
 200c58c:	80800204 	addi	r2,r16,8
 200c590:	003f2506 	br	200c228 <__reset+0xfe00b228>
 200c594:	12001704 	addi	r8,r2,92
 200c598:	11c016c4 	addi	r7,r2,91
 200c59c:	4209883a 	add	r4,r8,r8
 200c5a0:	003e9606 	br	200bffc <__reset+0xfe00affc>
 200c5a4:	3804d1ba 	srli	r2,r7,6
 200c5a8:	11400e44 	addi	r5,r2,57
 200c5ac:	10c00e04 	addi	r3,r2,56
 200c5b0:	294b883a 	add	r5,r5,r5
 200c5b4:	003fbc06 	br	200c4a8 <__reset+0xfe00b4a8>
 200c5b8:	84ff5926 	beq	r16,r19,200c320 <__reset+0xfe00b320>
 200c5bc:	00808074 	movhi	r2,513
 200c5c0:	108a4c04 	addi	r2,r2,10544
 200c5c4:	14000217 	ldw	r16,8(r2)
 200c5c8:	00bfff04 	movi	r2,-4
 200c5cc:	80c00117 	ldw	r3,4(r16)
 200c5d0:	1886703a 	and	r3,r3,r2
 200c5d4:	003f9106 	br	200c41c <__reset+0xfe00b41c>
 200c5d8:	60800217 	ldw	r2,8(r12)
 200c5dc:	213fffc4 	addi	r4,r4,-1
 200c5e0:	1300651e 	bne	r2,r12,200c778 <_malloc_r+0x7f4>
 200c5e4:	208000cc 	andi	r2,r4,3
 200c5e8:	633ffe04 	addi	r12,r12,-8
 200c5ec:	103ffa1e 	bne	r2,zero,200c5d8 <__reset+0xfe00b5d8>
 200c5f0:	98800117 	ldw	r2,4(r19)
 200c5f4:	0146303a 	nor	r3,zero,r5
 200c5f8:	1884703a 	and	r2,r3,r2
 200c5fc:	98800115 	stw	r2,4(r19)
 200c600:	294b883a 	add	r5,r5,r5
 200c604:	117f2836 	bltu	r2,r5,200c2a8 <__reset+0xfe00b2a8>
 200c608:	283f2726 	beq	r5,zero,200c2a8 <__reset+0xfe00b2a8>
 200c60c:	2886703a 	and	r3,r5,r2
 200c610:	5809883a 	mov	r4,r11
 200c614:	183ec31e 	bne	r3,zero,200c124 <__reset+0xfe00b124>
 200c618:	294b883a 	add	r5,r5,r5
 200c61c:	2886703a 	and	r3,r5,r2
 200c620:	21000104 	addi	r4,r4,4
 200c624:	183ffc26 	beq	r3,zero,200c618 <__reset+0xfe00b618>
 200c628:	003ebe06 	br	200c124 <__reset+0xfe00b124>
 200c62c:	00c05504 	movi	r3,340
 200c630:	18801236 	bltu	r3,r2,200c67c <_malloc_r+0x6f8>
 200c634:	8804d3fa 	srli	r2,r17,15
 200c638:	12001e04 	addi	r8,r2,120
 200c63c:	11c01dc4 	addi	r7,r2,119
 200c640:	4209883a 	add	r4,r8,r8
 200c644:	003e6d06 	br	200bffc <__reset+0xfe00affc>
 200c648:	00c40004 	movi	r3,4096
 200c64c:	003f4606 	br	200c368 <__reset+0xfe00b368>
 200c650:	00800044 	movi	r2,1
 200c654:	a0800115 	stw	r2,4(r20)
 200c658:	003f7406 	br	200c42c <__reset+0xfe00b42c>
 200c65c:	1805d0ba 	srai	r2,r3,2
 200c660:	01c00044 	movi	r7,1
 200c664:	30c00117 	ldw	r3,4(r6)
 200c668:	388e983a 	sll	r7,r7,r2
 200c66c:	2805883a 	mov	r2,r5
 200c670:	38c6b03a 	or	r3,r7,r3
 200c674:	30c00115 	stw	r3,4(r6)
 200c678:	003f9b06 	br	200c4e8 <__reset+0xfe00b4e8>
 200c67c:	00c15504 	movi	r3,1364
 200c680:	18801a36 	bltu	r3,r2,200c6ec <_malloc_r+0x768>
 200c684:	8804d4ba 	srli	r2,r17,18
 200c688:	12001f44 	addi	r8,r2,125
 200c68c:	11c01f04 	addi	r7,r2,124
 200c690:	4209883a 	add	r4,r8,r8
 200c694:	003e5906 	br	200bffc <__reset+0xfe00affc>
 200c698:	ad400404 	addi	r21,r21,16
 200c69c:	003f1706 	br	200c2fc <__reset+0xfe00b2fc>
 200c6a0:	00c01504 	movi	r3,84
 200c6a4:	18802336 	bltu	r3,r2,200c734 <_malloc_r+0x7b0>
 200c6a8:	3804d33a 	srli	r2,r7,12
 200c6ac:	11401bc4 	addi	r5,r2,111
 200c6b0:	10c01b84 	addi	r3,r2,110
 200c6b4:	294b883a 	add	r5,r5,r5
 200c6b8:	003f7b06 	br	200c4a8 <__reset+0xfe00b4a8>
 200c6bc:	9c000217 	ldw	r16,8(r19)
 200c6c0:	00bfff04 	movi	r2,-4
 200c6c4:	80c00117 	ldw	r3,4(r16)
 200c6c8:	1886703a 	and	r3,r3,r2
 200c6cc:	003f5306 	br	200c41c <__reset+0xfe00b41c>
 200c6d0:	3083ffcc 	andi	r2,r6,4095
 200c6d4:	103f181e 	bne	r2,zero,200c338 <__reset+0xfe00b338>
 200c6d8:	99000217 	ldw	r4,8(r19)
 200c6dc:	b545883a 	add	r2,r22,r21
 200c6e0:	10800054 	ori	r2,r2,1
 200c6e4:	20800115 	stw	r2,4(r4)
 200c6e8:	003f3e06 	br	200c3e4 <__reset+0xfe00b3e4>
 200c6ec:	01003f84 	movi	r4,254
 200c6f0:	02001fc4 	movi	r8,127
 200c6f4:	01c01f84 	movi	r7,126
 200c6f8:	003e4006 	br	200bffc <__reset+0xfe00affc>
 200c6fc:	00808074 	movhi	r2,513
 200c700:	1090ba04 	addi	r2,r2,17128
 200c704:	15000015 	stw	r20,0(r2)
 200c708:	003f1106 	br	200c350 <__reset+0xfe00b350>
 200c70c:	00800044 	movi	r2,1
 200c710:	002b883a 	mov	r21,zero
 200c714:	003f1f06 	br	200c394 <__reset+0xfe00b394>
 200c718:	81400204 	addi	r5,r16,8
 200c71c:	9009883a 	mov	r4,r18
 200c720:	200d79c0 	call	200d79c <_free_r>
 200c724:	0080a074 	movhi	r2,641
 200c728:	10917504 	addi	r2,r2,17876
 200c72c:	10c00017 	ldw	r3,0(r2)
 200c730:	003f2c06 	br	200c3e4 <__reset+0xfe00b3e4>
 200c734:	00c05504 	movi	r3,340
 200c738:	18800536 	bltu	r3,r2,200c750 <_malloc_r+0x7cc>
 200c73c:	3804d3fa 	srli	r2,r7,15
 200c740:	11401e04 	addi	r5,r2,120
 200c744:	10c01dc4 	addi	r3,r2,119
 200c748:	294b883a 	add	r5,r5,r5
 200c74c:	003f5606 	br	200c4a8 <__reset+0xfe00b4a8>
 200c750:	00c15504 	movi	r3,1364
 200c754:	18800536 	bltu	r3,r2,200c76c <_malloc_r+0x7e8>
 200c758:	3804d4ba 	srli	r2,r7,18
 200c75c:	11401f44 	addi	r5,r2,125
 200c760:	10c01f04 	addi	r3,r2,124
 200c764:	294b883a 	add	r5,r5,r5
 200c768:	003f4f06 	br	200c4a8 <__reset+0xfe00b4a8>
 200c76c:	01403f84 	movi	r5,254
 200c770:	00c01f84 	movi	r3,126
 200c774:	003f4c06 	br	200c4a8 <__reset+0xfe00b4a8>
 200c778:	98800117 	ldw	r2,4(r19)
 200c77c:	003fa006 	br	200c600 <__reset+0xfe00b600>
 200c780:	8808d0fa 	srli	r4,r17,3
 200c784:	20800044 	addi	r2,r4,1
 200c788:	1085883a 	add	r2,r2,r2
 200c78c:	003e9006 	br	200c1d0 <__reset+0xfe00b1d0>

0200c790 <memchr>:
 200c790:	208000cc 	andi	r2,r4,3
 200c794:	280f883a 	mov	r7,r5
 200c798:	10003426 	beq	r2,zero,200c86c <memchr+0xdc>
 200c79c:	30bfffc4 	addi	r2,r6,-1
 200c7a0:	30001a26 	beq	r6,zero,200c80c <memchr+0x7c>
 200c7a4:	20c00003 	ldbu	r3,0(r4)
 200c7a8:	29803fcc 	andi	r6,r5,255
 200c7ac:	30c0051e 	bne	r6,r3,200c7c4 <memchr+0x34>
 200c7b0:	00001806 	br	200c814 <memchr+0x84>
 200c7b4:	10001526 	beq	r2,zero,200c80c <memchr+0x7c>
 200c7b8:	20c00003 	ldbu	r3,0(r4)
 200c7bc:	10bfffc4 	addi	r2,r2,-1
 200c7c0:	30c01426 	beq	r6,r3,200c814 <memchr+0x84>
 200c7c4:	21000044 	addi	r4,r4,1
 200c7c8:	20c000cc 	andi	r3,r4,3
 200c7cc:	183ff91e 	bne	r3,zero,200c7b4 <__reset+0xfe00b7b4>
 200c7d0:	020000c4 	movi	r8,3
 200c7d4:	40801136 	bltu	r8,r2,200c81c <memchr+0x8c>
 200c7d8:	10000c26 	beq	r2,zero,200c80c <memchr+0x7c>
 200c7dc:	20c00003 	ldbu	r3,0(r4)
 200c7e0:	29403fcc 	andi	r5,r5,255
 200c7e4:	28c00b26 	beq	r5,r3,200c814 <memchr+0x84>
 200c7e8:	20c00044 	addi	r3,r4,1
 200c7ec:	39803fcc 	andi	r6,r7,255
 200c7f0:	2089883a 	add	r4,r4,r2
 200c7f4:	00000306 	br	200c804 <memchr+0x74>
 200c7f8:	18c00044 	addi	r3,r3,1
 200c7fc:	197fffc3 	ldbu	r5,-1(r3)
 200c800:	31400526 	beq	r6,r5,200c818 <memchr+0x88>
 200c804:	1805883a 	mov	r2,r3
 200c808:	20fffb1e 	bne	r4,r3,200c7f8 <__reset+0xfe00b7f8>
 200c80c:	0005883a 	mov	r2,zero
 200c810:	f800283a 	ret
 200c814:	2005883a 	mov	r2,r4
 200c818:	f800283a 	ret
 200c81c:	28c03fcc 	andi	r3,r5,255
 200c820:	1812923a 	slli	r9,r3,8
 200c824:	02ffbff4 	movhi	r11,65279
 200c828:	02a02074 	movhi	r10,32897
 200c82c:	48d2b03a 	or	r9,r9,r3
 200c830:	4806943a 	slli	r3,r9,16
 200c834:	5affbfc4 	addi	r11,r11,-257
 200c838:	52a02004 	addi	r10,r10,-32640
 200c83c:	48d2b03a 	or	r9,r9,r3
 200c840:	20c00017 	ldw	r3,0(r4)
 200c844:	48c6f03a 	xor	r3,r9,r3
 200c848:	1acd883a 	add	r6,r3,r11
 200c84c:	00c6303a 	nor	r3,zero,r3
 200c850:	30c6703a 	and	r3,r6,r3
 200c854:	1a86703a 	and	r3,r3,r10
 200c858:	183fe01e 	bne	r3,zero,200c7dc <__reset+0xfe00b7dc>
 200c85c:	10bfff04 	addi	r2,r2,-4
 200c860:	21000104 	addi	r4,r4,4
 200c864:	40bff636 	bltu	r8,r2,200c840 <__reset+0xfe00b840>
 200c868:	003fdb06 	br	200c7d8 <__reset+0xfe00b7d8>
 200c86c:	3005883a 	mov	r2,r6
 200c870:	003fd706 	br	200c7d0 <__reset+0xfe00b7d0>

0200c874 <memmove>:
 200c874:	2005883a 	mov	r2,r4
 200c878:	29000b2e 	bgeu	r5,r4,200c8a8 <memmove+0x34>
 200c87c:	298f883a 	add	r7,r5,r6
 200c880:	21c0092e 	bgeu	r4,r7,200c8a8 <memmove+0x34>
 200c884:	2187883a 	add	r3,r4,r6
 200c888:	198bc83a 	sub	r5,r3,r6
 200c88c:	30004826 	beq	r6,zero,200c9b0 <memmove+0x13c>
 200c890:	39ffffc4 	addi	r7,r7,-1
 200c894:	39000003 	ldbu	r4,0(r7)
 200c898:	18ffffc4 	addi	r3,r3,-1
 200c89c:	19000005 	stb	r4,0(r3)
 200c8a0:	28fffb1e 	bne	r5,r3,200c890 <__reset+0xfe00b890>
 200c8a4:	f800283a 	ret
 200c8a8:	00c003c4 	movi	r3,15
 200c8ac:	1980412e 	bgeu	r3,r6,200c9b4 <memmove+0x140>
 200c8b0:	2886b03a 	or	r3,r5,r2
 200c8b4:	18c000cc 	andi	r3,r3,3
 200c8b8:	1800401e 	bne	r3,zero,200c9bc <memmove+0x148>
 200c8bc:	33fffc04 	addi	r15,r6,-16
 200c8c0:	781ed13a 	srli	r15,r15,4
 200c8c4:	28c00104 	addi	r3,r5,4
 200c8c8:	13400104 	addi	r13,r2,4
 200c8cc:	781c913a 	slli	r14,r15,4
 200c8d0:	2b000204 	addi	r12,r5,8
 200c8d4:	12c00204 	addi	r11,r2,8
 200c8d8:	73800504 	addi	r14,r14,20
 200c8dc:	2a800304 	addi	r10,r5,12
 200c8e0:	12400304 	addi	r9,r2,12
 200c8e4:	2b9d883a 	add	r14,r5,r14
 200c8e8:	2811883a 	mov	r8,r5
 200c8ec:	100f883a 	mov	r7,r2
 200c8f0:	41000017 	ldw	r4,0(r8)
 200c8f4:	39c00404 	addi	r7,r7,16
 200c8f8:	18c00404 	addi	r3,r3,16
 200c8fc:	393ffc15 	stw	r4,-16(r7)
 200c900:	193ffc17 	ldw	r4,-16(r3)
 200c904:	6b400404 	addi	r13,r13,16
 200c908:	5ac00404 	addi	r11,r11,16
 200c90c:	693ffc15 	stw	r4,-16(r13)
 200c910:	61000017 	ldw	r4,0(r12)
 200c914:	4a400404 	addi	r9,r9,16
 200c918:	42000404 	addi	r8,r8,16
 200c91c:	593ffc15 	stw	r4,-16(r11)
 200c920:	51000017 	ldw	r4,0(r10)
 200c924:	63000404 	addi	r12,r12,16
 200c928:	52800404 	addi	r10,r10,16
 200c92c:	493ffc15 	stw	r4,-16(r9)
 200c930:	1bbfef1e 	bne	r3,r14,200c8f0 <__reset+0xfe00b8f0>
 200c934:	79000044 	addi	r4,r15,1
 200c938:	2008913a 	slli	r4,r4,4
 200c93c:	328003cc 	andi	r10,r6,15
 200c940:	02c000c4 	movi	r11,3
 200c944:	1107883a 	add	r3,r2,r4
 200c948:	290b883a 	add	r5,r5,r4
 200c94c:	5a801e2e 	bgeu	r11,r10,200c9c8 <memmove+0x154>
 200c950:	1813883a 	mov	r9,r3
 200c954:	2811883a 	mov	r8,r5
 200c958:	500f883a 	mov	r7,r10
 200c95c:	41000017 	ldw	r4,0(r8)
 200c960:	4a400104 	addi	r9,r9,4
 200c964:	39ffff04 	addi	r7,r7,-4
 200c968:	493fff15 	stw	r4,-4(r9)
 200c96c:	42000104 	addi	r8,r8,4
 200c970:	59fffa36 	bltu	r11,r7,200c95c <__reset+0xfe00b95c>
 200c974:	513fff04 	addi	r4,r10,-4
 200c978:	2008d0ba 	srli	r4,r4,2
 200c97c:	318000cc 	andi	r6,r6,3
 200c980:	21000044 	addi	r4,r4,1
 200c984:	2109883a 	add	r4,r4,r4
 200c988:	2109883a 	add	r4,r4,r4
 200c98c:	1907883a 	add	r3,r3,r4
 200c990:	290b883a 	add	r5,r5,r4
 200c994:	30000b26 	beq	r6,zero,200c9c4 <memmove+0x150>
 200c998:	198d883a 	add	r6,r3,r6
 200c99c:	29c00003 	ldbu	r7,0(r5)
 200c9a0:	18c00044 	addi	r3,r3,1
 200c9a4:	29400044 	addi	r5,r5,1
 200c9a8:	19ffffc5 	stb	r7,-1(r3)
 200c9ac:	19bffb1e 	bne	r3,r6,200c99c <__reset+0xfe00b99c>
 200c9b0:	f800283a 	ret
 200c9b4:	1007883a 	mov	r3,r2
 200c9b8:	003ff606 	br	200c994 <__reset+0xfe00b994>
 200c9bc:	1007883a 	mov	r3,r2
 200c9c0:	003ff506 	br	200c998 <__reset+0xfe00b998>
 200c9c4:	f800283a 	ret
 200c9c8:	500d883a 	mov	r6,r10
 200c9cc:	003ff106 	br	200c994 <__reset+0xfe00b994>

0200c9d0 <_realloc_r>:
 200c9d0:	defff604 	addi	sp,sp,-40
 200c9d4:	dc800215 	stw	r18,8(sp)
 200c9d8:	dfc00915 	stw	ra,36(sp)
 200c9dc:	df000815 	stw	fp,32(sp)
 200c9e0:	ddc00715 	stw	r23,28(sp)
 200c9e4:	dd800615 	stw	r22,24(sp)
 200c9e8:	dd400515 	stw	r21,20(sp)
 200c9ec:	dd000415 	stw	r20,16(sp)
 200c9f0:	dcc00315 	stw	r19,12(sp)
 200c9f4:	dc400115 	stw	r17,4(sp)
 200c9f8:	dc000015 	stw	r16,0(sp)
 200c9fc:	3025883a 	mov	r18,r6
 200ca00:	2800b726 	beq	r5,zero,200cce0 <_realloc_r+0x310>
 200ca04:	282b883a 	mov	r21,r5
 200ca08:	2029883a 	mov	r20,r4
 200ca0c:	200e4380 	call	200e438 <__malloc_lock>
 200ca10:	a8bfff17 	ldw	r2,-4(r21)
 200ca14:	043fff04 	movi	r16,-4
 200ca18:	90c002c4 	addi	r3,r18,11
 200ca1c:	01000584 	movi	r4,22
 200ca20:	acfffe04 	addi	r19,r21,-8
 200ca24:	1420703a 	and	r16,r2,r16
 200ca28:	20c0332e 	bgeu	r4,r3,200caf8 <_realloc_r+0x128>
 200ca2c:	047ffe04 	movi	r17,-8
 200ca30:	1c62703a 	and	r17,r3,r17
 200ca34:	8807883a 	mov	r3,r17
 200ca38:	88005816 	blt	r17,zero,200cb9c <_realloc_r+0x1cc>
 200ca3c:	8c805736 	bltu	r17,r18,200cb9c <_realloc_r+0x1cc>
 200ca40:	80c0300e 	bge	r16,r3,200cb04 <_realloc_r+0x134>
 200ca44:	07008074 	movhi	fp,513
 200ca48:	e70a4c04 	addi	fp,fp,10544
 200ca4c:	e1c00217 	ldw	r7,8(fp)
 200ca50:	9c09883a 	add	r4,r19,r16
 200ca54:	22000117 	ldw	r8,4(r4)
 200ca58:	21c06326 	beq	r4,r7,200cbe8 <_realloc_r+0x218>
 200ca5c:	017fff84 	movi	r5,-2
 200ca60:	414a703a 	and	r5,r8,r5
 200ca64:	214b883a 	add	r5,r4,r5
 200ca68:	29800117 	ldw	r6,4(r5)
 200ca6c:	3180004c 	andi	r6,r6,1
 200ca70:	30003f26 	beq	r6,zero,200cb70 <_realloc_r+0x1a0>
 200ca74:	1080004c 	andi	r2,r2,1
 200ca78:	10008326 	beq	r2,zero,200cc88 <_realloc_r+0x2b8>
 200ca7c:	900b883a 	mov	r5,r18
 200ca80:	a009883a 	mov	r4,r20
 200ca84:	200bf840 	call	200bf84 <_malloc_r>
 200ca88:	1025883a 	mov	r18,r2
 200ca8c:	10011e26 	beq	r2,zero,200cf08 <_realloc_r+0x538>
 200ca90:	a93fff17 	ldw	r4,-4(r21)
 200ca94:	10fffe04 	addi	r3,r2,-8
 200ca98:	00bfff84 	movi	r2,-2
 200ca9c:	2084703a 	and	r2,r4,r2
 200caa0:	9885883a 	add	r2,r19,r2
 200caa4:	1880ee26 	beq	r3,r2,200ce60 <_realloc_r+0x490>
 200caa8:	81bfff04 	addi	r6,r16,-4
 200caac:	00800904 	movi	r2,36
 200cab0:	1180b836 	bltu	r2,r6,200cd94 <_realloc_r+0x3c4>
 200cab4:	00c004c4 	movi	r3,19
 200cab8:	19809636 	bltu	r3,r6,200cd14 <_realloc_r+0x344>
 200cabc:	9005883a 	mov	r2,r18
 200cac0:	a807883a 	mov	r3,r21
 200cac4:	19000017 	ldw	r4,0(r3)
 200cac8:	11000015 	stw	r4,0(r2)
 200cacc:	19000117 	ldw	r4,4(r3)
 200cad0:	11000115 	stw	r4,4(r2)
 200cad4:	18c00217 	ldw	r3,8(r3)
 200cad8:	10c00215 	stw	r3,8(r2)
 200cadc:	a80b883a 	mov	r5,r21
 200cae0:	a009883a 	mov	r4,r20
 200cae4:	200d79c0 	call	200d79c <_free_r>
 200cae8:	a009883a 	mov	r4,r20
 200caec:	200e45c0 	call	200e45c <__malloc_unlock>
 200caf0:	9005883a 	mov	r2,r18
 200caf4:	00001206 	br	200cb40 <_realloc_r+0x170>
 200caf8:	00c00404 	movi	r3,16
 200cafc:	1823883a 	mov	r17,r3
 200cb00:	003fce06 	br	200ca3c <__reset+0xfe00ba3c>
 200cb04:	a825883a 	mov	r18,r21
 200cb08:	8445c83a 	sub	r2,r16,r17
 200cb0c:	00c003c4 	movi	r3,15
 200cb10:	18802636 	bltu	r3,r2,200cbac <_realloc_r+0x1dc>
 200cb14:	99800117 	ldw	r6,4(r19)
 200cb18:	9c07883a 	add	r3,r19,r16
 200cb1c:	3180004c 	andi	r6,r6,1
 200cb20:	3420b03a 	or	r16,r6,r16
 200cb24:	9c000115 	stw	r16,4(r19)
 200cb28:	18800117 	ldw	r2,4(r3)
 200cb2c:	10800054 	ori	r2,r2,1
 200cb30:	18800115 	stw	r2,4(r3)
 200cb34:	a009883a 	mov	r4,r20
 200cb38:	200e45c0 	call	200e45c <__malloc_unlock>
 200cb3c:	9005883a 	mov	r2,r18
 200cb40:	dfc00917 	ldw	ra,36(sp)
 200cb44:	df000817 	ldw	fp,32(sp)
 200cb48:	ddc00717 	ldw	r23,28(sp)
 200cb4c:	dd800617 	ldw	r22,24(sp)
 200cb50:	dd400517 	ldw	r21,20(sp)
 200cb54:	dd000417 	ldw	r20,16(sp)
 200cb58:	dcc00317 	ldw	r19,12(sp)
 200cb5c:	dc800217 	ldw	r18,8(sp)
 200cb60:	dc400117 	ldw	r17,4(sp)
 200cb64:	dc000017 	ldw	r16,0(sp)
 200cb68:	dec00a04 	addi	sp,sp,40
 200cb6c:	f800283a 	ret
 200cb70:	017fff04 	movi	r5,-4
 200cb74:	414a703a 	and	r5,r8,r5
 200cb78:	814d883a 	add	r6,r16,r5
 200cb7c:	30c01f16 	blt	r6,r3,200cbfc <_realloc_r+0x22c>
 200cb80:	20800317 	ldw	r2,12(r4)
 200cb84:	20c00217 	ldw	r3,8(r4)
 200cb88:	a825883a 	mov	r18,r21
 200cb8c:	3021883a 	mov	r16,r6
 200cb90:	18800315 	stw	r2,12(r3)
 200cb94:	10c00215 	stw	r3,8(r2)
 200cb98:	003fdb06 	br	200cb08 <__reset+0xfe00bb08>
 200cb9c:	00800304 	movi	r2,12
 200cba0:	a0800015 	stw	r2,0(r20)
 200cba4:	0005883a 	mov	r2,zero
 200cba8:	003fe506 	br	200cb40 <__reset+0xfe00bb40>
 200cbac:	98c00117 	ldw	r3,4(r19)
 200cbb0:	9c4b883a 	add	r5,r19,r17
 200cbb4:	11000054 	ori	r4,r2,1
 200cbb8:	18c0004c 	andi	r3,r3,1
 200cbbc:	1c62b03a 	or	r17,r3,r17
 200cbc0:	9c400115 	stw	r17,4(r19)
 200cbc4:	29000115 	stw	r4,4(r5)
 200cbc8:	2885883a 	add	r2,r5,r2
 200cbcc:	10c00117 	ldw	r3,4(r2)
 200cbd0:	29400204 	addi	r5,r5,8
 200cbd4:	a009883a 	mov	r4,r20
 200cbd8:	18c00054 	ori	r3,r3,1
 200cbdc:	10c00115 	stw	r3,4(r2)
 200cbe0:	200d79c0 	call	200d79c <_free_r>
 200cbe4:	003fd306 	br	200cb34 <__reset+0xfe00bb34>
 200cbe8:	017fff04 	movi	r5,-4
 200cbec:	414a703a 	and	r5,r8,r5
 200cbf0:	89800404 	addi	r6,r17,16
 200cbf4:	8151883a 	add	r8,r16,r5
 200cbf8:	4180590e 	bge	r8,r6,200cd60 <_realloc_r+0x390>
 200cbfc:	1080004c 	andi	r2,r2,1
 200cc00:	103f9e1e 	bne	r2,zero,200ca7c <__reset+0xfe00ba7c>
 200cc04:	adbffe17 	ldw	r22,-8(r21)
 200cc08:	00bfff04 	movi	r2,-4
 200cc0c:	9dadc83a 	sub	r22,r19,r22
 200cc10:	b1800117 	ldw	r6,4(r22)
 200cc14:	3084703a 	and	r2,r6,r2
 200cc18:	20002026 	beq	r4,zero,200cc9c <_realloc_r+0x2cc>
 200cc1c:	80af883a 	add	r23,r16,r2
 200cc20:	b96f883a 	add	r23,r23,r5
 200cc24:	21c05f26 	beq	r4,r7,200cda4 <_realloc_r+0x3d4>
 200cc28:	b8c01c16 	blt	r23,r3,200cc9c <_realloc_r+0x2cc>
 200cc2c:	20800317 	ldw	r2,12(r4)
 200cc30:	20c00217 	ldw	r3,8(r4)
 200cc34:	81bfff04 	addi	r6,r16,-4
 200cc38:	01000904 	movi	r4,36
 200cc3c:	18800315 	stw	r2,12(r3)
 200cc40:	10c00215 	stw	r3,8(r2)
 200cc44:	b0c00217 	ldw	r3,8(r22)
 200cc48:	b0800317 	ldw	r2,12(r22)
 200cc4c:	b4800204 	addi	r18,r22,8
 200cc50:	18800315 	stw	r2,12(r3)
 200cc54:	10c00215 	stw	r3,8(r2)
 200cc58:	21801b36 	bltu	r4,r6,200ccc8 <_realloc_r+0x2f8>
 200cc5c:	008004c4 	movi	r2,19
 200cc60:	1180352e 	bgeu	r2,r6,200cd38 <_realloc_r+0x368>
 200cc64:	a8800017 	ldw	r2,0(r21)
 200cc68:	b0800215 	stw	r2,8(r22)
 200cc6c:	a8800117 	ldw	r2,4(r21)
 200cc70:	b0800315 	stw	r2,12(r22)
 200cc74:	008006c4 	movi	r2,27
 200cc78:	11807f36 	bltu	r2,r6,200ce78 <_realloc_r+0x4a8>
 200cc7c:	b0800404 	addi	r2,r22,16
 200cc80:	ad400204 	addi	r21,r21,8
 200cc84:	00002d06 	br	200cd3c <_realloc_r+0x36c>
 200cc88:	adbffe17 	ldw	r22,-8(r21)
 200cc8c:	00bfff04 	movi	r2,-4
 200cc90:	9dadc83a 	sub	r22,r19,r22
 200cc94:	b1000117 	ldw	r4,4(r22)
 200cc98:	2084703a 	and	r2,r4,r2
 200cc9c:	b03f7726 	beq	r22,zero,200ca7c <__reset+0xfe00ba7c>
 200cca0:	80af883a 	add	r23,r16,r2
 200cca4:	b8ff7516 	blt	r23,r3,200ca7c <__reset+0xfe00ba7c>
 200cca8:	b0800317 	ldw	r2,12(r22)
 200ccac:	b0c00217 	ldw	r3,8(r22)
 200ccb0:	81bfff04 	addi	r6,r16,-4
 200ccb4:	01000904 	movi	r4,36
 200ccb8:	18800315 	stw	r2,12(r3)
 200ccbc:	10c00215 	stw	r3,8(r2)
 200ccc0:	b4800204 	addi	r18,r22,8
 200ccc4:	21bfe52e 	bgeu	r4,r6,200cc5c <__reset+0xfe00bc5c>
 200ccc8:	a80b883a 	mov	r5,r21
 200cccc:	9009883a 	mov	r4,r18
 200ccd0:	200c8740 	call	200c874 <memmove>
 200ccd4:	b821883a 	mov	r16,r23
 200ccd8:	b027883a 	mov	r19,r22
 200ccdc:	003f8a06 	br	200cb08 <__reset+0xfe00bb08>
 200cce0:	300b883a 	mov	r5,r6
 200cce4:	dfc00917 	ldw	ra,36(sp)
 200cce8:	df000817 	ldw	fp,32(sp)
 200ccec:	ddc00717 	ldw	r23,28(sp)
 200ccf0:	dd800617 	ldw	r22,24(sp)
 200ccf4:	dd400517 	ldw	r21,20(sp)
 200ccf8:	dd000417 	ldw	r20,16(sp)
 200ccfc:	dcc00317 	ldw	r19,12(sp)
 200cd00:	dc800217 	ldw	r18,8(sp)
 200cd04:	dc400117 	ldw	r17,4(sp)
 200cd08:	dc000017 	ldw	r16,0(sp)
 200cd0c:	dec00a04 	addi	sp,sp,40
 200cd10:	200bf841 	jmpi	200bf84 <_malloc_r>
 200cd14:	a8c00017 	ldw	r3,0(r21)
 200cd18:	90c00015 	stw	r3,0(r18)
 200cd1c:	a8c00117 	ldw	r3,4(r21)
 200cd20:	90c00115 	stw	r3,4(r18)
 200cd24:	00c006c4 	movi	r3,27
 200cd28:	19804536 	bltu	r3,r6,200ce40 <_realloc_r+0x470>
 200cd2c:	90800204 	addi	r2,r18,8
 200cd30:	a8c00204 	addi	r3,r21,8
 200cd34:	003f6306 	br	200cac4 <__reset+0xfe00bac4>
 200cd38:	9005883a 	mov	r2,r18
 200cd3c:	a8c00017 	ldw	r3,0(r21)
 200cd40:	b821883a 	mov	r16,r23
 200cd44:	b027883a 	mov	r19,r22
 200cd48:	10c00015 	stw	r3,0(r2)
 200cd4c:	a8c00117 	ldw	r3,4(r21)
 200cd50:	10c00115 	stw	r3,4(r2)
 200cd54:	a8c00217 	ldw	r3,8(r21)
 200cd58:	10c00215 	stw	r3,8(r2)
 200cd5c:	003f6a06 	br	200cb08 <__reset+0xfe00bb08>
 200cd60:	9c67883a 	add	r19,r19,r17
 200cd64:	4445c83a 	sub	r2,r8,r17
 200cd68:	e4c00215 	stw	r19,8(fp)
 200cd6c:	10800054 	ori	r2,r2,1
 200cd70:	98800115 	stw	r2,4(r19)
 200cd74:	a8bfff17 	ldw	r2,-4(r21)
 200cd78:	a009883a 	mov	r4,r20
 200cd7c:	1080004c 	andi	r2,r2,1
 200cd80:	1462b03a 	or	r17,r2,r17
 200cd84:	ac7fff15 	stw	r17,-4(r21)
 200cd88:	200e45c0 	call	200e45c <__malloc_unlock>
 200cd8c:	a805883a 	mov	r2,r21
 200cd90:	003f6b06 	br	200cb40 <__reset+0xfe00bb40>
 200cd94:	a80b883a 	mov	r5,r21
 200cd98:	9009883a 	mov	r4,r18
 200cd9c:	200c8740 	call	200c874 <memmove>
 200cda0:	003f4e06 	br	200cadc <__reset+0xfe00badc>
 200cda4:	89000404 	addi	r4,r17,16
 200cda8:	b93fbc16 	blt	r23,r4,200cc9c <__reset+0xfe00bc9c>
 200cdac:	b0800317 	ldw	r2,12(r22)
 200cdb0:	b0c00217 	ldw	r3,8(r22)
 200cdb4:	81bfff04 	addi	r6,r16,-4
 200cdb8:	01000904 	movi	r4,36
 200cdbc:	18800315 	stw	r2,12(r3)
 200cdc0:	10c00215 	stw	r3,8(r2)
 200cdc4:	b4800204 	addi	r18,r22,8
 200cdc8:	21804336 	bltu	r4,r6,200ced8 <_realloc_r+0x508>
 200cdcc:	008004c4 	movi	r2,19
 200cdd0:	11803f2e 	bgeu	r2,r6,200ced0 <_realloc_r+0x500>
 200cdd4:	a8800017 	ldw	r2,0(r21)
 200cdd8:	b0800215 	stw	r2,8(r22)
 200cddc:	a8800117 	ldw	r2,4(r21)
 200cde0:	b0800315 	stw	r2,12(r22)
 200cde4:	008006c4 	movi	r2,27
 200cde8:	11803f36 	bltu	r2,r6,200cee8 <_realloc_r+0x518>
 200cdec:	b0800404 	addi	r2,r22,16
 200cdf0:	ad400204 	addi	r21,r21,8
 200cdf4:	a8c00017 	ldw	r3,0(r21)
 200cdf8:	10c00015 	stw	r3,0(r2)
 200cdfc:	a8c00117 	ldw	r3,4(r21)
 200ce00:	10c00115 	stw	r3,4(r2)
 200ce04:	a8c00217 	ldw	r3,8(r21)
 200ce08:	10c00215 	stw	r3,8(r2)
 200ce0c:	b447883a 	add	r3,r22,r17
 200ce10:	bc45c83a 	sub	r2,r23,r17
 200ce14:	e0c00215 	stw	r3,8(fp)
 200ce18:	10800054 	ori	r2,r2,1
 200ce1c:	18800115 	stw	r2,4(r3)
 200ce20:	b0800117 	ldw	r2,4(r22)
 200ce24:	a009883a 	mov	r4,r20
 200ce28:	1080004c 	andi	r2,r2,1
 200ce2c:	1462b03a 	or	r17,r2,r17
 200ce30:	b4400115 	stw	r17,4(r22)
 200ce34:	200e45c0 	call	200e45c <__malloc_unlock>
 200ce38:	9005883a 	mov	r2,r18
 200ce3c:	003f4006 	br	200cb40 <__reset+0xfe00bb40>
 200ce40:	a8c00217 	ldw	r3,8(r21)
 200ce44:	90c00215 	stw	r3,8(r18)
 200ce48:	a8c00317 	ldw	r3,12(r21)
 200ce4c:	90c00315 	stw	r3,12(r18)
 200ce50:	30801126 	beq	r6,r2,200ce98 <_realloc_r+0x4c8>
 200ce54:	90800404 	addi	r2,r18,16
 200ce58:	a8c00404 	addi	r3,r21,16
 200ce5c:	003f1906 	br	200cac4 <__reset+0xfe00bac4>
 200ce60:	90ffff17 	ldw	r3,-4(r18)
 200ce64:	00bfff04 	movi	r2,-4
 200ce68:	a825883a 	mov	r18,r21
 200ce6c:	1884703a 	and	r2,r3,r2
 200ce70:	80a1883a 	add	r16,r16,r2
 200ce74:	003f2406 	br	200cb08 <__reset+0xfe00bb08>
 200ce78:	a8800217 	ldw	r2,8(r21)
 200ce7c:	b0800415 	stw	r2,16(r22)
 200ce80:	a8800317 	ldw	r2,12(r21)
 200ce84:	b0800515 	stw	r2,20(r22)
 200ce88:	31000a26 	beq	r6,r4,200ceb4 <_realloc_r+0x4e4>
 200ce8c:	b0800604 	addi	r2,r22,24
 200ce90:	ad400404 	addi	r21,r21,16
 200ce94:	003fa906 	br	200cd3c <__reset+0xfe00bd3c>
 200ce98:	a9000417 	ldw	r4,16(r21)
 200ce9c:	90800604 	addi	r2,r18,24
 200cea0:	a8c00604 	addi	r3,r21,24
 200cea4:	91000415 	stw	r4,16(r18)
 200cea8:	a9000517 	ldw	r4,20(r21)
 200ceac:	91000515 	stw	r4,20(r18)
 200ceb0:	003f0406 	br	200cac4 <__reset+0xfe00bac4>
 200ceb4:	a8c00417 	ldw	r3,16(r21)
 200ceb8:	ad400604 	addi	r21,r21,24
 200cebc:	b0800804 	addi	r2,r22,32
 200cec0:	b0c00615 	stw	r3,24(r22)
 200cec4:	a8ffff17 	ldw	r3,-4(r21)
 200cec8:	b0c00715 	stw	r3,28(r22)
 200cecc:	003f9b06 	br	200cd3c <__reset+0xfe00bd3c>
 200ced0:	9005883a 	mov	r2,r18
 200ced4:	003fc706 	br	200cdf4 <__reset+0xfe00bdf4>
 200ced8:	a80b883a 	mov	r5,r21
 200cedc:	9009883a 	mov	r4,r18
 200cee0:	200c8740 	call	200c874 <memmove>
 200cee4:	003fc906 	br	200ce0c <__reset+0xfe00be0c>
 200cee8:	a8800217 	ldw	r2,8(r21)
 200ceec:	b0800415 	stw	r2,16(r22)
 200cef0:	a8800317 	ldw	r2,12(r21)
 200cef4:	b0800515 	stw	r2,20(r22)
 200cef8:	31000726 	beq	r6,r4,200cf18 <_realloc_r+0x548>
 200cefc:	b0800604 	addi	r2,r22,24
 200cf00:	ad400404 	addi	r21,r21,16
 200cf04:	003fbb06 	br	200cdf4 <__reset+0xfe00bdf4>
 200cf08:	a009883a 	mov	r4,r20
 200cf0c:	200e45c0 	call	200e45c <__malloc_unlock>
 200cf10:	0005883a 	mov	r2,zero
 200cf14:	003f0a06 	br	200cb40 <__reset+0xfe00bb40>
 200cf18:	a8c00417 	ldw	r3,16(r21)
 200cf1c:	ad400604 	addi	r21,r21,24
 200cf20:	b0800804 	addi	r2,r22,32
 200cf24:	b0c00615 	stw	r3,24(r22)
 200cf28:	a8ffff17 	ldw	r3,-4(r21)
 200cf2c:	b0c00715 	stw	r3,28(r22)
 200cf30:	003fb006 	br	200cdf4 <__reset+0xfe00bdf4>

0200cf34 <_sbrk_r>:
 200cf34:	defffd04 	addi	sp,sp,-12
 200cf38:	dc000015 	stw	r16,0(sp)
 200cf3c:	04008074 	movhi	r16,513
 200cf40:	dc400115 	stw	r17,4(sp)
 200cf44:	84113404 	addi	r16,r16,17616
 200cf48:	2023883a 	mov	r17,r4
 200cf4c:	2809883a 	mov	r4,r5
 200cf50:	dfc00215 	stw	ra,8(sp)
 200cf54:	80000015 	stw	zero,0(r16)
 200cf58:	200e6440 	call	200e644 <sbrk>
 200cf5c:	00ffffc4 	movi	r3,-1
 200cf60:	10c00526 	beq	r2,r3,200cf78 <_sbrk_r+0x44>
 200cf64:	dfc00217 	ldw	ra,8(sp)
 200cf68:	dc400117 	ldw	r17,4(sp)
 200cf6c:	dc000017 	ldw	r16,0(sp)
 200cf70:	dec00304 	addi	sp,sp,12
 200cf74:	f800283a 	ret
 200cf78:	80c00017 	ldw	r3,0(r16)
 200cf7c:	183ff926 	beq	r3,zero,200cf64 <__reset+0xfe00bf64>
 200cf80:	88c00015 	stw	r3,0(r17)
 200cf84:	003ff706 	br	200cf64 <__reset+0xfe00bf64>

0200cf88 <__sread>:
 200cf88:	defffe04 	addi	sp,sp,-8
 200cf8c:	dc000015 	stw	r16,0(sp)
 200cf90:	2821883a 	mov	r16,r5
 200cf94:	2940038f 	ldh	r5,14(r5)
 200cf98:	dfc00115 	stw	ra,4(sp)
 200cf9c:	200dcc80 	call	200dcc8 <_read_r>
 200cfa0:	10000716 	blt	r2,zero,200cfc0 <__sread+0x38>
 200cfa4:	80c01417 	ldw	r3,80(r16)
 200cfa8:	1887883a 	add	r3,r3,r2
 200cfac:	80c01415 	stw	r3,80(r16)
 200cfb0:	dfc00117 	ldw	ra,4(sp)
 200cfb4:	dc000017 	ldw	r16,0(sp)
 200cfb8:	dec00204 	addi	sp,sp,8
 200cfbc:	f800283a 	ret
 200cfc0:	80c0030b 	ldhu	r3,12(r16)
 200cfc4:	18fbffcc 	andi	r3,r3,61439
 200cfc8:	80c0030d 	sth	r3,12(r16)
 200cfcc:	dfc00117 	ldw	ra,4(sp)
 200cfd0:	dc000017 	ldw	r16,0(sp)
 200cfd4:	dec00204 	addi	sp,sp,8
 200cfd8:	f800283a 	ret

0200cfdc <__seofread>:
 200cfdc:	0005883a 	mov	r2,zero
 200cfe0:	f800283a 	ret

0200cfe4 <__swrite>:
 200cfe4:	2880030b 	ldhu	r2,12(r5)
 200cfe8:	defffb04 	addi	sp,sp,-20
 200cfec:	dcc00315 	stw	r19,12(sp)
 200cff0:	dc800215 	stw	r18,8(sp)
 200cff4:	dc400115 	stw	r17,4(sp)
 200cff8:	dc000015 	stw	r16,0(sp)
 200cffc:	dfc00415 	stw	ra,16(sp)
 200d000:	10c0400c 	andi	r3,r2,256
 200d004:	2821883a 	mov	r16,r5
 200d008:	2023883a 	mov	r17,r4
 200d00c:	3025883a 	mov	r18,r6
 200d010:	3827883a 	mov	r19,r7
 200d014:	18000526 	beq	r3,zero,200d02c <__swrite+0x48>
 200d018:	2940038f 	ldh	r5,14(r5)
 200d01c:	01c00084 	movi	r7,2
 200d020:	000d883a 	mov	r6,zero
 200d024:	200daac0 	call	200daac <_lseek_r>
 200d028:	8080030b 	ldhu	r2,12(r16)
 200d02c:	8140038f 	ldh	r5,14(r16)
 200d030:	10bbffcc 	andi	r2,r2,61439
 200d034:	980f883a 	mov	r7,r19
 200d038:	900d883a 	mov	r6,r18
 200d03c:	8809883a 	mov	r4,r17
 200d040:	8080030d 	sth	r2,12(r16)
 200d044:	dfc00417 	ldw	ra,16(sp)
 200d048:	dcc00317 	ldw	r19,12(sp)
 200d04c:	dc800217 	ldw	r18,8(sp)
 200d050:	dc400117 	ldw	r17,4(sp)
 200d054:	dc000017 	ldw	r16,0(sp)
 200d058:	dec00504 	addi	sp,sp,20
 200d05c:	200d0c41 	jmpi	200d0c4 <_write_r>

0200d060 <__sseek>:
 200d060:	defffe04 	addi	sp,sp,-8
 200d064:	dc000015 	stw	r16,0(sp)
 200d068:	2821883a 	mov	r16,r5
 200d06c:	2940038f 	ldh	r5,14(r5)
 200d070:	dfc00115 	stw	ra,4(sp)
 200d074:	200daac0 	call	200daac <_lseek_r>
 200d078:	00ffffc4 	movi	r3,-1
 200d07c:	10c00826 	beq	r2,r3,200d0a0 <__sseek+0x40>
 200d080:	80c0030b 	ldhu	r3,12(r16)
 200d084:	80801415 	stw	r2,80(r16)
 200d088:	18c40014 	ori	r3,r3,4096
 200d08c:	80c0030d 	sth	r3,12(r16)
 200d090:	dfc00117 	ldw	ra,4(sp)
 200d094:	dc000017 	ldw	r16,0(sp)
 200d098:	dec00204 	addi	sp,sp,8
 200d09c:	f800283a 	ret
 200d0a0:	80c0030b 	ldhu	r3,12(r16)
 200d0a4:	18fbffcc 	andi	r3,r3,61439
 200d0a8:	80c0030d 	sth	r3,12(r16)
 200d0ac:	dfc00117 	ldw	ra,4(sp)
 200d0b0:	dc000017 	ldw	r16,0(sp)
 200d0b4:	dec00204 	addi	sp,sp,8
 200d0b8:	f800283a 	ret

0200d0bc <__sclose>:
 200d0bc:	2940038f 	ldh	r5,14(r5)
 200d0c0:	200d2781 	jmpi	200d278 <_close_r>

0200d0c4 <_write_r>:
 200d0c4:	defffd04 	addi	sp,sp,-12
 200d0c8:	2805883a 	mov	r2,r5
 200d0cc:	dc000015 	stw	r16,0(sp)
 200d0d0:	04008074 	movhi	r16,513
 200d0d4:	dc400115 	stw	r17,4(sp)
 200d0d8:	300b883a 	mov	r5,r6
 200d0dc:	84113404 	addi	r16,r16,17616
 200d0e0:	2023883a 	mov	r17,r4
 200d0e4:	380d883a 	mov	r6,r7
 200d0e8:	1009883a 	mov	r4,r2
 200d0ec:	dfc00215 	stw	ra,8(sp)
 200d0f0:	80000015 	stw	zero,0(r16)
 200d0f4:	200e7600 	call	200e760 <write>
 200d0f8:	00ffffc4 	movi	r3,-1
 200d0fc:	10c00526 	beq	r2,r3,200d114 <_write_r+0x50>
 200d100:	dfc00217 	ldw	ra,8(sp)
 200d104:	dc400117 	ldw	r17,4(sp)
 200d108:	dc000017 	ldw	r16,0(sp)
 200d10c:	dec00304 	addi	sp,sp,12
 200d110:	f800283a 	ret
 200d114:	80c00017 	ldw	r3,0(r16)
 200d118:	183ff926 	beq	r3,zero,200d100 <__reset+0xfe00c100>
 200d11c:	88c00015 	stw	r3,0(r17)
 200d120:	003ff706 	br	200d100 <__reset+0xfe00c100>

0200d124 <__swsetup_r>:
 200d124:	00808074 	movhi	r2,513
 200d128:	defffd04 	addi	sp,sp,-12
 200d12c:	1090b904 	addi	r2,r2,17124
 200d130:	dc400115 	stw	r17,4(sp)
 200d134:	2023883a 	mov	r17,r4
 200d138:	11000017 	ldw	r4,0(r2)
 200d13c:	dc000015 	stw	r16,0(sp)
 200d140:	dfc00215 	stw	ra,8(sp)
 200d144:	2821883a 	mov	r16,r5
 200d148:	20000226 	beq	r4,zero,200d154 <__swsetup_r+0x30>
 200d14c:	20800e17 	ldw	r2,56(r4)
 200d150:	10003126 	beq	r2,zero,200d218 <__swsetup_r+0xf4>
 200d154:	8080030b 	ldhu	r2,12(r16)
 200d158:	10c0020c 	andi	r3,r2,8
 200d15c:	1009883a 	mov	r4,r2
 200d160:	18000f26 	beq	r3,zero,200d1a0 <__swsetup_r+0x7c>
 200d164:	80c00417 	ldw	r3,16(r16)
 200d168:	18001526 	beq	r3,zero,200d1c0 <__swsetup_r+0x9c>
 200d16c:	1100004c 	andi	r4,r2,1
 200d170:	20001c1e 	bne	r4,zero,200d1e4 <__swsetup_r+0xc0>
 200d174:	1080008c 	andi	r2,r2,2
 200d178:	1000291e 	bne	r2,zero,200d220 <__swsetup_r+0xfc>
 200d17c:	80800517 	ldw	r2,20(r16)
 200d180:	80800215 	stw	r2,8(r16)
 200d184:	18001c26 	beq	r3,zero,200d1f8 <__swsetup_r+0xd4>
 200d188:	0005883a 	mov	r2,zero
 200d18c:	dfc00217 	ldw	ra,8(sp)
 200d190:	dc400117 	ldw	r17,4(sp)
 200d194:	dc000017 	ldw	r16,0(sp)
 200d198:	dec00304 	addi	sp,sp,12
 200d19c:	f800283a 	ret
 200d1a0:	2080040c 	andi	r2,r4,16
 200d1a4:	10002e26 	beq	r2,zero,200d260 <__swsetup_r+0x13c>
 200d1a8:	2080010c 	andi	r2,r4,4
 200d1ac:	10001e1e 	bne	r2,zero,200d228 <__swsetup_r+0x104>
 200d1b0:	80c00417 	ldw	r3,16(r16)
 200d1b4:	20800214 	ori	r2,r4,8
 200d1b8:	8080030d 	sth	r2,12(r16)
 200d1bc:	183feb1e 	bne	r3,zero,200d16c <__reset+0xfe00c16c>
 200d1c0:	1100a00c 	andi	r4,r2,640
 200d1c4:	01408004 	movi	r5,512
 200d1c8:	217fe826 	beq	r4,r5,200d16c <__reset+0xfe00c16c>
 200d1cc:	800b883a 	mov	r5,r16
 200d1d0:	8809883a 	mov	r4,r17
 200d1d4:	200db0c0 	call	200db0c <__smakebuf_r>
 200d1d8:	8080030b 	ldhu	r2,12(r16)
 200d1dc:	80c00417 	ldw	r3,16(r16)
 200d1e0:	003fe206 	br	200d16c <__reset+0xfe00c16c>
 200d1e4:	80800517 	ldw	r2,20(r16)
 200d1e8:	80000215 	stw	zero,8(r16)
 200d1ec:	0085c83a 	sub	r2,zero,r2
 200d1f0:	80800615 	stw	r2,24(r16)
 200d1f4:	183fe41e 	bne	r3,zero,200d188 <__reset+0xfe00c188>
 200d1f8:	80c0030b 	ldhu	r3,12(r16)
 200d1fc:	0005883a 	mov	r2,zero
 200d200:	1900200c 	andi	r4,r3,128
 200d204:	203fe126 	beq	r4,zero,200d18c <__reset+0xfe00c18c>
 200d208:	18c01014 	ori	r3,r3,64
 200d20c:	80c0030d 	sth	r3,12(r16)
 200d210:	00bfffc4 	movi	r2,-1
 200d214:	003fdd06 	br	200d18c <__reset+0xfe00c18c>
 200d218:	200b8e40 	call	200b8e4 <__sinit>
 200d21c:	003fcd06 	br	200d154 <__reset+0xfe00c154>
 200d220:	0005883a 	mov	r2,zero
 200d224:	003fd606 	br	200d180 <__reset+0xfe00c180>
 200d228:	81400c17 	ldw	r5,48(r16)
 200d22c:	28000626 	beq	r5,zero,200d248 <__swsetup_r+0x124>
 200d230:	80801004 	addi	r2,r16,64
 200d234:	28800326 	beq	r5,r2,200d244 <__swsetup_r+0x120>
 200d238:	8809883a 	mov	r4,r17
 200d23c:	200d79c0 	call	200d79c <_free_r>
 200d240:	8100030b 	ldhu	r4,12(r16)
 200d244:	80000c15 	stw	zero,48(r16)
 200d248:	80c00417 	ldw	r3,16(r16)
 200d24c:	00bff6c4 	movi	r2,-37
 200d250:	1108703a 	and	r4,r2,r4
 200d254:	80000115 	stw	zero,4(r16)
 200d258:	80c00015 	stw	r3,0(r16)
 200d25c:	003fd506 	br	200d1b4 <__reset+0xfe00c1b4>
 200d260:	00800244 	movi	r2,9
 200d264:	88800015 	stw	r2,0(r17)
 200d268:	20801014 	ori	r2,r4,64
 200d26c:	8080030d 	sth	r2,12(r16)
 200d270:	00bfffc4 	movi	r2,-1
 200d274:	003fc506 	br	200d18c <__reset+0xfe00c18c>

0200d278 <_close_r>:
 200d278:	defffd04 	addi	sp,sp,-12
 200d27c:	dc000015 	stw	r16,0(sp)
 200d280:	04008074 	movhi	r16,513
 200d284:	dc400115 	stw	r17,4(sp)
 200d288:	84113404 	addi	r16,r16,17616
 200d28c:	2023883a 	mov	r17,r4
 200d290:	2809883a 	mov	r4,r5
 200d294:	dfc00215 	stw	ra,8(sp)
 200d298:	80000015 	stw	zero,0(r16)
 200d29c:	200de140 	call	200de14 <close>
 200d2a0:	00ffffc4 	movi	r3,-1
 200d2a4:	10c00526 	beq	r2,r3,200d2bc <_close_r+0x44>
 200d2a8:	dfc00217 	ldw	ra,8(sp)
 200d2ac:	dc400117 	ldw	r17,4(sp)
 200d2b0:	dc000017 	ldw	r16,0(sp)
 200d2b4:	dec00304 	addi	sp,sp,12
 200d2b8:	f800283a 	ret
 200d2bc:	80c00017 	ldw	r3,0(r16)
 200d2c0:	183ff926 	beq	r3,zero,200d2a8 <__reset+0xfe00c2a8>
 200d2c4:	88c00015 	stw	r3,0(r17)
 200d2c8:	003ff706 	br	200d2a8 <__reset+0xfe00c2a8>

0200d2cc <_fclose_r>:
 200d2cc:	28003926 	beq	r5,zero,200d3b4 <_fclose_r+0xe8>
 200d2d0:	defffc04 	addi	sp,sp,-16
 200d2d4:	dc400115 	stw	r17,4(sp)
 200d2d8:	dc000015 	stw	r16,0(sp)
 200d2dc:	dfc00315 	stw	ra,12(sp)
 200d2e0:	dc800215 	stw	r18,8(sp)
 200d2e4:	2023883a 	mov	r17,r4
 200d2e8:	2821883a 	mov	r16,r5
 200d2ec:	20000226 	beq	r4,zero,200d2f8 <_fclose_r+0x2c>
 200d2f0:	20800e17 	ldw	r2,56(r4)
 200d2f4:	10002726 	beq	r2,zero,200d394 <_fclose_r+0xc8>
 200d2f8:	8080030f 	ldh	r2,12(r16)
 200d2fc:	1000071e 	bne	r2,zero,200d31c <_fclose_r+0x50>
 200d300:	0005883a 	mov	r2,zero
 200d304:	dfc00317 	ldw	ra,12(sp)
 200d308:	dc800217 	ldw	r18,8(sp)
 200d30c:	dc400117 	ldw	r17,4(sp)
 200d310:	dc000017 	ldw	r16,0(sp)
 200d314:	dec00404 	addi	sp,sp,16
 200d318:	f800283a 	ret
 200d31c:	800b883a 	mov	r5,r16
 200d320:	8809883a 	mov	r4,r17
 200d324:	200d3d00 	call	200d3d0 <__sflush_r>
 200d328:	1025883a 	mov	r18,r2
 200d32c:	80800b17 	ldw	r2,44(r16)
 200d330:	10000426 	beq	r2,zero,200d344 <_fclose_r+0x78>
 200d334:	81400717 	ldw	r5,28(r16)
 200d338:	8809883a 	mov	r4,r17
 200d33c:	103ee83a 	callr	r2
 200d340:	10001616 	blt	r2,zero,200d39c <_fclose_r+0xd0>
 200d344:	8080030b 	ldhu	r2,12(r16)
 200d348:	1080200c 	andi	r2,r2,128
 200d34c:	1000151e 	bne	r2,zero,200d3a4 <_fclose_r+0xd8>
 200d350:	81400c17 	ldw	r5,48(r16)
 200d354:	28000526 	beq	r5,zero,200d36c <_fclose_r+0xa0>
 200d358:	80801004 	addi	r2,r16,64
 200d35c:	28800226 	beq	r5,r2,200d368 <_fclose_r+0x9c>
 200d360:	8809883a 	mov	r4,r17
 200d364:	200d79c0 	call	200d79c <_free_r>
 200d368:	80000c15 	stw	zero,48(r16)
 200d36c:	81401117 	ldw	r5,68(r16)
 200d370:	28000326 	beq	r5,zero,200d380 <_fclose_r+0xb4>
 200d374:	8809883a 	mov	r4,r17
 200d378:	200d79c0 	call	200d79c <_free_r>
 200d37c:	80001115 	stw	zero,68(r16)
 200d380:	200b8f40 	call	200b8f4 <__sfp_lock_acquire>
 200d384:	8000030d 	sth	zero,12(r16)
 200d388:	200b8f80 	call	200b8f8 <__sfp_lock_release>
 200d38c:	9005883a 	mov	r2,r18
 200d390:	003fdc06 	br	200d304 <__reset+0xfe00c304>
 200d394:	200b8e40 	call	200b8e4 <__sinit>
 200d398:	003fd706 	br	200d2f8 <__reset+0xfe00c2f8>
 200d39c:	04bfffc4 	movi	r18,-1
 200d3a0:	003fe806 	br	200d344 <__reset+0xfe00c344>
 200d3a4:	81400417 	ldw	r5,16(r16)
 200d3a8:	8809883a 	mov	r4,r17
 200d3ac:	200d79c0 	call	200d79c <_free_r>
 200d3b0:	003fe706 	br	200d350 <__reset+0xfe00c350>
 200d3b4:	0005883a 	mov	r2,zero
 200d3b8:	f800283a 	ret

0200d3bc <fclose>:
 200d3bc:	00808074 	movhi	r2,513
 200d3c0:	1090b904 	addi	r2,r2,17124
 200d3c4:	200b883a 	mov	r5,r4
 200d3c8:	11000017 	ldw	r4,0(r2)
 200d3cc:	200d2cc1 	jmpi	200d2cc <_fclose_r>

0200d3d0 <__sflush_r>:
 200d3d0:	2880030b 	ldhu	r2,12(r5)
 200d3d4:	defffb04 	addi	sp,sp,-20
 200d3d8:	dcc00315 	stw	r19,12(sp)
 200d3dc:	dc400115 	stw	r17,4(sp)
 200d3e0:	dfc00415 	stw	ra,16(sp)
 200d3e4:	dc800215 	stw	r18,8(sp)
 200d3e8:	dc000015 	stw	r16,0(sp)
 200d3ec:	10c0020c 	andi	r3,r2,8
 200d3f0:	2823883a 	mov	r17,r5
 200d3f4:	2027883a 	mov	r19,r4
 200d3f8:	1800311e 	bne	r3,zero,200d4c0 <__sflush_r+0xf0>
 200d3fc:	28c00117 	ldw	r3,4(r5)
 200d400:	10820014 	ori	r2,r2,2048
 200d404:	2880030d 	sth	r2,12(r5)
 200d408:	00c04b0e 	bge	zero,r3,200d538 <__sflush_r+0x168>
 200d40c:	8a000a17 	ldw	r8,40(r17)
 200d410:	40002326 	beq	r8,zero,200d4a0 <__sflush_r+0xd0>
 200d414:	9c000017 	ldw	r16,0(r19)
 200d418:	10c4000c 	andi	r3,r2,4096
 200d41c:	98000015 	stw	zero,0(r19)
 200d420:	18004826 	beq	r3,zero,200d544 <__sflush_r+0x174>
 200d424:	89801417 	ldw	r6,80(r17)
 200d428:	10c0010c 	andi	r3,r2,4
 200d42c:	18000626 	beq	r3,zero,200d448 <__sflush_r+0x78>
 200d430:	88c00117 	ldw	r3,4(r17)
 200d434:	88800c17 	ldw	r2,48(r17)
 200d438:	30cdc83a 	sub	r6,r6,r3
 200d43c:	10000226 	beq	r2,zero,200d448 <__sflush_r+0x78>
 200d440:	88800f17 	ldw	r2,60(r17)
 200d444:	308dc83a 	sub	r6,r6,r2
 200d448:	89400717 	ldw	r5,28(r17)
 200d44c:	000f883a 	mov	r7,zero
 200d450:	9809883a 	mov	r4,r19
 200d454:	403ee83a 	callr	r8
 200d458:	00ffffc4 	movi	r3,-1
 200d45c:	10c04426 	beq	r2,r3,200d570 <__sflush_r+0x1a0>
 200d460:	88c0030b 	ldhu	r3,12(r17)
 200d464:	89000417 	ldw	r4,16(r17)
 200d468:	88000115 	stw	zero,4(r17)
 200d46c:	197dffcc 	andi	r5,r3,63487
 200d470:	8940030d 	sth	r5,12(r17)
 200d474:	89000015 	stw	r4,0(r17)
 200d478:	18c4000c 	andi	r3,r3,4096
 200d47c:	18002c1e 	bne	r3,zero,200d530 <__sflush_r+0x160>
 200d480:	89400c17 	ldw	r5,48(r17)
 200d484:	9c000015 	stw	r16,0(r19)
 200d488:	28000526 	beq	r5,zero,200d4a0 <__sflush_r+0xd0>
 200d48c:	88801004 	addi	r2,r17,64
 200d490:	28800226 	beq	r5,r2,200d49c <__sflush_r+0xcc>
 200d494:	9809883a 	mov	r4,r19
 200d498:	200d79c0 	call	200d79c <_free_r>
 200d49c:	88000c15 	stw	zero,48(r17)
 200d4a0:	0005883a 	mov	r2,zero
 200d4a4:	dfc00417 	ldw	ra,16(sp)
 200d4a8:	dcc00317 	ldw	r19,12(sp)
 200d4ac:	dc800217 	ldw	r18,8(sp)
 200d4b0:	dc400117 	ldw	r17,4(sp)
 200d4b4:	dc000017 	ldw	r16,0(sp)
 200d4b8:	dec00504 	addi	sp,sp,20
 200d4bc:	f800283a 	ret
 200d4c0:	2c800417 	ldw	r18,16(r5)
 200d4c4:	903ff626 	beq	r18,zero,200d4a0 <__reset+0xfe00c4a0>
 200d4c8:	2c000017 	ldw	r16,0(r5)
 200d4cc:	108000cc 	andi	r2,r2,3
 200d4d0:	2c800015 	stw	r18,0(r5)
 200d4d4:	84a1c83a 	sub	r16,r16,r18
 200d4d8:	1000131e 	bne	r2,zero,200d528 <__sflush_r+0x158>
 200d4dc:	28800517 	ldw	r2,20(r5)
 200d4e0:	88800215 	stw	r2,8(r17)
 200d4e4:	04000316 	blt	zero,r16,200d4f4 <__sflush_r+0x124>
 200d4e8:	003fed06 	br	200d4a0 <__reset+0xfe00c4a0>
 200d4ec:	90a5883a 	add	r18,r18,r2
 200d4f0:	043feb0e 	bge	zero,r16,200d4a0 <__reset+0xfe00c4a0>
 200d4f4:	88800917 	ldw	r2,36(r17)
 200d4f8:	89400717 	ldw	r5,28(r17)
 200d4fc:	800f883a 	mov	r7,r16
 200d500:	900d883a 	mov	r6,r18
 200d504:	9809883a 	mov	r4,r19
 200d508:	103ee83a 	callr	r2
 200d50c:	80a1c83a 	sub	r16,r16,r2
 200d510:	00bff616 	blt	zero,r2,200d4ec <__reset+0xfe00c4ec>
 200d514:	88c0030b 	ldhu	r3,12(r17)
 200d518:	00bfffc4 	movi	r2,-1
 200d51c:	18c01014 	ori	r3,r3,64
 200d520:	88c0030d 	sth	r3,12(r17)
 200d524:	003fdf06 	br	200d4a4 <__reset+0xfe00c4a4>
 200d528:	0005883a 	mov	r2,zero
 200d52c:	003fec06 	br	200d4e0 <__reset+0xfe00c4e0>
 200d530:	88801415 	stw	r2,80(r17)
 200d534:	003fd206 	br	200d480 <__reset+0xfe00c480>
 200d538:	28c00f17 	ldw	r3,60(r5)
 200d53c:	00ffb316 	blt	zero,r3,200d40c <__reset+0xfe00c40c>
 200d540:	003fd706 	br	200d4a0 <__reset+0xfe00c4a0>
 200d544:	89400717 	ldw	r5,28(r17)
 200d548:	000d883a 	mov	r6,zero
 200d54c:	01c00044 	movi	r7,1
 200d550:	9809883a 	mov	r4,r19
 200d554:	403ee83a 	callr	r8
 200d558:	100d883a 	mov	r6,r2
 200d55c:	00bfffc4 	movi	r2,-1
 200d560:	30801426 	beq	r6,r2,200d5b4 <__sflush_r+0x1e4>
 200d564:	8880030b 	ldhu	r2,12(r17)
 200d568:	8a000a17 	ldw	r8,40(r17)
 200d56c:	003fae06 	br	200d428 <__reset+0xfe00c428>
 200d570:	98c00017 	ldw	r3,0(r19)
 200d574:	183fba26 	beq	r3,zero,200d460 <__reset+0xfe00c460>
 200d578:	01000744 	movi	r4,29
 200d57c:	19000626 	beq	r3,r4,200d598 <__sflush_r+0x1c8>
 200d580:	01000584 	movi	r4,22
 200d584:	19000426 	beq	r3,r4,200d598 <__sflush_r+0x1c8>
 200d588:	88c0030b 	ldhu	r3,12(r17)
 200d58c:	18c01014 	ori	r3,r3,64
 200d590:	88c0030d 	sth	r3,12(r17)
 200d594:	003fc306 	br	200d4a4 <__reset+0xfe00c4a4>
 200d598:	8880030b 	ldhu	r2,12(r17)
 200d59c:	88c00417 	ldw	r3,16(r17)
 200d5a0:	88000115 	stw	zero,4(r17)
 200d5a4:	10bdffcc 	andi	r2,r2,63487
 200d5a8:	8880030d 	sth	r2,12(r17)
 200d5ac:	88c00015 	stw	r3,0(r17)
 200d5b0:	003fb306 	br	200d480 <__reset+0xfe00c480>
 200d5b4:	98800017 	ldw	r2,0(r19)
 200d5b8:	103fea26 	beq	r2,zero,200d564 <__reset+0xfe00c564>
 200d5bc:	00c00744 	movi	r3,29
 200d5c0:	10c00226 	beq	r2,r3,200d5cc <__sflush_r+0x1fc>
 200d5c4:	00c00584 	movi	r3,22
 200d5c8:	10c0031e 	bne	r2,r3,200d5d8 <__sflush_r+0x208>
 200d5cc:	9c000015 	stw	r16,0(r19)
 200d5d0:	0005883a 	mov	r2,zero
 200d5d4:	003fb306 	br	200d4a4 <__reset+0xfe00c4a4>
 200d5d8:	88c0030b 	ldhu	r3,12(r17)
 200d5dc:	3005883a 	mov	r2,r6
 200d5e0:	18c01014 	ori	r3,r3,64
 200d5e4:	88c0030d 	sth	r3,12(r17)
 200d5e8:	003fae06 	br	200d4a4 <__reset+0xfe00c4a4>

0200d5ec <_fflush_r>:
 200d5ec:	defffd04 	addi	sp,sp,-12
 200d5f0:	dc000115 	stw	r16,4(sp)
 200d5f4:	dfc00215 	stw	ra,8(sp)
 200d5f8:	2021883a 	mov	r16,r4
 200d5fc:	20000226 	beq	r4,zero,200d608 <_fflush_r+0x1c>
 200d600:	20800e17 	ldw	r2,56(r4)
 200d604:	10000c26 	beq	r2,zero,200d638 <_fflush_r+0x4c>
 200d608:	2880030f 	ldh	r2,12(r5)
 200d60c:	1000051e 	bne	r2,zero,200d624 <_fflush_r+0x38>
 200d610:	0005883a 	mov	r2,zero
 200d614:	dfc00217 	ldw	ra,8(sp)
 200d618:	dc000117 	ldw	r16,4(sp)
 200d61c:	dec00304 	addi	sp,sp,12
 200d620:	f800283a 	ret
 200d624:	8009883a 	mov	r4,r16
 200d628:	dfc00217 	ldw	ra,8(sp)
 200d62c:	dc000117 	ldw	r16,4(sp)
 200d630:	dec00304 	addi	sp,sp,12
 200d634:	200d3d01 	jmpi	200d3d0 <__sflush_r>
 200d638:	d9400015 	stw	r5,0(sp)
 200d63c:	200b8e40 	call	200b8e4 <__sinit>
 200d640:	d9400017 	ldw	r5,0(sp)
 200d644:	003ff006 	br	200d608 <__reset+0xfe00c608>

0200d648 <fflush>:
 200d648:	20000526 	beq	r4,zero,200d660 <fflush+0x18>
 200d64c:	00808074 	movhi	r2,513
 200d650:	1090b904 	addi	r2,r2,17124
 200d654:	200b883a 	mov	r5,r4
 200d658:	11000017 	ldw	r4,0(r2)
 200d65c:	200d5ec1 	jmpi	200d5ec <_fflush_r>
 200d660:	00808074 	movhi	r2,513
 200d664:	1090b804 	addi	r2,r2,17120
 200d668:	11000017 	ldw	r4,0(r2)
 200d66c:	01408074 	movhi	r5,513
 200d670:	29757b04 	addi	r5,r5,-10772
 200d674:	200bec01 	jmpi	200bec0 <_fwalk_reent>

0200d678 <_malloc_trim_r>:
 200d678:	defffb04 	addi	sp,sp,-20
 200d67c:	dcc00315 	stw	r19,12(sp)
 200d680:	04c08074 	movhi	r19,513
 200d684:	dc800215 	stw	r18,8(sp)
 200d688:	dc400115 	stw	r17,4(sp)
 200d68c:	dc000015 	stw	r16,0(sp)
 200d690:	dfc00415 	stw	ra,16(sp)
 200d694:	2821883a 	mov	r16,r5
 200d698:	9cca4c04 	addi	r19,r19,10544
 200d69c:	2025883a 	mov	r18,r4
 200d6a0:	200e4380 	call	200e438 <__malloc_lock>
 200d6a4:	98800217 	ldw	r2,8(r19)
 200d6a8:	14400117 	ldw	r17,4(r2)
 200d6ac:	00bfff04 	movi	r2,-4
 200d6b0:	88a2703a 	and	r17,r17,r2
 200d6b4:	8c21c83a 	sub	r16,r17,r16
 200d6b8:	8403fbc4 	addi	r16,r16,4079
 200d6bc:	8020d33a 	srli	r16,r16,12
 200d6c0:	0083ffc4 	movi	r2,4095
 200d6c4:	843fffc4 	addi	r16,r16,-1
 200d6c8:	8020933a 	slli	r16,r16,12
 200d6cc:	1400060e 	bge	r2,r16,200d6e8 <_malloc_trim_r+0x70>
 200d6d0:	000b883a 	mov	r5,zero
 200d6d4:	9009883a 	mov	r4,r18
 200d6d8:	200cf340 	call	200cf34 <_sbrk_r>
 200d6dc:	98c00217 	ldw	r3,8(r19)
 200d6e0:	1c47883a 	add	r3,r3,r17
 200d6e4:	10c00a26 	beq	r2,r3,200d710 <_malloc_trim_r+0x98>
 200d6e8:	9009883a 	mov	r4,r18
 200d6ec:	200e45c0 	call	200e45c <__malloc_unlock>
 200d6f0:	0005883a 	mov	r2,zero
 200d6f4:	dfc00417 	ldw	ra,16(sp)
 200d6f8:	dcc00317 	ldw	r19,12(sp)
 200d6fc:	dc800217 	ldw	r18,8(sp)
 200d700:	dc400117 	ldw	r17,4(sp)
 200d704:	dc000017 	ldw	r16,0(sp)
 200d708:	dec00504 	addi	sp,sp,20
 200d70c:	f800283a 	ret
 200d710:	040bc83a 	sub	r5,zero,r16
 200d714:	9009883a 	mov	r4,r18
 200d718:	200cf340 	call	200cf34 <_sbrk_r>
 200d71c:	00ffffc4 	movi	r3,-1
 200d720:	10c00d26 	beq	r2,r3,200d758 <_malloc_trim_r+0xe0>
 200d724:	00c0a074 	movhi	r3,641
 200d728:	18d17504 	addi	r3,r3,17876
 200d72c:	18800017 	ldw	r2,0(r3)
 200d730:	99000217 	ldw	r4,8(r19)
 200d734:	8c23c83a 	sub	r17,r17,r16
 200d738:	8c400054 	ori	r17,r17,1
 200d73c:	1421c83a 	sub	r16,r2,r16
 200d740:	24400115 	stw	r17,4(r4)
 200d744:	9009883a 	mov	r4,r18
 200d748:	1c000015 	stw	r16,0(r3)
 200d74c:	200e45c0 	call	200e45c <__malloc_unlock>
 200d750:	00800044 	movi	r2,1
 200d754:	003fe706 	br	200d6f4 <__reset+0xfe00c6f4>
 200d758:	000b883a 	mov	r5,zero
 200d75c:	9009883a 	mov	r4,r18
 200d760:	200cf340 	call	200cf34 <_sbrk_r>
 200d764:	99000217 	ldw	r4,8(r19)
 200d768:	014003c4 	movi	r5,15
 200d76c:	1107c83a 	sub	r3,r2,r4
 200d770:	28ffdd0e 	bge	r5,r3,200d6e8 <__reset+0xfe00c6e8>
 200d774:	01408074 	movhi	r5,513
 200d778:	2950ba04 	addi	r5,r5,17128
 200d77c:	29400017 	ldw	r5,0(r5)
 200d780:	18c00054 	ori	r3,r3,1
 200d784:	20c00115 	stw	r3,4(r4)
 200d788:	00c0a074 	movhi	r3,641
 200d78c:	1145c83a 	sub	r2,r2,r5
 200d790:	18d17504 	addi	r3,r3,17876
 200d794:	18800015 	stw	r2,0(r3)
 200d798:	003fd306 	br	200d6e8 <__reset+0xfe00c6e8>

0200d79c <_free_r>:
 200d79c:	28004126 	beq	r5,zero,200d8a4 <_free_r+0x108>
 200d7a0:	defffd04 	addi	sp,sp,-12
 200d7a4:	dc400115 	stw	r17,4(sp)
 200d7a8:	dc000015 	stw	r16,0(sp)
 200d7ac:	2023883a 	mov	r17,r4
 200d7b0:	2821883a 	mov	r16,r5
 200d7b4:	dfc00215 	stw	ra,8(sp)
 200d7b8:	200e4380 	call	200e438 <__malloc_lock>
 200d7bc:	81ffff17 	ldw	r7,-4(r16)
 200d7c0:	00bfff84 	movi	r2,-2
 200d7c4:	01008074 	movhi	r4,513
 200d7c8:	81bffe04 	addi	r6,r16,-8
 200d7cc:	3884703a 	and	r2,r7,r2
 200d7d0:	210a4c04 	addi	r4,r4,10544
 200d7d4:	308b883a 	add	r5,r6,r2
 200d7d8:	2a400117 	ldw	r9,4(r5)
 200d7dc:	22000217 	ldw	r8,8(r4)
 200d7e0:	00ffff04 	movi	r3,-4
 200d7e4:	48c6703a 	and	r3,r9,r3
 200d7e8:	2a005726 	beq	r5,r8,200d948 <_free_r+0x1ac>
 200d7ec:	28c00115 	stw	r3,4(r5)
 200d7f0:	39c0004c 	andi	r7,r7,1
 200d7f4:	3800091e 	bne	r7,zero,200d81c <_free_r+0x80>
 200d7f8:	823ffe17 	ldw	r8,-8(r16)
 200d7fc:	22400204 	addi	r9,r4,8
 200d800:	320dc83a 	sub	r6,r6,r8
 200d804:	31c00217 	ldw	r7,8(r6)
 200d808:	1205883a 	add	r2,r2,r8
 200d80c:	3a406526 	beq	r7,r9,200d9a4 <_free_r+0x208>
 200d810:	32000317 	ldw	r8,12(r6)
 200d814:	3a000315 	stw	r8,12(r7)
 200d818:	41c00215 	stw	r7,8(r8)
 200d81c:	28cf883a 	add	r7,r5,r3
 200d820:	39c00117 	ldw	r7,4(r7)
 200d824:	39c0004c 	andi	r7,r7,1
 200d828:	38003a26 	beq	r7,zero,200d914 <_free_r+0x178>
 200d82c:	10c00054 	ori	r3,r2,1
 200d830:	30c00115 	stw	r3,4(r6)
 200d834:	3087883a 	add	r3,r6,r2
 200d838:	18800015 	stw	r2,0(r3)
 200d83c:	00c07fc4 	movi	r3,511
 200d840:	18801936 	bltu	r3,r2,200d8a8 <_free_r+0x10c>
 200d844:	1004d0fa 	srli	r2,r2,3
 200d848:	01c00044 	movi	r7,1
 200d84c:	21400117 	ldw	r5,4(r4)
 200d850:	10c00044 	addi	r3,r2,1
 200d854:	18c7883a 	add	r3,r3,r3
 200d858:	1005d0ba 	srai	r2,r2,2
 200d85c:	18c7883a 	add	r3,r3,r3
 200d860:	18c7883a 	add	r3,r3,r3
 200d864:	1907883a 	add	r3,r3,r4
 200d868:	3884983a 	sll	r2,r7,r2
 200d86c:	19c00017 	ldw	r7,0(r3)
 200d870:	1a3ffe04 	addi	r8,r3,-8
 200d874:	1144b03a 	or	r2,r2,r5
 200d878:	32000315 	stw	r8,12(r6)
 200d87c:	31c00215 	stw	r7,8(r6)
 200d880:	20800115 	stw	r2,4(r4)
 200d884:	19800015 	stw	r6,0(r3)
 200d888:	39800315 	stw	r6,12(r7)
 200d88c:	8809883a 	mov	r4,r17
 200d890:	dfc00217 	ldw	ra,8(sp)
 200d894:	dc400117 	ldw	r17,4(sp)
 200d898:	dc000017 	ldw	r16,0(sp)
 200d89c:	dec00304 	addi	sp,sp,12
 200d8a0:	200e45c1 	jmpi	200e45c <__malloc_unlock>
 200d8a4:	f800283a 	ret
 200d8a8:	100ad27a 	srli	r5,r2,9
 200d8ac:	00c00104 	movi	r3,4
 200d8b0:	19404a36 	bltu	r3,r5,200d9dc <_free_r+0x240>
 200d8b4:	100ad1ba 	srli	r5,r2,6
 200d8b8:	28c00e44 	addi	r3,r5,57
 200d8bc:	18c7883a 	add	r3,r3,r3
 200d8c0:	29400e04 	addi	r5,r5,56
 200d8c4:	18c7883a 	add	r3,r3,r3
 200d8c8:	18c7883a 	add	r3,r3,r3
 200d8cc:	1909883a 	add	r4,r3,r4
 200d8d0:	20c00017 	ldw	r3,0(r4)
 200d8d4:	01c08074 	movhi	r7,513
 200d8d8:	213ffe04 	addi	r4,r4,-8
 200d8dc:	39ca4c04 	addi	r7,r7,10544
 200d8e0:	20c04426 	beq	r4,r3,200d9f4 <_free_r+0x258>
 200d8e4:	01ffff04 	movi	r7,-4
 200d8e8:	19400117 	ldw	r5,4(r3)
 200d8ec:	29ca703a 	and	r5,r5,r7
 200d8f0:	1140022e 	bgeu	r2,r5,200d8fc <_free_r+0x160>
 200d8f4:	18c00217 	ldw	r3,8(r3)
 200d8f8:	20fffb1e 	bne	r4,r3,200d8e8 <__reset+0xfe00c8e8>
 200d8fc:	19000317 	ldw	r4,12(r3)
 200d900:	31000315 	stw	r4,12(r6)
 200d904:	30c00215 	stw	r3,8(r6)
 200d908:	21800215 	stw	r6,8(r4)
 200d90c:	19800315 	stw	r6,12(r3)
 200d910:	003fde06 	br	200d88c <__reset+0xfe00c88c>
 200d914:	29c00217 	ldw	r7,8(r5)
 200d918:	10c5883a 	add	r2,r2,r3
 200d91c:	00c08074 	movhi	r3,513
 200d920:	18ca4e04 	addi	r3,r3,10552
 200d924:	38c03b26 	beq	r7,r3,200da14 <_free_r+0x278>
 200d928:	2a000317 	ldw	r8,12(r5)
 200d92c:	11400054 	ori	r5,r2,1
 200d930:	3087883a 	add	r3,r6,r2
 200d934:	3a000315 	stw	r8,12(r7)
 200d938:	41c00215 	stw	r7,8(r8)
 200d93c:	31400115 	stw	r5,4(r6)
 200d940:	18800015 	stw	r2,0(r3)
 200d944:	003fbd06 	br	200d83c <__reset+0xfe00c83c>
 200d948:	39c0004c 	andi	r7,r7,1
 200d94c:	10c5883a 	add	r2,r2,r3
 200d950:	3800071e 	bne	r7,zero,200d970 <_free_r+0x1d4>
 200d954:	81fffe17 	ldw	r7,-8(r16)
 200d958:	31cdc83a 	sub	r6,r6,r7
 200d95c:	30c00317 	ldw	r3,12(r6)
 200d960:	31400217 	ldw	r5,8(r6)
 200d964:	11c5883a 	add	r2,r2,r7
 200d968:	28c00315 	stw	r3,12(r5)
 200d96c:	19400215 	stw	r5,8(r3)
 200d970:	10c00054 	ori	r3,r2,1
 200d974:	30c00115 	stw	r3,4(r6)
 200d978:	00c08074 	movhi	r3,513
 200d97c:	18d0bb04 	addi	r3,r3,17132
 200d980:	18c00017 	ldw	r3,0(r3)
 200d984:	21800215 	stw	r6,8(r4)
 200d988:	10ffc036 	bltu	r2,r3,200d88c <__reset+0xfe00c88c>
 200d98c:	00808074 	movhi	r2,513
 200d990:	10913304 	addi	r2,r2,17612
 200d994:	11400017 	ldw	r5,0(r2)
 200d998:	8809883a 	mov	r4,r17
 200d99c:	200d6780 	call	200d678 <_malloc_trim_r>
 200d9a0:	003fba06 	br	200d88c <__reset+0xfe00c88c>
 200d9a4:	28c9883a 	add	r4,r5,r3
 200d9a8:	21000117 	ldw	r4,4(r4)
 200d9ac:	2100004c 	andi	r4,r4,1
 200d9b0:	2000391e 	bne	r4,zero,200da98 <_free_r+0x2fc>
 200d9b4:	29c00217 	ldw	r7,8(r5)
 200d9b8:	29000317 	ldw	r4,12(r5)
 200d9bc:	1885883a 	add	r2,r3,r2
 200d9c0:	10c00054 	ori	r3,r2,1
 200d9c4:	39000315 	stw	r4,12(r7)
 200d9c8:	21c00215 	stw	r7,8(r4)
 200d9cc:	30c00115 	stw	r3,4(r6)
 200d9d0:	308d883a 	add	r6,r6,r2
 200d9d4:	30800015 	stw	r2,0(r6)
 200d9d8:	003fac06 	br	200d88c <__reset+0xfe00c88c>
 200d9dc:	00c00504 	movi	r3,20
 200d9e0:	19401536 	bltu	r3,r5,200da38 <_free_r+0x29c>
 200d9e4:	28c01704 	addi	r3,r5,92
 200d9e8:	18c7883a 	add	r3,r3,r3
 200d9ec:	294016c4 	addi	r5,r5,91
 200d9f0:	003fb406 	br	200d8c4 <__reset+0xfe00c8c4>
 200d9f4:	280bd0ba 	srai	r5,r5,2
 200d9f8:	00c00044 	movi	r3,1
 200d9fc:	38800117 	ldw	r2,4(r7)
 200da00:	194a983a 	sll	r5,r3,r5
 200da04:	2007883a 	mov	r3,r4
 200da08:	2884b03a 	or	r2,r5,r2
 200da0c:	38800115 	stw	r2,4(r7)
 200da10:	003fbb06 	br	200d900 <__reset+0xfe00c900>
 200da14:	21800515 	stw	r6,20(r4)
 200da18:	21800415 	stw	r6,16(r4)
 200da1c:	10c00054 	ori	r3,r2,1
 200da20:	31c00315 	stw	r7,12(r6)
 200da24:	31c00215 	stw	r7,8(r6)
 200da28:	30c00115 	stw	r3,4(r6)
 200da2c:	308d883a 	add	r6,r6,r2
 200da30:	30800015 	stw	r2,0(r6)
 200da34:	003f9506 	br	200d88c <__reset+0xfe00c88c>
 200da38:	00c01504 	movi	r3,84
 200da3c:	19400536 	bltu	r3,r5,200da54 <_free_r+0x2b8>
 200da40:	100ad33a 	srli	r5,r2,12
 200da44:	28c01bc4 	addi	r3,r5,111
 200da48:	18c7883a 	add	r3,r3,r3
 200da4c:	29401b84 	addi	r5,r5,110
 200da50:	003f9c06 	br	200d8c4 <__reset+0xfe00c8c4>
 200da54:	00c05504 	movi	r3,340
 200da58:	19400536 	bltu	r3,r5,200da70 <_free_r+0x2d4>
 200da5c:	100ad3fa 	srli	r5,r2,15
 200da60:	28c01e04 	addi	r3,r5,120
 200da64:	18c7883a 	add	r3,r3,r3
 200da68:	29401dc4 	addi	r5,r5,119
 200da6c:	003f9506 	br	200d8c4 <__reset+0xfe00c8c4>
 200da70:	00c15504 	movi	r3,1364
 200da74:	19400536 	bltu	r3,r5,200da8c <_free_r+0x2f0>
 200da78:	100ad4ba 	srli	r5,r2,18
 200da7c:	28c01f44 	addi	r3,r5,125
 200da80:	18c7883a 	add	r3,r3,r3
 200da84:	29401f04 	addi	r5,r5,124
 200da88:	003f8e06 	br	200d8c4 <__reset+0xfe00c8c4>
 200da8c:	00c03f84 	movi	r3,254
 200da90:	01401f84 	movi	r5,126
 200da94:	003f8b06 	br	200d8c4 <__reset+0xfe00c8c4>
 200da98:	10c00054 	ori	r3,r2,1
 200da9c:	30c00115 	stw	r3,4(r6)
 200daa0:	308d883a 	add	r6,r6,r2
 200daa4:	30800015 	stw	r2,0(r6)
 200daa8:	003f7806 	br	200d88c <__reset+0xfe00c88c>

0200daac <_lseek_r>:
 200daac:	defffd04 	addi	sp,sp,-12
 200dab0:	2805883a 	mov	r2,r5
 200dab4:	dc000015 	stw	r16,0(sp)
 200dab8:	04008074 	movhi	r16,513
 200dabc:	dc400115 	stw	r17,4(sp)
 200dac0:	300b883a 	mov	r5,r6
 200dac4:	84113404 	addi	r16,r16,17616
 200dac8:	2023883a 	mov	r17,r4
 200dacc:	380d883a 	mov	r6,r7
 200dad0:	1009883a 	mov	r4,r2
 200dad4:	dfc00215 	stw	ra,8(sp)
 200dad8:	80000015 	stw	zero,0(r16)
 200dadc:	200e2e00 	call	200e2e0 <lseek>
 200dae0:	00ffffc4 	movi	r3,-1
 200dae4:	10c00526 	beq	r2,r3,200dafc <_lseek_r+0x50>
 200dae8:	dfc00217 	ldw	ra,8(sp)
 200daec:	dc400117 	ldw	r17,4(sp)
 200daf0:	dc000017 	ldw	r16,0(sp)
 200daf4:	dec00304 	addi	sp,sp,12
 200daf8:	f800283a 	ret
 200dafc:	80c00017 	ldw	r3,0(r16)
 200db00:	183ff926 	beq	r3,zero,200dae8 <__reset+0xfe00cae8>
 200db04:	88c00015 	stw	r3,0(r17)
 200db08:	003ff706 	br	200dae8 <__reset+0xfe00cae8>

0200db0c <__smakebuf_r>:
 200db0c:	2880030b 	ldhu	r2,12(r5)
 200db10:	10c0008c 	andi	r3,r2,2
 200db14:	1800411e 	bne	r3,zero,200dc1c <__smakebuf_r+0x110>
 200db18:	deffec04 	addi	sp,sp,-80
 200db1c:	dc000f15 	stw	r16,60(sp)
 200db20:	2821883a 	mov	r16,r5
 200db24:	2940038f 	ldh	r5,14(r5)
 200db28:	dc401015 	stw	r17,64(sp)
 200db2c:	dfc01315 	stw	ra,76(sp)
 200db30:	dcc01215 	stw	r19,72(sp)
 200db34:	dc801115 	stw	r18,68(sp)
 200db38:	2023883a 	mov	r17,r4
 200db3c:	28001c16 	blt	r5,zero,200dbb0 <__smakebuf_r+0xa4>
 200db40:	d80d883a 	mov	r6,sp
 200db44:	200dd280 	call	200dd28 <_fstat_r>
 200db48:	10001816 	blt	r2,zero,200dbac <__smakebuf_r+0xa0>
 200db4c:	d8800117 	ldw	r2,4(sp)
 200db50:	00e00014 	movui	r3,32768
 200db54:	10bc000c 	andi	r2,r2,61440
 200db58:	14c80020 	cmpeqi	r19,r2,8192
 200db5c:	10c03726 	beq	r2,r3,200dc3c <__smakebuf_r+0x130>
 200db60:	80c0030b 	ldhu	r3,12(r16)
 200db64:	18c20014 	ori	r3,r3,2048
 200db68:	80c0030d 	sth	r3,12(r16)
 200db6c:	00c80004 	movi	r3,8192
 200db70:	10c0521e 	bne	r2,r3,200dcbc <__smakebuf_r+0x1b0>
 200db74:	8140038f 	ldh	r5,14(r16)
 200db78:	8809883a 	mov	r4,r17
 200db7c:	200dd840 	call	200dd84 <_isatty_r>
 200db80:	10004c26 	beq	r2,zero,200dcb4 <__smakebuf_r+0x1a8>
 200db84:	8080030b 	ldhu	r2,12(r16)
 200db88:	80c010c4 	addi	r3,r16,67
 200db8c:	80c00015 	stw	r3,0(r16)
 200db90:	10800054 	ori	r2,r2,1
 200db94:	8080030d 	sth	r2,12(r16)
 200db98:	00800044 	movi	r2,1
 200db9c:	80c00415 	stw	r3,16(r16)
 200dba0:	80800515 	stw	r2,20(r16)
 200dba4:	04810004 	movi	r18,1024
 200dba8:	00000706 	br	200dbc8 <__smakebuf_r+0xbc>
 200dbac:	8080030b 	ldhu	r2,12(r16)
 200dbb0:	10c0200c 	andi	r3,r2,128
 200dbb4:	18001f1e 	bne	r3,zero,200dc34 <__smakebuf_r+0x128>
 200dbb8:	04810004 	movi	r18,1024
 200dbbc:	10820014 	ori	r2,r2,2048
 200dbc0:	8080030d 	sth	r2,12(r16)
 200dbc4:	0027883a 	mov	r19,zero
 200dbc8:	900b883a 	mov	r5,r18
 200dbcc:	8809883a 	mov	r4,r17
 200dbd0:	200bf840 	call	200bf84 <_malloc_r>
 200dbd4:	10002c26 	beq	r2,zero,200dc88 <__smakebuf_r+0x17c>
 200dbd8:	80c0030b 	ldhu	r3,12(r16)
 200dbdc:	01008074 	movhi	r4,513
 200dbe0:	212d6304 	addi	r4,r4,-19060
 200dbe4:	89000f15 	stw	r4,60(r17)
 200dbe8:	18c02014 	ori	r3,r3,128
 200dbec:	80c0030d 	sth	r3,12(r16)
 200dbf0:	80800015 	stw	r2,0(r16)
 200dbf4:	80800415 	stw	r2,16(r16)
 200dbf8:	84800515 	stw	r18,20(r16)
 200dbfc:	98001a1e 	bne	r19,zero,200dc68 <__smakebuf_r+0x15c>
 200dc00:	dfc01317 	ldw	ra,76(sp)
 200dc04:	dcc01217 	ldw	r19,72(sp)
 200dc08:	dc801117 	ldw	r18,68(sp)
 200dc0c:	dc401017 	ldw	r17,64(sp)
 200dc10:	dc000f17 	ldw	r16,60(sp)
 200dc14:	dec01404 	addi	sp,sp,80
 200dc18:	f800283a 	ret
 200dc1c:	288010c4 	addi	r2,r5,67
 200dc20:	28800015 	stw	r2,0(r5)
 200dc24:	28800415 	stw	r2,16(r5)
 200dc28:	00800044 	movi	r2,1
 200dc2c:	28800515 	stw	r2,20(r5)
 200dc30:	f800283a 	ret
 200dc34:	04801004 	movi	r18,64
 200dc38:	003fe006 	br	200dbbc <__reset+0xfe00cbbc>
 200dc3c:	81000a17 	ldw	r4,40(r16)
 200dc40:	00c08074 	movhi	r3,513
 200dc44:	18f41804 	addi	r3,r3,-12192
 200dc48:	20ffc51e 	bne	r4,r3,200db60 <__reset+0xfe00cb60>
 200dc4c:	8080030b 	ldhu	r2,12(r16)
 200dc50:	04810004 	movi	r18,1024
 200dc54:	84801315 	stw	r18,76(r16)
 200dc58:	1484b03a 	or	r2,r2,r18
 200dc5c:	8080030d 	sth	r2,12(r16)
 200dc60:	0027883a 	mov	r19,zero
 200dc64:	003fd806 	br	200dbc8 <__reset+0xfe00cbc8>
 200dc68:	8140038f 	ldh	r5,14(r16)
 200dc6c:	8809883a 	mov	r4,r17
 200dc70:	200dd840 	call	200dd84 <_isatty_r>
 200dc74:	103fe226 	beq	r2,zero,200dc00 <__reset+0xfe00cc00>
 200dc78:	8080030b 	ldhu	r2,12(r16)
 200dc7c:	10800054 	ori	r2,r2,1
 200dc80:	8080030d 	sth	r2,12(r16)
 200dc84:	003fde06 	br	200dc00 <__reset+0xfe00cc00>
 200dc88:	8080030b 	ldhu	r2,12(r16)
 200dc8c:	10c0800c 	andi	r3,r2,512
 200dc90:	183fdb1e 	bne	r3,zero,200dc00 <__reset+0xfe00cc00>
 200dc94:	10800094 	ori	r2,r2,2
 200dc98:	80c010c4 	addi	r3,r16,67
 200dc9c:	8080030d 	sth	r2,12(r16)
 200dca0:	00800044 	movi	r2,1
 200dca4:	80c00015 	stw	r3,0(r16)
 200dca8:	80c00415 	stw	r3,16(r16)
 200dcac:	80800515 	stw	r2,20(r16)
 200dcb0:	003fd306 	br	200dc00 <__reset+0xfe00cc00>
 200dcb4:	04810004 	movi	r18,1024
 200dcb8:	003fc306 	br	200dbc8 <__reset+0xfe00cbc8>
 200dcbc:	0027883a 	mov	r19,zero
 200dcc0:	04810004 	movi	r18,1024
 200dcc4:	003fc006 	br	200dbc8 <__reset+0xfe00cbc8>

0200dcc8 <_read_r>:
 200dcc8:	defffd04 	addi	sp,sp,-12
 200dccc:	2805883a 	mov	r2,r5
 200dcd0:	dc000015 	stw	r16,0(sp)
 200dcd4:	04008074 	movhi	r16,513
 200dcd8:	dc400115 	stw	r17,4(sp)
 200dcdc:	300b883a 	mov	r5,r6
 200dce0:	84113404 	addi	r16,r16,17616
 200dce4:	2023883a 	mov	r17,r4
 200dce8:	380d883a 	mov	r6,r7
 200dcec:	1009883a 	mov	r4,r2
 200dcf0:	dfc00215 	stw	ra,8(sp)
 200dcf4:	80000015 	stw	zero,0(r16)
 200dcf8:	200e4bc0 	call	200e4bc <read>
 200dcfc:	00ffffc4 	movi	r3,-1
 200dd00:	10c00526 	beq	r2,r3,200dd18 <_read_r+0x50>
 200dd04:	dfc00217 	ldw	ra,8(sp)
 200dd08:	dc400117 	ldw	r17,4(sp)
 200dd0c:	dc000017 	ldw	r16,0(sp)
 200dd10:	dec00304 	addi	sp,sp,12
 200dd14:	f800283a 	ret
 200dd18:	80c00017 	ldw	r3,0(r16)
 200dd1c:	183ff926 	beq	r3,zero,200dd04 <__reset+0xfe00cd04>
 200dd20:	88c00015 	stw	r3,0(r17)
 200dd24:	003ff706 	br	200dd04 <__reset+0xfe00cd04>

0200dd28 <_fstat_r>:
 200dd28:	defffd04 	addi	sp,sp,-12
 200dd2c:	2805883a 	mov	r2,r5
 200dd30:	dc000015 	stw	r16,0(sp)
 200dd34:	04008074 	movhi	r16,513
 200dd38:	dc400115 	stw	r17,4(sp)
 200dd3c:	84113404 	addi	r16,r16,17616
 200dd40:	2023883a 	mov	r17,r4
 200dd44:	300b883a 	mov	r5,r6
 200dd48:	1009883a 	mov	r4,r2
 200dd4c:	dfc00215 	stw	ra,8(sp)
 200dd50:	80000015 	stw	zero,0(r16)
 200dd54:	200df540 	call	200df54 <fstat>
 200dd58:	00ffffc4 	movi	r3,-1
 200dd5c:	10c00526 	beq	r2,r3,200dd74 <_fstat_r+0x4c>
 200dd60:	dfc00217 	ldw	ra,8(sp)
 200dd64:	dc400117 	ldw	r17,4(sp)
 200dd68:	dc000017 	ldw	r16,0(sp)
 200dd6c:	dec00304 	addi	sp,sp,12
 200dd70:	f800283a 	ret
 200dd74:	80c00017 	ldw	r3,0(r16)
 200dd78:	183ff926 	beq	r3,zero,200dd60 <__reset+0xfe00cd60>
 200dd7c:	88c00015 	stw	r3,0(r17)
 200dd80:	003ff706 	br	200dd60 <__reset+0xfe00cd60>

0200dd84 <_isatty_r>:
 200dd84:	defffd04 	addi	sp,sp,-12
 200dd88:	dc000015 	stw	r16,0(sp)
 200dd8c:	04008074 	movhi	r16,513
 200dd90:	dc400115 	stw	r17,4(sp)
 200dd94:	84113404 	addi	r16,r16,17616
 200dd98:	2023883a 	mov	r17,r4
 200dd9c:	2809883a 	mov	r4,r5
 200dda0:	dfc00215 	stw	ra,8(sp)
 200dda4:	80000015 	stw	zero,0(r16)
 200dda8:	200e1f80 	call	200e1f8 <isatty>
 200ddac:	00ffffc4 	movi	r3,-1
 200ddb0:	10c00526 	beq	r2,r3,200ddc8 <_isatty_r+0x44>
 200ddb4:	dfc00217 	ldw	ra,8(sp)
 200ddb8:	dc400117 	ldw	r17,4(sp)
 200ddbc:	dc000017 	ldw	r16,0(sp)
 200ddc0:	dec00304 	addi	sp,sp,12
 200ddc4:	f800283a 	ret
 200ddc8:	80c00017 	ldw	r3,0(r16)
 200ddcc:	183ff926 	beq	r3,zero,200ddb4 <__reset+0xfe00cdb4>
 200ddd0:	88c00015 	stw	r3,0(r17)
 200ddd4:	003ff706 	br	200ddb4 <__reset+0xfe00cdb4>

0200ddd8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 200ddd8:	defffe04 	addi	sp,sp,-8
 200dddc:	dfc00115 	stw	ra,4(sp)
 200dde0:	df000015 	stw	fp,0(sp)
 200dde4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 200dde8:	d0a01a17 	ldw	r2,-32664(gp)
 200ddec:	10000326 	beq	r2,zero,200ddfc <alt_get_errno+0x24>
 200ddf0:	d0a01a17 	ldw	r2,-32664(gp)
 200ddf4:	103ee83a 	callr	r2
 200ddf8:	00000106 	br	200de00 <alt_get_errno+0x28>
 200ddfc:	d0a08d04 	addi	r2,gp,-32204
}
 200de00:	e037883a 	mov	sp,fp
 200de04:	dfc00117 	ldw	ra,4(sp)
 200de08:	df000017 	ldw	fp,0(sp)
 200de0c:	dec00204 	addi	sp,sp,8
 200de10:	f800283a 	ret

0200de14 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 200de14:	defffb04 	addi	sp,sp,-20
 200de18:	dfc00415 	stw	ra,16(sp)
 200de1c:	df000315 	stw	fp,12(sp)
 200de20:	df000304 	addi	fp,sp,12
 200de24:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 200de28:	e0bfff17 	ldw	r2,-4(fp)
 200de2c:	10000816 	blt	r2,zero,200de50 <close+0x3c>
 200de30:	01400304 	movi	r5,12
 200de34:	e13fff17 	ldw	r4,-4(fp)
 200de38:	2009bcc0 	call	2009bcc <__mulsi3>
 200de3c:	1007883a 	mov	r3,r2
 200de40:	00808074 	movhi	r2,513
 200de44:	108b5804 	addi	r2,r2,11616
 200de48:	1885883a 	add	r2,r3,r2
 200de4c:	00000106 	br	200de54 <close+0x40>
 200de50:	0005883a 	mov	r2,zero
 200de54:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 200de58:	e0bffd17 	ldw	r2,-12(fp)
 200de5c:	10001926 	beq	r2,zero,200dec4 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 200de60:	e0bffd17 	ldw	r2,-12(fp)
 200de64:	10800017 	ldw	r2,0(r2)
 200de68:	10800417 	ldw	r2,16(r2)
 200de6c:	10000626 	beq	r2,zero,200de88 <close+0x74>
 200de70:	e0bffd17 	ldw	r2,-12(fp)
 200de74:	10800017 	ldw	r2,0(r2)
 200de78:	10800417 	ldw	r2,16(r2)
 200de7c:	e13ffd17 	ldw	r4,-12(fp)
 200de80:	103ee83a 	callr	r2
 200de84:	00000106 	br	200de8c <close+0x78>
 200de88:	0005883a 	mov	r2,zero
 200de8c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 200de90:	e13fff17 	ldw	r4,-4(fp)
 200de94:	200e5c00 	call	200e5c0 <alt_release_fd>
    if (rval < 0)
 200de98:	e0bffe17 	ldw	r2,-8(fp)
 200de9c:	1000070e 	bge	r2,zero,200debc <close+0xa8>
    {
      ALT_ERRNO = -rval;
 200dea0:	200ddd80 	call	200ddd8 <alt_get_errno>
 200dea4:	1007883a 	mov	r3,r2
 200dea8:	e0bffe17 	ldw	r2,-8(fp)
 200deac:	0085c83a 	sub	r2,zero,r2
 200deb0:	18800015 	stw	r2,0(r3)
      return -1;
 200deb4:	00bfffc4 	movi	r2,-1
 200deb8:	00000706 	br	200ded8 <close+0xc4>
    }
    return 0;
 200debc:	0005883a 	mov	r2,zero
 200dec0:	00000506 	br	200ded8 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 200dec4:	200ddd80 	call	200ddd8 <alt_get_errno>
 200dec8:	1007883a 	mov	r3,r2
 200decc:	00801444 	movi	r2,81
 200ded0:	18800015 	stw	r2,0(r3)
    return -1;
 200ded4:	00bfffc4 	movi	r2,-1
  }
}
 200ded8:	e037883a 	mov	sp,fp
 200dedc:	dfc00117 	ldw	ra,4(sp)
 200dee0:	df000017 	ldw	fp,0(sp)
 200dee4:	dec00204 	addi	sp,sp,8
 200dee8:	f800283a 	ret

0200deec <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 200deec:	defffc04 	addi	sp,sp,-16
 200def0:	df000315 	stw	fp,12(sp)
 200def4:	df000304 	addi	fp,sp,12
 200def8:	e13ffd15 	stw	r4,-12(fp)
 200defc:	e17ffe15 	stw	r5,-8(fp)
 200df00:	e1bfff15 	stw	r6,-4(fp)
  return len;
 200df04:	e0bfff17 	ldw	r2,-4(fp)
}
 200df08:	e037883a 	mov	sp,fp
 200df0c:	df000017 	ldw	fp,0(sp)
 200df10:	dec00104 	addi	sp,sp,4
 200df14:	f800283a 	ret

0200df18 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 200df18:	defffe04 	addi	sp,sp,-8
 200df1c:	dfc00115 	stw	ra,4(sp)
 200df20:	df000015 	stw	fp,0(sp)
 200df24:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 200df28:	d0a01a17 	ldw	r2,-32664(gp)
 200df2c:	10000326 	beq	r2,zero,200df3c <alt_get_errno+0x24>
 200df30:	d0a01a17 	ldw	r2,-32664(gp)
 200df34:	103ee83a 	callr	r2
 200df38:	00000106 	br	200df40 <alt_get_errno+0x28>
 200df3c:	d0a08d04 	addi	r2,gp,-32204
}
 200df40:	e037883a 	mov	sp,fp
 200df44:	dfc00117 	ldw	ra,4(sp)
 200df48:	df000017 	ldw	fp,0(sp)
 200df4c:	dec00204 	addi	sp,sp,8
 200df50:	f800283a 	ret

0200df54 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 200df54:	defffb04 	addi	sp,sp,-20
 200df58:	dfc00415 	stw	ra,16(sp)
 200df5c:	df000315 	stw	fp,12(sp)
 200df60:	df000304 	addi	fp,sp,12
 200df64:	e13ffe15 	stw	r4,-8(fp)
 200df68:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 200df6c:	e0bffe17 	ldw	r2,-8(fp)
 200df70:	10000816 	blt	r2,zero,200df94 <fstat+0x40>
 200df74:	01400304 	movi	r5,12
 200df78:	e13ffe17 	ldw	r4,-8(fp)
 200df7c:	2009bcc0 	call	2009bcc <__mulsi3>
 200df80:	1007883a 	mov	r3,r2
 200df84:	00808074 	movhi	r2,513
 200df88:	108b5804 	addi	r2,r2,11616
 200df8c:	1885883a 	add	r2,r3,r2
 200df90:	00000106 	br	200df98 <fstat+0x44>
 200df94:	0005883a 	mov	r2,zero
 200df98:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 200df9c:	e0bffd17 	ldw	r2,-12(fp)
 200dfa0:	10001026 	beq	r2,zero,200dfe4 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 200dfa4:	e0bffd17 	ldw	r2,-12(fp)
 200dfa8:	10800017 	ldw	r2,0(r2)
 200dfac:	10800817 	ldw	r2,32(r2)
 200dfb0:	10000726 	beq	r2,zero,200dfd0 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
 200dfb4:	e0bffd17 	ldw	r2,-12(fp)
 200dfb8:	10800017 	ldw	r2,0(r2)
 200dfbc:	10800817 	ldw	r2,32(r2)
 200dfc0:	e17fff17 	ldw	r5,-4(fp)
 200dfc4:	e13ffd17 	ldw	r4,-12(fp)
 200dfc8:	103ee83a 	callr	r2
 200dfcc:	00000a06 	br	200dff8 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 200dfd0:	e0bfff17 	ldw	r2,-4(fp)
 200dfd4:	00c80004 	movi	r3,8192
 200dfd8:	10c00115 	stw	r3,4(r2)
      return 0;
 200dfdc:	0005883a 	mov	r2,zero
 200dfe0:	00000506 	br	200dff8 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 200dfe4:	200df180 	call	200df18 <alt_get_errno>
 200dfe8:	1007883a 	mov	r3,r2
 200dfec:	00801444 	movi	r2,81
 200dff0:	18800015 	stw	r2,0(r3)
    return -1;
 200dff4:	00bfffc4 	movi	r2,-1
  }
}
 200dff8:	e037883a 	mov	sp,fp
 200dffc:	dfc00117 	ldw	ra,4(sp)
 200e000:	df000017 	ldw	fp,0(sp)
 200e004:	dec00204 	addi	sp,sp,8
 200e008:	f800283a 	ret

0200e00c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 200e00c:	defff904 	addi	sp,sp,-28
 200e010:	dfc00615 	stw	ra,24(sp)
 200e014:	df000515 	stw	fp,20(sp)
 200e018:	df000504 	addi	fp,sp,20
 200e01c:	e13ffc15 	stw	r4,-16(fp)
 200e020:	e17ffd15 	stw	r5,-12(fp)
 200e024:	e1bffe15 	stw	r6,-8(fp)
 200e028:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 200e02c:	e0800217 	ldw	r2,8(fp)
 200e030:	d8800015 	stw	r2,0(sp)
 200e034:	e1ffff17 	ldw	r7,-4(fp)
 200e038:	e1bffe17 	ldw	r6,-8(fp)
 200e03c:	e17ffd17 	ldw	r5,-12(fp)
 200e040:	e13ffc17 	ldw	r4,-16(fp)
 200e044:	2003ea40 	call	2003ea4 <alt_iic_isr_register>
}  
 200e048:	e037883a 	mov	sp,fp
 200e04c:	dfc00117 	ldw	ra,4(sp)
 200e050:	df000017 	ldw	fp,0(sp)
 200e054:	dec00204 	addi	sp,sp,8
 200e058:	f800283a 	ret

0200e05c <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 200e05c:	defff904 	addi	sp,sp,-28
 200e060:	df000615 	stw	fp,24(sp)
 200e064:	df000604 	addi	fp,sp,24
 200e068:	e13ffe15 	stw	r4,-8(fp)
 200e06c:	e17fff15 	stw	r5,-4(fp)
 200e070:	e0bfff17 	ldw	r2,-4(fp)
 200e074:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 200e078:	0005303a 	rdctl	r2,status
 200e07c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 200e080:	e0fffb17 	ldw	r3,-20(fp)
 200e084:	00bfff84 	movi	r2,-2
 200e088:	1884703a 	and	r2,r3,r2
 200e08c:	1001703a 	wrctl	status,r2
  
  return context;
 200e090:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 200e094:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 200e098:	00c00044 	movi	r3,1
 200e09c:	e0bffa17 	ldw	r2,-24(fp)
 200e0a0:	1884983a 	sll	r2,r3,r2
 200e0a4:	1007883a 	mov	r3,r2
 200e0a8:	d0a08e17 	ldw	r2,-32200(gp)
 200e0ac:	1884b03a 	or	r2,r3,r2
 200e0b0:	d0a08e15 	stw	r2,-32200(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 200e0b4:	d0a08e17 	ldw	r2,-32200(gp)
 200e0b8:	100170fa 	wrctl	ienable,r2
 200e0bc:	e0bffc17 	ldw	r2,-16(fp)
 200e0c0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 200e0c4:	e0bffd17 	ldw	r2,-12(fp)
 200e0c8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 200e0cc:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 200e0d0:	0001883a 	nop
}
 200e0d4:	e037883a 	mov	sp,fp
 200e0d8:	df000017 	ldw	fp,0(sp)
 200e0dc:	dec00104 	addi	sp,sp,4
 200e0e0:	f800283a 	ret

0200e0e4 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 200e0e4:	defff904 	addi	sp,sp,-28
 200e0e8:	df000615 	stw	fp,24(sp)
 200e0ec:	df000604 	addi	fp,sp,24
 200e0f0:	e13ffe15 	stw	r4,-8(fp)
 200e0f4:	e17fff15 	stw	r5,-4(fp)
 200e0f8:	e0bfff17 	ldw	r2,-4(fp)
 200e0fc:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 200e100:	0005303a 	rdctl	r2,status
 200e104:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 200e108:	e0fffb17 	ldw	r3,-20(fp)
 200e10c:	00bfff84 	movi	r2,-2
 200e110:	1884703a 	and	r2,r3,r2
 200e114:	1001703a 	wrctl	status,r2
  
  return context;
 200e118:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 200e11c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 200e120:	00c00044 	movi	r3,1
 200e124:	e0bffa17 	ldw	r2,-24(fp)
 200e128:	1884983a 	sll	r2,r3,r2
 200e12c:	0084303a 	nor	r2,zero,r2
 200e130:	1007883a 	mov	r3,r2
 200e134:	d0a08e17 	ldw	r2,-32200(gp)
 200e138:	1884703a 	and	r2,r3,r2
 200e13c:	d0a08e15 	stw	r2,-32200(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 200e140:	d0a08e17 	ldw	r2,-32200(gp)
 200e144:	100170fa 	wrctl	ienable,r2
 200e148:	e0bffc17 	ldw	r2,-16(fp)
 200e14c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 200e150:	e0bffd17 	ldw	r2,-12(fp)
 200e154:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 200e158:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 200e15c:	0001883a 	nop
}
 200e160:	e037883a 	mov	sp,fp
 200e164:	df000017 	ldw	fp,0(sp)
 200e168:	dec00104 	addi	sp,sp,4
 200e16c:	f800283a 	ret

0200e170 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 200e170:	defffc04 	addi	sp,sp,-16
 200e174:	df000315 	stw	fp,12(sp)
 200e178:	df000304 	addi	fp,sp,12
 200e17c:	e13ffe15 	stw	r4,-8(fp)
 200e180:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 200e184:	000530fa 	rdctl	r2,ienable
 200e188:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 200e18c:	00c00044 	movi	r3,1
 200e190:	e0bfff17 	ldw	r2,-4(fp)
 200e194:	1884983a 	sll	r2,r3,r2
 200e198:	1007883a 	mov	r3,r2
 200e19c:	e0bffd17 	ldw	r2,-12(fp)
 200e1a0:	1884703a 	and	r2,r3,r2
 200e1a4:	1004c03a 	cmpne	r2,r2,zero
 200e1a8:	10803fcc 	andi	r2,r2,255
}
 200e1ac:	e037883a 	mov	sp,fp
 200e1b0:	df000017 	ldw	fp,0(sp)
 200e1b4:	dec00104 	addi	sp,sp,4
 200e1b8:	f800283a 	ret

0200e1bc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 200e1bc:	defffe04 	addi	sp,sp,-8
 200e1c0:	dfc00115 	stw	ra,4(sp)
 200e1c4:	df000015 	stw	fp,0(sp)
 200e1c8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 200e1cc:	d0a01a17 	ldw	r2,-32664(gp)
 200e1d0:	10000326 	beq	r2,zero,200e1e0 <alt_get_errno+0x24>
 200e1d4:	d0a01a17 	ldw	r2,-32664(gp)
 200e1d8:	103ee83a 	callr	r2
 200e1dc:	00000106 	br	200e1e4 <alt_get_errno+0x28>
 200e1e0:	d0a08d04 	addi	r2,gp,-32204
}
 200e1e4:	e037883a 	mov	sp,fp
 200e1e8:	dfc00117 	ldw	ra,4(sp)
 200e1ec:	df000017 	ldw	fp,0(sp)
 200e1f0:	dec00204 	addi	sp,sp,8
 200e1f4:	f800283a 	ret

0200e1f8 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 200e1f8:	deffed04 	addi	sp,sp,-76
 200e1fc:	dfc01215 	stw	ra,72(sp)
 200e200:	df001115 	stw	fp,68(sp)
 200e204:	df001104 	addi	fp,sp,68
 200e208:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 200e20c:	e0bfff17 	ldw	r2,-4(fp)
 200e210:	10000816 	blt	r2,zero,200e234 <isatty+0x3c>
 200e214:	01400304 	movi	r5,12
 200e218:	e13fff17 	ldw	r4,-4(fp)
 200e21c:	2009bcc0 	call	2009bcc <__mulsi3>
 200e220:	1007883a 	mov	r3,r2
 200e224:	00808074 	movhi	r2,513
 200e228:	108b5804 	addi	r2,r2,11616
 200e22c:	1885883a 	add	r2,r3,r2
 200e230:	00000106 	br	200e238 <isatty+0x40>
 200e234:	0005883a 	mov	r2,zero
 200e238:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 200e23c:	e0bfef17 	ldw	r2,-68(fp)
 200e240:	10000e26 	beq	r2,zero,200e27c <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 200e244:	e0bfef17 	ldw	r2,-68(fp)
 200e248:	10800017 	ldw	r2,0(r2)
 200e24c:	10800817 	ldw	r2,32(r2)
 200e250:	1000021e 	bne	r2,zero,200e25c <isatty+0x64>
    {
      return 1;
 200e254:	00800044 	movi	r2,1
 200e258:	00000d06 	br	200e290 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 200e25c:	e0bff004 	addi	r2,fp,-64
 200e260:	100b883a 	mov	r5,r2
 200e264:	e13fff17 	ldw	r4,-4(fp)
 200e268:	200df540 	call	200df54 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 200e26c:	e0bff117 	ldw	r2,-60(fp)
 200e270:	10880020 	cmpeqi	r2,r2,8192
 200e274:	10803fcc 	andi	r2,r2,255
 200e278:	00000506 	br	200e290 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 200e27c:	200e1bc0 	call	200e1bc <alt_get_errno>
 200e280:	1007883a 	mov	r3,r2
 200e284:	00801444 	movi	r2,81
 200e288:	18800015 	stw	r2,0(r3)
    return 0;
 200e28c:	0005883a 	mov	r2,zero
  }
}
 200e290:	e037883a 	mov	sp,fp
 200e294:	dfc00117 	ldw	ra,4(sp)
 200e298:	df000017 	ldw	fp,0(sp)
 200e29c:	dec00204 	addi	sp,sp,8
 200e2a0:	f800283a 	ret

0200e2a4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 200e2a4:	defffe04 	addi	sp,sp,-8
 200e2a8:	dfc00115 	stw	ra,4(sp)
 200e2ac:	df000015 	stw	fp,0(sp)
 200e2b0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 200e2b4:	d0a01a17 	ldw	r2,-32664(gp)
 200e2b8:	10000326 	beq	r2,zero,200e2c8 <alt_get_errno+0x24>
 200e2bc:	d0a01a17 	ldw	r2,-32664(gp)
 200e2c0:	103ee83a 	callr	r2
 200e2c4:	00000106 	br	200e2cc <alt_get_errno+0x28>
 200e2c8:	d0a08d04 	addi	r2,gp,-32204
}
 200e2cc:	e037883a 	mov	sp,fp
 200e2d0:	dfc00117 	ldw	ra,4(sp)
 200e2d4:	df000017 	ldw	fp,0(sp)
 200e2d8:	dec00204 	addi	sp,sp,8
 200e2dc:	f800283a 	ret

0200e2e0 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 200e2e0:	defff904 	addi	sp,sp,-28
 200e2e4:	dfc00615 	stw	ra,24(sp)
 200e2e8:	df000515 	stw	fp,20(sp)
 200e2ec:	df000504 	addi	fp,sp,20
 200e2f0:	e13ffd15 	stw	r4,-12(fp)
 200e2f4:	e17ffe15 	stw	r5,-8(fp)
 200e2f8:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 200e2fc:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 200e300:	e0bffd17 	ldw	r2,-12(fp)
 200e304:	10000816 	blt	r2,zero,200e328 <lseek+0x48>
 200e308:	01400304 	movi	r5,12
 200e30c:	e13ffd17 	ldw	r4,-12(fp)
 200e310:	2009bcc0 	call	2009bcc <__mulsi3>
 200e314:	1007883a 	mov	r3,r2
 200e318:	00808074 	movhi	r2,513
 200e31c:	108b5804 	addi	r2,r2,11616
 200e320:	1885883a 	add	r2,r3,r2
 200e324:	00000106 	br	200e32c <lseek+0x4c>
 200e328:	0005883a 	mov	r2,zero
 200e32c:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 200e330:	e0bffc17 	ldw	r2,-16(fp)
 200e334:	10001026 	beq	r2,zero,200e378 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 200e338:	e0bffc17 	ldw	r2,-16(fp)
 200e33c:	10800017 	ldw	r2,0(r2)
 200e340:	10800717 	ldw	r2,28(r2)
 200e344:	10000926 	beq	r2,zero,200e36c <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 200e348:	e0bffc17 	ldw	r2,-16(fp)
 200e34c:	10800017 	ldw	r2,0(r2)
 200e350:	10800717 	ldw	r2,28(r2)
 200e354:	e1bfff17 	ldw	r6,-4(fp)
 200e358:	e17ffe17 	ldw	r5,-8(fp)
 200e35c:	e13ffc17 	ldw	r4,-16(fp)
 200e360:	103ee83a 	callr	r2
 200e364:	e0bffb15 	stw	r2,-20(fp)
 200e368:	00000506 	br	200e380 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 200e36c:	00bfde84 	movi	r2,-134
 200e370:	e0bffb15 	stw	r2,-20(fp)
 200e374:	00000206 	br	200e380 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
 200e378:	00bfebc4 	movi	r2,-81
 200e37c:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 200e380:	e0bffb17 	ldw	r2,-20(fp)
 200e384:	1000070e 	bge	r2,zero,200e3a4 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
 200e388:	200e2a40 	call	200e2a4 <alt_get_errno>
 200e38c:	1007883a 	mov	r3,r2
 200e390:	e0bffb17 	ldw	r2,-20(fp)
 200e394:	0085c83a 	sub	r2,zero,r2
 200e398:	18800015 	stw	r2,0(r3)
    rc = -1;
 200e39c:	00bfffc4 	movi	r2,-1
 200e3a0:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 200e3a4:	e0bffb17 	ldw	r2,-20(fp)
}
 200e3a8:	e037883a 	mov	sp,fp
 200e3ac:	dfc00117 	ldw	ra,4(sp)
 200e3b0:	df000017 	ldw	fp,0(sp)
 200e3b4:	dec00204 	addi	sp,sp,8
 200e3b8:	f800283a 	ret

0200e3bc <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 200e3bc:	defffd04 	addi	sp,sp,-12
 200e3c0:	dfc00215 	stw	ra,8(sp)
 200e3c4:	df000115 	stw	fp,4(sp)
 200e3c8:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 200e3cc:	0009883a 	mov	r4,zero
 200e3d0:	200e8940 	call	200e894 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 200e3d4:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 200e3d8:	200e8cc0 	call	200e8cc <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 200e3dc:	01808074 	movhi	r6,513
 200e3e0:	31891a04 	addi	r6,r6,9320
 200e3e4:	01408074 	movhi	r5,513
 200e3e8:	29491a04 	addi	r5,r5,9320
 200e3ec:	01008074 	movhi	r4,513
 200e3f0:	21091a04 	addi	r4,r4,9320
 200e3f4:	20115080 	call	2011508 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 200e3f8:	20112a80 	call	20112a8 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 200e3fc:	01008074 	movhi	r4,513
 200e400:	2104c204 	addi	r4,r4,4872
 200e404:	2011e280 	call	2011e28 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 200e408:	d0a08f17 	ldw	r2,-32196(gp)
 200e40c:	d0e09017 	ldw	r3,-32192(gp)
 200e410:	d1209117 	ldw	r4,-32188(gp)
 200e414:	200d883a 	mov	r6,r4
 200e418:	180b883a 	mov	r5,r3
 200e41c:	1009883a 	mov	r4,r2
 200e420:	2007f2c0 	call	2007f2c <main>
 200e424:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 200e428:	01000044 	movi	r4,1
 200e42c:	200de140 	call	200de14 <close>
  exit (result);
 200e430:	e13fff17 	ldw	r4,-4(fp)
 200e434:	2011e3c0 	call	2011e3c <exit>

0200e438 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 200e438:	defffe04 	addi	sp,sp,-8
 200e43c:	df000115 	stw	fp,4(sp)
 200e440:	df000104 	addi	fp,sp,4
 200e444:	e13fff15 	stw	r4,-4(fp)
}
 200e448:	0001883a 	nop
 200e44c:	e037883a 	mov	sp,fp
 200e450:	df000017 	ldw	fp,0(sp)
 200e454:	dec00104 	addi	sp,sp,4
 200e458:	f800283a 	ret

0200e45c <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 200e45c:	defffe04 	addi	sp,sp,-8
 200e460:	df000115 	stw	fp,4(sp)
 200e464:	df000104 	addi	fp,sp,4
 200e468:	e13fff15 	stw	r4,-4(fp)
}
 200e46c:	0001883a 	nop
 200e470:	e037883a 	mov	sp,fp
 200e474:	df000017 	ldw	fp,0(sp)
 200e478:	dec00104 	addi	sp,sp,4
 200e47c:	f800283a 	ret

0200e480 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 200e480:	defffe04 	addi	sp,sp,-8
 200e484:	dfc00115 	stw	ra,4(sp)
 200e488:	df000015 	stw	fp,0(sp)
 200e48c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 200e490:	d0a01a17 	ldw	r2,-32664(gp)
 200e494:	10000326 	beq	r2,zero,200e4a4 <alt_get_errno+0x24>
 200e498:	d0a01a17 	ldw	r2,-32664(gp)
 200e49c:	103ee83a 	callr	r2
 200e4a0:	00000106 	br	200e4a8 <alt_get_errno+0x28>
 200e4a4:	d0a08d04 	addi	r2,gp,-32204
}
 200e4a8:	e037883a 	mov	sp,fp
 200e4ac:	dfc00117 	ldw	ra,4(sp)
 200e4b0:	df000017 	ldw	fp,0(sp)
 200e4b4:	dec00204 	addi	sp,sp,8
 200e4b8:	f800283a 	ret

0200e4bc <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 200e4bc:	defff904 	addi	sp,sp,-28
 200e4c0:	dfc00615 	stw	ra,24(sp)
 200e4c4:	df000515 	stw	fp,20(sp)
 200e4c8:	df000504 	addi	fp,sp,20
 200e4cc:	e13ffd15 	stw	r4,-12(fp)
 200e4d0:	e17ffe15 	stw	r5,-8(fp)
 200e4d4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 200e4d8:	e0bffd17 	ldw	r2,-12(fp)
 200e4dc:	10000816 	blt	r2,zero,200e500 <read+0x44>
 200e4e0:	01400304 	movi	r5,12
 200e4e4:	e13ffd17 	ldw	r4,-12(fp)
 200e4e8:	2009bcc0 	call	2009bcc <__mulsi3>
 200e4ec:	1007883a 	mov	r3,r2
 200e4f0:	00808074 	movhi	r2,513
 200e4f4:	108b5804 	addi	r2,r2,11616
 200e4f8:	1885883a 	add	r2,r3,r2
 200e4fc:	00000106 	br	200e504 <read+0x48>
 200e500:	0005883a 	mov	r2,zero
 200e504:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 200e508:	e0bffb17 	ldw	r2,-20(fp)
 200e50c:	10002226 	beq	r2,zero,200e598 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 200e510:	e0bffb17 	ldw	r2,-20(fp)
 200e514:	10800217 	ldw	r2,8(r2)
 200e518:	108000cc 	andi	r2,r2,3
 200e51c:	10800060 	cmpeqi	r2,r2,1
 200e520:	1000181e 	bne	r2,zero,200e584 <read+0xc8>
        (fd->dev->read))
 200e524:	e0bffb17 	ldw	r2,-20(fp)
 200e528:	10800017 	ldw	r2,0(r2)
 200e52c:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 200e530:	10001426 	beq	r2,zero,200e584 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 200e534:	e0bffb17 	ldw	r2,-20(fp)
 200e538:	10800017 	ldw	r2,0(r2)
 200e53c:	10800517 	ldw	r2,20(r2)
 200e540:	e0ffff17 	ldw	r3,-4(fp)
 200e544:	180d883a 	mov	r6,r3
 200e548:	e17ffe17 	ldw	r5,-8(fp)
 200e54c:	e13ffb17 	ldw	r4,-20(fp)
 200e550:	103ee83a 	callr	r2
 200e554:	e0bffc15 	stw	r2,-16(fp)
 200e558:	e0bffc17 	ldw	r2,-16(fp)
 200e55c:	1000070e 	bge	r2,zero,200e57c <read+0xc0>
        {
          ALT_ERRNO = -rval;
 200e560:	200e4800 	call	200e480 <alt_get_errno>
 200e564:	1007883a 	mov	r3,r2
 200e568:	e0bffc17 	ldw	r2,-16(fp)
 200e56c:	0085c83a 	sub	r2,zero,r2
 200e570:	18800015 	stw	r2,0(r3)
          return -1;
 200e574:	00bfffc4 	movi	r2,-1
 200e578:	00000c06 	br	200e5ac <read+0xf0>
        }
        return rval;
 200e57c:	e0bffc17 	ldw	r2,-16(fp)
 200e580:	00000a06 	br	200e5ac <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
 200e584:	200e4800 	call	200e480 <alt_get_errno>
 200e588:	1007883a 	mov	r3,r2
 200e58c:	00800344 	movi	r2,13
 200e590:	18800015 	stw	r2,0(r3)
 200e594:	00000406 	br	200e5a8 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 200e598:	200e4800 	call	200e480 <alt_get_errno>
 200e59c:	1007883a 	mov	r3,r2
 200e5a0:	00801444 	movi	r2,81
 200e5a4:	18800015 	stw	r2,0(r3)
  }
  return -1;
 200e5a8:	00bfffc4 	movi	r2,-1
}
 200e5ac:	e037883a 	mov	sp,fp
 200e5b0:	dfc00117 	ldw	ra,4(sp)
 200e5b4:	df000017 	ldw	fp,0(sp)
 200e5b8:	dec00204 	addi	sp,sp,8
 200e5bc:	f800283a 	ret

0200e5c0 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 200e5c0:	defffc04 	addi	sp,sp,-16
 200e5c4:	dfc00315 	stw	ra,12(sp)
 200e5c8:	df000215 	stw	fp,8(sp)
 200e5cc:	dc000115 	stw	r16,4(sp)
 200e5d0:	df000204 	addi	fp,sp,8
 200e5d4:	e13ffe15 	stw	r4,-8(fp)
  if (fd > 2)
 200e5d8:	e0bffe17 	ldw	r2,-8(fp)
 200e5dc:	108000d0 	cmplti	r2,r2,3
 200e5e0:	1000111e 	bne	r2,zero,200e628 <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
 200e5e4:	04008074 	movhi	r16,513
 200e5e8:	840b5804 	addi	r16,r16,11616
 200e5ec:	e0bffe17 	ldw	r2,-8(fp)
 200e5f0:	01400304 	movi	r5,12
 200e5f4:	1009883a 	mov	r4,r2
 200e5f8:	2009bcc0 	call	2009bcc <__mulsi3>
 200e5fc:	8085883a 	add	r2,r16,r2
 200e600:	10800204 	addi	r2,r2,8
 200e604:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 200e608:	04008074 	movhi	r16,513
 200e60c:	840b5804 	addi	r16,r16,11616
 200e610:	e0bffe17 	ldw	r2,-8(fp)
 200e614:	01400304 	movi	r5,12
 200e618:	1009883a 	mov	r4,r2
 200e61c:	2009bcc0 	call	2009bcc <__mulsi3>
 200e620:	8085883a 	add	r2,r16,r2
 200e624:	10000015 	stw	zero,0(r2)
  }
}
 200e628:	0001883a 	nop
 200e62c:	e6ffff04 	addi	sp,fp,-4
 200e630:	dfc00217 	ldw	ra,8(sp)
 200e634:	df000117 	ldw	fp,4(sp)
 200e638:	dc000017 	ldw	r16,0(sp)
 200e63c:	dec00304 	addi	sp,sp,12
 200e640:	f800283a 	ret

0200e644 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 200e644:	defff904 	addi	sp,sp,-28
 200e648:	df000615 	stw	fp,24(sp)
 200e64c:	df000604 	addi	fp,sp,24
 200e650:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 200e654:	0005303a 	rdctl	r2,status
 200e658:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 200e65c:	e0fffe17 	ldw	r3,-8(fp)
 200e660:	00bfff84 	movi	r2,-2
 200e664:	1884703a 	and	r2,r3,r2
 200e668:	1001703a 	wrctl	status,r2
  
  return context;
 200e66c:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 200e670:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 200e674:	d0a01c17 	ldw	r2,-32656(gp)
 200e678:	10c000c4 	addi	r3,r2,3
 200e67c:	00bfff04 	movi	r2,-4
 200e680:	1884703a 	and	r2,r3,r2
 200e684:	d0a01c15 	stw	r2,-32656(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 200e688:	d0e01c17 	ldw	r3,-32656(gp)
 200e68c:	e0bfff17 	ldw	r2,-4(fp)
 200e690:	1887883a 	add	r3,r3,r2
 200e694:	00810034 	movhi	r2,1024
 200e698:	10800004 	addi	r2,r2,0
 200e69c:	10c0062e 	bgeu	r2,r3,200e6b8 <sbrk+0x74>
 200e6a0:	e0bffb17 	ldw	r2,-20(fp)
 200e6a4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 200e6a8:	e0bffa17 	ldw	r2,-24(fp)
 200e6ac:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 200e6b0:	00bfffc4 	movi	r2,-1
 200e6b4:	00000b06 	br	200e6e4 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 200e6b8:	d0a01c17 	ldw	r2,-32656(gp)
 200e6bc:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 200e6c0:	d0e01c17 	ldw	r3,-32656(gp)
 200e6c4:	e0bfff17 	ldw	r2,-4(fp)
 200e6c8:	1885883a 	add	r2,r3,r2
 200e6cc:	d0a01c15 	stw	r2,-32656(gp)
 200e6d0:	e0bffb17 	ldw	r2,-20(fp)
 200e6d4:	e0bffc15 	stw	r2,-16(fp)
 200e6d8:	e0bffc17 	ldw	r2,-16(fp)
 200e6dc:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 200e6e0:	e0bffd17 	ldw	r2,-12(fp)
} 
 200e6e4:	e037883a 	mov	sp,fp
 200e6e8:	df000017 	ldw	fp,0(sp)
 200e6ec:	dec00104 	addi	sp,sp,4
 200e6f0:	f800283a 	ret

0200e6f4 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 200e6f4:	defffd04 	addi	sp,sp,-12
 200e6f8:	dfc00215 	stw	ra,8(sp)
 200e6fc:	df000115 	stw	fp,4(sp)
 200e700:	df000104 	addi	fp,sp,4
 200e704:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 200e708:	e13fff17 	ldw	r4,-4(fp)
 200e70c:	20110700 	call	2011070 <alt_busy_sleep>
}
 200e710:	e037883a 	mov	sp,fp
 200e714:	dfc00117 	ldw	ra,4(sp)
 200e718:	df000017 	ldw	fp,0(sp)
 200e71c:	dec00204 	addi	sp,sp,8
 200e720:	f800283a 	ret

0200e724 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 200e724:	defffe04 	addi	sp,sp,-8
 200e728:	dfc00115 	stw	ra,4(sp)
 200e72c:	df000015 	stw	fp,0(sp)
 200e730:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 200e734:	d0a01a17 	ldw	r2,-32664(gp)
 200e738:	10000326 	beq	r2,zero,200e748 <alt_get_errno+0x24>
 200e73c:	d0a01a17 	ldw	r2,-32664(gp)
 200e740:	103ee83a 	callr	r2
 200e744:	00000106 	br	200e74c <alt_get_errno+0x28>
 200e748:	d0a08d04 	addi	r2,gp,-32204
}
 200e74c:	e037883a 	mov	sp,fp
 200e750:	dfc00117 	ldw	ra,4(sp)
 200e754:	df000017 	ldw	fp,0(sp)
 200e758:	dec00204 	addi	sp,sp,8
 200e75c:	f800283a 	ret

0200e760 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 200e760:	defff904 	addi	sp,sp,-28
 200e764:	dfc00615 	stw	ra,24(sp)
 200e768:	df000515 	stw	fp,20(sp)
 200e76c:	df000504 	addi	fp,sp,20
 200e770:	e13ffd15 	stw	r4,-12(fp)
 200e774:	e17ffe15 	stw	r5,-8(fp)
 200e778:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 200e77c:	e0bffd17 	ldw	r2,-12(fp)
 200e780:	10000816 	blt	r2,zero,200e7a4 <write+0x44>
 200e784:	01400304 	movi	r5,12
 200e788:	e13ffd17 	ldw	r4,-12(fp)
 200e78c:	2009bcc0 	call	2009bcc <__mulsi3>
 200e790:	1007883a 	mov	r3,r2
 200e794:	00808074 	movhi	r2,513
 200e798:	108b5804 	addi	r2,r2,11616
 200e79c:	1885883a 	add	r2,r3,r2
 200e7a0:	00000106 	br	200e7a8 <write+0x48>
 200e7a4:	0005883a 	mov	r2,zero
 200e7a8:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 200e7ac:	e0bffb17 	ldw	r2,-20(fp)
 200e7b0:	10002126 	beq	r2,zero,200e838 <write+0xd8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 200e7b4:	e0bffb17 	ldw	r2,-20(fp)
 200e7b8:	10800217 	ldw	r2,8(r2)
 200e7bc:	108000cc 	andi	r2,r2,3
 200e7c0:	10001826 	beq	r2,zero,200e824 <write+0xc4>
 200e7c4:	e0bffb17 	ldw	r2,-20(fp)
 200e7c8:	10800017 	ldw	r2,0(r2)
 200e7cc:	10800617 	ldw	r2,24(r2)
 200e7d0:	10001426 	beq	r2,zero,200e824 <write+0xc4>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 200e7d4:	e0bffb17 	ldw	r2,-20(fp)
 200e7d8:	10800017 	ldw	r2,0(r2)
 200e7dc:	10800617 	ldw	r2,24(r2)
 200e7e0:	e0ffff17 	ldw	r3,-4(fp)
 200e7e4:	180d883a 	mov	r6,r3
 200e7e8:	e17ffe17 	ldw	r5,-8(fp)
 200e7ec:	e13ffb17 	ldw	r4,-20(fp)
 200e7f0:	103ee83a 	callr	r2
 200e7f4:	e0bffc15 	stw	r2,-16(fp)
 200e7f8:	e0bffc17 	ldw	r2,-16(fp)
 200e7fc:	1000070e 	bge	r2,zero,200e81c <write+0xbc>
      {
        ALT_ERRNO = -rval;
 200e800:	200e7240 	call	200e724 <alt_get_errno>
 200e804:	1007883a 	mov	r3,r2
 200e808:	e0bffc17 	ldw	r2,-16(fp)
 200e80c:	0085c83a 	sub	r2,zero,r2
 200e810:	18800015 	stw	r2,0(r3)
        return -1;
 200e814:	00bfffc4 	movi	r2,-1
 200e818:	00000c06 	br	200e84c <write+0xec>
      }
      return rval;
 200e81c:	e0bffc17 	ldw	r2,-16(fp)
 200e820:	00000a06 	br	200e84c <write+0xec>
    }
    else
    {
      ALT_ERRNO = EACCES;
 200e824:	200e7240 	call	200e724 <alt_get_errno>
 200e828:	1007883a 	mov	r3,r2
 200e82c:	00800344 	movi	r2,13
 200e830:	18800015 	stw	r2,0(r3)
 200e834:	00000406 	br	200e848 <write+0xe8>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 200e838:	200e7240 	call	200e724 <alt_get_errno>
 200e83c:	1007883a 	mov	r3,r2
 200e840:	00801444 	movi	r2,81
 200e844:	18800015 	stw	r2,0(r3)
  }
  return -1;
 200e848:	00bfffc4 	movi	r2,-1
}
 200e84c:	e037883a 	mov	sp,fp
 200e850:	dfc00117 	ldw	ra,4(sp)
 200e854:	df000017 	ldw	fp,0(sp)
 200e858:	dec00204 	addi	sp,sp,8
 200e85c:	f800283a 	ret

0200e860 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 200e860:	defffd04 	addi	sp,sp,-12
 200e864:	dfc00215 	stw	ra,8(sp)
 200e868:	df000115 	stw	fp,4(sp)
 200e86c:	df000104 	addi	fp,sp,4
 200e870:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 200e874:	d1601704 	addi	r5,gp,-32676
 200e878:	e13fff17 	ldw	r4,-4(fp)
 200e87c:	20112040 	call	2011204 <alt_dev_llist_insert>
}
 200e880:	e037883a 	mov	sp,fp
 200e884:	dfc00117 	ldw	ra,4(sp)
 200e888:	df000017 	ldw	fp,0(sp)
 200e88c:	dec00204 	addi	sp,sp,8
 200e890:	f800283a 	ret

0200e894 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 200e894:	defffd04 	addi	sp,sp,-12
 200e898:	dfc00215 	stw	ra,8(sp)
 200e89c:	df000115 	stw	fp,4(sp)
 200e8a0:	df000104 	addi	fp,sp,4
 200e8a4:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU, cpu);
 200e8a8:	20119ac0 	call	20119ac <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 200e8ac:	00800044 	movi	r2,1
 200e8b0:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 200e8b4:	0001883a 	nop
 200e8b8:	e037883a 	mov	sp,fp
 200e8bc:	dfc00117 	ldw	ra,4(sp)
 200e8c0:	df000017 	ldw	fp,0(sp)
 200e8c4:	dec00204 	addi	sp,sp,8
 200e8c8:	f800283a 	ret

0200e8cc <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 200e8cc:	defffe04 	addi	sp,sp,-8
 200e8d0:	dfc00115 	stw	ra,4(sp)
 200e8d4:	df000015 	stw	fp,0(sp)
 200e8d8:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( RELOJ_FEO, reloj_feo);
 200e8dc:	01c0fa04 	movi	r7,1000
 200e8e0:	000d883a 	mov	r6,zero
 200e8e4:	000b883a 	mov	r5,zero
 200e8e8:	0009883a 	mov	r4,zero
 200e8ec:	200ffb40 	call	200ffb4 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER_N, sys_clk_timer_n);
 200e8f0:	00810034 	movhi	r2,1024
 200e8f4:	10880804 	addi	r2,r2,8224
 200e8f8:	d0a09215 	stw	r2,-32184(gp)
 200e8fc:	00817db4 	movhi	r2,1526
 200e900:	10b84004 	addi	r2,r2,-7936
 200e904:	d0a09315 	stw	r2,-32180(gp)
    ALTERA_AVALON_EPCS_FLASH_CONTROLLER_INIT ( EPCS, epcs);
 200e908:	01008074 	movhi	r4,513
 200e90c:	210bb804 	addi	r4,r4,12000
 200e910:	200ea0c0 	call	200ea0c <alt_epcs_flash_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG, jtag);
 200e914:	018000c4 	movi	r6,3
 200e918:	000b883a 	mov	r5,zero
 200e91c:	01008074 	movhi	r4,513
 200e920:	210bf504 	addi	r4,r4,12244
 200e924:	200f6380 	call	200f638 <altera_avalon_jtag_uart_init>
 200e928:	01008074 	movhi	r4,513
 200e92c:	210beb04 	addi	r4,r4,12204
 200e930:	200e8600 	call	200e860 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYS_ID, sys_id);
 200e934:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( UART, uart);
 200e938:	01800104 	movi	r6,4
 200e93c:	000b883a 	mov	r5,zero
 200e940:	01008074 	movhi	r4,513
 200e944:	21100d04 	addi	r4,r4,16436
 200e948:	20101400 	call	2010140 <altera_avalon_uart_init>
 200e94c:	01008074 	movhi	r4,513
 200e950:	21100304 	addi	r4,r4,16396
 200e954:	200e8600 	call	200e860 <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_2, uart_2);
 200e958:	01800144 	movi	r6,5
 200e95c:	000b883a 	mov	r5,zero
 200e960:	01008074 	movhi	r4,513
 200e964:	21103e04 	addi	r4,r4,16632
 200e968:	20101400 	call	2010140 <altera_avalon_uart_init>
 200e96c:	01008074 	movhi	r4,513
 200e970:	21103404 	addi	r4,r4,16592
 200e974:	200e8600 	call	200e860 <alt_dev_reg>
    ALTERA_UP_AVALON_PARALLEL_PORT_INIT ( IO_PIO, IO_Pio);
 200e978:	01008074 	movhi	r4,513
 200e97c:	21106504 	addi	r4,r4,16788
 200e980:	200e8600 	call	200e860 <alt_dev_reg>
    ALTERA_UP_AVALON_PARALLEL_PORT_INIT ( IO_PIO1, IO_Pio1);
 200e984:	01008074 	movhi	r4,513
 200e988:	21107004 	addi	r4,r4,16832
 200e98c:	200e8600 	call	200e860 <alt_dev_reg>
    ALTERA_UP_AVALON_PARALLEL_PORT_INIT ( KEYS, KEYS);
 200e990:	01008074 	movhi	r4,513
 200e994:	21107b04 	addi	r4,r4,16876
 200e998:	200e8600 	call	200e860 <alt_dev_reg>
    ALTERA_UP_AVALON_PARALLEL_PORT_INIT ( LED_PIO, LED_Pio);
 200e99c:	01008074 	movhi	r4,513
 200e9a0:	21108604 	addi	r4,r4,16920
 200e9a4:	200e8600 	call	200e860 <alt_dev_reg>
    ALTERA_UP_AVALON_PARALLEL_PORT_INIT ( PARALLEL_PORT_0, parallel_port_0);
 200e9a8:	01008074 	movhi	r4,513
 200e9ac:	21109104 	addi	r4,r4,16964
 200e9b0:	200e8600 	call	200e860 <alt_dev_reg>
    ALTERA_UP_AVALON_PARALLEL_PORT_INIT ( PARALLEL_PORT_1, parallel_port_1);
 200e9b4:	01008074 	movhi	r4,513
 200e9b8:	21109c04 	addi	r4,r4,17008
 200e9bc:	200e8600 	call	200e860 <alt_dev_reg>
}
 200e9c0:	0001883a 	nop
 200e9c4:	e037883a 	mov	sp,fp
 200e9c8:	dfc00117 	ldw	ra,4(sp)
 200e9cc:	df000017 	ldw	fp,0(sp)
 200e9d0:	dec00204 	addi	sp,sp,8
 200e9d4:	f800283a 	ret

0200e9d8 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 200e9d8:	defffd04 	addi	sp,sp,-12
 200e9dc:	dfc00215 	stw	ra,8(sp)
 200e9e0:	df000115 	stw	fp,4(sp)
 200e9e4:	df000104 	addi	fp,sp,4
 200e9e8:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 200e9ec:	d1601d04 	addi	r5,gp,-32652
 200e9f0:	e13fff17 	ldw	r4,-4(fp)
 200e9f4:	20112040 	call	2011204 <alt_dev_llist_insert>
}
 200e9f8:	e037883a 	mov	sp,fp
 200e9fc:	dfc00117 	ldw	ra,4(sp)
 200ea00:	df000017 	ldw	fp,0(sp)
 200ea04:	dec00204 	addi	sp,sp,8
 200ea08:	f800283a 	ret

0200ea0c <alt_epcs_flash_init>:
/*
 * alt_epcs_flash_init
 *
 */
int alt_epcs_flash_init(alt_flash_epcs_dev* flash)
{
 200ea0c:	defffc04 	addi	sp,sp,-16
 200ea10:	dfc00315 	stw	ra,12(sp)
 200ea14:	df000215 	stw	fp,8(sp)
 200ea18:	df000204 	addi	fp,sp,8
 200ea1c:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 200ea20:	e03ffe15 	stw	zero,-8(fp)

  /* Set up function pointers and/or data structures as needed. */
  ret_code = alt_epcs_flash_query(flash);
 200ea24:	e13fff17 	ldw	r4,-4(fp)
 200ea28:	200ea600 	call	200ea60 <alt_epcs_flash_query>
 200ea2c:	e0bffe15 	stw	r2,-8(fp)
  */

  /*
  *  Register this device as a valid flash device type
  */
  if (!ret_code)
 200ea30:	e0bffe17 	ldw	r2,-8(fp)
 200ea34:	1000041e 	bne	r2,zero,200ea48 <alt_epcs_flash_init+0x3c>
    ret_code = alt_flash_device_register(&(flash->dev));
 200ea38:	e0bfff17 	ldw	r2,-4(fp)
 200ea3c:	1009883a 	mov	r4,r2
 200ea40:	200e9d80 	call	200e9d8 <alt_flash_device_register>
 200ea44:	e0bffe15 	stw	r2,-8(fp)

  return ret_code;
 200ea48:	e0bffe17 	ldw	r2,-8(fp)
}
 200ea4c:	e037883a 	mov	sp,fp
 200ea50:	dfc00117 	ldw	ra,4(sp)
 200ea54:	df000017 	ldw	fp,0(sp)
 200ea58:	dec00204 	addi	sp,sp,8
 200ea5c:	f800283a 	ret

0200ea60 <alt_epcs_flash_query>:


static int alt_epcs_flash_query(alt_flash_epcs_dev* flash)
{
 200ea60:	defffc04 	addi	sp,sp,-16
 200ea64:	dfc00315 	stw	ra,12(sp)
 200ea68:	df000215 	stw	fp,8(sp)
 200ea6c:	df000204 	addi	fp,sp,8
 200ea70:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 200ea74:	e03ffe15 	stw	zero,-8(fp)
   * reset the device, or whatever, to ensure that
   * it's in a known working state.
  */
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
 200ea78:	e0bfff17 	ldw	r2,-4(fp)
 200ea7c:	10003215 	stw	zero,200(r2)
  
  /* Send the RES command sequence */
  flash->silicon_id =
    epcs_read_electronic_signature(flash->register_base);
 200ea80:	e0bfff17 	ldw	r2,-4(fp)
 200ea84:	10802e17 	ldw	r2,184(r2)
 200ea88:	1009883a 	mov	r4,r2
 200ea8c:	2010da40 	call	2010da4 <epcs_read_electronic_signature>
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
  
  /* Send the RES command sequence */
  flash->silicon_id =
 200ea90:	10c03fcc 	andi	r3,r2,255
 200ea94:	e0bfff17 	ldw	r2,-4(fp)
 200ea98:	10c03015 	stw	r3,192(r2)
    epcs_read_electronic_signature(flash->register_base);

  /* Fill in all device-specific parameters. */
  if (flash->silicon_id == 0x16) /* EPCS64 */
 200ea9c:	e0bfff17 	ldw	r2,-4(fp)
 200eaa0:	10803017 	ldw	r2,192(r2)
 200eaa4:	10800598 	cmpnei	r2,r2,22
 200eaa8:	10000a1e 	bne	r2,zero,200ead4 <alt_epcs_flash_query+0x74>
  {
    flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
 200eaac:	e0bfff17 	ldw	r2,-4(fp)
 200eab0:	00c02034 	movhi	r3,128
 200eab4:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 128;
 200eab8:	e0bfff17 	ldw	r2,-4(fp)
 200eabc:	00c02004 	movi	r3,128
 200eac0:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 200eac4:	e0bfff17 	ldw	r2,-4(fp)
 200eac8:	00c00074 	movhi	r3,1
 200eacc:	10c01015 	stw	r3,64(r2)
 200ead0:	0000ce06 	br	200ee0c <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x14) /* EPCS16 */
 200ead4:	e0bfff17 	ldw	r2,-4(fp)
 200ead8:	10803017 	ldw	r2,192(r2)
 200eadc:	10800518 	cmpnei	r2,r2,20
 200eae0:	10000a1e 	bne	r2,zero,200eb0c <alt_epcs_flash_query+0xac>
  {
    flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
 200eae4:	e0bfff17 	ldw	r2,-4(fp)
 200eae8:	00c00834 	movhi	r3,32
 200eaec:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 32;
 200eaf0:	e0bfff17 	ldw	r2,-4(fp)
 200eaf4:	00c00804 	movi	r3,32
 200eaf8:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 200eafc:	e0bfff17 	ldw	r2,-4(fp)
 200eb00:	00c00074 	movhi	r3,1
 200eb04:	10c01015 	stw	r3,64(r2)
 200eb08:	0000c006 	br	200ee0c <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x13) /* EPCS8 */
 200eb0c:	e0bfff17 	ldw	r2,-4(fp)
 200eb10:	10803017 	ldw	r2,192(r2)
 200eb14:	108004d8 	cmpnei	r2,r2,19
 200eb18:	10000a1e 	bne	r2,zero,200eb44 <alt_epcs_flash_query+0xe4>
  {
    flash->dev.region_info[0].region_size = 8 * 1024 * 1024 / 8;
 200eb1c:	e0bfff17 	ldw	r2,-4(fp)
 200eb20:	00c00434 	movhi	r3,16
 200eb24:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 16;
 200eb28:	e0bfff17 	ldw	r2,-4(fp)
 200eb2c:	00c00404 	movi	r3,16
 200eb30:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 200eb34:	e0bfff17 	ldw	r2,-4(fp)
 200eb38:	00c00074 	movhi	r3,1
 200eb3c:	10c01015 	stw	r3,64(r2)
 200eb40:	0000b206 	br	200ee0c <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x12) /* EPCS4 */
 200eb44:	e0bfff17 	ldw	r2,-4(fp)
 200eb48:	10803017 	ldw	r2,192(r2)
 200eb4c:	10800498 	cmpnei	r2,r2,18
 200eb50:	10000a1e 	bne	r2,zero,200eb7c <alt_epcs_flash_query+0x11c>
  {
    flash->dev.region_info[0].region_size = 4 * 1024 * 1024 / 8;
 200eb54:	e0bfff17 	ldw	r2,-4(fp)
 200eb58:	00c00234 	movhi	r3,8
 200eb5c:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 8;
 200eb60:	e0bfff17 	ldw	r2,-4(fp)
 200eb64:	00c00204 	movi	r3,8
 200eb68:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 200eb6c:	e0bfff17 	ldw	r2,-4(fp)
 200eb70:	00c00074 	movhi	r3,1
 200eb74:	10c01015 	stw	r3,64(r2)
 200eb78:	0000a406 	br	200ee0c <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x10) /* EPCS1 */
 200eb7c:	e0bfff17 	ldw	r2,-4(fp)
 200eb80:	10803017 	ldw	r2,192(r2)
 200eb84:	10800418 	cmpnei	r2,r2,16
 200eb88:	10000a1e 	bne	r2,zero,200ebb4 <alt_epcs_flash_query+0x154>
  {
    flash->dev.region_info[0].region_size = 1 * 1024 * 1024 / 8;
 200eb8c:	e0bfff17 	ldw	r2,-4(fp)
 200eb90:	00c000b4 	movhi	r3,2
 200eb94:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 4;
 200eb98:	e0bfff17 	ldw	r2,-4(fp)
 200eb9c:	00c00104 	movi	r3,4
 200eba0:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 32768;
 200eba4:	e0bfff17 	ldw	r2,-4(fp)
 200eba8:	00e00014 	movui	r3,32768
 200ebac:	10c01015 	stw	r3,64(r2)
 200ebb0:	00009606 	br	200ee0c <alt_epcs_flash_query+0x3ac>
  {
    /* 
     * Read electronic signature doesn't work for newer devices; try 
     * the "Read Device ID" command" before giving up.
     */
    flash->silicon_id = epcs_read_device_id(flash->register_base);
 200ebb4:	e0bfff17 	ldw	r2,-4(fp)
 200ebb8:	10802e17 	ldw	r2,184(r2)
 200ebbc:	1009883a 	mov	r4,r2
 200ebc0:	2010e0c0 	call	2010e0c <epcs_read_device_id>
 200ebc4:	1007883a 	mov	r3,r2
 200ebc8:	e0bfff17 	ldw	r2,-4(fp)
 200ebcc:	10c03015 	stw	r3,192(r2)
    /*
     * Last byte is the density ID. Note the difference between
     * EPCS128 and EPCQ128 -- arranged differently, though the 
     * least significant byte of each is '0x18'.
     */
    if((flash->silicon_id & 0xFFFFFF) == 0x20BA15) /* EPCQ16 */
 200ebd0:	e0bfff17 	ldw	r2,-4(fp)
 200ebd4:	10c03017 	ldw	r3,192(r2)
 200ebd8:	00804034 	movhi	r2,256
 200ebdc:	10bfffc4 	addi	r2,r2,-1
 200ebe0:	1886703a 	and	r3,r3,r2
 200ebe4:	00800874 	movhi	r2,33
 200ebe8:	10ae8544 	addi	r2,r2,-17899
 200ebec:	18800a1e 	bne	r3,r2,200ec18 <alt_epcs_flash_query+0x1b8>
    {
      flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
 200ebf0:	e0bfff17 	ldw	r2,-4(fp)
 200ebf4:	00c00834 	movhi	r3,32
 200ebf8:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 32; /* number of sectors */
 200ebfc:	e0bfff17 	ldw	r2,-4(fp)
 200ec00:	00c00804 	movi	r3,32
 200ec04:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 200ec08:	e0bfff17 	ldw	r2,-4(fp)
 200ec0c:	00c00074 	movhi	r3,1
 200ec10:	10c01015 	stw	r3,64(r2)
 200ec14:	00007d06 	br	200ee0c <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA16) /* EPCQ32 */
 200ec18:	e0bfff17 	ldw	r2,-4(fp)
 200ec1c:	10c03017 	ldw	r3,192(r2)
 200ec20:	00804034 	movhi	r2,256
 200ec24:	10bfffc4 	addi	r2,r2,-1
 200ec28:	1886703a 	and	r3,r3,r2
 200ec2c:	00800874 	movhi	r2,33
 200ec30:	10ae8584 	addi	r2,r2,-17898
 200ec34:	18800a1e 	bne	r3,r2,200ec60 <alt_epcs_flash_query+0x200>
    {
      flash->dev.region_info[0].region_size = 32 * 1024 * 1024 / 8;
 200ec38:	e0bfff17 	ldw	r2,-4(fp)
 200ec3c:	00c01034 	movhi	r3,64
 200ec40:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64; /* number of sectors */
 200ec44:	e0bfff17 	ldw	r2,-4(fp)
 200ec48:	00c01004 	movi	r3,64
 200ec4c:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 200ec50:	e0bfff17 	ldw	r2,-4(fp)
 200ec54:	00c00074 	movhi	r3,1
 200ec58:	10c01015 	stw	r3,64(r2)
 200ec5c:	00006b06 	br	200ee0c <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA17) /* EPCQ64 */
 200ec60:	e0bfff17 	ldw	r2,-4(fp)
 200ec64:	10c03017 	ldw	r3,192(r2)
 200ec68:	00804034 	movhi	r2,256
 200ec6c:	10bfffc4 	addi	r2,r2,-1
 200ec70:	1886703a 	and	r3,r3,r2
 200ec74:	00800874 	movhi	r2,33
 200ec78:	10ae85c4 	addi	r2,r2,-17897
 200ec7c:	18800a1e 	bne	r3,r2,200eca8 <alt_epcs_flash_query+0x248>
    {
      flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
 200ec80:	e0bfff17 	ldw	r2,-4(fp)
 200ec84:	00c02034 	movhi	r3,128
 200ec88:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 128; /* number of sectors */
 200ec8c:	e0bfff17 	ldw	r2,-4(fp)
 200ec90:	00c02004 	movi	r3,128
 200ec94:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 200ec98:	e0bfff17 	ldw	r2,-4(fp)
 200ec9c:	00c00074 	movhi	r3,1
 200eca0:	10c01015 	stw	r3,64(r2)
 200eca4:	00005906 	br	200ee0c <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA18) /* EPCQ128 */
 200eca8:	e0bfff17 	ldw	r2,-4(fp)
 200ecac:	10c03017 	ldw	r3,192(r2)
 200ecb0:	00804034 	movhi	r2,256
 200ecb4:	10bfffc4 	addi	r2,r2,-1
 200ecb8:	1886703a 	and	r3,r3,r2
 200ecbc:	00800874 	movhi	r2,33
 200ecc0:	10ae8604 	addi	r2,r2,-17896
 200ecc4:	18800a1e 	bne	r3,r2,200ecf0 <alt_epcs_flash_query+0x290>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
 200ecc8:	e0bfff17 	ldw	r2,-4(fp)
 200eccc:	00c04034 	movhi	r3,256
 200ecd0:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 256; /* number of sectors */
 200ecd4:	e0bfff17 	ldw	r2,-4(fp)
 200ecd8:	00c04004 	movi	r3,256
 200ecdc:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 200ece0:	e0bfff17 	ldw	r2,-4(fp)
 200ece4:	00c00074 	movhi	r3,1
 200ece8:	10c01015 	stw	r3,64(r2)
 200ecec:	00004706 	br	200ee0c <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF) == 0x18) /* EPCS128 */
 200ecf0:	e0bfff17 	ldw	r2,-4(fp)
 200ecf4:	10803017 	ldw	r2,192(r2)
 200ecf8:	10803fcc 	andi	r2,r2,255
 200ecfc:	10800618 	cmpnei	r2,r2,24
 200ed00:	10000a1e 	bne	r2,zero,200ed2c <alt_epcs_flash_query+0x2cc>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
 200ed04:	e0bfff17 	ldw	r2,-4(fp)
 200ed08:	00c04034 	movhi	r3,256
 200ed0c:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64;
 200ed10:	e0bfff17 	ldw	r2,-4(fp)
 200ed14:	00c01004 	movi	r3,64
 200ed18:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 262144;
 200ed1c:	e0bfff17 	ldw	r2,-4(fp)
 200ed20:	00c00134 	movhi	r3,4
 200ed24:	10c01015 	stw	r3,64(r2)
 200ed28:	00003806 	br	200ee0c <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x19) /* EPCQ256 */
 200ed2c:	e0bfff17 	ldw	r2,-4(fp)
 200ed30:	10803017 	ldw	r2,192(r2)
 200ed34:	10803fcc 	andi	r2,r2,255
 200ed38:	10800658 	cmpnei	r2,r2,25
 200ed3c:	10000d1e 	bne	r2,zero,200ed74 <alt_epcs_flash_query+0x314>
    {
      flash->dev.region_info[0].region_size = 256 * 1024 * 1024 / 8;
 200ed40:	e0bfff17 	ldw	r2,-4(fp)
 200ed44:	00c08034 	movhi	r3,512
 200ed48:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 512; /* number of sectors */
 200ed4c:	e0bfff17 	ldw	r2,-4(fp)
 200ed50:	00c08004 	movi	r3,512
 200ed54:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 200ed58:	e0bfff17 	ldw	r2,-4(fp)
 200ed5c:	00c00074 	movhi	r3,1
 200ed60:	10c01015 	stw	r3,64(r2)
       * must first be programmed into the device, though. To complicate things, 
       * other Altera IP expects the chip to be in 3 byte address mode when they 
       * start using it. To be nice, we'll place the device into 4-byte address mode
       * when we need to, and take it back out when we're done.
       */
      flash->four_bytes_mode = 1;
 200ed64:	e0bfff17 	ldw	r2,-4(fp)
 200ed68:	00c00044 	movi	r3,1
 200ed6c:	10c03215 	stw	r3,200(r2)
 200ed70:	00002606 	br	200ee0c <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x20) /* EPCQ512 */
 200ed74:	e0bfff17 	ldw	r2,-4(fp)
 200ed78:	10803017 	ldw	r2,192(r2)
 200ed7c:	10803fcc 	andi	r2,r2,255
 200ed80:	10800818 	cmpnei	r2,r2,32
 200ed84:	10000d1e 	bne	r2,zero,200edbc <alt_epcs_flash_query+0x35c>
    {
      flash->dev.region_info[0].region_size = 512 * 1024 * 1024 / 8;
 200ed88:	e0bfff17 	ldw	r2,-4(fp)
 200ed8c:	00c10034 	movhi	r3,1024
 200ed90:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 1024; /* number of sectors */
 200ed94:	e0bfff17 	ldw	r2,-4(fp)
 200ed98:	00c10004 	movi	r3,1024
 200ed9c:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 200eda0:	e0bfff17 	ldw	r2,-4(fp)
 200eda4:	00c00074 	movhi	r3,1
 200eda8:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
 200edac:	e0bfff17 	ldw	r2,-4(fp)
 200edb0:	00c00044 	movi	r3,1
 200edb4:	10c03215 	stw	r3,200(r2)
 200edb8:	00001406 	br	200ee0c <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x21) /* EPCQ1024 */
 200edbc:	e0bfff17 	ldw	r2,-4(fp)
 200edc0:	10803017 	ldw	r2,192(r2)
 200edc4:	10803fcc 	andi	r2,r2,255
 200edc8:	10800858 	cmpnei	r2,r2,33
 200edcc:	10000d1e 	bne	r2,zero,200ee04 <alt_epcs_flash_query+0x3a4>
    {
      flash->dev.region_info[0].region_size = 1024 * 1024 * 1024 / 8;
 200edd0:	e0bfff17 	ldw	r2,-4(fp)
 200edd4:	00c20034 	movhi	r3,2048
 200edd8:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 2048; /* number of sectors */
 200eddc:	e0bfff17 	ldw	r2,-4(fp)
 200ede0:	00c20004 	movi	r3,2048
 200ede4:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 200ede8:	e0bfff17 	ldw	r2,-4(fp)
 200edec:	00c00074 	movhi	r3,1
 200edf0:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
 200edf4:	e0bfff17 	ldw	r2,-4(fp)
 200edf8:	00c00044 	movi	r3,1
 200edfc:	10c03215 	stw	r3,200(r2)
 200ee00:	00000206 	br	200ee0c <alt_epcs_flash_query+0x3ac>
    }
    else 
    {
      ret_code = -ENODEV; /* No known device found! */
 200ee04:	00bffb44 	movi	r2,-19
 200ee08:	e0bffe15 	stw	r2,-8(fp)
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
 200ee0c:	e0bfff17 	ldw	r2,-4(fp)
 200ee10:	10800e17 	ldw	r2,56(r2)
 200ee14:	1007883a 	mov	r3,r2
 200ee18:	e0bfff17 	ldw	r2,-4(fp)
 200ee1c:	10c02f15 	stw	r3,188(r2)
  flash->dev.number_of_regions = 1;
 200ee20:	e0bfff17 	ldw	r2,-4(fp)
 200ee24:	00c00044 	movi	r3,1
 200ee28:	10c00c15 	stw	r3,48(r2)
  flash->dev.region_info[0].offset = 0;
 200ee2c:	e0bfff17 	ldw	r2,-4(fp)
 200ee30:	10000d15 	stw	zero,52(r2)
  flash->page_size = 256;
 200ee34:	e0bfff17 	ldw	r2,-4(fp)
 200ee38:	00c04004 	movi	r3,256
 200ee3c:	10c03115 	stw	r3,196(r2)

  /* Consider clearing all BP bits here. */
  return ret_code;
 200ee40:	e0bffe17 	ldw	r2,-8(fp)
}
 200ee44:	e037883a 	mov	sp,fp
 200ee48:	dfc00117 	ldw	ra,4(sp)
 200ee4c:	df000017 	ldw	fp,0(sp)
 200ee50:	dec00204 	addi	sp,sp,8
 200ee54:	f800283a 	ret

0200ee58 <alt_epcs_flash_memcmp>:
  alt_flash_dev* flash_info,
  const void* src_buffer,
  int offset,
  size_t n
)
{
 200ee58:	deffee04 	addi	sp,sp,-72
 200ee5c:	dfc01115 	stw	ra,68(sp)
 200ee60:	df001015 	stw	fp,64(sp)
 200ee64:	df001004 	addi	fp,sp,64
 200ee68:	e13ffc15 	stw	r4,-16(fp)
 200ee6c:	e17ffd15 	stw	r5,-12(fp)
 200ee70:	e1bffe15 	stw	r6,-8(fp)
 200ee74:	e1ffff15 	stw	r7,-4(fp)
  /*
   * Compare chunks of memory at a time, for better serial-flash
   * read efficiency.
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
 200ee78:	00800804 	movi	r2,32
 200ee7c:	e0bff115 	stw	r2,-60(fp)
  int current_offset = 0;
 200ee80:	e03ff015 	stw	zero,-64(fp)

  while (n > 0)
 200ee84:	00002706 	br	200ef24 <alt_epcs_flash_memcmp+0xcc>
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
 200ee88:	e0fff117 	ldw	r3,-60(fp)
 200ee8c:	e0bfff17 	ldw	r2,-4(fp)
 200ee90:	1880012e 	bgeu	r3,r2,200ee98 <alt_epcs_flash_memcmp+0x40>
 200ee94:	1805883a 	mov	r2,r3
 200ee98:	e0bff215 	stw	r2,-56(fp)
    int this_chunk_cmp;

    if (
      alt_epcs_flash_read(
 200ee9c:	e0fffe17 	ldw	r3,-8(fp)
 200eea0:	e0bff017 	ldw	r2,-64(fp)
 200eea4:	1885883a 	add	r2,r3,r2
 200eea8:	e0fff404 	addi	r3,fp,-48
 200eeac:	e1fff217 	ldw	r7,-56(fp)
 200eeb0:	180d883a 	mov	r6,r3
 200eeb4:	100b883a 	mov	r5,r2
 200eeb8:	e13ffc17 	ldw	r4,-16(fp)
 200eebc:	200f43c0 	call	200f43c <alt_epcs_flash_read>
  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
    int this_chunk_cmp;

    if (
 200eec0:	1000020e 	bge	r2,zero,200eecc <alt_epcs_flash_memcmp+0x74>
    {
      /*
      * If the read fails, I'm not sure what the appropriate action is.
      * Compare success seems wrong, so make it compare fail.
      */
      return -1;
 200eec4:	00bfffc4 	movi	r2,-1
 200eec8:	00001906 	br	200ef30 <alt_epcs_flash_memcmp+0xd8>
    }

    /* Compare this chunk against the source memory buffer. */
    this_chunk_cmp = memcmp(&((unsigned char*)(src_buffer))[current_offset], chunk_buffer, this_chunk_size);
 200eecc:	e0bff017 	ldw	r2,-64(fp)
 200eed0:	e0fffd17 	ldw	r3,-12(fp)
 200eed4:	1885883a 	add	r2,r3,r2
 200eed8:	e13ff217 	ldw	r4,-56(fp)
 200eedc:	e0fff404 	addi	r3,fp,-48
 200eee0:	200d883a 	mov	r6,r4
 200eee4:	180b883a 	mov	r5,r3
 200eee8:	1009883a 	mov	r4,r2
 200eeec:	2011e740 	call	2011e74 <memcmp>
 200eef0:	e0bff315 	stw	r2,-52(fp)
    if (this_chunk_cmp)
 200eef4:	e0bff317 	ldw	r2,-52(fp)
 200eef8:	10000226 	beq	r2,zero,200ef04 <alt_epcs_flash_memcmp+0xac>
    {
      return this_chunk_cmp;
 200eefc:	e0bff317 	ldw	r2,-52(fp)
 200ef00:	00000b06 	br	200ef30 <alt_epcs_flash_memcmp+0xd8>
    }

    n -= this_chunk_size;
 200ef04:	e0bff217 	ldw	r2,-56(fp)
 200ef08:	e0ffff17 	ldw	r3,-4(fp)
 200ef0c:	1885c83a 	sub	r2,r3,r2
 200ef10:	e0bfff15 	stw	r2,-4(fp)
    current_offset += this_chunk_size;
 200ef14:	e0fff017 	ldw	r3,-64(fp)
 200ef18:	e0bff217 	ldw	r2,-56(fp)
 200ef1c:	1885883a 	add	r2,r3,r2
 200ef20:	e0bff015 	stw	r2,-64(fp)
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
 200ef24:	e0bfff17 	ldw	r2,-4(fp)
 200ef28:	103fd71e 	bne	r2,zero,200ee88 <__reset+0xfe00de88>
  }

  /*
   * If execution made it to this point, compare is successful.
   */
  return 0;
 200ef2c:	0005883a 	mov	r2,zero
}
 200ef30:	e037883a 	mov	sp,fp
 200ef34:	dfc00117 	ldw	ra,4(sp)
 200ef38:	df000017 	ldw	fp,0(sp)
 200ef3c:	dec00204 	addi	sp,sp,8
 200ef40:	f800283a 	ret

0200ef44 <alt_epcs_flash_write>:
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
 200ef44:	defff404 	addi	sp,sp,-48
 200ef48:	dfc00b15 	stw	ra,44(sp)
 200ef4c:	df000a15 	stw	fp,40(sp)
 200ef50:	df000a04 	addi	fp,sp,40
 200ef54:	e13ffc15 	stw	r4,-16(fp)
 200ef58:	e17ffd15 	stw	r5,-12(fp)
 200ef5c:	e1bffe15 	stw	r6,-8(fp)
 200ef60:	e1ffff15 	stw	r7,-4(fp)
  int         ret_code = 0;
 200ef64:	e03ff715 	stw	zero,-36(fp)
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
 200ef68:	e03ff815 	stw	zero,-32(fp)
 200ef6c:	00008306 	br	200f17c <alt_epcs_flash_write+0x238>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
 200ef70:	e0fffc17 	ldw	r3,-16(fp)
 200ef74:	e0bff817 	ldw	r2,-32(fp)
 200ef78:	1004913a 	slli	r2,r2,4
 200ef7c:	1885883a 	add	r2,r3,r2
 200ef80:	10800d04 	addi	r2,r2,52
 200ef84:	10800017 	ldw	r2,0(r2)
 200ef88:	e0fffd17 	ldw	r3,-12(fp)
 200ef8c:	18807816 	blt	r3,r2,200f170 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
 200ef90:	e0fffc17 	ldw	r3,-16(fp)
 200ef94:	e0bff817 	ldw	r2,-32(fp)
 200ef98:	1004913a 	slli	r2,r2,4
 200ef9c:	1885883a 	add	r2,r3,r2
 200efa0:	10800d04 	addi	r2,r2,52
 200efa4:	10c00017 	ldw	r3,0(r2)
      flash_info->region_info[i].region_size)))
 200efa8:	e13ffc17 	ldw	r4,-16(fp)
 200efac:	e0bff817 	ldw	r2,-32(fp)
 200efb0:	1004913a 	slli	r2,r2,4
 200efb4:	2085883a 	add	r2,r4,r2
 200efb8:	10800e04 	addi	r2,r2,56
 200efbc:	10800017 	ldw	r2,0(r2)
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
      (offset < (flash_info->region_info[i].offset +
 200efc0:	1885883a 	add	r2,r3,r2
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
 200efc4:	e0fffd17 	ldw	r3,-12(fp)
 200efc8:	1880690e 	bge	r3,r2,200f170 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;
 200efcc:	e0fffc17 	ldw	r3,-16(fp)
 200efd0:	e0bff817 	ldw	r2,-32(fp)
 200efd4:	1004913a 	slli	r2,r2,4
 200efd8:	1885883a 	add	r2,r3,r2
 200efdc:	10800d04 	addi	r2,r2,52
 200efe0:	10800017 	ldw	r2,0(r2)
 200efe4:	e0bffa15 	stw	r2,-24(fp)

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
 200efe8:	e03ff915 	stw	zero,-28(fp)
 200efec:	00005806 	br	200f150 <alt_epcs_flash_write+0x20c>
      {
        if ((offset >= current_offset ) &&
 200eff0:	e0fffd17 	ldw	r3,-12(fp)
 200eff4:	e0bffa17 	ldw	r2,-24(fp)
 200eff8:	18804916 	blt	r3,r2,200f120 <alt_epcs_flash_write+0x1dc>
            (offset < (current_offset +
            flash_info->region_info[i].block_size)))
 200effc:	e0fffc17 	ldw	r3,-16(fp)
 200f000:	e0bff817 	ldw	r2,-32(fp)
 200f004:	10800104 	addi	r2,r2,4
 200f008:	1004913a 	slli	r2,r2,4
 200f00c:	1885883a 	add	r2,r3,r2
 200f010:	10c00017 	ldw	r3,0(r2)
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
            (offset < (current_offset +
 200f014:	e0bffa17 	ldw	r2,-24(fp)
 200f018:	1885883a 	add	r2,r3,r2
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
 200f01c:	e0fffd17 	ldw	r3,-12(fp)
 200f020:	18803f0e 	bge	r3,r2,200f120 <alt_epcs_flash_write+0x1dc>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
 200f024:	e0fffc17 	ldw	r3,-16(fp)
 200f028:	e0bff817 	ldw	r2,-32(fp)
 200f02c:	10800104 	addi	r2,r2,4
 200f030:	1004913a 	slli	r2,r2,4
 200f034:	1885883a 	add	r2,r3,r2
 200f038:	10c00017 	ldw	r3,0(r2)
 200f03c:	e0bffa17 	ldw	r2,-24(fp)
 200f040:	1887883a 	add	r3,r3,r2
 200f044:	e0bffd17 	ldw	r2,-12(fp)
 200f048:	1885c83a 	sub	r2,r3,r2
 200f04c:	e0bffb15 	stw	r2,-20(fp)
                            - offset);
          data_to_write = MIN(data_to_write, length);
 200f050:	e0fffb17 	ldw	r3,-20(fp)
 200f054:	e0bfff17 	ldw	r2,-4(fp)
 200f058:	1880010e 	bge	r3,r2,200f060 <alt_epcs_flash_write+0x11c>
 200f05c:	1805883a 	mov	r2,r3
 200f060:	e0bffb15 	stw	r2,-20(fp)

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
 200f064:	e0bffb17 	ldw	r2,-20(fp)
 200f068:	100f883a 	mov	r7,r2
 200f06c:	e1bffd17 	ldw	r6,-12(fp)
 200f070:	e17ffe17 	ldw	r5,-8(fp)
 200f074:	e13ffc17 	ldw	r4,-16(fp)
 200f078:	200ee580 	call	200ee58 <alt_epcs_flash_memcmp>
 200f07c:	10001226 	beq	r2,zero,200f0c8 <alt_epcs_flash_write+0x184>
          {
            ret_code = (*flash_info->erase_block)(flash_info, current_offset);
 200f080:	e0bffc17 	ldw	r2,-16(fp)
 200f084:	10800817 	ldw	r2,32(r2)
 200f088:	e17ffa17 	ldw	r5,-24(fp)
 200f08c:	e13ffc17 	ldw	r4,-16(fp)
 200f090:	103ee83a 	callr	r2
 200f094:	e0bff715 	stw	r2,-36(fp)

            if (!ret_code)
 200f098:	e0bff717 	ldw	r2,-36(fp)
 200f09c:	10000a1e 	bne	r2,zero,200f0c8 <alt_epcs_flash_write+0x184>
            {
              ret_code = (*flash_info->write_block)(
 200f0a0:	e0bffc17 	ldw	r2,-16(fp)
 200f0a4:	10800917 	ldw	r2,36(r2)
 200f0a8:	e0fffb17 	ldw	r3,-20(fp)
 200f0ac:	d8c00015 	stw	r3,0(sp)
 200f0b0:	e1fffe17 	ldw	r7,-8(fp)
 200f0b4:	e1bffd17 	ldw	r6,-12(fp)
 200f0b8:	e17ffa17 	ldw	r5,-24(fp)
 200f0bc:	e13ffc17 	ldw	r4,-16(fp)
 200f0c0:	103ee83a 	callr	r2
 200f0c4:	e0bff715 	stw	r2,-36(fp)
                                                  data_to_write);
            }
          }

          /* Was this the last block? */
          if ((length == data_to_write) || ret_code)
 200f0c8:	e0ffff17 	ldw	r3,-4(fp)
 200f0cc:	e0bffb17 	ldw	r2,-20(fp)
 200f0d0:	18802e26 	beq	r3,r2,200f18c <alt_epcs_flash_write+0x248>
 200f0d4:	e0bff717 	ldw	r2,-36(fp)
 200f0d8:	10002c1e 	bne	r2,zero,200f18c <alt_epcs_flash_write+0x248>
          {
            goto finished;
          }

          length -= data_to_write;
 200f0dc:	e0ffff17 	ldw	r3,-4(fp)
 200f0e0:	e0bffb17 	ldw	r2,-20(fp)
 200f0e4:	1885c83a 	sub	r2,r3,r2
 200f0e8:	e0bfff15 	stw	r2,-4(fp)
          offset = current_offset + flash_info->region_info[i].block_size;
 200f0ec:	e0fffc17 	ldw	r3,-16(fp)
 200f0f0:	e0bff817 	ldw	r2,-32(fp)
 200f0f4:	10800104 	addi	r2,r2,4
 200f0f8:	1004913a 	slli	r2,r2,4
 200f0fc:	1885883a 	add	r2,r3,r2
 200f100:	10c00017 	ldw	r3,0(r2)
 200f104:	e0bffa17 	ldw	r2,-24(fp)
 200f108:	1885883a 	add	r2,r3,r2
 200f10c:	e0bffd15 	stw	r2,-12(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 200f110:	e0bffb17 	ldw	r2,-20(fp)
 200f114:	e0fffe17 	ldw	r3,-8(fp)
 200f118:	1885883a 	add	r2,r3,r2
 200f11c:	e0bffe15 	stw	r2,-8(fp)
        }
        current_offset += flash_info->region_info[i].block_size;
 200f120:	e0fffc17 	ldw	r3,-16(fp)
 200f124:	e0bff817 	ldw	r2,-32(fp)
 200f128:	10800104 	addi	r2,r2,4
 200f12c:	1004913a 	slli	r2,r2,4
 200f130:	1885883a 	add	r2,r3,r2
 200f134:	10800017 	ldw	r2,0(r2)
 200f138:	e0fffa17 	ldw	r3,-24(fp)
 200f13c:	1885883a 	add	r2,r3,r2
 200f140:	e0bffa15 	stw	r2,-24(fp)
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
 200f144:	e0bff917 	ldw	r2,-28(fp)
 200f148:	10800044 	addi	r2,r2,1
 200f14c:	e0bff915 	stw	r2,-28(fp)
 200f150:	e0fffc17 	ldw	r3,-16(fp)
 200f154:	e0bff817 	ldw	r2,-32(fp)
 200f158:	1004913a 	slli	r2,r2,4
 200f15c:	1885883a 	add	r2,r3,r2
 200f160:	10800f04 	addi	r2,r2,60
 200f164:	10800017 	ldw	r2,0(r2)
 200f168:	e0fff917 	ldw	r3,-28(fp)
 200f16c:	18bfa016 	blt	r3,r2,200eff0 <__reset+0xfe00dff0>
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
 200f170:	e0bff817 	ldw	r2,-32(fp)
 200f174:	10800044 	addi	r2,r2,1
 200f178:	e0bff815 	stw	r2,-32(fp)
 200f17c:	e0bffc17 	ldw	r2,-16(fp)
 200f180:	10800c17 	ldw	r2,48(r2)
 200f184:	e0fff817 	ldw	r3,-32(fp)
 200f188:	18bf7916 	blt	r3,r2,200ef70 <__reset+0xfe00df70>
      }
    }
  }

finished:
  return ret_code;
 200f18c:	e0bff717 	ldw	r2,-36(fp)
}
 200f190:	e037883a 	mov	sp,fp
 200f194:	dfc00117 	ldw	ra,4(sp)
 200f198:	df000017 	ldw	fp,0(sp)
 200f19c:	dec00204 	addi	sp,sp,8
 200f1a0:	f800283a 	ret

0200f1a4 <alt_epcs_flash_get_info>:
 *
 *  Pass the table of erase blocks to the user
 */
int alt_epcs_flash_get_info(alt_flash_fd* fd, flash_region** info,
                            int* number_of_regions)
{
 200f1a4:	defffa04 	addi	sp,sp,-24
 200f1a8:	df000515 	stw	fp,20(sp)
 200f1ac:	df000504 	addi	fp,sp,20
 200f1b0:	e13ffd15 	stw	r4,-12(fp)
 200f1b4:	e17ffe15 	stw	r5,-8(fp)
 200f1b8:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 200f1bc:	e03ffb15 	stw	zero,-20(fp)

  alt_flash_dev* flash = (alt_flash_dev*)fd;
 200f1c0:	e0bffd17 	ldw	r2,-12(fp)
 200f1c4:	e0bffc15 	stw	r2,-16(fp)

  *number_of_regions = flash->number_of_regions;
 200f1c8:	e0bffc17 	ldw	r2,-16(fp)
 200f1cc:	10c00c17 	ldw	r3,48(r2)
 200f1d0:	e0bfff17 	ldw	r2,-4(fp)
 200f1d4:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 200f1d8:	e0bffc17 	ldw	r2,-16(fp)
 200f1dc:	10800c17 	ldw	r2,48(r2)
 200f1e0:	1000031e 	bne	r2,zero,200f1f0 <alt_epcs_flash_get_info+0x4c>
  {
    ret_code = -EIO;
 200f1e4:	00bffec4 	movi	r2,-5
 200f1e8:	e0bffb15 	stw	r2,-20(fp)
 200f1ec:	00000b06 	br	200f21c <alt_epcs_flash_get_info+0x78>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 200f1f0:	e0bffc17 	ldw	r2,-16(fp)
 200f1f4:	10800c17 	ldw	r2,48(r2)
 200f1f8:	10800250 	cmplti	r2,r2,9
 200f1fc:	1000031e 	bne	r2,zero,200f20c <alt_epcs_flash_get_info+0x68>
  {
    ret_code = -ENOMEM;
 200f200:	00bffd04 	movi	r2,-12
 200f204:	e0bffb15 	stw	r2,-20(fp)
 200f208:	00000406 	br	200f21c <alt_epcs_flash_get_info+0x78>
  }
  else
  {
    *info = &flash->region_info[0];
 200f20c:	e0bffc17 	ldw	r2,-16(fp)
 200f210:	10c00d04 	addi	r3,r2,52
 200f214:	e0bffe17 	ldw	r2,-8(fp)
 200f218:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 200f21c:	e0bffb17 	ldw	r2,-20(fp)
}
 200f220:	e037883a 	mov	sp,fp
 200f224:	df000017 	ldw	fp,0(sp)
 200f228:	dec00104 	addi	sp,sp,4
 200f22c:	f800283a 	ret

0200f230 <alt_epcs_test_address>:


/* This might be a candidate for optimization.  Precompute the last-address? */
static ALT_INLINE int alt_epcs_test_address(alt_flash_dev* flash_info, int offset)
{
 200f230:	defff904 	addi	sp,sp,-28
 200f234:	df000615 	stw	fp,24(sp)
 200f238:	df000604 	addi	fp,sp,24
 200f23c:	e13ffe15 	stw	r4,-8(fp)
 200f240:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
 200f244:	e03ffa15 	stw	zero,-24(fp)
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 200f248:	e0bffe17 	ldw	r2,-8(fp)
 200f24c:	e0bffb15 	stw	r2,-20(fp)

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
 200f250:	e0bffb17 	ldw	r2,-20(fp)
 200f254:	10800c17 	ldw	r2,48(r2)
 200f258:	10bfffc4 	addi	r2,r2,-1
 200f25c:	e0bffc15 	stw	r2,-16(fp)
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
 200f260:	e0fffb17 	ldw	r3,-20(fp)
 200f264:	e0bffc17 	ldw	r2,-16(fp)
 200f268:	1004913a 	slli	r2,r2,4
 200f26c:	1885883a 	add	r2,r3,r2
 200f270:	10800d04 	addi	r2,r2,52
 200f274:	10800017 	ldw	r2,0(r2)
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
 200f278:	10ffffc4 	addi	r3,r2,-1
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;
 200f27c:	e13ffb17 	ldw	r4,-20(fp)
 200f280:	e0bffc17 	ldw	r2,-16(fp)
 200f284:	1004913a 	slli	r2,r2,4
 200f288:	2085883a 	add	r2,r4,r2
 200f28c:	10800e04 	addi	r2,r2,56
 200f290:	10800017 	ldw	r2,0(r2)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
 200f294:	1885883a 	add	r2,r3,r2
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
 200f298:	e0bffd15 	stw	r2,-12(fp)
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;

  if (offset > last_device_address)
 200f29c:	e0bfff17 	ldw	r2,-4(fp)
 200f2a0:	e0fffd17 	ldw	r3,-12(fp)
 200f2a4:	1880022e 	bgeu	r3,r2,200f2b0 <alt_epcs_test_address+0x80>
  {
    /* Someone tried to erase a block outside of this device's range. */
    ret_code = -EIO;
 200f2a8:	00bffec4 	movi	r2,-5
 200f2ac:	e0bffa15 	stw	r2,-24(fp)
  }
  return ret_code;
 200f2b0:	e0bffa17 	ldw	r2,-24(fp)
}
 200f2b4:	e037883a 	mov	sp,fp
 200f2b8:	df000017 	ldw	fp,0(sp)
 200f2bc:	dec00104 	addi	sp,sp,4
 200f2c0:	f800283a 	ret

0200f2c4 <alt_epcs_flash_erase_block>:
 *
 * Erase the selected erase block ("sector erase", from the POV
 * of the EPCS data sheet).
 */
int alt_epcs_flash_erase_block(alt_flash_dev* flash_info, int block_offset)
{
 200f2c4:	defffa04 	addi	sp,sp,-24
 200f2c8:	dfc00515 	stw	ra,20(sp)
 200f2cc:	df000415 	stw	fp,16(sp)
 200f2d0:	df000404 	addi	fp,sp,16
 200f2d4:	e13ffe15 	stw	r4,-8(fp)
 200f2d8:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
 200f2dc:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 200f2e0:	e0bffe17 	ldw	r2,-8(fp)
 200f2e4:	e0bffd15 	stw	r2,-12(fp)

  ret_code = alt_epcs_test_address(flash_info, block_offset);
 200f2e8:	e17fff17 	ldw	r5,-4(fp)
 200f2ec:	e13ffe17 	ldw	r4,-8(fp)
 200f2f0:	200f2300 	call	200f230 <alt_epcs_test_address>
 200f2f4:	e0bffc15 	stw	r2,-16(fp)

  if (ret_code >= 0)
 200f2f8:	e0bffc17 	ldw	r2,-16(fp)
 200f2fc:	10000916 	blt	r2,zero,200f324 <alt_epcs_flash_erase_block+0x60>
  {
    /* Send the Sector Erase command, whose 3 address bytes are anywhere
     * within the chosen sector.
     */
    epcs_sector_erase(f->register_base, block_offset, f->four_bytes_mode);
 200f300:	e0bffd17 	ldw	r2,-12(fp)
 200f304:	10c02e17 	ldw	r3,184(r2)
 200f308:	e13fff17 	ldw	r4,-4(fp)
 200f30c:	e0bffd17 	ldw	r2,-12(fp)
 200f310:	10803217 	ldw	r2,200(r2)
 200f314:	100d883a 	mov	r6,r2
 200f318:	200b883a 	mov	r5,r4
 200f31c:	1809883a 	mov	r4,r3
 200f320:	20109d80 	call	20109d8 <epcs_sector_erase>
  }
  return ret_code;
 200f324:	e0bffc17 	ldw	r2,-16(fp)
}
 200f328:	e037883a 	mov	sp,fp
 200f32c:	dfc00117 	ldw	ra,4(sp)
 200f330:	df000017 	ldw	fp,0(sp)
 200f334:	dec00204 	addi	sp,sp,8
 200f338:	f800283a 	ret

0200f33c <alt_epcs_flash_write_block>:
 * function type compatibility.
 */
int alt_epcs_flash_write_block(alt_flash_dev* flash_info, int block_offset,
                                      int data_offset, const void* data,
                                      int length)
{
 200f33c:	defff404 	addi	sp,sp,-48
 200f340:	dfc00b15 	stw	ra,44(sp)
 200f344:	df000a15 	stw	fp,40(sp)
 200f348:	df000a04 	addi	fp,sp,40
 200f34c:	e13ffc15 	stw	r4,-16(fp)
 200f350:	e17ffd15 	stw	r5,-12(fp)
 200f354:	e1bffe15 	stw	r6,-8(fp)
 200f358:	e1ffff15 	stw	r7,-4(fp)
  int ret_code;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 200f35c:	e0bffc17 	ldw	r2,-16(fp)
 200f360:	e0bff815 	stw	r2,-32(fp)

  int buffer_offset = 0;
 200f364:	e03ff715 	stw	zero,-36(fp)
  int length_of_current_write;
  ret_code = alt_epcs_test_address(flash_info, data_offset);
 200f368:	e17ffe17 	ldw	r5,-8(fp)
 200f36c:	e13ffc17 	ldw	r4,-16(fp)
 200f370:	200f2300 	call	200f230 <alt_epcs_test_address>
 200f374:	e0bff915 	stw	r2,-28(fp)

  if (ret_code >= 0)
 200f378:	e0bff917 	ldw	r2,-28(fp)
 200f37c:	10002916 	blt	r2,zero,200f424 <alt_epcs_flash_write_block+0xe8>
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
 200f380:	00002606 	br	200f41c <alt_epcs_flash_write_block+0xe0>
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
 200f384:	e0bff817 	ldw	r2,-32(fp)
 200f388:	10c03117 	ldw	r3,196(r2)
 200f38c:	e0bffe17 	ldw	r2,-8(fp)
 200f390:	1887883a 	add	r3,r3,r2
 200f394:	e0bff817 	ldw	r2,-32(fp)
 200f398:	10803117 	ldw	r2,196(r2)
 200f39c:	0085c83a 	sub	r2,zero,r2
 200f3a0:	1884703a 	and	r2,r3,r2
 200f3a4:	e0bffa15 	stw	r2,-24(fp)
      length_of_current_write = MIN(length, next_page_start - data_offset);
 200f3a8:	e0fffa17 	ldw	r3,-24(fp)
 200f3ac:	e0bffe17 	ldw	r2,-8(fp)
 200f3b0:	1885c83a 	sub	r2,r3,r2
 200f3b4:	e0c00217 	ldw	r3,8(fp)
 200f3b8:	1880010e 	bge	r3,r2,200f3c0 <alt_epcs_flash_write_block+0x84>
 200f3bc:	1805883a 	mov	r2,r3
 200f3c0:	e0bffb15 	stw	r2,-20(fp)

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
 200f3c4:	e0bff817 	ldw	r2,-32(fp)
 200f3c8:	11002e17 	ldw	r4,184(r2)
 200f3cc:	e0bff717 	ldw	r2,-36(fp)
 200f3d0:	e0ffff17 	ldw	r3,-4(fp)
 200f3d4:	1887883a 	add	r3,r3,r2
 200f3d8:	e0bff817 	ldw	r2,-32(fp)
 200f3dc:	10803217 	ldw	r2,200(r2)
 200f3e0:	d8800015 	stw	r2,0(sp)
 200f3e4:	e1fffb17 	ldw	r7,-20(fp)
 200f3e8:	180d883a 	mov	r6,r3
 200f3ec:	e17ffe17 	ldw	r5,-8(fp)
 200f3f0:	2010c880 	call	2010c88 <epcs_write_buffer>
          f->four_bytes_mode);

      length -= length_of_current_write;
 200f3f4:	e0c00217 	ldw	r3,8(fp)
 200f3f8:	e0bffb17 	ldw	r2,-20(fp)
 200f3fc:	1885c83a 	sub	r2,r3,r2
 200f400:	e0800215 	stw	r2,8(fp)
      buffer_offset += length_of_current_write;
 200f404:	e0fff717 	ldw	r3,-36(fp)
 200f408:	e0bffb17 	ldw	r2,-20(fp)
 200f40c:	1885883a 	add	r2,r3,r2
 200f410:	e0bff715 	stw	r2,-36(fp)
      data_offset = next_page_start;
 200f414:	e0bffa17 	ldw	r2,-24(fp)
 200f418:	e0bffe15 	stw	r2,-8(fp)
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
 200f41c:	e0800217 	ldw	r2,8(fp)
 200f420:	103fd81e 	bne	r2,zero,200f384 <__reset+0xfe00e384>
      length -= length_of_current_write;
      buffer_offset += length_of_current_write;
      data_offset = next_page_start;
    }
  }
  return ret_code;
 200f424:	e0bff917 	ldw	r2,-28(fp)
}
 200f428:	e037883a 	mov	sp,fp
 200f42c:	dfc00117 	ldw	ra,4(sp)
 200f430:	df000017 	ldw	fp,0(sp)
 200f434:	dec00204 	addi	sp,sp,8
 200f438:	f800283a 	ret

0200f43c <alt_epcs_flash_read>:
 *  to the beginning.  Reads that start beyond the end of the memory are
 *  flagged as errors with EIO (is there a better error code?).
 */
int alt_epcs_flash_read(alt_flash_dev* flash_info, int offset,
                        void* dest_addr, int length)
{
 200f43c:	defff704 	addi	sp,sp,-36
 200f440:	dfc00815 	stw	ra,32(sp)
 200f444:	df000715 	stw	fp,28(sp)
 200f448:	df000704 	addi	fp,sp,28
 200f44c:	e13ffc15 	stw	r4,-16(fp)
 200f450:	e17ffd15 	stw	r5,-12(fp)
 200f454:	e1bffe15 	stw	r6,-8(fp)
 200f458:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 200f45c:	e03ffa15 	stw	zero,-24(fp)

  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 200f460:	e0bffc17 	ldw	r2,-16(fp)
 200f464:	e0bffb15 	stw	r2,-20(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);
 200f468:	e17ffd17 	ldw	r5,-12(fp)
 200f46c:	e13ffc17 	ldw	r4,-16(fp)
 200f470:	200f2300 	call	200f230 <alt_epcs_test_address>
 200f474:	e0bffa15 	stw	r2,-24(fp)

  if (ret_code >= 0)
 200f478:	e0bffa17 	ldw	r2,-24(fp)
 200f47c:	10000f16 	blt	r2,zero,200f4bc <alt_epcs_flash_read+0x80>
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
 200f480:	e0bffb17 	ldw	r2,-20(fp)
 200f484:	10c02e17 	ldw	r3,184(r2)
 200f488:	e0bffb17 	ldw	r2,-20(fp)
 200f48c:	10803217 	ldw	r2,200(r2)
 200f490:	d8800015 	stw	r2,0(sp)
 200f494:	e1ffff17 	ldw	r7,-4(fp)
 200f498:	e1bffe17 	ldw	r6,-8(fp)
 200f49c:	e17ffd17 	ldw	r5,-12(fp)
 200f4a0:	1809883a 	mov	r4,r3
 200f4a4:	2010ad40 	call	2010ad4 <epcs_read_buffer>
 200f4a8:	e0bffa15 	stw	r2,-24(fp)
                                f->four_bytes_mode);

    /* epcs_read_buffer returns the number of buffers read, but
     * alt_epcs_flash_read returns 0 on success, <0 on failure.
     */
    if (ret_code == length)
 200f4ac:	e0fffa17 	ldw	r3,-24(fp)
 200f4b0:	e0bfff17 	ldw	r2,-4(fp)
 200f4b4:	1880011e 	bne	r3,r2,200f4bc <alt_epcs_flash_read+0x80>
    {
      ret_code = 0;
 200f4b8:	e03ffa15 	stw	zero,-24(fp)
    }
  }
  return ret_code;
 200f4bc:	e0bffa17 	ldw	r2,-24(fp)
}
 200f4c0:	e037883a 	mov	sp,fp
 200f4c4:	dfc00117 	ldw	ra,4(sp)
 200f4c8:	df000017 	ldw	fp,0(sp)
 200f4cc:	dec00204 	addi	sp,sp,8
 200f4d0:	f800283a 	ret

0200f4d4 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 200f4d4:	defffa04 	addi	sp,sp,-24
 200f4d8:	dfc00515 	stw	ra,20(sp)
 200f4dc:	df000415 	stw	fp,16(sp)
 200f4e0:	df000404 	addi	fp,sp,16
 200f4e4:	e13ffd15 	stw	r4,-12(fp)
 200f4e8:	e17ffe15 	stw	r5,-8(fp)
 200f4ec:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 200f4f0:	e0bffd17 	ldw	r2,-12(fp)
 200f4f4:	10800017 	ldw	r2,0(r2)
 200f4f8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 200f4fc:	e0bffc17 	ldw	r2,-16(fp)
 200f500:	10c00a04 	addi	r3,r2,40
 200f504:	e0bffd17 	ldw	r2,-12(fp)
 200f508:	10800217 	ldw	r2,8(r2)
 200f50c:	100f883a 	mov	r7,r2
 200f510:	e1bfff17 	ldw	r6,-4(fp)
 200f514:	e17ffe17 	ldw	r5,-8(fp)
 200f518:	1809883a 	mov	r4,r3
 200f51c:	200fafc0 	call	200fafc <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 200f520:	e037883a 	mov	sp,fp
 200f524:	dfc00117 	ldw	ra,4(sp)
 200f528:	df000017 	ldw	fp,0(sp)
 200f52c:	dec00204 	addi	sp,sp,8
 200f530:	f800283a 	ret

0200f534 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 200f534:	defffa04 	addi	sp,sp,-24
 200f538:	dfc00515 	stw	ra,20(sp)
 200f53c:	df000415 	stw	fp,16(sp)
 200f540:	df000404 	addi	fp,sp,16
 200f544:	e13ffd15 	stw	r4,-12(fp)
 200f548:	e17ffe15 	stw	r5,-8(fp)
 200f54c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 200f550:	e0bffd17 	ldw	r2,-12(fp)
 200f554:	10800017 	ldw	r2,0(r2)
 200f558:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 200f55c:	e0bffc17 	ldw	r2,-16(fp)
 200f560:	10c00a04 	addi	r3,r2,40
 200f564:	e0bffd17 	ldw	r2,-12(fp)
 200f568:	10800217 	ldw	r2,8(r2)
 200f56c:	100f883a 	mov	r7,r2
 200f570:	e1bfff17 	ldw	r6,-4(fp)
 200f574:	e17ffe17 	ldw	r5,-8(fp)
 200f578:	1809883a 	mov	r4,r3
 200f57c:	200fd180 	call	200fd18 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 200f580:	e037883a 	mov	sp,fp
 200f584:	dfc00117 	ldw	ra,4(sp)
 200f588:	df000017 	ldw	fp,0(sp)
 200f58c:	dec00204 	addi	sp,sp,8
 200f590:	f800283a 	ret

0200f594 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 200f594:	defffc04 	addi	sp,sp,-16
 200f598:	dfc00315 	stw	ra,12(sp)
 200f59c:	df000215 	stw	fp,8(sp)
 200f5a0:	df000204 	addi	fp,sp,8
 200f5a4:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 200f5a8:	e0bfff17 	ldw	r2,-4(fp)
 200f5ac:	10800017 	ldw	r2,0(r2)
 200f5b0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 200f5b4:	e0bffe17 	ldw	r2,-8(fp)
 200f5b8:	10c00a04 	addi	r3,r2,40
 200f5bc:	e0bfff17 	ldw	r2,-4(fp)
 200f5c0:	10800217 	ldw	r2,8(r2)
 200f5c4:	100b883a 	mov	r5,r2
 200f5c8:	1809883a 	mov	r4,r3
 200f5cc:	200f9a40 	call	200f9a4 <altera_avalon_jtag_uart_close>
}
 200f5d0:	e037883a 	mov	sp,fp
 200f5d4:	dfc00117 	ldw	ra,4(sp)
 200f5d8:	df000017 	ldw	fp,0(sp)
 200f5dc:	dec00204 	addi	sp,sp,8
 200f5e0:	f800283a 	ret

0200f5e4 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 200f5e4:	defffa04 	addi	sp,sp,-24
 200f5e8:	dfc00515 	stw	ra,20(sp)
 200f5ec:	df000415 	stw	fp,16(sp)
 200f5f0:	df000404 	addi	fp,sp,16
 200f5f4:	e13ffd15 	stw	r4,-12(fp)
 200f5f8:	e17ffe15 	stw	r5,-8(fp)
 200f5fc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 200f600:	e0bffd17 	ldw	r2,-12(fp)
 200f604:	10800017 	ldw	r2,0(r2)
 200f608:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 200f60c:	e0bffc17 	ldw	r2,-16(fp)
 200f610:	10800a04 	addi	r2,r2,40
 200f614:	e1bfff17 	ldw	r6,-4(fp)
 200f618:	e17ffe17 	ldw	r5,-8(fp)
 200f61c:	1009883a 	mov	r4,r2
 200f620:	200fa0c0 	call	200fa0c <altera_avalon_jtag_uart_ioctl>
}
 200f624:	e037883a 	mov	sp,fp
 200f628:	dfc00117 	ldw	ra,4(sp)
 200f62c:	df000017 	ldw	fp,0(sp)
 200f630:	dec00204 	addi	sp,sp,8
 200f634:	f800283a 	ret

0200f638 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 200f638:	defffa04 	addi	sp,sp,-24
 200f63c:	dfc00515 	stw	ra,20(sp)
 200f640:	df000415 	stw	fp,16(sp)
 200f644:	df000404 	addi	fp,sp,16
 200f648:	e13ffd15 	stw	r4,-12(fp)
 200f64c:	e17ffe15 	stw	r5,-8(fp)
 200f650:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 200f654:	e0bffd17 	ldw	r2,-12(fp)
 200f658:	00c00044 	movi	r3,1
 200f65c:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 200f660:	e0bffd17 	ldw	r2,-12(fp)
 200f664:	10800017 	ldw	r2,0(r2)
 200f668:	10800104 	addi	r2,r2,4
 200f66c:	1007883a 	mov	r3,r2
 200f670:	e0bffd17 	ldw	r2,-12(fp)
 200f674:	10800817 	ldw	r2,32(r2)
 200f678:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 200f67c:	e0bffe17 	ldw	r2,-8(fp)
 200f680:	e0ffff17 	ldw	r3,-4(fp)
 200f684:	d8000015 	stw	zero,0(sp)
 200f688:	e1fffd17 	ldw	r7,-12(fp)
 200f68c:	01808074 	movhi	r6,513
 200f690:	31bdbe04 	addi	r6,r6,-2312
 200f694:	180b883a 	mov	r5,r3
 200f698:	1009883a 	mov	r4,r2
 200f69c:	200e00c0 	call	200e00c <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 200f6a0:	e0bffd17 	ldw	r2,-12(fp)
 200f6a4:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 200f6a8:	e0bffd17 	ldw	r2,-12(fp)
 200f6ac:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 200f6b0:	d0e09417 	ldw	r3,-32176(gp)
 200f6b4:	e1fffd17 	ldw	r7,-12(fp)
 200f6b8:	01808074 	movhi	r6,513
 200f6bc:	31be4104 	addi	r6,r6,-1788
 200f6c0:	180b883a 	mov	r5,r3
 200f6c4:	1009883a 	mov	r4,r2
 200f6c8:	2010f440 	call	2010f44 <alt_alarm_start>
 200f6cc:	1000040e 	bge	r2,zero,200f6e0 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 200f6d0:	e0fffd17 	ldw	r3,-12(fp)
 200f6d4:	00a00034 	movhi	r2,32768
 200f6d8:	10bfffc4 	addi	r2,r2,-1
 200f6dc:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 200f6e0:	0001883a 	nop
 200f6e4:	e037883a 	mov	sp,fp
 200f6e8:	dfc00117 	ldw	ra,4(sp)
 200f6ec:	df000017 	ldw	fp,0(sp)
 200f6f0:	dec00204 	addi	sp,sp,8
 200f6f4:	f800283a 	ret

0200f6f8 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 200f6f8:	defff804 	addi	sp,sp,-32
 200f6fc:	df000715 	stw	fp,28(sp)
 200f700:	df000704 	addi	fp,sp,28
 200f704:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 200f708:	e0bfff17 	ldw	r2,-4(fp)
 200f70c:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
 200f710:	e0bffb17 	ldw	r2,-20(fp)
 200f714:	10800017 	ldw	r2,0(r2)
 200f718:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 200f71c:	e0bffc17 	ldw	r2,-16(fp)
 200f720:	10800104 	addi	r2,r2,4
 200f724:	10800037 	ldwio	r2,0(r2)
 200f728:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 200f72c:	e0bffd17 	ldw	r2,-12(fp)
 200f730:	1080c00c 	andi	r2,r2,768
 200f734:	10006d26 	beq	r2,zero,200f8ec <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 200f738:	e0bffd17 	ldw	r2,-12(fp)
 200f73c:	1080400c 	andi	r2,r2,256
 200f740:	10003526 	beq	r2,zero,200f818 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 200f744:	00800074 	movhi	r2,1
 200f748:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 200f74c:	e0bffb17 	ldw	r2,-20(fp)
 200f750:	10800a17 	ldw	r2,40(r2)
 200f754:	10800044 	addi	r2,r2,1
 200f758:	1081ffcc 	andi	r2,r2,2047
 200f75c:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
 200f760:	e0bffb17 	ldw	r2,-20(fp)
 200f764:	10c00b17 	ldw	r3,44(r2)
 200f768:	e0bffe17 	ldw	r2,-8(fp)
 200f76c:	18801526 	beq	r3,r2,200f7c4 <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 200f770:	e0bffc17 	ldw	r2,-16(fp)
 200f774:	10800037 	ldwio	r2,0(r2)
 200f778:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 200f77c:	e0bff917 	ldw	r2,-28(fp)
 200f780:	10a0000c 	andi	r2,r2,32768
 200f784:	10001126 	beq	r2,zero,200f7cc <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 200f788:	e0bffb17 	ldw	r2,-20(fp)
 200f78c:	10800a17 	ldw	r2,40(r2)
 200f790:	e0fff917 	ldw	r3,-28(fp)
 200f794:	1809883a 	mov	r4,r3
 200f798:	e0fffb17 	ldw	r3,-20(fp)
 200f79c:	1885883a 	add	r2,r3,r2
 200f7a0:	10800e04 	addi	r2,r2,56
 200f7a4:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 200f7a8:	e0bffb17 	ldw	r2,-20(fp)
 200f7ac:	10800a17 	ldw	r2,40(r2)
 200f7b0:	10800044 	addi	r2,r2,1
 200f7b4:	10c1ffcc 	andi	r3,r2,2047
 200f7b8:	e0bffb17 	ldw	r2,-20(fp)
 200f7bc:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 200f7c0:	003fe206 	br	200f74c <__reset+0xfe00e74c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 200f7c4:	0001883a 	nop
 200f7c8:	00000106 	br	200f7d0 <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 200f7cc:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 200f7d0:	e0bff917 	ldw	r2,-28(fp)
 200f7d4:	10bfffec 	andhi	r2,r2,65535
 200f7d8:	10000f26 	beq	r2,zero,200f818 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 200f7dc:	e0bffb17 	ldw	r2,-20(fp)
 200f7e0:	10c00817 	ldw	r3,32(r2)
 200f7e4:	00bfff84 	movi	r2,-2
 200f7e8:	1886703a 	and	r3,r3,r2
 200f7ec:	e0bffb17 	ldw	r2,-20(fp)
 200f7f0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 200f7f4:	e0bffc17 	ldw	r2,-16(fp)
 200f7f8:	10800104 	addi	r2,r2,4
 200f7fc:	1007883a 	mov	r3,r2
 200f800:	e0bffb17 	ldw	r2,-20(fp)
 200f804:	10800817 	ldw	r2,32(r2)
 200f808:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 200f80c:	e0bffc17 	ldw	r2,-16(fp)
 200f810:	10800104 	addi	r2,r2,4
 200f814:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 200f818:	e0bffd17 	ldw	r2,-12(fp)
 200f81c:	1080800c 	andi	r2,r2,512
 200f820:	103fbe26 	beq	r2,zero,200f71c <__reset+0xfe00e71c>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 200f824:	e0bffd17 	ldw	r2,-12(fp)
 200f828:	1004d43a 	srli	r2,r2,16
 200f82c:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 200f830:	00001406 	br	200f884 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 200f834:	e0bffc17 	ldw	r2,-16(fp)
 200f838:	e0fffb17 	ldw	r3,-20(fp)
 200f83c:	18c00d17 	ldw	r3,52(r3)
 200f840:	e13ffb17 	ldw	r4,-20(fp)
 200f844:	20c7883a 	add	r3,r4,r3
 200f848:	18c20e04 	addi	r3,r3,2104
 200f84c:	18c00003 	ldbu	r3,0(r3)
 200f850:	18c03fcc 	andi	r3,r3,255
 200f854:	18c0201c 	xori	r3,r3,128
 200f858:	18ffe004 	addi	r3,r3,-128
 200f85c:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 200f860:	e0bffb17 	ldw	r2,-20(fp)
 200f864:	10800d17 	ldw	r2,52(r2)
 200f868:	10800044 	addi	r2,r2,1
 200f86c:	10c1ffcc 	andi	r3,r2,2047
 200f870:	e0bffb17 	ldw	r2,-20(fp)
 200f874:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 200f878:	e0bffa17 	ldw	r2,-24(fp)
 200f87c:	10bfffc4 	addi	r2,r2,-1
 200f880:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 200f884:	e0bffa17 	ldw	r2,-24(fp)
 200f888:	10000526 	beq	r2,zero,200f8a0 <altera_avalon_jtag_uart_irq+0x1a8>
 200f88c:	e0bffb17 	ldw	r2,-20(fp)
 200f890:	10c00d17 	ldw	r3,52(r2)
 200f894:	e0bffb17 	ldw	r2,-20(fp)
 200f898:	10800c17 	ldw	r2,48(r2)
 200f89c:	18bfe51e 	bne	r3,r2,200f834 <__reset+0xfe00e834>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 200f8a0:	e0bffa17 	ldw	r2,-24(fp)
 200f8a4:	103f9d26 	beq	r2,zero,200f71c <__reset+0xfe00e71c>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 200f8a8:	e0bffb17 	ldw	r2,-20(fp)
 200f8ac:	10c00817 	ldw	r3,32(r2)
 200f8b0:	00bfff44 	movi	r2,-3
 200f8b4:	1886703a 	and	r3,r3,r2
 200f8b8:	e0bffb17 	ldw	r2,-20(fp)
 200f8bc:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 200f8c0:	e0bffb17 	ldw	r2,-20(fp)
 200f8c4:	10800017 	ldw	r2,0(r2)
 200f8c8:	10800104 	addi	r2,r2,4
 200f8cc:	1007883a 	mov	r3,r2
 200f8d0:	e0bffb17 	ldw	r2,-20(fp)
 200f8d4:	10800817 	ldw	r2,32(r2)
 200f8d8:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 200f8dc:	e0bffc17 	ldw	r2,-16(fp)
 200f8e0:	10800104 	addi	r2,r2,4
 200f8e4:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 200f8e8:	003f8c06 	br	200f71c <__reset+0xfe00e71c>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 200f8ec:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 200f8f0:	0001883a 	nop
 200f8f4:	e037883a 	mov	sp,fp
 200f8f8:	df000017 	ldw	fp,0(sp)
 200f8fc:	dec00104 	addi	sp,sp,4
 200f900:	f800283a 	ret

0200f904 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 200f904:	defff804 	addi	sp,sp,-32
 200f908:	df000715 	stw	fp,28(sp)
 200f90c:	df000704 	addi	fp,sp,28
 200f910:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 200f914:	e0bffb17 	ldw	r2,-20(fp)
 200f918:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 200f91c:	e0bff917 	ldw	r2,-28(fp)
 200f920:	10800017 	ldw	r2,0(r2)
 200f924:	10800104 	addi	r2,r2,4
 200f928:	10800037 	ldwio	r2,0(r2)
 200f92c:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 200f930:	e0bffa17 	ldw	r2,-24(fp)
 200f934:	1081000c 	andi	r2,r2,1024
 200f938:	10000b26 	beq	r2,zero,200f968 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 200f93c:	e0bff917 	ldw	r2,-28(fp)
 200f940:	10800017 	ldw	r2,0(r2)
 200f944:	10800104 	addi	r2,r2,4
 200f948:	1007883a 	mov	r3,r2
 200f94c:	e0bff917 	ldw	r2,-28(fp)
 200f950:	10800817 	ldw	r2,32(r2)
 200f954:	10810014 	ori	r2,r2,1024
 200f958:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 200f95c:	e0bff917 	ldw	r2,-28(fp)
 200f960:	10000915 	stw	zero,36(r2)
 200f964:	00000a06 	br	200f990 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 200f968:	e0bff917 	ldw	r2,-28(fp)
 200f96c:	10c00917 	ldw	r3,36(r2)
 200f970:	00a00034 	movhi	r2,32768
 200f974:	10bfff04 	addi	r2,r2,-4
 200f978:	10c00536 	bltu	r2,r3,200f990 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 200f97c:	e0bff917 	ldw	r2,-28(fp)
 200f980:	10800917 	ldw	r2,36(r2)
 200f984:	10c00044 	addi	r3,r2,1
 200f988:	e0bff917 	ldw	r2,-28(fp)
 200f98c:	10c00915 	stw	r3,36(r2)
 200f990:	d0a09417 	ldw	r2,-32176(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 200f994:	e037883a 	mov	sp,fp
 200f998:	df000017 	ldw	fp,0(sp)
 200f99c:	dec00104 	addi	sp,sp,4
 200f9a0:	f800283a 	ret

0200f9a4 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 200f9a4:	defffd04 	addi	sp,sp,-12
 200f9a8:	df000215 	stw	fp,8(sp)
 200f9ac:	df000204 	addi	fp,sp,8
 200f9b0:	e13ffe15 	stw	r4,-8(fp)
 200f9b4:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 200f9b8:	00000506 	br	200f9d0 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 200f9bc:	e0bfff17 	ldw	r2,-4(fp)
 200f9c0:	1090000c 	andi	r2,r2,16384
 200f9c4:	10000226 	beq	r2,zero,200f9d0 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 200f9c8:	00bffd44 	movi	r2,-11
 200f9cc:	00000b06 	br	200f9fc <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 200f9d0:	e0bffe17 	ldw	r2,-8(fp)
 200f9d4:	10c00d17 	ldw	r3,52(r2)
 200f9d8:	e0bffe17 	ldw	r2,-8(fp)
 200f9dc:	10800c17 	ldw	r2,48(r2)
 200f9e0:	18800526 	beq	r3,r2,200f9f8 <altera_avalon_jtag_uart_close+0x54>
 200f9e4:	e0bffe17 	ldw	r2,-8(fp)
 200f9e8:	10c00917 	ldw	r3,36(r2)
 200f9ec:	e0bffe17 	ldw	r2,-8(fp)
 200f9f0:	10800117 	ldw	r2,4(r2)
 200f9f4:	18bff136 	bltu	r3,r2,200f9bc <__reset+0xfe00e9bc>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 200f9f8:	0005883a 	mov	r2,zero
}
 200f9fc:	e037883a 	mov	sp,fp
 200fa00:	df000017 	ldw	fp,0(sp)
 200fa04:	dec00104 	addi	sp,sp,4
 200fa08:	f800283a 	ret

0200fa0c <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 200fa0c:	defffa04 	addi	sp,sp,-24
 200fa10:	df000515 	stw	fp,20(sp)
 200fa14:	df000504 	addi	fp,sp,20
 200fa18:	e13ffd15 	stw	r4,-12(fp)
 200fa1c:	e17ffe15 	stw	r5,-8(fp)
 200fa20:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 200fa24:	00bff9c4 	movi	r2,-25
 200fa28:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 200fa2c:	e0bffe17 	ldw	r2,-8(fp)
 200fa30:	10da8060 	cmpeqi	r3,r2,27137
 200fa34:	1800031e 	bne	r3,zero,200fa44 <altera_avalon_jtag_uart_ioctl+0x38>
 200fa38:	109a80a0 	cmpeqi	r2,r2,27138
 200fa3c:	1000181e 	bne	r2,zero,200faa0 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 200fa40:	00002906 	br	200fae8 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 200fa44:	e0bffd17 	ldw	r2,-12(fp)
 200fa48:	10c00117 	ldw	r3,4(r2)
 200fa4c:	00a00034 	movhi	r2,32768
 200fa50:	10bfffc4 	addi	r2,r2,-1
 200fa54:	18802126 	beq	r3,r2,200fadc <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 200fa58:	e0bfff17 	ldw	r2,-4(fp)
 200fa5c:	10800017 	ldw	r2,0(r2)
 200fa60:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 200fa64:	e0bffc17 	ldw	r2,-16(fp)
 200fa68:	10800090 	cmplti	r2,r2,2
 200fa6c:	1000061e 	bne	r2,zero,200fa88 <altera_avalon_jtag_uart_ioctl+0x7c>
 200fa70:	e0fffc17 	ldw	r3,-16(fp)
 200fa74:	00a00034 	movhi	r2,32768
 200fa78:	10bfffc4 	addi	r2,r2,-1
 200fa7c:	18800226 	beq	r3,r2,200fa88 <altera_avalon_jtag_uart_ioctl+0x7c>
 200fa80:	e0bffc17 	ldw	r2,-16(fp)
 200fa84:	00000206 	br	200fa90 <altera_avalon_jtag_uart_ioctl+0x84>
 200fa88:	00a00034 	movhi	r2,32768
 200fa8c:	10bfff84 	addi	r2,r2,-2
 200fa90:	e0fffd17 	ldw	r3,-12(fp)
 200fa94:	18800115 	stw	r2,4(r3)
      rc = 0;
 200fa98:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 200fa9c:	00000f06 	br	200fadc <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 200faa0:	e0bffd17 	ldw	r2,-12(fp)
 200faa4:	10c00117 	ldw	r3,4(r2)
 200faa8:	00a00034 	movhi	r2,32768
 200faac:	10bfffc4 	addi	r2,r2,-1
 200fab0:	18800c26 	beq	r3,r2,200fae4 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 200fab4:	e0bffd17 	ldw	r2,-12(fp)
 200fab8:	10c00917 	ldw	r3,36(r2)
 200fabc:	e0bffd17 	ldw	r2,-12(fp)
 200fac0:	10800117 	ldw	r2,4(r2)
 200fac4:	1885803a 	cmpltu	r2,r3,r2
 200fac8:	10c03fcc 	andi	r3,r2,255
 200facc:	e0bfff17 	ldw	r2,-4(fp)
 200fad0:	10c00015 	stw	r3,0(r2)
      rc = 0;
 200fad4:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 200fad8:	00000206 	br	200fae4 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 200fadc:	0001883a 	nop
 200fae0:	00000106 	br	200fae8 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 200fae4:	0001883a 	nop

  default:
    break;
  }

  return rc;
 200fae8:	e0bffb17 	ldw	r2,-20(fp)
}
 200faec:	e037883a 	mov	sp,fp
 200faf0:	df000017 	ldw	fp,0(sp)
 200faf4:	dec00104 	addi	sp,sp,4
 200faf8:	f800283a 	ret

0200fafc <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 200fafc:	defff304 	addi	sp,sp,-52
 200fb00:	dfc00c15 	stw	ra,48(sp)
 200fb04:	df000b15 	stw	fp,44(sp)
 200fb08:	df000b04 	addi	fp,sp,44
 200fb0c:	e13ffc15 	stw	r4,-16(fp)
 200fb10:	e17ffd15 	stw	r5,-12(fp)
 200fb14:	e1bffe15 	stw	r6,-8(fp)
 200fb18:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 200fb1c:	e0bffd17 	ldw	r2,-12(fp)
 200fb20:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 200fb24:	00004706 	br	200fc44 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 200fb28:	e0bffc17 	ldw	r2,-16(fp)
 200fb2c:	10800a17 	ldw	r2,40(r2)
 200fb30:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 200fb34:	e0bffc17 	ldw	r2,-16(fp)
 200fb38:	10800b17 	ldw	r2,44(r2)
 200fb3c:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
 200fb40:	e0fff717 	ldw	r3,-36(fp)
 200fb44:	e0bff817 	ldw	r2,-32(fp)
 200fb48:	18800536 	bltu	r3,r2,200fb60 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 200fb4c:	e0fff717 	ldw	r3,-36(fp)
 200fb50:	e0bff817 	ldw	r2,-32(fp)
 200fb54:	1885c83a 	sub	r2,r3,r2
 200fb58:	e0bff615 	stw	r2,-40(fp)
 200fb5c:	00000406 	br	200fb70 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 200fb60:	00c20004 	movi	r3,2048
 200fb64:	e0bff817 	ldw	r2,-32(fp)
 200fb68:	1885c83a 	sub	r2,r3,r2
 200fb6c:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 200fb70:	e0bff617 	ldw	r2,-40(fp)
 200fb74:	10001e26 	beq	r2,zero,200fbf0 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 200fb78:	e0fffe17 	ldw	r3,-8(fp)
 200fb7c:	e0bff617 	ldw	r2,-40(fp)
 200fb80:	1880022e 	bgeu	r3,r2,200fb8c <altera_avalon_jtag_uart_read+0x90>
        n = space;
 200fb84:	e0bffe17 	ldw	r2,-8(fp)
 200fb88:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 200fb8c:	e0bffc17 	ldw	r2,-16(fp)
 200fb90:	10c00e04 	addi	r3,r2,56
 200fb94:	e0bff817 	ldw	r2,-32(fp)
 200fb98:	1885883a 	add	r2,r3,r2
 200fb9c:	e1bff617 	ldw	r6,-40(fp)
 200fba0:	100b883a 	mov	r5,r2
 200fba4:	e13ff517 	ldw	r4,-44(fp)
 200fba8:	200af380 	call	200af38 <memcpy>
      ptr   += n;
 200fbac:	e0fff517 	ldw	r3,-44(fp)
 200fbb0:	e0bff617 	ldw	r2,-40(fp)
 200fbb4:	1885883a 	add	r2,r3,r2
 200fbb8:	e0bff515 	stw	r2,-44(fp)
      space -= n;
 200fbbc:	e0fffe17 	ldw	r3,-8(fp)
 200fbc0:	e0bff617 	ldw	r2,-40(fp)
 200fbc4:	1885c83a 	sub	r2,r3,r2
 200fbc8:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 200fbcc:	e0fff817 	ldw	r3,-32(fp)
 200fbd0:	e0bff617 	ldw	r2,-40(fp)
 200fbd4:	1885883a 	add	r2,r3,r2
 200fbd8:	10c1ffcc 	andi	r3,r2,2047
 200fbdc:	e0bffc17 	ldw	r2,-16(fp)
 200fbe0:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 200fbe4:	e0bffe17 	ldw	r2,-8(fp)
 200fbe8:	00bfcf16 	blt	zero,r2,200fb28 <__reset+0xfe00eb28>
 200fbec:	00000106 	br	200fbf4 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 200fbf0:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 200fbf4:	e0fff517 	ldw	r3,-44(fp)
 200fbf8:	e0bffd17 	ldw	r2,-12(fp)
 200fbfc:	1880141e 	bne	r3,r2,200fc50 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 200fc00:	e0bfff17 	ldw	r2,-4(fp)
 200fc04:	1090000c 	andi	r2,r2,16384
 200fc08:	1000131e 	bne	r2,zero,200fc58 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 200fc0c:	0001883a 	nop
 200fc10:	e0bffc17 	ldw	r2,-16(fp)
 200fc14:	10c00a17 	ldw	r3,40(r2)
 200fc18:	e0bff717 	ldw	r2,-36(fp)
 200fc1c:	1880051e 	bne	r3,r2,200fc34 <altera_avalon_jtag_uart_read+0x138>
 200fc20:	e0bffc17 	ldw	r2,-16(fp)
 200fc24:	10c00917 	ldw	r3,36(r2)
 200fc28:	e0bffc17 	ldw	r2,-16(fp)
 200fc2c:	10800117 	ldw	r2,4(r2)
 200fc30:	18bff736 	bltu	r3,r2,200fc10 <__reset+0xfe00ec10>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 200fc34:	e0bffc17 	ldw	r2,-16(fp)
 200fc38:	10c00a17 	ldw	r3,40(r2)
 200fc3c:	e0bff717 	ldw	r2,-36(fp)
 200fc40:	18800726 	beq	r3,r2,200fc60 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 200fc44:	e0bffe17 	ldw	r2,-8(fp)
 200fc48:	00bfb716 	blt	zero,r2,200fb28 <__reset+0xfe00eb28>
 200fc4c:	00000506 	br	200fc64 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 200fc50:	0001883a 	nop
 200fc54:	00000306 	br	200fc64 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 200fc58:	0001883a 	nop
 200fc5c:	00000106 	br	200fc64 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 200fc60:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 200fc64:	e0fff517 	ldw	r3,-44(fp)
 200fc68:	e0bffd17 	ldw	r2,-12(fp)
 200fc6c:	18801826 	beq	r3,r2,200fcd0 <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 200fc70:	0005303a 	rdctl	r2,status
 200fc74:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 200fc78:	e0fffb17 	ldw	r3,-20(fp)
 200fc7c:	00bfff84 	movi	r2,-2
 200fc80:	1884703a 	and	r2,r3,r2
 200fc84:	1001703a 	wrctl	status,r2
  
  return context;
 200fc88:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 200fc8c:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 200fc90:	e0bffc17 	ldw	r2,-16(fp)
 200fc94:	10800817 	ldw	r2,32(r2)
 200fc98:	10c00054 	ori	r3,r2,1
 200fc9c:	e0bffc17 	ldw	r2,-16(fp)
 200fca0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 200fca4:	e0bffc17 	ldw	r2,-16(fp)
 200fca8:	10800017 	ldw	r2,0(r2)
 200fcac:	10800104 	addi	r2,r2,4
 200fcb0:	1007883a 	mov	r3,r2
 200fcb4:	e0bffc17 	ldw	r2,-16(fp)
 200fcb8:	10800817 	ldw	r2,32(r2)
 200fcbc:	18800035 	stwio	r2,0(r3)
 200fcc0:	e0bffa17 	ldw	r2,-24(fp)
 200fcc4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 200fcc8:	e0bff917 	ldw	r2,-28(fp)
 200fccc:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 200fcd0:	e0fff517 	ldw	r3,-44(fp)
 200fcd4:	e0bffd17 	ldw	r2,-12(fp)
 200fcd8:	18800426 	beq	r3,r2,200fcec <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
 200fcdc:	e0fff517 	ldw	r3,-44(fp)
 200fce0:	e0bffd17 	ldw	r2,-12(fp)
 200fce4:	1885c83a 	sub	r2,r3,r2
 200fce8:	00000606 	br	200fd04 <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
 200fcec:	e0bfff17 	ldw	r2,-4(fp)
 200fcf0:	1090000c 	andi	r2,r2,16384
 200fcf4:	10000226 	beq	r2,zero,200fd00 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 200fcf8:	00bffd44 	movi	r2,-11
 200fcfc:	00000106 	br	200fd04 <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
 200fd00:	00bffec4 	movi	r2,-5
}
 200fd04:	e037883a 	mov	sp,fp
 200fd08:	dfc00117 	ldw	ra,4(sp)
 200fd0c:	df000017 	ldw	fp,0(sp)
 200fd10:	dec00204 	addi	sp,sp,8
 200fd14:	f800283a 	ret

0200fd18 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 200fd18:	defff304 	addi	sp,sp,-52
 200fd1c:	dfc00c15 	stw	ra,48(sp)
 200fd20:	df000b15 	stw	fp,44(sp)
 200fd24:	df000b04 	addi	fp,sp,44
 200fd28:	e13ffc15 	stw	r4,-16(fp)
 200fd2c:	e17ffd15 	stw	r5,-12(fp)
 200fd30:	e1bffe15 	stw	r6,-8(fp)
 200fd34:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 200fd38:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 200fd3c:	e0bffd17 	ldw	r2,-12(fp)
 200fd40:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 200fd44:	00003706 	br	200fe24 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 200fd48:	e0bffc17 	ldw	r2,-16(fp)
 200fd4c:	10800c17 	ldw	r2,48(r2)
 200fd50:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 200fd54:	e0bffc17 	ldw	r2,-16(fp)
 200fd58:	10800d17 	ldw	r2,52(r2)
 200fd5c:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
 200fd60:	e0fff917 	ldw	r3,-28(fp)
 200fd64:	e0bff517 	ldw	r2,-44(fp)
 200fd68:	1880062e 	bgeu	r3,r2,200fd84 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 200fd6c:	e0fff517 	ldw	r3,-44(fp)
 200fd70:	e0bff917 	ldw	r2,-28(fp)
 200fd74:	1885c83a 	sub	r2,r3,r2
 200fd78:	10bfffc4 	addi	r2,r2,-1
 200fd7c:	e0bff615 	stw	r2,-40(fp)
 200fd80:	00000b06 	br	200fdb0 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 200fd84:	e0bff517 	ldw	r2,-44(fp)
 200fd88:	10000526 	beq	r2,zero,200fda0 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 200fd8c:	00c20004 	movi	r3,2048
 200fd90:	e0bff917 	ldw	r2,-28(fp)
 200fd94:	1885c83a 	sub	r2,r3,r2
 200fd98:	e0bff615 	stw	r2,-40(fp)
 200fd9c:	00000406 	br	200fdb0 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 200fda0:	00c1ffc4 	movi	r3,2047
 200fda4:	e0bff917 	ldw	r2,-28(fp)
 200fda8:	1885c83a 	sub	r2,r3,r2
 200fdac:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 200fdb0:	e0bff617 	ldw	r2,-40(fp)
 200fdb4:	10001e26 	beq	r2,zero,200fe30 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 200fdb8:	e0fffe17 	ldw	r3,-8(fp)
 200fdbc:	e0bff617 	ldw	r2,-40(fp)
 200fdc0:	1880022e 	bgeu	r3,r2,200fdcc <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 200fdc4:	e0bffe17 	ldw	r2,-8(fp)
 200fdc8:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 200fdcc:	e0bffc17 	ldw	r2,-16(fp)
 200fdd0:	10c20e04 	addi	r3,r2,2104
 200fdd4:	e0bff917 	ldw	r2,-28(fp)
 200fdd8:	1885883a 	add	r2,r3,r2
 200fddc:	e1bff617 	ldw	r6,-40(fp)
 200fde0:	e17ffd17 	ldw	r5,-12(fp)
 200fde4:	1009883a 	mov	r4,r2
 200fde8:	200af380 	call	200af38 <memcpy>
      ptr   += n;
 200fdec:	e0fffd17 	ldw	r3,-12(fp)
 200fdf0:	e0bff617 	ldw	r2,-40(fp)
 200fdf4:	1885883a 	add	r2,r3,r2
 200fdf8:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 200fdfc:	e0fffe17 	ldw	r3,-8(fp)
 200fe00:	e0bff617 	ldw	r2,-40(fp)
 200fe04:	1885c83a 	sub	r2,r3,r2
 200fe08:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 200fe0c:	e0fff917 	ldw	r3,-28(fp)
 200fe10:	e0bff617 	ldw	r2,-40(fp)
 200fe14:	1885883a 	add	r2,r3,r2
 200fe18:	10c1ffcc 	andi	r3,r2,2047
 200fe1c:	e0bffc17 	ldw	r2,-16(fp)
 200fe20:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 200fe24:	e0bffe17 	ldw	r2,-8(fp)
 200fe28:	00bfc716 	blt	zero,r2,200fd48 <__reset+0xfe00ed48>
 200fe2c:	00000106 	br	200fe34 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 200fe30:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 200fe34:	0005303a 	rdctl	r2,status
 200fe38:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 200fe3c:	e0fffb17 	ldw	r3,-20(fp)
 200fe40:	00bfff84 	movi	r2,-2
 200fe44:	1884703a 	and	r2,r3,r2
 200fe48:	1001703a 	wrctl	status,r2
  
  return context;
 200fe4c:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 200fe50:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 200fe54:	e0bffc17 	ldw	r2,-16(fp)
 200fe58:	10800817 	ldw	r2,32(r2)
 200fe5c:	10c00094 	ori	r3,r2,2
 200fe60:	e0bffc17 	ldw	r2,-16(fp)
 200fe64:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 200fe68:	e0bffc17 	ldw	r2,-16(fp)
 200fe6c:	10800017 	ldw	r2,0(r2)
 200fe70:	10800104 	addi	r2,r2,4
 200fe74:	1007883a 	mov	r3,r2
 200fe78:	e0bffc17 	ldw	r2,-16(fp)
 200fe7c:	10800817 	ldw	r2,32(r2)
 200fe80:	18800035 	stwio	r2,0(r3)
 200fe84:	e0bffa17 	ldw	r2,-24(fp)
 200fe88:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 200fe8c:	e0bff817 	ldw	r2,-32(fp)
 200fe90:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 200fe94:	e0bffe17 	ldw	r2,-8(fp)
 200fe98:	0080100e 	bge	zero,r2,200fedc <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
 200fe9c:	e0bfff17 	ldw	r2,-4(fp)
 200fea0:	1090000c 	andi	r2,r2,16384
 200fea4:	1000101e 	bne	r2,zero,200fee8 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 200fea8:	0001883a 	nop
 200feac:	e0bffc17 	ldw	r2,-16(fp)
 200feb0:	10c00d17 	ldw	r3,52(r2)
 200feb4:	e0bff517 	ldw	r2,-44(fp)
 200feb8:	1880051e 	bne	r3,r2,200fed0 <altera_avalon_jtag_uart_write+0x1b8>
 200febc:	e0bffc17 	ldw	r2,-16(fp)
 200fec0:	10c00917 	ldw	r3,36(r2)
 200fec4:	e0bffc17 	ldw	r2,-16(fp)
 200fec8:	10800117 	ldw	r2,4(r2)
 200fecc:	18bff736 	bltu	r3,r2,200feac <__reset+0xfe00eeac>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 200fed0:	e0bffc17 	ldw	r2,-16(fp)
 200fed4:	10800917 	ldw	r2,36(r2)
 200fed8:	1000051e 	bne	r2,zero,200fef0 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
 200fedc:	e0bffe17 	ldw	r2,-8(fp)
 200fee0:	00bfd016 	blt	zero,r2,200fe24 <__reset+0xfe00ee24>
 200fee4:	00000306 	br	200fef4 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 200fee8:	0001883a 	nop
 200feec:	00000106 	br	200fef4 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 200fef0:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 200fef4:	e0fffd17 	ldw	r3,-12(fp)
 200fef8:	e0bff717 	ldw	r2,-36(fp)
 200fefc:	18800426 	beq	r3,r2,200ff10 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
 200ff00:	e0fffd17 	ldw	r3,-12(fp)
 200ff04:	e0bff717 	ldw	r2,-36(fp)
 200ff08:	1885c83a 	sub	r2,r3,r2
 200ff0c:	00000606 	br	200ff28 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
 200ff10:	e0bfff17 	ldw	r2,-4(fp)
 200ff14:	1090000c 	andi	r2,r2,16384
 200ff18:	10000226 	beq	r2,zero,200ff24 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
 200ff1c:	00bffd44 	movi	r2,-11
 200ff20:	00000106 	br	200ff28 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 200ff24:	00bffec4 	movi	r2,-5
}
 200ff28:	e037883a 	mov	sp,fp
 200ff2c:	dfc00117 	ldw	ra,4(sp)
 200ff30:	df000017 	ldw	fp,0(sp)
 200ff34:	dec00204 	addi	sp,sp,8
 200ff38:	f800283a 	ret

0200ff3c <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 200ff3c:	defffa04 	addi	sp,sp,-24
 200ff40:	dfc00515 	stw	ra,20(sp)
 200ff44:	df000415 	stw	fp,16(sp)
 200ff48:	df000404 	addi	fp,sp,16
 200ff4c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 200ff50:	0007883a 	mov	r3,zero
 200ff54:	e0bfff17 	ldw	r2,-4(fp)
 200ff58:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 200ff5c:	e0bfff17 	ldw	r2,-4(fp)
 200ff60:	10800104 	addi	r2,r2,4
 200ff64:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 200ff68:	0005303a 	rdctl	r2,status
 200ff6c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 200ff70:	e0fffd17 	ldw	r3,-12(fp)
 200ff74:	00bfff84 	movi	r2,-2
 200ff78:	1884703a 	and	r2,r3,r2
 200ff7c:	1001703a 	wrctl	status,r2
  
  return context;
 200ff80:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 200ff84:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 200ff88:	20118a40 	call	20118a4 <alt_tick>
 200ff8c:	e0bffc17 	ldw	r2,-16(fp)
 200ff90:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 200ff94:	e0bffe17 	ldw	r2,-8(fp)
 200ff98:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 200ff9c:	0001883a 	nop
 200ffa0:	e037883a 	mov	sp,fp
 200ffa4:	dfc00117 	ldw	ra,4(sp)
 200ffa8:	df000017 	ldw	fp,0(sp)
 200ffac:	dec00204 	addi	sp,sp,8
 200ffb0:	f800283a 	ret

0200ffb4 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 200ffb4:	defff804 	addi	sp,sp,-32
 200ffb8:	dfc00715 	stw	ra,28(sp)
 200ffbc:	df000615 	stw	fp,24(sp)
 200ffc0:	df000604 	addi	fp,sp,24
 200ffc4:	e13ffc15 	stw	r4,-16(fp)
 200ffc8:	e17ffd15 	stw	r5,-12(fp)
 200ffcc:	e1bffe15 	stw	r6,-8(fp)
 200ffd0:	e1ffff15 	stw	r7,-4(fp)
 200ffd4:	e0bfff17 	ldw	r2,-4(fp)
 200ffd8:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 200ffdc:	d0a09417 	ldw	r2,-32176(gp)
 200ffe0:	1000021e 	bne	r2,zero,200ffec <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 200ffe4:	e0bffb17 	ldw	r2,-20(fp)
 200ffe8:	d0a09415 	stw	r2,-32176(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 200ffec:	e0bffc17 	ldw	r2,-16(fp)
 200fff0:	10800104 	addi	r2,r2,4
 200fff4:	00c001c4 	movi	r3,7
 200fff8:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 200fffc:	d8000015 	stw	zero,0(sp)
 2010000:	e1fffc17 	ldw	r7,-16(fp)
 2010004:	01808074 	movhi	r6,513
 2010008:	31bfcf04 	addi	r6,r6,-196
 201000c:	e17ffe17 	ldw	r5,-8(fp)
 2010010:	e13ffd17 	ldw	r4,-12(fp)
 2010014:	200e00c0 	call	200e00c <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 2010018:	0001883a 	nop
 201001c:	e037883a 	mov	sp,fp
 2010020:	dfc00117 	ldw	ra,4(sp)
 2010024:	df000017 	ldw	fp,0(sp)
 2010028:	dec00204 	addi	sp,sp,8
 201002c:	f800283a 	ret

02010030 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 2010030:	defffa04 	addi	sp,sp,-24
 2010034:	dfc00515 	stw	ra,20(sp)
 2010038:	df000415 	stw	fp,16(sp)
 201003c:	df000404 	addi	fp,sp,16
 2010040:	e13ffd15 	stw	r4,-12(fp)
 2010044:	e17ffe15 	stw	r5,-8(fp)
 2010048:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 201004c:	e0bffd17 	ldw	r2,-12(fp)
 2010050:	10800017 	ldw	r2,0(r2)
 2010054:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
 2010058:	e0bffc17 	ldw	r2,-16(fp)
 201005c:	10c00a04 	addi	r3,r2,40
 2010060:	e0bffd17 	ldw	r2,-12(fp)
 2010064:	10800217 	ldw	r2,8(r2)
 2010068:	100f883a 	mov	r7,r2
 201006c:	e1bfff17 	ldw	r6,-4(fp)
 2010070:	e17ffe17 	ldw	r5,-8(fp)
 2010074:	1809883a 	mov	r4,r3
 2010078:	20105440 	call	2010544 <altera_avalon_uart_read>
      fd->fd_flags);
}
 201007c:	e037883a 	mov	sp,fp
 2010080:	dfc00117 	ldw	ra,4(sp)
 2010084:	df000017 	ldw	fp,0(sp)
 2010088:	dec00204 	addi	sp,sp,8
 201008c:	f800283a 	ret

02010090 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 2010090:	defffa04 	addi	sp,sp,-24
 2010094:	dfc00515 	stw	ra,20(sp)
 2010098:	df000415 	stw	fp,16(sp)
 201009c:	df000404 	addi	fp,sp,16
 20100a0:	e13ffd15 	stw	r4,-12(fp)
 20100a4:	e17ffe15 	stw	r5,-8(fp)
 20100a8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 20100ac:	e0bffd17 	ldw	r2,-12(fp)
 20100b0:	10800017 	ldw	r2,0(r2)
 20100b4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
 20100b8:	e0bffc17 	ldw	r2,-16(fp)
 20100bc:	10c00a04 	addi	r3,r2,40
 20100c0:	e0bffd17 	ldw	r2,-12(fp)
 20100c4:	10800217 	ldw	r2,8(r2)
 20100c8:	100f883a 	mov	r7,r2
 20100cc:	e1bfff17 	ldw	r6,-4(fp)
 20100d0:	e17ffe17 	ldw	r5,-8(fp)
 20100d4:	1809883a 	mov	r4,r3
 20100d8:	201075c0 	call	201075c <altera_avalon_uart_write>
      fd->fd_flags);
}
 20100dc:	e037883a 	mov	sp,fp
 20100e0:	dfc00117 	ldw	ra,4(sp)
 20100e4:	df000017 	ldw	fp,0(sp)
 20100e8:	dec00204 	addi	sp,sp,8
 20100ec:	f800283a 	ret

020100f0 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
 20100f0:	defffc04 	addi	sp,sp,-16
 20100f4:	dfc00315 	stw	ra,12(sp)
 20100f8:	df000215 	stw	fp,8(sp)
 20100fc:	df000204 	addi	fp,sp,8
 2010100:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 2010104:	e0bfff17 	ldw	r2,-4(fp)
 2010108:	10800017 	ldw	r2,0(r2)
 201010c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
 2010110:	e0bffe17 	ldw	r2,-8(fp)
 2010114:	10c00a04 	addi	r3,r2,40
 2010118:	e0bfff17 	ldw	r2,-4(fp)
 201011c:	10800217 	ldw	r2,8(r2)
 2010120:	100b883a 	mov	r5,r2
 2010124:	1809883a 	mov	r4,r3
 2010128:	20104b40 	call	20104b4 <altera_avalon_uart_close>
}
 201012c:	e037883a 	mov	sp,fp
 2010130:	dfc00117 	ldw	ra,4(sp)
 2010134:	df000017 	ldw	fp,0(sp)
 2010138:	dec00204 	addi	sp,sp,8
 201013c:	f800283a 	ret

02010140 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
 2010140:	defff804 	addi	sp,sp,-32
 2010144:	dfc00715 	stw	ra,28(sp)
 2010148:	df000615 	stw	fp,24(sp)
 201014c:	df000604 	addi	fp,sp,24
 2010150:	e13ffd15 	stw	r4,-12(fp)
 2010154:	e17ffe15 	stw	r5,-8(fp)
 2010158:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
 201015c:	e0bffd17 	ldw	r2,-12(fp)
 2010160:	10800017 	ldw	r2,0(r2)
 2010164:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 2010168:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 201016c:	1000041e 	bne	r2,zero,2010180 <altera_avalon_uart_init+0x40>
 2010170:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 2010174:	1000021e 	bne	r2,zero,2010180 <altera_avalon_uart_init+0x40>
 2010178:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 201017c:	10000226 	beq	r2,zero,2010188 <altera_avalon_uart_init+0x48>
 2010180:	00800044 	movi	r2,1
 2010184:	00000106 	br	201018c <altera_avalon_uart_init+0x4c>
 2010188:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 201018c:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
 2010190:	e0bffc17 	ldw	r2,-16(fp)
 2010194:	10000f1e 	bne	r2,zero,20101d4 <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
 2010198:	e0bffd17 	ldw	r2,-12(fp)
 201019c:	00c32004 	movi	r3,3200
 20101a0:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
 20101a4:	e0bffb17 	ldw	r2,-20(fp)
 20101a8:	10800304 	addi	r2,r2,12
 20101ac:	e0fffd17 	ldw	r3,-12(fp)
 20101b0:	18c00117 	ldw	r3,4(r3)
 20101b4:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
 20101b8:	d8000015 	stw	zero,0(sp)
 20101bc:	e1fffd17 	ldw	r7,-12(fp)
 20101c0:	01808074 	movhi	r6,513
 20101c4:	31807b04 	addi	r6,r6,492
 20101c8:	e17fff17 	ldw	r5,-4(fp)
 20101cc:	e13ffe17 	ldw	r4,-8(fp)
 20101d0:	200e00c0 	call	200e00c <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
 20101d4:	0001883a 	nop
 20101d8:	e037883a 	mov	sp,fp
 20101dc:	dfc00117 	ldw	ra,4(sp)
 20101e0:	df000017 	ldw	fp,0(sp)
 20101e4:	dec00204 	addi	sp,sp,8
 20101e8:	f800283a 	ret

020101ec <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
 20101ec:	defffa04 	addi	sp,sp,-24
 20101f0:	dfc00515 	stw	ra,20(sp)
 20101f4:	df000415 	stw	fp,16(sp)
 20101f8:	df000404 	addi	fp,sp,16
 20101fc:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
 2010200:	e0bfff17 	ldw	r2,-4(fp)
 2010204:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
 2010208:	e0bffc17 	ldw	r2,-16(fp)
 201020c:	10800017 	ldw	r2,0(r2)
 2010210:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
 2010214:	e0bffd17 	ldw	r2,-12(fp)
 2010218:	10800204 	addi	r2,r2,8
 201021c:	10800037 	ldwio	r2,0(r2)
 2010220:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
 2010224:	e0bffd17 	ldw	r2,-12(fp)
 2010228:	10800204 	addi	r2,r2,8
 201022c:	0007883a 	mov	r3,zero
 2010230:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
 2010234:	e0bffd17 	ldw	r2,-12(fp)
 2010238:	10800204 	addi	r2,r2,8
 201023c:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
 2010240:	e0bffe17 	ldw	r2,-8(fp)
 2010244:	1080200c 	andi	r2,r2,128
 2010248:	10000326 	beq	r2,zero,2010258 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
 201024c:	e17ffe17 	ldw	r5,-8(fp)
 2010250:	e13ffc17 	ldw	r4,-16(fp)
 2010254:	20102880 	call	2010288 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
 2010258:	e0bffe17 	ldw	r2,-8(fp)
 201025c:	1081100c 	andi	r2,r2,1088
 2010260:	10000326 	beq	r2,zero,2010270 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
 2010264:	e17ffe17 	ldw	r5,-8(fp)
 2010268:	e13ffc17 	ldw	r4,-16(fp)
 201026c:	201036c0 	call	201036c <altera_avalon_uart_txirq>
  }
  

}
 2010270:	0001883a 	nop
 2010274:	e037883a 	mov	sp,fp
 2010278:	dfc00117 	ldw	ra,4(sp)
 201027c:	df000017 	ldw	fp,0(sp)
 2010280:	dec00204 	addi	sp,sp,8
 2010284:	f800283a 	ret

02010288 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 2010288:	defffc04 	addi	sp,sp,-16
 201028c:	df000315 	stw	fp,12(sp)
 2010290:	df000304 	addi	fp,sp,12
 2010294:	e13ffe15 	stw	r4,-8(fp)
 2010298:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
 201029c:	e0bfff17 	ldw	r2,-4(fp)
 20102a0:	108000cc 	andi	r2,r2,3
 20102a4:	10002c1e 	bne	r2,zero,2010358 <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
 20102a8:	e0bffe17 	ldw	r2,-8(fp)
 20102ac:	10800317 	ldw	r2,12(r2)
 20102b0:	e0bffe17 	ldw	r2,-8(fp)
 20102b4:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 20102b8:	e0bffe17 	ldw	r2,-8(fp)
 20102bc:	10800317 	ldw	r2,12(r2)
 20102c0:	10800044 	addi	r2,r2,1
 20102c4:	10800fcc 	andi	r2,r2,63
 20102c8:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
 20102cc:	e0bffe17 	ldw	r2,-8(fp)
 20102d0:	10800317 	ldw	r2,12(r2)
 20102d4:	e0fffe17 	ldw	r3,-8(fp)
 20102d8:	18c00017 	ldw	r3,0(r3)
 20102dc:	18c00037 	ldwio	r3,0(r3)
 20102e0:	1809883a 	mov	r4,r3
 20102e4:	e0fffe17 	ldw	r3,-8(fp)
 20102e8:	1885883a 	add	r2,r3,r2
 20102ec:	10800704 	addi	r2,r2,28
 20102f0:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
 20102f4:	e0bffe17 	ldw	r2,-8(fp)
 20102f8:	e0fffd17 	ldw	r3,-12(fp)
 20102fc:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 2010300:	e0bffe17 	ldw	r2,-8(fp)
 2010304:	10800317 	ldw	r2,12(r2)
 2010308:	10800044 	addi	r2,r2,1
 201030c:	10800fcc 	andi	r2,r2,63
 2010310:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
 2010314:	e0bffe17 	ldw	r2,-8(fp)
 2010318:	10c00217 	ldw	r3,8(r2)
 201031c:	e0bffd17 	ldw	r2,-12(fp)
 2010320:	18800e1e 	bne	r3,r2,201035c <altera_avalon_uart_rxirq+0xd4>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 2010324:	e0bffe17 	ldw	r2,-8(fp)
 2010328:	10c00117 	ldw	r3,4(r2)
 201032c:	00bfdfc4 	movi	r2,-129
 2010330:	1886703a 	and	r3,r3,r2
 2010334:	e0bffe17 	ldw	r2,-8(fp)
 2010338:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
 201033c:	e0bffe17 	ldw	r2,-8(fp)
 2010340:	10800017 	ldw	r2,0(r2)
 2010344:	10800304 	addi	r2,r2,12
 2010348:	e0fffe17 	ldw	r3,-8(fp)
 201034c:	18c00117 	ldw	r3,4(r3)
 2010350:	10c00035 	stwio	r3,0(r2)
 2010354:	00000106 	br	201035c <altera_avalon_uart_rxirq+0xd4>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
 2010358:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
 201035c:	e037883a 	mov	sp,fp
 2010360:	df000017 	ldw	fp,0(sp)
 2010364:	dec00104 	addi	sp,sp,4
 2010368:	f800283a 	ret

0201036c <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 201036c:	defffb04 	addi	sp,sp,-20
 2010370:	df000415 	stw	fp,16(sp)
 2010374:	df000404 	addi	fp,sp,16
 2010378:	e13ffc15 	stw	r4,-16(fp)
 201037c:	e17ffd15 	stw	r5,-12(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
 2010380:	e0bffc17 	ldw	r2,-16(fp)
 2010384:	10c00417 	ldw	r3,16(r2)
 2010388:	e0bffc17 	ldw	r2,-16(fp)
 201038c:	10800517 	ldw	r2,20(r2)
 2010390:	18803226 	beq	r3,r2,201045c <altera_avalon_uart_txirq+0xf0>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 2010394:	e0bffc17 	ldw	r2,-16(fp)
 2010398:	10800617 	ldw	r2,24(r2)
 201039c:	1080008c 	andi	r2,r2,2
 20103a0:	10000326 	beq	r2,zero,20103b0 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 20103a4:	e0bffd17 	ldw	r2,-12(fp)
 20103a8:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 20103ac:	10001d26 	beq	r2,zero,2010424 <altera_avalon_uart_txirq+0xb8>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
 20103b0:	e0bffc17 	ldw	r2,-16(fp)
 20103b4:	10800417 	ldw	r2,16(r2)
 20103b8:	e0bffc17 	ldw	r2,-16(fp)
 20103bc:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
 20103c0:	e0bffc17 	ldw	r2,-16(fp)
 20103c4:	10800017 	ldw	r2,0(r2)
 20103c8:	10800104 	addi	r2,r2,4
 20103cc:	e0fffc17 	ldw	r3,-16(fp)
 20103d0:	18c00417 	ldw	r3,16(r3)
 20103d4:	e13ffc17 	ldw	r4,-16(fp)
 20103d8:	20c7883a 	add	r3,r4,r3
 20103dc:	18c01704 	addi	r3,r3,92
 20103e0:	18c00003 	ldbu	r3,0(r3)
 20103e4:	18c03fcc 	andi	r3,r3,255
 20103e8:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
 20103ec:	e0bffc17 	ldw	r2,-16(fp)
 20103f0:	10800417 	ldw	r2,16(r2)
 20103f4:	10800044 	addi	r2,r2,1
 20103f8:	e0fffc17 	ldw	r3,-16(fp)
 20103fc:	18800415 	stw	r2,16(r3)
 2010400:	10c00fcc 	andi	r3,r2,63
 2010404:	e0bffc17 	ldw	r2,-16(fp)
 2010408:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 201040c:	e0bffc17 	ldw	r2,-16(fp)
 2010410:	10800117 	ldw	r2,4(r2)
 2010414:	10c01014 	ori	r3,r2,64
 2010418:	e0bffc17 	ldw	r2,-16(fp)
 201041c:	10c00115 	stw	r3,4(r2)
 2010420:	00000e06 	br	201045c <altera_avalon_uart_txirq+0xf0>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
 2010424:	e0bffc17 	ldw	r2,-16(fp)
 2010428:	10800017 	ldw	r2,0(r2)
 201042c:	10800204 	addi	r2,r2,8
 2010430:	10800037 	ldwio	r2,0(r2)
 2010434:	e0bffd15 	stw	r2,-12(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 2010438:	e0bffd17 	ldw	r2,-12(fp)
 201043c:	1082000c 	andi	r2,r2,2048
 2010440:	1000061e 	bne	r2,zero,201045c <altera_avalon_uart_txirq+0xf0>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 2010444:	e0bffc17 	ldw	r2,-16(fp)
 2010448:	10c00117 	ldw	r3,4(r2)
 201044c:	00bfefc4 	movi	r2,-65
 2010450:	1886703a 	and	r3,r3,r2
 2010454:	e0bffc17 	ldw	r2,-16(fp)
 2010458:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
 201045c:	e0bffc17 	ldw	r2,-16(fp)
 2010460:	10c00417 	ldw	r3,16(r2)
 2010464:	e0bffc17 	ldw	r2,-16(fp)
 2010468:	10800517 	ldw	r2,20(r2)
 201046c:	1880061e 	bne	r3,r2,2010488 <altera_avalon_uart_txirq+0x11c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 2010470:	e0bffc17 	ldw	r2,-16(fp)
 2010474:	10c00117 	ldw	r3,4(r2)
 2010478:	00beefc4 	movi	r2,-1089
 201047c:	1886703a 	and	r3,r3,r2
 2010480:	e0bffc17 	ldw	r2,-16(fp)
 2010484:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 2010488:	e0bffc17 	ldw	r2,-16(fp)
 201048c:	10800017 	ldw	r2,0(r2)
 2010490:	10800304 	addi	r2,r2,12
 2010494:	e0fffc17 	ldw	r3,-16(fp)
 2010498:	18c00117 	ldw	r3,4(r3)
 201049c:	10c00035 	stwio	r3,0(r2)
}
 20104a0:	0001883a 	nop
 20104a4:	e037883a 	mov	sp,fp
 20104a8:	df000017 	ldw	fp,0(sp)
 20104ac:	dec00104 	addi	sp,sp,4
 20104b0:	f800283a 	ret

020104b4 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
 20104b4:	defffd04 	addi	sp,sp,-12
 20104b8:	df000215 	stw	fp,8(sp)
 20104bc:	df000204 	addi	fp,sp,8
 20104c0:	e13ffe15 	stw	r4,-8(fp)
 20104c4:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 20104c8:	00000506 	br	20104e0 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 20104cc:	e0bfff17 	ldw	r2,-4(fp)
 20104d0:	1090000c 	andi	r2,r2,16384
 20104d4:	10000226 	beq	r2,zero,20104e0 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
 20104d8:	00bffd44 	movi	r2,-11
 20104dc:	00000606 	br	20104f8 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 20104e0:	e0bffe17 	ldw	r2,-8(fp)
 20104e4:	10c00417 	ldw	r3,16(r2)
 20104e8:	e0bffe17 	ldw	r2,-8(fp)
 20104ec:	10800517 	ldw	r2,20(r2)
 20104f0:	18bff61e 	bne	r3,r2,20104cc <__reset+0xfe00f4cc>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 20104f4:	0005883a 	mov	r2,zero
}
 20104f8:	e037883a 	mov	sp,fp
 20104fc:	df000017 	ldw	fp,0(sp)
 2010500:	dec00104 	addi	sp,sp,4
 2010504:	f800283a 	ret

02010508 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2010508:	defffe04 	addi	sp,sp,-8
 201050c:	dfc00115 	stw	ra,4(sp)
 2010510:	df000015 	stw	fp,0(sp)
 2010514:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2010518:	d0a01a17 	ldw	r2,-32664(gp)
 201051c:	10000326 	beq	r2,zero,201052c <alt_get_errno+0x24>
 2010520:	d0a01a17 	ldw	r2,-32664(gp)
 2010524:	103ee83a 	callr	r2
 2010528:	00000106 	br	2010530 <alt_get_errno+0x28>
 201052c:	d0a08d04 	addi	r2,gp,-32204
}
 2010530:	e037883a 	mov	sp,fp
 2010534:	dfc00117 	ldw	ra,4(sp)
 2010538:	df000017 	ldw	fp,0(sp)
 201053c:	dec00204 	addi	sp,sp,8
 2010540:	f800283a 	ret

02010544 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
 2010544:	defff204 	addi	sp,sp,-56
 2010548:	dfc00d15 	stw	ra,52(sp)
 201054c:	df000c15 	stw	fp,48(sp)
 2010550:	df000c04 	addi	fp,sp,48
 2010554:	e13ffc15 	stw	r4,-16(fp)
 2010558:	e17ffd15 	stw	r5,-12(fp)
 201055c:	e1bffe15 	stw	r6,-8(fp)
 2010560:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
 2010564:	e03ff405 	stb	zero,-48(fp)
  int             count = 0;
 2010568:	e03ff515 	stw	zero,-44(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
 201056c:	e0bfff17 	ldw	r2,-4(fp)
 2010570:	1090000c 	andi	r2,r2,16384
 2010574:	1005003a 	cmpeq	r2,r2,zero
 2010578:	10803fcc 	andi	r2,r2,255
 201057c:	e0bff615 	stw	r2,-40(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 2010580:	00001306 	br	20105d0 <altera_avalon_uart_read+0x8c>
    {
      count++;
 2010584:	e0bff517 	ldw	r2,-44(fp)
 2010588:	10800044 	addi	r2,r2,1
 201058c:	e0bff515 	stw	r2,-44(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
 2010590:	e0bffd17 	ldw	r2,-12(fp)
 2010594:	10c00044 	addi	r3,r2,1
 2010598:	e0fffd15 	stw	r3,-12(fp)
 201059c:	e0fffc17 	ldw	r3,-16(fp)
 20105a0:	18c00217 	ldw	r3,8(r3)
 20105a4:	e13ffc17 	ldw	r4,-16(fp)
 20105a8:	20c7883a 	add	r3,r4,r3
 20105ac:	18c00704 	addi	r3,r3,28
 20105b0:	18c00003 	ldbu	r3,0(r3)
 20105b4:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
 20105b8:	e0bffc17 	ldw	r2,-16(fp)
 20105bc:	10800217 	ldw	r2,8(r2)
 20105c0:	10800044 	addi	r2,r2,1
 20105c4:	10c00fcc 	andi	r3,r2,63
 20105c8:	e0bffc17 	ldw	r2,-16(fp)
 20105cc:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 20105d0:	e0fff517 	ldw	r3,-44(fp)
 20105d4:	e0bffe17 	ldw	r2,-8(fp)
 20105d8:	1880050e 	bge	r3,r2,20105f0 <altera_avalon_uart_read+0xac>
 20105dc:	e0bffc17 	ldw	r2,-16(fp)
 20105e0:	10c00217 	ldw	r3,8(r2)
 20105e4:	e0bffc17 	ldw	r2,-16(fp)
 20105e8:	10800317 	ldw	r2,12(r2)
 20105ec:	18bfe51e 	bne	r3,r2,2010584 <__reset+0xfe00f584>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
 20105f0:	e0bff517 	ldw	r2,-44(fp)
 20105f4:	1000251e 	bne	r2,zero,201068c <altera_avalon_uart_read+0x148>
 20105f8:	e0bffc17 	ldw	r2,-16(fp)
 20105fc:	10c00217 	ldw	r3,8(r2)
 2010600:	e0bffc17 	ldw	r2,-16(fp)
 2010604:	10800317 	ldw	r2,12(r2)
 2010608:	1880201e 	bne	r3,r2,201068c <altera_avalon_uart_read+0x148>
    {
      if (!block)
 201060c:	e0bff617 	ldw	r2,-40(fp)
 2010610:	1000071e 	bne	r2,zero,2010630 <altera_avalon_uart_read+0xec>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
 2010614:	20105080 	call	2010508 <alt_get_errno>
 2010618:	1007883a 	mov	r3,r2
 201061c:	008002c4 	movi	r2,11
 2010620:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
 2010624:	00800044 	movi	r2,1
 2010628:	e0bff405 	stb	r2,-48(fp)
        break;
 201062c:	00001b06 	br	201069c <altera_avalon_uart_read+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2010630:	0005303a 	rdctl	r2,status
 2010634:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2010638:	e0fff917 	ldw	r3,-28(fp)
 201063c:	00bfff84 	movi	r2,-2
 2010640:	1884703a 	and	r2,r3,r2
 2010644:	1001703a 	wrctl	status,r2
  
  return context;
 2010648:	e0bff917 	ldw	r2,-28(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
 201064c:	e0bff815 	stw	r2,-32(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 2010650:	e0bffc17 	ldw	r2,-16(fp)
 2010654:	10800117 	ldw	r2,4(r2)
 2010658:	10c02014 	ori	r3,r2,128
 201065c:	e0bffc17 	ldw	r2,-16(fp)
 2010660:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 2010664:	e0bffc17 	ldw	r2,-16(fp)
 2010668:	10800017 	ldw	r2,0(r2)
 201066c:	10800304 	addi	r2,r2,12
 2010670:	e0fffc17 	ldw	r3,-16(fp)
 2010674:	18c00117 	ldw	r3,4(r3)
 2010678:	10c00035 	stwio	r3,0(r2)
 201067c:	e0bff817 	ldw	r2,-32(fp)
 2010680:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2010684:	e0bffa17 	ldw	r2,-24(fp)
 2010688:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
 201068c:	e0bff517 	ldw	r2,-44(fp)
 2010690:	1000021e 	bne	r2,zero,201069c <altera_avalon_uart_read+0x158>
 2010694:	e0bffe17 	ldw	r2,-8(fp)
 2010698:	103fcd1e 	bne	r2,zero,20105d0 <__reset+0xfe00f5d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201069c:	0005303a 	rdctl	r2,status
 20106a0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20106a4:	e0fffb17 	ldw	r3,-20(fp)
 20106a8:	00bfff84 	movi	r2,-2
 20106ac:	1884703a 	and	r2,r3,r2
 20106b0:	1001703a 	wrctl	status,r2
  
  return context;
 20106b4:	e0bffb17 	ldw	r2,-20(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
 20106b8:	e0bff815 	stw	r2,-32(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 20106bc:	e0bffc17 	ldw	r2,-16(fp)
 20106c0:	10800117 	ldw	r2,4(r2)
 20106c4:	10c02014 	ori	r3,r2,128
 20106c8:	e0bffc17 	ldw	r2,-16(fp)
 20106cc:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 20106d0:	e0bffc17 	ldw	r2,-16(fp)
 20106d4:	10800017 	ldw	r2,0(r2)
 20106d8:	10800304 	addi	r2,r2,12
 20106dc:	e0fffc17 	ldw	r3,-16(fp)
 20106e0:	18c00117 	ldw	r3,4(r3)
 20106e4:	10c00035 	stwio	r3,0(r2)
 20106e8:	e0bff817 	ldw	r2,-32(fp)
 20106ec:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20106f0:	e0bff717 	ldw	r2,-36(fp)
 20106f4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
 20106f8:	e0bff403 	ldbu	r2,-48(fp)
 20106fc:	10000226 	beq	r2,zero,2010708 <altera_avalon_uart_read+0x1c4>
    return -EWOULDBLOCK;
 2010700:	00bffd44 	movi	r2,-11
 2010704:	00000106 	br	201070c <altera_avalon_uart_read+0x1c8>
  }
  else {
    return count;
 2010708:	e0bff517 	ldw	r2,-44(fp)
  }
}
 201070c:	e037883a 	mov	sp,fp
 2010710:	dfc00117 	ldw	ra,4(sp)
 2010714:	df000017 	ldw	fp,0(sp)
 2010718:	dec00204 	addi	sp,sp,8
 201071c:	f800283a 	ret

02010720 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2010720:	defffe04 	addi	sp,sp,-8
 2010724:	dfc00115 	stw	ra,4(sp)
 2010728:	df000015 	stw	fp,0(sp)
 201072c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2010730:	d0a01a17 	ldw	r2,-32664(gp)
 2010734:	10000326 	beq	r2,zero,2010744 <alt_get_errno+0x24>
 2010738:	d0a01a17 	ldw	r2,-32664(gp)
 201073c:	103ee83a 	callr	r2
 2010740:	00000106 	br	2010748 <alt_get_errno+0x28>
 2010744:	d0a08d04 	addi	r2,gp,-32204
}
 2010748:	e037883a 	mov	sp,fp
 201074c:	dfc00117 	ldw	ra,4(sp)
 2010750:	df000017 	ldw	fp,0(sp)
 2010754:	dec00204 	addi	sp,sp,8
 2010758:	f800283a 	ret

0201075c <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
 201075c:	defff204 	addi	sp,sp,-56
 2010760:	dfc00d15 	stw	ra,52(sp)
 2010764:	df000c15 	stw	fp,48(sp)
 2010768:	df000c04 	addi	fp,sp,48
 201076c:	e13ffc15 	stw	r4,-16(fp)
 2010770:	e17ffd15 	stw	r5,-12(fp)
 2010774:	e1bffe15 	stw	r6,-8(fp)
 2010778:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
 201077c:	e0bffe17 	ldw	r2,-8(fp)
 2010780:	e0bff415 	stw	r2,-48(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
 2010784:	e0bfff17 	ldw	r2,-4(fp)
 2010788:	1090000c 	andi	r2,r2,16384
 201078c:	e0bff515 	stw	r2,-44(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 2010790:	00003c06 	br	2010884 <altera_avalon_uart_write+0x128>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 2010794:	e0bffc17 	ldw	r2,-16(fp)
 2010798:	10800517 	ldw	r2,20(r2)
 201079c:	10800044 	addi	r2,r2,1
 20107a0:	10800fcc 	andi	r2,r2,63
 20107a4:	e0bff715 	stw	r2,-36(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
 20107a8:	e0bffc17 	ldw	r2,-16(fp)
 20107ac:	10c00417 	ldw	r3,16(r2)
 20107b0:	e0bff717 	ldw	r2,-36(fp)
 20107b4:	1880221e 	bne	r3,r2,2010840 <altera_avalon_uart_write+0xe4>
    {
      if (no_block)
 20107b8:	e0bff517 	ldw	r2,-44(fp)
 20107bc:	10000526 	beq	r2,zero,20107d4 <altera_avalon_uart_write+0x78>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
 20107c0:	20107200 	call	2010720 <alt_get_errno>
 20107c4:	1007883a 	mov	r3,r2
 20107c8:	008002c4 	movi	r2,11
 20107cc:	18800015 	stw	r2,0(r3)
        break;
 20107d0:	00002e06 	br	201088c <altera_avalon_uart_write+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20107d4:	0005303a 	rdctl	r2,status
 20107d8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20107dc:	e0fff917 	ldw	r3,-28(fp)
 20107e0:	00bfff84 	movi	r2,-2
 20107e4:	1884703a 	and	r2,r3,r2
 20107e8:	1001703a 	wrctl	status,r2
  
  return context;
 20107ec:	e0bff917 	ldw	r2,-28(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
 20107f0:	e0bff815 	stw	r2,-32(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 20107f4:	e0bffc17 	ldw	r2,-16(fp)
 20107f8:	10800117 	ldw	r2,4(r2)
 20107fc:	10c11014 	ori	r3,r2,1088
 2010800:	e0bffc17 	ldw	r2,-16(fp)
 2010804:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 2010808:	e0bffc17 	ldw	r2,-16(fp)
 201080c:	10800017 	ldw	r2,0(r2)
 2010810:	10800304 	addi	r2,r2,12
 2010814:	e0fffc17 	ldw	r3,-16(fp)
 2010818:	18c00117 	ldw	r3,4(r3)
 201081c:	10c00035 	stwio	r3,0(r2)
 2010820:	e0bff817 	ldw	r2,-32(fp)
 2010824:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2010828:	e0bff617 	ldw	r2,-40(fp)
 201082c:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
 2010830:	e0bffc17 	ldw	r2,-16(fp)
 2010834:	10c00417 	ldw	r3,16(r2)
 2010838:	e0bff717 	ldw	r2,-36(fp)
 201083c:	18bffc26 	beq	r3,r2,2010830 <__reset+0xfe00f830>
      }
    }

    count--;
 2010840:	e0bff417 	ldw	r2,-48(fp)
 2010844:	10bfffc4 	addi	r2,r2,-1
 2010848:	e0bff415 	stw	r2,-48(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
 201084c:	e0bffc17 	ldw	r2,-16(fp)
 2010850:	10c00517 	ldw	r3,20(r2)
 2010854:	e0bffd17 	ldw	r2,-12(fp)
 2010858:	11000044 	addi	r4,r2,1
 201085c:	e13ffd15 	stw	r4,-12(fp)
 2010860:	10800003 	ldbu	r2,0(r2)
 2010864:	1009883a 	mov	r4,r2
 2010868:	e0bffc17 	ldw	r2,-16(fp)
 201086c:	10c5883a 	add	r2,r2,r3
 2010870:	10801704 	addi	r2,r2,92
 2010874:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
 2010878:	e0bffc17 	ldw	r2,-16(fp)
 201087c:	e0fff717 	ldw	r3,-36(fp)
 2010880:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 2010884:	e0bff417 	ldw	r2,-48(fp)
 2010888:	103fc21e 	bne	r2,zero,2010794 <__reset+0xfe00f794>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201088c:	0005303a 	rdctl	r2,status
 2010890:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2010894:	e0fffb17 	ldw	r3,-20(fp)
 2010898:	00bfff84 	movi	r2,-2
 201089c:	1884703a 	and	r2,r3,r2
 20108a0:	1001703a 	wrctl	status,r2
  
  return context;
 20108a4:	e0bffb17 	ldw	r2,-20(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
 20108a8:	e0bff815 	stw	r2,-32(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 20108ac:	e0bffc17 	ldw	r2,-16(fp)
 20108b0:	10800117 	ldw	r2,4(r2)
 20108b4:	10c11014 	ori	r3,r2,1088
 20108b8:	e0bffc17 	ldw	r2,-16(fp)
 20108bc:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 20108c0:	e0bffc17 	ldw	r2,-16(fp)
 20108c4:	10800017 	ldw	r2,0(r2)
 20108c8:	10800304 	addi	r2,r2,12
 20108cc:	e0fffc17 	ldw	r3,-16(fp)
 20108d0:	18c00117 	ldw	r3,4(r3)
 20108d4:	10c00035 	stwio	r3,0(r2)
 20108d8:	e0bff817 	ldw	r2,-32(fp)
 20108dc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20108e0:	e0bffa17 	ldw	r2,-24(fp)
 20108e4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
 20108e8:	e0fffe17 	ldw	r3,-8(fp)
 20108ec:	e0bff417 	ldw	r2,-48(fp)
 20108f0:	1885c83a 	sub	r2,r3,r2
}
 20108f4:	e037883a 	mov	sp,fp
 20108f8:	dfc00117 	ldw	ra,4(sp)
 20108fc:	df000017 	ldw	fp,0(sp)
 2010900:	dec00204 	addi	sp,sp,8
 2010904:	f800283a 	ret

02010908 <epcs_read_status_register>:
#include "alt_types.h"
#include "epcs_commands.h"
#include "altera_avalon_spi.h"

alt_u8 epcs_read_status_register(alt_u32 base)
{
 2010908:	defff904 	addi	sp,sp,-28
 201090c:	dfc00615 	stw	ra,24(sp)
 2010910:	df000515 	stw	fp,20(sp)
 2010914:	df000504 	addi	fp,sp,20
 2010918:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rdsr = epcs_rdsr;
 201091c:	00800144 	movi	r2,5
 2010920:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 status;
  alt_avalon_spi_command(
 2010924:	d8000215 	stw	zero,8(sp)
 2010928:	e0bffe44 	addi	r2,fp,-7
 201092c:	d8800115 	stw	r2,4(sp)
 2010930:	00800044 	movi	r2,1
 2010934:	d8800015 	stw	r2,0(sp)
 2010938:	e1fffe04 	addi	r7,fp,-8
 201093c:	01800044 	movi	r6,1
 2010940:	000b883a 	mov	r5,zero
 2010944:	e13fff17 	ldw	r4,-4(fp)
 2010948:	20119d00 	call	20119d0 <alt_avalon_spi_command>
    1,
    &status,
    0
  );

  return status;
 201094c:	e0bffe43 	ldbu	r2,-7(fp)
}
 2010950:	e037883a 	mov	sp,fp
 2010954:	dfc00117 	ldw	ra,4(sp)
 2010958:	df000017 	ldw	fp,0(sp)
 201095c:	dec00204 	addi	sp,sp,8
 2010960:	f800283a 	ret

02010964 <epcs_test_wip>:

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
 2010964:	defffd04 	addi	sp,sp,-12
 2010968:	dfc00215 	stw	ra,8(sp)
 201096c:	df000115 	stw	fp,4(sp)
 2010970:	df000104 	addi	fp,sp,4
 2010974:	e13fff15 	stw	r4,-4(fp)
  return epcs_read_status_register(base) & 1;
 2010978:	e13fff17 	ldw	r4,-4(fp)
 201097c:	20109080 	call	2010908 <epcs_read_status_register>
 2010980:	10803fcc 	andi	r2,r2,255
 2010984:	1080004c 	andi	r2,r2,1
}
 2010988:	e037883a 	mov	sp,fp
 201098c:	dfc00117 	ldw	ra,4(sp)
 2010990:	df000017 	ldw	fp,0(sp)
 2010994:	dec00204 	addi	sp,sp,8
 2010998:	f800283a 	ret

0201099c <epcs_await_wip_released>:

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
 201099c:	defffd04 	addi	sp,sp,-12
 20109a0:	dfc00215 	stw	ra,8(sp)
 20109a4:	df000115 	stw	fp,4(sp)
 20109a8:	df000104 	addi	fp,sp,4
 20109ac:	e13fff15 	stw	r4,-4(fp)
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
 20109b0:	0001883a 	nop
 20109b4:	e13fff17 	ldw	r4,-4(fp)
 20109b8:	20109640 	call	2010964 <epcs_test_wip>
 20109bc:	103ffd1e 	bne	r2,zero,20109b4 <__reset+0xfe00f9b4>
  {
  }
}
 20109c0:	0001883a 	nop
 20109c4:	e037883a 	mov	sp,fp
 20109c8:	dfc00117 	ldw	ra,4(sp)
 20109cc:	df000017 	ldw	fp,0(sp)
 20109d0:	dec00204 	addi	sp,sp,8
 20109d4:	f800283a 	ret

020109d8 <epcs_sector_erase>:

void epcs_sector_erase(alt_u32 base, alt_u32 offset, alt_u32 four_bytes_mode)
{
 20109d8:	defff604 	addi	sp,sp,-40
 20109dc:	dfc00915 	stw	ra,36(sp)
 20109e0:	df000815 	stw	fp,32(sp)
 20109e4:	df000804 	addi	fp,sp,32
 20109e8:	e13ffd15 	stw	r4,-12(fp)
 20109ec:	e17ffe15 	stw	r5,-8(fp)
 20109f0:	e1bfff15 	stw	r6,-4(fp)
  alt_u8 se[5];
  alt_u8 len;
  
  if(four_bytes_mode)
 20109f4:	e0bfff17 	ldw	r2,-4(fp)
 20109f8:	10001226 	beq	r2,zero,2010a44 <epcs_sector_erase+0x6c>
  {
      se[0] = epcs_se;  /* Note: Use epcs_se for Micron EPCS256 */
 20109fc:	00bff604 	movi	r2,-40
 2010a00:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 24) & 0xFF;
 2010a04:	e0bffe17 	ldw	r2,-8(fp)
 2010a08:	1004d63a 	srli	r2,r2,24
 2010a0c:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 16) & 0xFF;
 2010a10:	e0bffe17 	ldw	r2,-8(fp)
 2010a14:	1004d43a 	srli	r2,r2,16
 2010a18:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = (offset >> 8) & 0xFF;
 2010a1c:	e0bffe17 	ldw	r2,-8(fp)
 2010a20:	1004d23a 	srli	r2,r2,8
 2010a24:	e0bffc05 	stb	r2,-16(fp)
      se[4] = offset & 0xFF;
 2010a28:	e0bffe17 	ldw	r2,-8(fp)
 2010a2c:	e0bffc45 	stb	r2,-15(fp)
      len   = 5;
 2010a30:	00800144 	movi	r2,5
 2010a34:	e0bffb05 	stb	r2,-20(fp)
      epcs_enter_4_bytes_mode(base);
 2010a38:	e13ffd17 	ldw	r4,-12(fp)
 2010a3c:	2010e8c0 	call	2010e8c <epcs_enter_4_bytes_mode>
 2010a40:	00000c06 	br	2010a74 <epcs_sector_erase+0x9c>
  }
  else
  {
      se[0] = epcs_se;
 2010a44:	00bff604 	movi	r2,-40
 2010a48:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 16) & 0xFF;
 2010a4c:	e0bffe17 	ldw	r2,-8(fp)
 2010a50:	1004d43a 	srli	r2,r2,16
 2010a54:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 8) & 0xFF;
 2010a58:	e0bffe17 	ldw	r2,-8(fp)
 2010a5c:	1004d23a 	srli	r2,r2,8
 2010a60:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = offset & 0xFF;
 2010a64:	e0bffe17 	ldw	r2,-8(fp)
 2010a68:	e0bffc05 	stb	r2,-16(fp)
      len   = 4;
 2010a6c:	00800104 	movi	r2,4
 2010a70:	e0bffb05 	stb	r2,-20(fp)
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);
 2010a74:	e13ffd17 	ldw	r4,-12(fp)
 2010a78:	2010bc80 	call	2010bc8 <epcs_write_enable>

  alt_avalon_spi_command(
 2010a7c:	e0bffb03 	ldbu	r2,-20(fp)
 2010a80:	e0fffb44 	addi	r3,fp,-19
 2010a84:	d8000215 	stw	zero,8(sp)
 2010a88:	d8000115 	stw	zero,4(sp)
 2010a8c:	d8000015 	stw	zero,0(sp)
 2010a90:	180f883a 	mov	r7,r3
 2010a94:	100d883a 	mov	r6,r2
 2010a98:	000b883a 	mov	r5,zero
 2010a9c:	e13ffd17 	ldw	r4,-12(fp)
 2010aa0:	20119d00 	call	20119d0 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
 2010aa4:	e13ffd17 	ldw	r4,-12(fp)
 2010aa8:	201099c0 	call	201099c <epcs_await_wip_released>

  if(four_bytes_mode)
 2010aac:	e0bfff17 	ldw	r2,-4(fp)
 2010ab0:	10000226 	beq	r2,zero,2010abc <epcs_sector_erase+0xe4>
  {
    epcs_exit_4_bytes_mode(base);
 2010ab4:	e13ffd17 	ldw	r4,-12(fp)
 2010ab8:	2010ee80 	call	2010ee8 <epcs_exit_4_bytes_mode>
  }
}
 2010abc:	0001883a 	nop
 2010ac0:	e037883a 	mov	sp,fp
 2010ac4:	dfc00117 	ldw	ra,4(sp)
 2010ac8:	df000017 	ldw	fp,0(sp)
 2010acc:	dec00204 	addi	sp,sp,8
 2010ad0:	f800283a 	ret

02010ad4 <epcs_read_buffer>:

alt_32 epcs_read_buffer(alt_u32 base, int offset, alt_u8 *dest_addr, int length,
                        alt_u32 four_bytes_mode)
{
 2010ad4:	defff404 	addi	sp,sp,-48
 2010ad8:	dfc00b15 	stw	ra,44(sp)
 2010adc:	df000a15 	stw	fp,40(sp)
 2010ae0:	df000a04 	addi	fp,sp,40
 2010ae4:	e13ffc15 	stw	r4,-16(fp)
 2010ae8:	e17ffd15 	stw	r5,-12(fp)
 2010aec:	e1bffe15 	stw	r6,-8(fp)
 2010af0:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 read_command[5];
  alt_u32 cmd_len;

  read_command[0] = epcs_read;
 2010af4:	008000c4 	movi	r2,3
 2010af8:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
 2010afc:	e0800217 	ldw	r2,8(fp)
 2010b00:	10001026 	beq	r2,zero,2010b44 <epcs_read_buffer+0x70>
  {
        read_command[1] = (offset >> 24) & 0xFF;
 2010b04:	e0bffd17 	ldw	r2,-12(fp)
 2010b08:	1004d63a 	srli	r2,r2,24
 2010b0c:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 16) & 0xFF;
 2010b10:	e0bffd17 	ldw	r2,-12(fp)
 2010b14:	1005d43a 	srai	r2,r2,16
 2010b18:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = (offset >> 8) & 0xFF;
 2010b1c:	e0bffd17 	ldw	r2,-12(fp)
 2010b20:	1005d23a 	srai	r2,r2,8
 2010b24:	e0bffac5 	stb	r2,-21(fp)
        read_command[4] = offset & 0xFF;
 2010b28:	e0bffd17 	ldw	r2,-12(fp)
 2010b2c:	e0bffb05 	stb	r2,-20(fp)
        cmd_len = 5;
 2010b30:	00800144 	movi	r2,5
 2010b34:	e0bff915 	stw	r2,-28(fp)
        epcs_enter_4_bytes_mode(base);
 2010b38:	e13ffc17 	ldw	r4,-16(fp)
 2010b3c:	2010e8c0 	call	2010e8c <epcs_enter_4_bytes_mode>
 2010b40:	00000a06 	br	2010b6c <epcs_read_buffer+0x98>
  }
  else
  {
        read_command[1] = (offset >> 16) & 0xFF;
 2010b44:	e0bffd17 	ldw	r2,-12(fp)
 2010b48:	1005d43a 	srai	r2,r2,16
 2010b4c:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 8) & 0xFF;
 2010b50:	e0bffd17 	ldw	r2,-12(fp)
 2010b54:	1005d23a 	srai	r2,r2,8
 2010b58:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = offset & 0xFF;
 2010b5c:	e0bffd17 	ldw	r2,-12(fp)
 2010b60:	e0bffac5 	stb	r2,-21(fp)
        cmd_len = 4;
 2010b64:	00800104 	movi	r2,4
 2010b68:	e0bff915 	stw	r2,-28(fp)
  }

  epcs_await_wip_released(base);
 2010b6c:	e13ffc17 	ldw	r4,-16(fp)
 2010b70:	201099c0 	call	201099c <epcs_await_wip_released>

  alt_avalon_spi_command(
 2010b74:	e0bfff17 	ldw	r2,-4(fp)
 2010b78:	e13ffa04 	addi	r4,fp,-24
 2010b7c:	d8000215 	stw	zero,8(sp)
 2010b80:	e0fffe17 	ldw	r3,-8(fp)
 2010b84:	d8c00115 	stw	r3,4(sp)
 2010b88:	d8800015 	stw	r2,0(sp)
 2010b8c:	200f883a 	mov	r7,r4
 2010b90:	e1bff917 	ldw	r6,-28(fp)
 2010b94:	000b883a 	mov	r5,zero
 2010b98:	e13ffc17 	ldw	r4,-16(fp)
 2010b9c:	20119d00 	call	20119d0 <alt_avalon_spi_command>
    length,
    (alt_u8*)dest_addr,
    0
  );

  if(four_bytes_mode)
 2010ba0:	e0800217 	ldw	r2,8(fp)
 2010ba4:	10000226 	beq	r2,zero,2010bb0 <epcs_read_buffer+0xdc>
  {
    epcs_exit_4_bytes_mode(base);
 2010ba8:	e13ffc17 	ldw	r4,-16(fp)
 2010bac:	2010ee80 	call	2010ee8 <epcs_exit_4_bytes_mode>
  }

  return length;
 2010bb0:	e0bfff17 	ldw	r2,-4(fp)
}
 2010bb4:	e037883a 	mov	sp,fp
 2010bb8:	dfc00117 	ldw	ra,4(sp)
 2010bbc:	df000017 	ldw	fp,0(sp)
 2010bc0:	dec00204 	addi	sp,sp,8
 2010bc4:	f800283a 	ret

02010bc8 <epcs_write_enable>:

void epcs_write_enable(alt_u32 base)
{
 2010bc8:	defff904 	addi	sp,sp,-28
 2010bcc:	dfc00615 	stw	ra,24(sp)
 2010bd0:	df000515 	stw	fp,20(sp)
 2010bd4:	df000504 	addi	fp,sp,20
 2010bd8:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 wren = epcs_wren;
 2010bdc:	00800184 	movi	r2,6
 2010be0:	e0bffe05 	stb	r2,-8(fp)
  alt_avalon_spi_command(
 2010be4:	d8000215 	stw	zero,8(sp)
 2010be8:	d8000115 	stw	zero,4(sp)
 2010bec:	d8000015 	stw	zero,0(sp)
 2010bf0:	e1fffe04 	addi	r7,fp,-8
 2010bf4:	01800044 	movi	r6,1
 2010bf8:	000b883a 	mov	r5,zero
 2010bfc:	e13fff17 	ldw	r4,-4(fp)
 2010c00:	20119d00 	call	20119d0 <alt_avalon_spi_command>
    &wren,
    0,
    (alt_u8*)0,
    0
  );
}
 2010c04:	0001883a 	nop
 2010c08:	e037883a 	mov	sp,fp
 2010c0c:	dfc00117 	ldw	ra,4(sp)
 2010c10:	df000017 	ldw	fp,0(sp)
 2010c14:	dec00204 	addi	sp,sp,8
 2010c18:	f800283a 	ret

02010c1c <epcs_write_status_register>:

void epcs_write_status_register(alt_u32 base, alt_u8 value)
{
 2010c1c:	defff804 	addi	sp,sp,-32
 2010c20:	dfc00715 	stw	ra,28(sp)
 2010c24:	df000615 	stw	fp,24(sp)
 2010c28:	df000604 	addi	fp,sp,24
 2010c2c:	e13ffe15 	stw	r4,-8(fp)
 2010c30:	2805883a 	mov	r2,r5
 2010c34:	e0bfff05 	stb	r2,-4(fp)
  alt_u8 wrsr[2];
  
  wrsr[0] = epcs_wrsr;
 2010c38:	00800044 	movi	r2,1
 2010c3c:	e0bffd05 	stb	r2,-12(fp)
  wrsr[1] = value;
 2010c40:	e0bfff03 	ldbu	r2,-4(fp)
 2010c44:	e0bffd45 	stb	r2,-11(fp)

  alt_avalon_spi_command(
 2010c48:	d8000215 	stw	zero,8(sp)
 2010c4c:	d8000115 	stw	zero,4(sp)
 2010c50:	d8000015 	stw	zero,0(sp)
 2010c54:	e1fffd04 	addi	r7,fp,-12
 2010c58:	01800084 	movi	r6,2
 2010c5c:	000b883a 	mov	r5,zero
 2010c60:	e13ffe17 	ldw	r4,-8(fp)
 2010c64:	20119d00 	call	20119d0 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
 2010c68:	e13ffe17 	ldw	r4,-8(fp)
 2010c6c:	201099c0 	call	201099c <epcs_await_wip_released>
}
 2010c70:	0001883a 	nop
 2010c74:	e037883a 	mov	sp,fp
 2010c78:	dfc00117 	ldw	ra,4(sp)
 2010c7c:	df000017 	ldw	fp,0(sp)
 2010c80:	dec00204 	addi	sp,sp,8
 2010c84:	f800283a 	ret

02010c88 <epcs_write_buffer>:

/* Write a partial or full page, assuming that page has been erased */
alt_32 epcs_write_buffer(alt_u32 base, int offset, const alt_u8* src_addr, 
                         int length, alt_u32 four_bytes_mode)
{
 2010c88:	defff404 	addi	sp,sp,-48
 2010c8c:	dfc00b15 	stw	ra,44(sp)
 2010c90:	df000a15 	stw	fp,40(sp)
 2010c94:	df000a04 	addi	fp,sp,40
 2010c98:	e13ffc15 	stw	r4,-16(fp)
 2010c9c:	e17ffd15 	stw	r5,-12(fp)
 2010ca0:	e1bffe15 	stw	r6,-8(fp)
 2010ca4:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 pp[5];
  alt_u32 cmd_len;
  
  pp[0] = epcs_pp;
 2010ca8:	00800084 	movi	r2,2
 2010cac:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
 2010cb0:	e0800217 	ldw	r2,8(fp)
 2010cb4:	10001026 	beq	r2,zero,2010cf8 <epcs_write_buffer+0x70>
  {
      pp[1] = (offset >> 24) & 0xFF;
 2010cb8:	e0bffd17 	ldw	r2,-12(fp)
 2010cbc:	1004d63a 	srli	r2,r2,24
 2010cc0:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 16) & 0xFF;
 2010cc4:	e0bffd17 	ldw	r2,-12(fp)
 2010cc8:	1005d43a 	srai	r2,r2,16
 2010ccc:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = (offset >> 8) & 0xFF;
 2010cd0:	e0bffd17 	ldw	r2,-12(fp)
 2010cd4:	1005d23a 	srai	r2,r2,8
 2010cd8:	e0bffac5 	stb	r2,-21(fp)
      pp[4] = offset & 0xFF;
 2010cdc:	e0bffd17 	ldw	r2,-12(fp)
 2010ce0:	e0bffb05 	stb	r2,-20(fp)
      cmd_len = 5;
 2010ce4:	00800144 	movi	r2,5
 2010ce8:	e0bff915 	stw	r2,-28(fp)
      epcs_enter_4_bytes_mode(base);
 2010cec:	e13ffc17 	ldw	r4,-16(fp)
 2010cf0:	2010e8c0 	call	2010e8c <epcs_enter_4_bytes_mode>
 2010cf4:	00000a06 	br	2010d20 <epcs_write_buffer+0x98>
  }
  else
  {
      pp[1] = (offset >> 16) & 0xFF;
 2010cf8:	e0bffd17 	ldw	r2,-12(fp)
 2010cfc:	1005d43a 	srai	r2,r2,16
 2010d00:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 8) & 0xFF;
 2010d04:	e0bffd17 	ldw	r2,-12(fp)
 2010d08:	1005d23a 	srai	r2,r2,8
 2010d0c:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = offset & 0xFF;
 2010d10:	e0bffd17 	ldw	r2,-12(fp)
 2010d14:	e0bffac5 	stb	r2,-21(fp)
      cmd_len = 4;
 2010d18:	00800104 	movi	r2,4
 2010d1c:	e0bff915 	stw	r2,-28(fp)
  }

  /* First, WREN */
  epcs_write_enable(base);
 2010d20:	e13ffc17 	ldw	r4,-16(fp)
 2010d24:	2010bc80 	call	2010bc8 <epcs_write_enable>

  /* Send the PP command */
  alt_avalon_spi_command(
 2010d28:	e0fffa04 	addi	r3,fp,-24
 2010d2c:	00800044 	movi	r2,1
 2010d30:	d8800215 	stw	r2,8(sp)
 2010d34:	d8000115 	stw	zero,4(sp)
 2010d38:	d8000015 	stw	zero,0(sp)
 2010d3c:	180f883a 	mov	r7,r3
 2010d40:	e1bff917 	ldw	r6,-28(fp)
 2010d44:	000b883a 	mov	r5,zero
 2010d48:	e13ffc17 	ldw	r4,-16(fp)
 2010d4c:	20119d00 	call	20119d0 <alt_avalon_spi_command>
    (alt_u8*)0,
    ALT_AVALON_SPI_COMMAND_MERGE
  );

  /* Send the user's buffer */
  alt_avalon_spi_command(
 2010d50:	e0bfff17 	ldw	r2,-4(fp)
 2010d54:	d8000215 	stw	zero,8(sp)
 2010d58:	d8000115 	stw	zero,4(sp)
 2010d5c:	d8000015 	stw	zero,0(sp)
 2010d60:	e1fffe17 	ldw	r7,-8(fp)
 2010d64:	100d883a 	mov	r6,r2
 2010d68:	000b883a 	mov	r5,zero
 2010d6c:	e13ffc17 	ldw	r4,-16(fp)
 2010d70:	20119d00 	call	20119d0 <alt_avalon_spi_command>
   * if the user's going to go off and ignore the flash for
   * a while, its writes could occur in parallel with user code
   * execution.  Unfortunately, I have to guard all reads/writes
   * with wip-tests, to make that happen.
   */
  epcs_await_wip_released(base);
 2010d74:	e13ffc17 	ldw	r4,-16(fp)
 2010d78:	201099c0 	call	201099c <epcs_await_wip_released>

  if(four_bytes_mode)
 2010d7c:	e0800217 	ldw	r2,8(fp)
 2010d80:	10000226 	beq	r2,zero,2010d8c <epcs_write_buffer+0x104>
  {
    epcs_exit_4_bytes_mode(base);
 2010d84:	e13ffc17 	ldw	r4,-16(fp)
 2010d88:	2010ee80 	call	2010ee8 <epcs_exit_4_bytes_mode>
  }

  return length;
 2010d8c:	e0bfff17 	ldw	r2,-4(fp)
}
 2010d90:	e037883a 	mov	sp,fp
 2010d94:	dfc00117 	ldw	ra,4(sp)
 2010d98:	df000017 	ldw	fp,0(sp)
 2010d9c:	dec00204 	addi	sp,sp,8
 2010da0:	f800283a 	ret

02010da4 <epcs_read_electronic_signature>:


alt_u8 epcs_read_electronic_signature(alt_u32 base)
{
 2010da4:	defff804 	addi	sp,sp,-32
 2010da8:	dfc00715 	stw	ra,28(sp)
 2010dac:	df000615 	stw	fp,24(sp)
 2010db0:	df000604 	addi	fp,sp,24
 2010db4:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 res_cmd[] = {epcs_res, 0, 0, 0};
 2010db8:	00bfeac4 	movi	r2,-85
 2010dbc:	e0bffd05 	stb	r2,-12(fp)
 2010dc0:	e03ffd45 	stb	zero,-11(fp)
 2010dc4:	e03ffd85 	stb	zero,-10(fp)
 2010dc8:	e03ffdc5 	stb	zero,-9(fp)
  alt_u8 res;

  alt_avalon_spi_command(
 2010dcc:	d8000215 	stw	zero,8(sp)
 2010dd0:	e0bffe04 	addi	r2,fp,-8
 2010dd4:	d8800115 	stw	r2,4(sp)
 2010dd8:	00800044 	movi	r2,1
 2010ddc:	d8800015 	stw	r2,0(sp)
 2010de0:	e1fffd04 	addi	r7,fp,-12
 2010de4:	01800104 	movi	r6,4
 2010de8:	000b883a 	mov	r5,zero
 2010dec:	e13fff17 	ldw	r4,-4(fp)
 2010df0:	20119d00 	call	20119d0 <alt_avalon_spi_command>
    1,
    &res,
    0
  );

  return res;
 2010df4:	e0bffe03 	ldbu	r2,-8(fp)
}
 2010df8:	e037883a 	mov	sp,fp
 2010dfc:	dfc00117 	ldw	ra,4(sp)
 2010e00:	df000017 	ldw	fp,0(sp)
 2010e04:	dec00204 	addi	sp,sp,8
 2010e08:	f800283a 	ret

02010e0c <epcs_read_device_id>:

alt_u32 epcs_read_device_id(alt_u32 base)
{
 2010e0c:	defff904 	addi	sp,sp,-28
 2010e10:	dfc00615 	stw	ra,24(sp)
 2010e14:	df000515 	stw	fp,20(sp)
 2010e18:	df000504 	addi	fp,sp,20
 2010e1c:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
 2010e20:	00bfe7c4 	movi	r2,-97
 2010e24:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 id[3];

  alt_avalon_spi_command(
 2010e28:	d8000215 	stw	zero,8(sp)
 2010e2c:	e0bffe44 	addi	r2,fp,-7
 2010e30:	d8800115 	stw	r2,4(sp)
 2010e34:	008000c4 	movi	r2,3
 2010e38:	d8800015 	stw	r2,0(sp)
 2010e3c:	e1fffe04 	addi	r7,fp,-8
 2010e40:	01800044 	movi	r6,1
 2010e44:	000b883a 	mov	r5,zero
 2010e48:	e13fff17 	ldw	r4,-4(fp)
 2010e4c:	20119d00 	call	20119d0 <alt_avalon_spi_command>
    3,
    id,
    0
  );

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
 2010e50:	e0bffe43 	ldbu	r2,-7(fp)
 2010e54:	10803fcc 	andi	r2,r2,255
 2010e58:	1006943a 	slli	r3,r2,16
 2010e5c:	e0bffe83 	ldbu	r2,-6(fp)
 2010e60:	10803fcc 	andi	r2,r2,255
 2010e64:	1004923a 	slli	r2,r2,8
 2010e68:	1886b03a 	or	r3,r3,r2
 2010e6c:	e0bffec3 	ldbu	r2,-5(fp)
 2010e70:	10803fcc 	andi	r2,r2,255
 2010e74:	1884b03a 	or	r2,r3,r2
}
 2010e78:	e037883a 	mov	sp,fp
 2010e7c:	dfc00117 	ldw	ra,4(sp)
 2010e80:	df000017 	ldw	fp,0(sp)
 2010e84:	dec00204 	addi	sp,sp,8
 2010e88:	f800283a 	ret

02010e8c <epcs_enter_4_bytes_mode>:

void epcs_enter_4_bytes_mode(alt_u32 base)
{
 2010e8c:	defff904 	addi	sp,sp,-28
 2010e90:	dfc00615 	stw	ra,24(sp)
 2010e94:	df000515 	stw	fp,20(sp)
 2010e98:	df000504 	addi	fp,sp,20
 2010e9c:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 en4b_cmd = epcs_en4b;
 2010ea0:	00bfedc4 	movi	r2,-73
 2010ea4:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
 2010ea8:	e13fff17 	ldw	r4,-4(fp)
 2010eac:	2010bc80 	call	2010bc8 <epcs_write_enable>

  alt_avalon_spi_command(
 2010eb0:	d8000215 	stw	zero,8(sp)
 2010eb4:	d8000115 	stw	zero,4(sp)
 2010eb8:	d8000015 	stw	zero,0(sp)
 2010ebc:	e1fffe04 	addi	r7,fp,-8
 2010ec0:	01800044 	movi	r6,1
 2010ec4:	000b883a 	mov	r5,zero
 2010ec8:	e13fff17 	ldw	r4,-4(fp)
 2010ecc:	20119d00 	call	20119d0 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
 2010ed0:	0001883a 	nop
}
 2010ed4:	e037883a 	mov	sp,fp
 2010ed8:	dfc00117 	ldw	ra,4(sp)
 2010edc:	df000017 	ldw	fp,0(sp)
 2010ee0:	dec00204 	addi	sp,sp,8
 2010ee4:	f800283a 	ret

02010ee8 <epcs_exit_4_bytes_mode>:

void epcs_exit_4_bytes_mode(alt_u32 base)
{
 2010ee8:	defff904 	addi	sp,sp,-28
 2010eec:	dfc00615 	stw	ra,24(sp)
 2010ef0:	df000515 	stw	fp,20(sp)
 2010ef4:	df000504 	addi	fp,sp,20
 2010ef8:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 exit4b_cmd = epcs_dis4b;
 2010efc:	00bffa44 	movi	r2,-23
 2010f00:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
 2010f04:	e13fff17 	ldw	r4,-4(fp)
 2010f08:	2010bc80 	call	2010bc8 <epcs_write_enable>

  alt_avalon_spi_command(
 2010f0c:	d8000215 	stw	zero,8(sp)
 2010f10:	d8000115 	stw	zero,4(sp)
 2010f14:	d8000015 	stw	zero,0(sp)
 2010f18:	e1fffe04 	addi	r7,fp,-8
 2010f1c:	01800044 	movi	r6,1
 2010f20:	000b883a 	mov	r5,zero
 2010f24:	e13fff17 	ldw	r4,-4(fp)
 2010f28:	20119d00 	call	20119d0 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
 2010f2c:	0001883a 	nop
}
 2010f30:	e037883a 	mov	sp,fp
 2010f34:	dfc00117 	ldw	ra,4(sp)
 2010f38:	df000017 	ldw	fp,0(sp)
 2010f3c:	dec00204 	addi	sp,sp,8
 2010f40:	f800283a 	ret

02010f44 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 2010f44:	defff504 	addi	sp,sp,-44
 2010f48:	df000a15 	stw	fp,40(sp)
 2010f4c:	df000a04 	addi	fp,sp,40
 2010f50:	e13ffc15 	stw	r4,-16(fp)
 2010f54:	e17ffd15 	stw	r5,-12(fp)
 2010f58:	e1bffe15 	stw	r6,-8(fp)
 2010f5c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 2010f60:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 2010f64:	d0a09417 	ldw	r2,-32176(gp)
  
  if (alt_ticks_per_second ())
 2010f68:	10003c26 	beq	r2,zero,201105c <alt_alarm_start+0x118>
  {
    if (alarm)
 2010f6c:	e0bffc17 	ldw	r2,-16(fp)
 2010f70:	10003826 	beq	r2,zero,2011054 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 2010f74:	e0bffc17 	ldw	r2,-16(fp)
 2010f78:	e0fffe17 	ldw	r3,-8(fp)
 2010f7c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 2010f80:	e0bffc17 	ldw	r2,-16(fp)
 2010f84:	e0ffff17 	ldw	r3,-4(fp)
 2010f88:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2010f8c:	0005303a 	rdctl	r2,status
 2010f90:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2010f94:	e0fff917 	ldw	r3,-28(fp)
 2010f98:	00bfff84 	movi	r2,-2
 2010f9c:	1884703a 	and	r2,r3,r2
 2010fa0:	1001703a 	wrctl	status,r2
  
  return context;
 2010fa4:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 2010fa8:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 2010fac:	d0a09517 	ldw	r2,-32172(gp)
      
      current_nticks = alt_nticks();
 2010fb0:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 2010fb4:	e0fffd17 	ldw	r3,-12(fp)
 2010fb8:	e0bff617 	ldw	r2,-40(fp)
 2010fbc:	1885883a 	add	r2,r3,r2
 2010fc0:	10c00044 	addi	r3,r2,1
 2010fc4:	e0bffc17 	ldw	r2,-16(fp)
 2010fc8:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 2010fcc:	e0bffc17 	ldw	r2,-16(fp)
 2010fd0:	10c00217 	ldw	r3,8(r2)
 2010fd4:	e0bff617 	ldw	r2,-40(fp)
 2010fd8:	1880042e 	bgeu	r3,r2,2010fec <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 2010fdc:	e0bffc17 	ldw	r2,-16(fp)
 2010fe0:	00c00044 	movi	r3,1
 2010fe4:	10c00405 	stb	r3,16(r2)
 2010fe8:	00000206 	br	2010ff4 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 2010fec:	e0bffc17 	ldw	r2,-16(fp)
 2010ff0:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 2010ff4:	e0bffc17 	ldw	r2,-16(fp)
 2010ff8:	d0e01f04 	addi	r3,gp,-32644
 2010ffc:	e0fffa15 	stw	r3,-24(fp)
 2011000:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 2011004:	e0bffb17 	ldw	r2,-20(fp)
 2011008:	e0fffa17 	ldw	r3,-24(fp)
 201100c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 2011010:	e0bffa17 	ldw	r2,-24(fp)
 2011014:	10c00017 	ldw	r3,0(r2)
 2011018:	e0bffb17 	ldw	r2,-20(fp)
 201101c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 2011020:	e0bffa17 	ldw	r2,-24(fp)
 2011024:	10800017 	ldw	r2,0(r2)
 2011028:	e0fffb17 	ldw	r3,-20(fp)
 201102c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 2011030:	e0bffa17 	ldw	r2,-24(fp)
 2011034:	e0fffb17 	ldw	r3,-20(fp)
 2011038:	10c00015 	stw	r3,0(r2)
 201103c:	e0bff817 	ldw	r2,-32(fp)
 2011040:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2011044:	e0bff717 	ldw	r2,-36(fp)
 2011048:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 201104c:	0005883a 	mov	r2,zero
 2011050:	00000306 	br	2011060 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 2011054:	00bffa84 	movi	r2,-22
 2011058:	00000106 	br	2011060 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 201105c:	00bfde84 	movi	r2,-134
  }
}
 2011060:	e037883a 	mov	sp,fp
 2011064:	df000017 	ldw	fp,0(sp)
 2011068:	dec00104 	addi	sp,sp,4
 201106c:	f800283a 	ret

02011070 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 2011070:	defffa04 	addi	sp,sp,-24
 2011074:	dfc00515 	stw	ra,20(sp)
 2011078:	df000415 	stw	fp,16(sp)
 201107c:	df000404 	addi	fp,sp,16
 2011080:	e13fff15 	stw	r4,-4(fp)
  int big_loops;
  alt_u32 cycles_per_loop;
  
  if (!strcmp(NIOS2_CPU_IMPLEMENTATION,"tiny"))
  {
    cycles_per_loop = 9;
 2011084:	00800244 	movi	r2,9
 2011088:	e0bffd15 	stw	r2,-12(fp)
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 201108c:	014003f4 	movhi	r5,15
 2011090:	29509004 	addi	r5,r5,16960
 2011094:	e13ffd17 	ldw	r4,-12(fp)
 2011098:	2009bcc0 	call	2009bcc <__mulsi3>
 201109c:	100b883a 	mov	r5,r2
 20110a0:	01017db4 	movhi	r4,1526
 20110a4:	21384004 	addi	r4,r4,-7936
 20110a8:	2009b100 	call	2009b10 <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 20110ac:	100b883a 	mov	r5,r2
 20110b0:	01200034 	movhi	r4,32768
 20110b4:	213fffc4 	addi	r4,r4,-1
 20110b8:	2009b100 	call	2009b10 <__udivsi3>
 20110bc:	100b883a 	mov	r5,r2
 20110c0:	e13fff17 	ldw	r4,-4(fp)
 20110c4:	2009b100 	call	2009b10 <__udivsi3>
 20110c8:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 20110cc:	e0bffe17 	ldw	r2,-8(fp)
 20110d0:	10002a26 	beq	r2,zero,201117c <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 20110d4:	e03ffc15 	stw	zero,-16(fp)
 20110d8:	00001706 	br	2011138 <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 20110dc:	00a00034 	movhi	r2,32768
 20110e0:	10bfffc4 	addi	r2,r2,-1
 20110e4:	10bfffc4 	addi	r2,r2,-1
 20110e8:	103ffe1e 	bne	r2,zero,20110e4 <__reset+0xfe0100e4>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 20110ec:	014003f4 	movhi	r5,15
 20110f0:	29509004 	addi	r5,r5,16960
 20110f4:	e13ffd17 	ldw	r4,-12(fp)
 20110f8:	2009bcc0 	call	2009bcc <__mulsi3>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 20110fc:	100b883a 	mov	r5,r2
 2011100:	01017db4 	movhi	r4,1526
 2011104:	21384004 	addi	r4,r4,-7936
 2011108:	2009b100 	call	2009b10 <__udivsi3>
 201110c:	100b883a 	mov	r5,r2
 2011110:	01200034 	movhi	r4,32768
 2011114:	213fffc4 	addi	r4,r4,-1
 2011118:	2009b100 	call	2009b10 <__udivsi3>
 201111c:	1007883a 	mov	r3,r2
 2011120:	e0bfff17 	ldw	r2,-4(fp)
 2011124:	10c5c83a 	sub	r2,r2,r3
 2011128:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 201112c:	e0bffc17 	ldw	r2,-16(fp)
 2011130:	10800044 	addi	r2,r2,1
 2011134:	e0bffc15 	stw	r2,-16(fp)
 2011138:	e0fffc17 	ldw	r3,-16(fp)
 201113c:	e0bffe17 	ldw	r2,-8(fp)
 2011140:	18bfe616 	blt	r3,r2,20110dc <__reset+0xfe0100dc>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 2011144:	014003f4 	movhi	r5,15
 2011148:	29509004 	addi	r5,r5,16960
 201114c:	e13ffd17 	ldw	r4,-12(fp)
 2011150:	2009bcc0 	call	2009bcc <__mulsi3>
 2011154:	100b883a 	mov	r5,r2
 2011158:	01017db4 	movhi	r4,1526
 201115c:	21384004 	addi	r4,r4,-7936
 2011160:	2009b100 	call	2009b10 <__udivsi3>
 2011164:	e17fff17 	ldw	r5,-4(fp)
 2011168:	1009883a 	mov	r4,r2
 201116c:	2009bcc0 	call	2009bcc <__mulsi3>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 2011170:	10bfffc4 	addi	r2,r2,-1
 2011174:	103ffe1e 	bne	r2,zero,2011170 <__reset+0xfe010170>
 2011178:	00000d06 	br	20111b0 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 201117c:	014003f4 	movhi	r5,15
 2011180:	29509004 	addi	r5,r5,16960
 2011184:	e13ffd17 	ldw	r4,-12(fp)
 2011188:	2009bcc0 	call	2009bcc <__mulsi3>
 201118c:	100b883a 	mov	r5,r2
 2011190:	01017db4 	movhi	r4,1526
 2011194:	21384004 	addi	r4,r4,-7936
 2011198:	2009b100 	call	2009b10 <__udivsi3>
 201119c:	e17fff17 	ldw	r5,-4(fp)
 20111a0:	1009883a 	mov	r4,r2
 20111a4:	2009bcc0 	call	2009bcc <__mulsi3>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 20111a8:	10bfffc4 	addi	r2,r2,-1
 20111ac:	00bffe16 	blt	zero,r2,20111a8 <__reset+0xfe0101a8>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 20111b0:	0005883a 	mov	r2,zero
}
 20111b4:	e037883a 	mov	sp,fp
 20111b8:	dfc00117 	ldw	ra,4(sp)
 20111bc:	df000017 	ldw	fp,0(sp)
 20111c0:	dec00204 	addi	sp,sp,8
 20111c4:	f800283a 	ret

020111c8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 20111c8:	defffe04 	addi	sp,sp,-8
 20111cc:	dfc00115 	stw	ra,4(sp)
 20111d0:	df000015 	stw	fp,0(sp)
 20111d4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 20111d8:	d0a01a17 	ldw	r2,-32664(gp)
 20111dc:	10000326 	beq	r2,zero,20111ec <alt_get_errno+0x24>
 20111e0:	d0a01a17 	ldw	r2,-32664(gp)
 20111e4:	103ee83a 	callr	r2
 20111e8:	00000106 	br	20111f0 <alt_get_errno+0x28>
 20111ec:	d0a08d04 	addi	r2,gp,-32204
}
 20111f0:	e037883a 	mov	sp,fp
 20111f4:	dfc00117 	ldw	ra,4(sp)
 20111f8:	df000017 	ldw	fp,0(sp)
 20111fc:	dec00204 	addi	sp,sp,8
 2011200:	f800283a 	ret

02011204 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 2011204:	defffa04 	addi	sp,sp,-24
 2011208:	dfc00515 	stw	ra,20(sp)
 201120c:	df000415 	stw	fp,16(sp)
 2011210:	df000404 	addi	fp,sp,16
 2011214:	e13ffe15 	stw	r4,-8(fp)
 2011218:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 201121c:	e0bffe17 	ldw	r2,-8(fp)
 2011220:	10000326 	beq	r2,zero,2011230 <alt_dev_llist_insert+0x2c>
 2011224:	e0bffe17 	ldw	r2,-8(fp)
 2011228:	10800217 	ldw	r2,8(r2)
 201122c:	1000061e 	bne	r2,zero,2011248 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 2011230:	20111c80 	call	20111c8 <alt_get_errno>
 2011234:	1007883a 	mov	r3,r2
 2011238:	00800584 	movi	r2,22
 201123c:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 2011240:	00bffa84 	movi	r2,-22
 2011244:	00001306 	br	2011294 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 2011248:	e0bffe17 	ldw	r2,-8(fp)
 201124c:	e0ffff17 	ldw	r3,-4(fp)
 2011250:	e0fffc15 	stw	r3,-16(fp)
 2011254:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 2011258:	e0bffd17 	ldw	r2,-12(fp)
 201125c:	e0fffc17 	ldw	r3,-16(fp)
 2011260:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 2011264:	e0bffc17 	ldw	r2,-16(fp)
 2011268:	10c00017 	ldw	r3,0(r2)
 201126c:	e0bffd17 	ldw	r2,-12(fp)
 2011270:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 2011274:	e0bffc17 	ldw	r2,-16(fp)
 2011278:	10800017 	ldw	r2,0(r2)
 201127c:	e0fffd17 	ldw	r3,-12(fp)
 2011280:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 2011284:	e0bffc17 	ldw	r2,-16(fp)
 2011288:	e0fffd17 	ldw	r3,-12(fp)
 201128c:	10c00015 	stw	r3,0(r2)

  return 0;  
 2011290:	0005883a 	mov	r2,zero
}
 2011294:	e037883a 	mov	sp,fp
 2011298:	dfc00117 	ldw	ra,4(sp)
 201129c:	df000017 	ldw	fp,0(sp)
 20112a0:	dec00204 	addi	sp,sp,8
 20112a4:	f800283a 	ret

020112a8 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 20112a8:	defffd04 	addi	sp,sp,-12
 20112ac:	dfc00215 	stw	ra,8(sp)
 20112b0:	df000115 	stw	fp,4(sp)
 20112b4:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 20112b8:	00808074 	movhi	r2,513
 20112bc:	10886e04 	addi	r2,r2,8632
 20112c0:	e0bfff15 	stw	r2,-4(fp)
 20112c4:	00000606 	br	20112e0 <_do_ctors+0x38>
        (*ctor) (); 
 20112c8:	e0bfff17 	ldw	r2,-4(fp)
 20112cc:	10800017 	ldw	r2,0(r2)
 20112d0:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 20112d4:	e0bfff17 	ldw	r2,-4(fp)
 20112d8:	10bfff04 	addi	r2,r2,-4
 20112dc:	e0bfff15 	stw	r2,-4(fp)
 20112e0:	e0ffff17 	ldw	r3,-4(fp)
 20112e4:	00808074 	movhi	r2,513
 20112e8:	10886f04 	addi	r2,r2,8636
 20112ec:	18bff62e 	bgeu	r3,r2,20112c8 <__reset+0xfe0102c8>
        (*ctor) (); 
}
 20112f0:	0001883a 	nop
 20112f4:	e037883a 	mov	sp,fp
 20112f8:	dfc00117 	ldw	ra,4(sp)
 20112fc:	df000017 	ldw	fp,0(sp)
 2011300:	dec00204 	addi	sp,sp,8
 2011304:	f800283a 	ret

02011308 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 2011308:	defffd04 	addi	sp,sp,-12
 201130c:	dfc00215 	stw	ra,8(sp)
 2011310:	df000115 	stw	fp,4(sp)
 2011314:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 2011318:	00808074 	movhi	r2,513
 201131c:	10886e04 	addi	r2,r2,8632
 2011320:	e0bfff15 	stw	r2,-4(fp)
 2011324:	00000606 	br	2011340 <_do_dtors+0x38>
        (*dtor) (); 
 2011328:	e0bfff17 	ldw	r2,-4(fp)
 201132c:	10800017 	ldw	r2,0(r2)
 2011330:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 2011334:	e0bfff17 	ldw	r2,-4(fp)
 2011338:	10bfff04 	addi	r2,r2,-4
 201133c:	e0bfff15 	stw	r2,-4(fp)
 2011340:	e0ffff17 	ldw	r3,-4(fp)
 2011344:	00808074 	movhi	r2,513
 2011348:	10886f04 	addi	r2,r2,8636
 201134c:	18bff62e 	bgeu	r3,r2,2011328 <__reset+0xfe010328>
        (*dtor) (); 
}
 2011350:	0001883a 	nop
 2011354:	e037883a 	mov	sp,fp
 2011358:	dfc00117 	ldw	ra,4(sp)
 201135c:	df000017 	ldw	fp,0(sp)
 2011360:	dec00204 	addi	sp,sp,8
 2011364:	f800283a 	ret

02011368 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 2011368:	defffc04 	addi	sp,sp,-16
 201136c:	dfc00315 	stw	ra,12(sp)
 2011370:	df000215 	stw	fp,8(sp)
 2011374:	df000204 	addi	fp,sp,8
 2011378:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 201137c:	d1601d04 	addi	r5,gp,-32652
 2011380:	e13fff17 	ldw	r4,-4(fp)
 2011384:	2011bcc0 	call	2011bcc <alt_find_dev>
 2011388:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
 201138c:	e0bffe17 	ldw	r2,-8(fp)
 2011390:	10000926 	beq	r2,zero,20113b8 <alt_flash_open_dev+0x50>
 2011394:	e0bffe17 	ldw	r2,-8(fp)
 2011398:	10800317 	ldw	r2,12(r2)
 201139c:	10000626 	beq	r2,zero,20113b8 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
 20113a0:	e0bffe17 	ldw	r2,-8(fp)
 20113a4:	10800317 	ldw	r2,12(r2)
 20113a8:	e17fff17 	ldw	r5,-4(fp)
 20113ac:	e13ffe17 	ldw	r4,-8(fp)
 20113b0:	103ee83a 	callr	r2
 20113b4:	00000106 	br	20113bc <alt_flash_open_dev+0x54>
  }

  return dev;
 20113b8:	e0bffe17 	ldw	r2,-8(fp)
}
 20113bc:	e037883a 	mov	sp,fp
 20113c0:	dfc00117 	ldw	ra,4(sp)
 20113c4:	df000017 	ldw	fp,0(sp)
 20113c8:	dec00204 	addi	sp,sp,8
 20113cc:	f800283a 	ret

020113d0 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 20113d0:	defffd04 	addi	sp,sp,-12
 20113d4:	dfc00215 	stw	ra,8(sp)
 20113d8:	df000115 	stw	fp,4(sp)
 20113dc:	df000104 	addi	fp,sp,4
 20113e0:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 20113e4:	e0bfff17 	ldw	r2,-4(fp)
 20113e8:	10000826 	beq	r2,zero,201140c <alt_flash_close_dev+0x3c>
 20113ec:	e0bfff17 	ldw	r2,-4(fp)
 20113f0:	10800417 	ldw	r2,16(r2)
 20113f4:	10000526 	beq	r2,zero,201140c <alt_flash_close_dev+0x3c>
  {
    fd->close(fd);
 20113f8:	e0bfff17 	ldw	r2,-4(fp)
 20113fc:	10800417 	ldw	r2,16(r2)
 2011400:	e13fff17 	ldw	r4,-4(fp)
 2011404:	103ee83a 	callr	r2
  }
  return;
 2011408:	0001883a 	nop
 201140c:	0001883a 	nop
}
 2011410:	e037883a 	mov	sp,fp
 2011414:	dfc00117 	ldw	ra,4(sp)
 2011418:	df000017 	ldw	fp,0(sp)
 201141c:	dec00204 	addi	sp,sp,8
 2011420:	f800283a 	ret

02011424 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 2011424:	defff804 	addi	sp,sp,-32
 2011428:	dfc00715 	stw	ra,28(sp)
 201142c:	df000615 	stw	fp,24(sp)
 2011430:	dc000515 	stw	r16,20(sp)
 2011434:	df000604 	addi	fp,sp,24
 2011438:	e13ffb15 	stw	r4,-20(fp)
 201143c:	e17ffc15 	stw	r5,-16(fp)
 2011440:	e1bffd15 	stw	r6,-12(fp)
 2011444:	e1fffe15 	stw	r7,-8(fp)
  int old;

  old = open (name, flags, mode);
 2011448:	e1bffe17 	ldw	r6,-8(fp)
 201144c:	e17ffd17 	ldw	r5,-12(fp)
 2011450:	e13ffc17 	ldw	r4,-16(fp)
 2011454:	20116ac0 	call	20116ac <open>
 2011458:	e0bffa15 	stw	r2,-24(fp)

  if (old >= 0)
 201145c:	e0bffa17 	ldw	r2,-24(fp)
 2011460:	10002216 	blt	r2,zero,20114ec <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
 2011464:	04008074 	movhi	r16,513
 2011468:	840b5804 	addi	r16,r16,11616
 201146c:	e0bffa17 	ldw	r2,-24(fp)
 2011470:	01400304 	movi	r5,12
 2011474:	1009883a 	mov	r4,r2
 2011478:	2009bcc0 	call	2009bcc <__mulsi3>
 201147c:	8085883a 	add	r2,r16,r2
 2011480:	10c00017 	ldw	r3,0(r2)
 2011484:	e0bffb17 	ldw	r2,-20(fp)
 2011488:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 201148c:	04008074 	movhi	r16,513
 2011490:	840b5804 	addi	r16,r16,11616
 2011494:	e0bffa17 	ldw	r2,-24(fp)
 2011498:	01400304 	movi	r5,12
 201149c:	1009883a 	mov	r4,r2
 20114a0:	2009bcc0 	call	2009bcc <__mulsi3>
 20114a4:	8085883a 	add	r2,r16,r2
 20114a8:	10800104 	addi	r2,r2,4
 20114ac:	10c00017 	ldw	r3,0(r2)
 20114b0:	e0bffb17 	ldw	r2,-20(fp)
 20114b4:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 20114b8:	04008074 	movhi	r16,513
 20114bc:	840b5804 	addi	r16,r16,11616
 20114c0:	e0bffa17 	ldw	r2,-24(fp)
 20114c4:	01400304 	movi	r5,12
 20114c8:	1009883a 	mov	r4,r2
 20114cc:	2009bcc0 	call	2009bcc <__mulsi3>
 20114d0:	8085883a 	add	r2,r16,r2
 20114d4:	10800204 	addi	r2,r2,8
 20114d8:	10c00017 	ldw	r3,0(r2)
 20114dc:	e0bffb17 	ldw	r2,-20(fp)
 20114e0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 20114e4:	e13ffa17 	ldw	r4,-24(fp)
 20114e8:	200e5c00 	call	200e5c0 <alt_release_fd>
  }
} 
 20114ec:	0001883a 	nop
 20114f0:	e6ffff04 	addi	sp,fp,-4
 20114f4:	dfc00217 	ldw	ra,8(sp)
 20114f8:	df000117 	ldw	fp,4(sp)
 20114fc:	dc000017 	ldw	r16,0(sp)
 2011500:	dec00304 	addi	sp,sp,12
 2011504:	f800283a 	ret

02011508 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 2011508:	defffb04 	addi	sp,sp,-20
 201150c:	dfc00415 	stw	ra,16(sp)
 2011510:	df000315 	stw	fp,12(sp)
 2011514:	df000304 	addi	fp,sp,12
 2011518:	e13ffd15 	stw	r4,-12(fp)
 201151c:	e17ffe15 	stw	r5,-8(fp)
 2011520:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 2011524:	01c07fc4 	movi	r7,511
 2011528:	01800044 	movi	r6,1
 201152c:	e17ffd17 	ldw	r5,-12(fp)
 2011530:	01008074 	movhi	r4,513
 2011534:	210b5b04 	addi	r4,r4,11628
 2011538:	20114240 	call	2011424 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 201153c:	01c07fc4 	movi	r7,511
 2011540:	000d883a 	mov	r6,zero
 2011544:	e17ffe17 	ldw	r5,-8(fp)
 2011548:	01008074 	movhi	r4,513
 201154c:	210b5804 	addi	r4,r4,11616
 2011550:	20114240 	call	2011424 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 2011554:	01c07fc4 	movi	r7,511
 2011558:	01800044 	movi	r6,1
 201155c:	e17fff17 	ldw	r5,-4(fp)
 2011560:	01008074 	movhi	r4,513
 2011564:	210b5e04 	addi	r4,r4,11640
 2011568:	20114240 	call	2011424 <alt_open_fd>
}  
 201156c:	0001883a 	nop
 2011570:	e037883a 	mov	sp,fp
 2011574:	dfc00117 	ldw	ra,4(sp)
 2011578:	df000017 	ldw	fp,0(sp)
 201157c:	dec00204 	addi	sp,sp,8
 2011580:	f800283a 	ret

02011584 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2011584:	defffe04 	addi	sp,sp,-8
 2011588:	dfc00115 	stw	ra,4(sp)
 201158c:	df000015 	stw	fp,0(sp)
 2011590:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2011594:	d0a01a17 	ldw	r2,-32664(gp)
 2011598:	10000326 	beq	r2,zero,20115a8 <alt_get_errno+0x24>
 201159c:	d0a01a17 	ldw	r2,-32664(gp)
 20115a0:	103ee83a 	callr	r2
 20115a4:	00000106 	br	20115ac <alt_get_errno+0x28>
 20115a8:	d0a08d04 	addi	r2,gp,-32204
}
 20115ac:	e037883a 	mov	sp,fp
 20115b0:	dfc00117 	ldw	ra,4(sp)
 20115b4:	df000017 	ldw	fp,0(sp)
 20115b8:	dec00204 	addi	sp,sp,8
 20115bc:	f800283a 	ret

020115c0 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 20115c0:	defffb04 	addi	sp,sp,-20
 20115c4:	dfc00415 	stw	ra,16(sp)
 20115c8:	df000315 	stw	fp,12(sp)
 20115cc:	dc000215 	stw	r16,8(sp)
 20115d0:	df000304 	addi	fp,sp,12
 20115d4:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 20115d8:	e0bffe17 	ldw	r2,-8(fp)
 20115dc:	10800217 	ldw	r2,8(r2)
 20115e0:	10d00034 	orhi	r3,r2,16384
 20115e4:	e0bffe17 	ldw	r2,-8(fp)
 20115e8:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 20115ec:	e03ffd15 	stw	zero,-12(fp)
 20115f0:	00002306 	br	2011680 <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 20115f4:	04008074 	movhi	r16,513
 20115f8:	840b5804 	addi	r16,r16,11616
 20115fc:	e0bffd17 	ldw	r2,-12(fp)
 2011600:	01400304 	movi	r5,12
 2011604:	1009883a 	mov	r4,r2
 2011608:	2009bcc0 	call	2009bcc <__mulsi3>
 201160c:	8085883a 	add	r2,r16,r2
 2011610:	10c00017 	ldw	r3,0(r2)
 2011614:	e0bffe17 	ldw	r2,-8(fp)
 2011618:	10800017 	ldw	r2,0(r2)
 201161c:	1880151e 	bne	r3,r2,2011674 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 2011620:	04008074 	movhi	r16,513
 2011624:	840b5804 	addi	r16,r16,11616
 2011628:	e0bffd17 	ldw	r2,-12(fp)
 201162c:	01400304 	movi	r5,12
 2011630:	1009883a 	mov	r4,r2
 2011634:	2009bcc0 	call	2009bcc <__mulsi3>
 2011638:	8085883a 	add	r2,r16,r2
 201163c:	10800204 	addi	r2,r2,8
 2011640:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 2011644:	10000b0e 	bge	r2,zero,2011674 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 2011648:	01400304 	movi	r5,12
 201164c:	e13ffd17 	ldw	r4,-12(fp)
 2011650:	2009bcc0 	call	2009bcc <__mulsi3>
 2011654:	1007883a 	mov	r3,r2
 2011658:	00808074 	movhi	r2,513
 201165c:	108b5804 	addi	r2,r2,11616
 2011660:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 2011664:	e0bffe17 	ldw	r2,-8(fp)
 2011668:	18800226 	beq	r3,r2,2011674 <alt_file_locked+0xb4>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 201166c:	00bffcc4 	movi	r2,-13
 2011670:	00000806 	br	2011694 <alt_file_locked+0xd4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 2011674:	e0bffd17 	ldw	r2,-12(fp)
 2011678:	10800044 	addi	r2,r2,1
 201167c:	e0bffd15 	stw	r2,-12(fp)
 2011680:	d0a01917 	ldw	r2,-32668(gp)
 2011684:	1007883a 	mov	r3,r2
 2011688:	e0bffd17 	ldw	r2,-12(fp)
 201168c:	18bfd92e 	bgeu	r3,r2,20115f4 <__reset+0xfe0105f4>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 2011690:	0005883a 	mov	r2,zero
}
 2011694:	e6ffff04 	addi	sp,fp,-4
 2011698:	dfc00217 	ldw	ra,8(sp)
 201169c:	df000117 	ldw	fp,4(sp)
 20116a0:	dc000017 	ldw	r16,0(sp)
 20116a4:	dec00304 	addi	sp,sp,12
 20116a8:	f800283a 	ret

020116ac <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 20116ac:	defff604 	addi	sp,sp,-40
 20116b0:	dfc00915 	stw	ra,36(sp)
 20116b4:	df000815 	stw	fp,32(sp)
 20116b8:	df000804 	addi	fp,sp,32
 20116bc:	e13ffd15 	stw	r4,-12(fp)
 20116c0:	e17ffe15 	stw	r5,-8(fp)
 20116c4:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 20116c8:	00bfffc4 	movi	r2,-1
 20116cc:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 20116d0:	00bffb44 	movi	r2,-19
 20116d4:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 20116d8:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 20116dc:	d1601704 	addi	r5,gp,-32676
 20116e0:	e13ffd17 	ldw	r4,-12(fp)
 20116e4:	2011bcc0 	call	2011bcc <alt_find_dev>
 20116e8:	e0bff815 	stw	r2,-32(fp)
 20116ec:	e0bff817 	ldw	r2,-32(fp)
 20116f0:	1000051e 	bne	r2,zero,2011708 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 20116f4:	e13ffd17 	ldw	r4,-12(fp)
 20116f8:	2011c5c0 	call	2011c5c <alt_find_file>
 20116fc:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 2011700:	00800044 	movi	r2,1
 2011704:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 2011708:	e0bff817 	ldw	r2,-32(fp)
 201170c:	10002b26 	beq	r2,zero,20117bc <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
 2011710:	e13ff817 	ldw	r4,-32(fp)
 2011714:	2011d640 	call	2011d64 <alt_get_fd>
 2011718:	e0bff915 	stw	r2,-28(fp)
 201171c:	e0bff917 	ldw	r2,-28(fp)
 2011720:	1000030e 	bge	r2,zero,2011730 <open+0x84>
    {
      status = index;
 2011724:	e0bff917 	ldw	r2,-28(fp)
 2011728:	e0bffa15 	stw	r2,-24(fp)
 201172c:	00002506 	br	20117c4 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
 2011730:	01400304 	movi	r5,12
 2011734:	e13ff917 	ldw	r4,-28(fp)
 2011738:	2009bcc0 	call	2009bcc <__mulsi3>
 201173c:	1007883a 	mov	r3,r2
 2011740:	00808074 	movhi	r2,513
 2011744:	108b5804 	addi	r2,r2,11616
 2011748:	1885883a 	add	r2,r3,r2
 201174c:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 2011750:	e0fffe17 	ldw	r3,-8(fp)
 2011754:	00900034 	movhi	r2,16384
 2011758:	10bfffc4 	addi	r2,r2,-1
 201175c:	1886703a 	and	r3,r3,r2
 2011760:	e0bffc17 	ldw	r2,-16(fp)
 2011764:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 2011768:	e0bffb17 	ldw	r2,-20(fp)
 201176c:	1000051e 	bne	r2,zero,2011784 <open+0xd8>
 2011770:	e13ffc17 	ldw	r4,-16(fp)
 2011774:	20115c00 	call	20115c0 <alt_file_locked>
 2011778:	e0bffa15 	stw	r2,-24(fp)
 201177c:	e0bffa17 	ldw	r2,-24(fp)
 2011780:	10001016 	blt	r2,zero,20117c4 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 2011784:	e0bff817 	ldw	r2,-32(fp)
 2011788:	10800317 	ldw	r2,12(r2)
 201178c:	10000826 	beq	r2,zero,20117b0 <open+0x104>
 2011790:	e0bff817 	ldw	r2,-32(fp)
 2011794:	10800317 	ldw	r2,12(r2)
 2011798:	e1ffff17 	ldw	r7,-4(fp)
 201179c:	e1bffe17 	ldw	r6,-8(fp)
 20117a0:	e17ffd17 	ldw	r5,-12(fp)
 20117a4:	e13ffc17 	ldw	r4,-16(fp)
 20117a8:	103ee83a 	callr	r2
 20117ac:	00000106 	br	20117b4 <open+0x108>
 20117b0:	0005883a 	mov	r2,zero
 20117b4:	e0bffa15 	stw	r2,-24(fp)
 20117b8:	00000206 	br	20117c4 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
 20117bc:	00bffb44 	movi	r2,-19
 20117c0:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 20117c4:	e0bffa17 	ldw	r2,-24(fp)
 20117c8:	1000090e 	bge	r2,zero,20117f0 <open+0x144>
  {
    alt_release_fd (index);  
 20117cc:	e13ff917 	ldw	r4,-28(fp)
 20117d0:	200e5c00 	call	200e5c0 <alt_release_fd>
    ALT_ERRNO = -status;
 20117d4:	20115840 	call	2011584 <alt_get_errno>
 20117d8:	1007883a 	mov	r3,r2
 20117dc:	e0bffa17 	ldw	r2,-24(fp)
 20117e0:	0085c83a 	sub	r2,zero,r2
 20117e4:	18800015 	stw	r2,0(r3)
    return -1;
 20117e8:	00bfffc4 	movi	r2,-1
 20117ec:	00000106 	br	20117f4 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
 20117f0:	e0bff917 	ldw	r2,-28(fp)
}
 20117f4:	e037883a 	mov	sp,fp
 20117f8:	dfc00117 	ldw	ra,4(sp)
 20117fc:	df000017 	ldw	fp,0(sp)
 2011800:	dec00204 	addi	sp,sp,8
 2011804:	f800283a 	ret

02011808 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 2011808:	defffa04 	addi	sp,sp,-24
 201180c:	df000515 	stw	fp,20(sp)
 2011810:	df000504 	addi	fp,sp,20
 2011814:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2011818:	0005303a 	rdctl	r2,status
 201181c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2011820:	e0fffc17 	ldw	r3,-16(fp)
 2011824:	00bfff84 	movi	r2,-2
 2011828:	1884703a 	and	r2,r3,r2
 201182c:	1001703a 	wrctl	status,r2
  
  return context;
 2011830:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 2011834:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 2011838:	e0bfff17 	ldw	r2,-4(fp)
 201183c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 2011840:	e0bffd17 	ldw	r2,-12(fp)
 2011844:	10800017 	ldw	r2,0(r2)
 2011848:	e0fffd17 	ldw	r3,-12(fp)
 201184c:	18c00117 	ldw	r3,4(r3)
 2011850:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 2011854:	e0bffd17 	ldw	r2,-12(fp)
 2011858:	10800117 	ldw	r2,4(r2)
 201185c:	e0fffd17 	ldw	r3,-12(fp)
 2011860:	18c00017 	ldw	r3,0(r3)
 2011864:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 2011868:	e0bffd17 	ldw	r2,-12(fp)
 201186c:	e0fffd17 	ldw	r3,-12(fp)
 2011870:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 2011874:	e0bffd17 	ldw	r2,-12(fp)
 2011878:	e0fffd17 	ldw	r3,-12(fp)
 201187c:	10c00015 	stw	r3,0(r2)
 2011880:	e0bffb17 	ldw	r2,-20(fp)
 2011884:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2011888:	e0bffe17 	ldw	r2,-8(fp)
 201188c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 2011890:	0001883a 	nop
 2011894:	e037883a 	mov	sp,fp
 2011898:	df000017 	ldw	fp,0(sp)
 201189c:	dec00104 	addi	sp,sp,4
 20118a0:	f800283a 	ret

020118a4 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 20118a4:	defffb04 	addi	sp,sp,-20
 20118a8:	dfc00415 	stw	ra,16(sp)
 20118ac:	df000315 	stw	fp,12(sp)
 20118b0:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 20118b4:	d0a01f17 	ldw	r2,-32644(gp)
 20118b8:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 20118bc:	d0a09517 	ldw	r2,-32172(gp)
 20118c0:	10800044 	addi	r2,r2,1
 20118c4:	d0a09515 	stw	r2,-32172(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 20118c8:	00002e06 	br	2011984 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 20118cc:	e0bffd17 	ldw	r2,-12(fp)
 20118d0:	10800017 	ldw	r2,0(r2)
 20118d4:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 20118d8:	e0bffd17 	ldw	r2,-12(fp)
 20118dc:	10800403 	ldbu	r2,16(r2)
 20118e0:	10803fcc 	andi	r2,r2,255
 20118e4:	10000426 	beq	r2,zero,20118f8 <alt_tick+0x54>
 20118e8:	d0a09517 	ldw	r2,-32172(gp)
 20118ec:	1000021e 	bne	r2,zero,20118f8 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 20118f0:	e0bffd17 	ldw	r2,-12(fp)
 20118f4:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 20118f8:	e0bffd17 	ldw	r2,-12(fp)
 20118fc:	10800217 	ldw	r2,8(r2)
 2011900:	d0e09517 	ldw	r3,-32172(gp)
 2011904:	18801d36 	bltu	r3,r2,201197c <alt_tick+0xd8>
 2011908:	e0bffd17 	ldw	r2,-12(fp)
 201190c:	10800403 	ldbu	r2,16(r2)
 2011910:	10803fcc 	andi	r2,r2,255
 2011914:	1000191e 	bne	r2,zero,201197c <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 2011918:	e0bffd17 	ldw	r2,-12(fp)
 201191c:	10800317 	ldw	r2,12(r2)
 2011920:	e0fffd17 	ldw	r3,-12(fp)
 2011924:	18c00517 	ldw	r3,20(r3)
 2011928:	1809883a 	mov	r4,r3
 201192c:	103ee83a 	callr	r2
 2011930:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 2011934:	e0bfff17 	ldw	r2,-4(fp)
 2011938:	1000031e 	bne	r2,zero,2011948 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 201193c:	e13ffd17 	ldw	r4,-12(fp)
 2011940:	20118080 	call	2011808 <alt_alarm_stop>
 2011944:	00000d06 	br	201197c <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 2011948:	e0bffd17 	ldw	r2,-12(fp)
 201194c:	10c00217 	ldw	r3,8(r2)
 2011950:	e0bfff17 	ldw	r2,-4(fp)
 2011954:	1887883a 	add	r3,r3,r2
 2011958:	e0bffd17 	ldw	r2,-12(fp)
 201195c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 2011960:	e0bffd17 	ldw	r2,-12(fp)
 2011964:	10c00217 	ldw	r3,8(r2)
 2011968:	d0a09517 	ldw	r2,-32172(gp)
 201196c:	1880032e 	bgeu	r3,r2,201197c <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 2011970:	e0bffd17 	ldw	r2,-12(fp)
 2011974:	00c00044 	movi	r3,1
 2011978:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 201197c:	e0bffe17 	ldw	r2,-8(fp)
 2011980:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 2011984:	e0fffd17 	ldw	r3,-12(fp)
 2011988:	d0a01f04 	addi	r2,gp,-32644
 201198c:	18bfcf1e 	bne	r3,r2,20118cc <__reset+0xfe0108cc>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 2011990:	0001883a 	nop
}
 2011994:	0001883a 	nop
 2011998:	e037883a 	mov	sp,fp
 201199c:	dfc00117 	ldw	ra,4(sp)
 20119a0:	df000017 	ldw	fp,0(sp)
 20119a4:	dec00204 	addi	sp,sp,8
 20119a8:	f800283a 	ret

020119ac <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 20119ac:	deffff04 	addi	sp,sp,-4
 20119b0:	df000015 	stw	fp,0(sp)
 20119b4:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 20119b8:	000170fa 	wrctl	ienable,zero
}
 20119bc:	0001883a 	nop
 20119c0:	e037883a 	mov	sp,fp
 20119c4:	df000017 	ldw	fp,0(sp)
 20119c8:	dec00104 	addi	sp,sp,4
 20119cc:	f800283a 	ret

020119d0 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
 20119d0:	defff404 	addi	sp,sp,-48
 20119d4:	df000b15 	stw	fp,44(sp)
 20119d8:	df000b04 	addi	fp,sp,44
 20119dc:	e13ffc15 	stw	r4,-16(fp)
 20119e0:	e17ffd15 	stw	r5,-12(fp)
 20119e4:	e1bffe15 	stw	r6,-8(fp)
 20119e8:	e1ffff15 	stw	r7,-4(fp)
  const alt_u8 * write_end = write_data + write_length;
 20119ec:	e0ffff17 	ldw	r3,-4(fp)
 20119f0:	e0bffe17 	ldw	r2,-8(fp)
 20119f4:	1885883a 	add	r2,r3,r2
 20119f8:	e0bff815 	stw	r2,-32(fp)
  alt_u8 * read_end = read_data + read_length;
 20119fc:	e0c00217 	ldw	r3,8(fp)
 2011a00:	e0800117 	ldw	r2,4(fp)
 2011a04:	1885883a 	add	r2,r3,r2
 2011a08:	e0bff915 	stw	r2,-28(fp)

  alt_u32 write_zeros = read_length;
 2011a0c:	e0800117 	ldw	r2,4(fp)
 2011a10:	e0bff515 	stw	r2,-44(fp)
  alt_u32 read_ignore = write_length;
 2011a14:	e0bffe17 	ldw	r2,-8(fp)
 2011a18:	e0bff615 	stw	r2,-40(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
 2011a1c:	00800044 	movi	r2,1
 2011a20:	e0bff715 	stw	r2,-36(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 2011a24:	e0bffc17 	ldw	r2,-16(fp)
 2011a28:	10800504 	addi	r2,r2,20
 2011a2c:	1009883a 	mov	r4,r2
 2011a30:	00c00044 	movi	r3,1
 2011a34:	e0bffd17 	ldw	r2,-12(fp)
 2011a38:	1884983a 	sll	r2,r3,r2
 2011a3c:	20800035 	stwio	r2,0(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
 2011a40:	e0800317 	ldw	r2,12(fp)
 2011a44:	1080008c 	andi	r2,r2,2
 2011a48:	1000051e 	bne	r2,zero,2011a60 <alt_avalon_spi_command+0x90>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
 2011a4c:	e0bffc17 	ldw	r2,-16(fp)
 2011a50:	10800304 	addi	r2,r2,12
 2011a54:	1007883a 	mov	r3,r2
 2011a58:	00810004 	movi	r2,1024
 2011a5c:	18800035 	stwio	r2,0(r3)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
 2011a60:	e0bffc17 	ldw	r2,-16(fp)
 2011a64:	10800037 	ldwio	r2,0(r2)
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 2011a68:	e0bffc17 	ldw	r2,-16(fp)
 2011a6c:	10800204 	addi	r2,r2,8
 2011a70:	10800037 	ldwio	r2,0(r2)
 2011a74:	e0bffa15 	stw	r2,-24(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 2011a78:	e0bffa17 	ldw	r2,-24(fp)
 2011a7c:	1080100c 	andi	r2,r2,64
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 2011a80:	10000226 	beq	r2,zero,2011a8c <alt_avalon_spi_command+0xbc>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 2011a84:	e0bff717 	ldw	r2,-36(fp)
 2011a88:	1000031e 	bne	r2,zero,2011a98 <alt_avalon_spi_command+0xc8>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 2011a8c:	e0bffa17 	ldw	r2,-24(fp)
 2011a90:	1080200c 	andi	r2,r2,128
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 2011a94:	103ff426 	beq	r2,zero,2011a68 <__reset+0xfe010a68>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
 2011a98:	e0bffa17 	ldw	r2,-24(fp)
 2011a9c:	1080100c 	andi	r2,r2,64
 2011aa0:	10001e26 	beq	r2,zero,2011b1c <alt_avalon_spi_command+0x14c>
 2011aa4:	e0bff717 	ldw	r2,-36(fp)
 2011aa8:	00801c0e 	bge	zero,r2,2011b1c <alt_avalon_spi_command+0x14c>
    {
      credits--;
 2011aac:	e0bff717 	ldw	r2,-36(fp)
 2011ab0:	10bfffc4 	addi	r2,r2,-1
 2011ab4:	e0bff715 	stw	r2,-36(fp)

      if (write_data < write_end)
 2011ab8:	e0ffff17 	ldw	r3,-4(fp)
 2011abc:	e0bff817 	ldw	r2,-32(fp)
 2011ac0:	18800a2e 	bgeu	r3,r2,2011aec <alt_avalon_spi_command+0x11c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
 2011ac4:	e0bffc17 	ldw	r2,-16(fp)
 2011ac8:	10800104 	addi	r2,r2,4
 2011acc:	1009883a 	mov	r4,r2
 2011ad0:	e0bfff17 	ldw	r2,-4(fp)
 2011ad4:	10c00044 	addi	r3,r2,1
 2011ad8:	e0ffff15 	stw	r3,-4(fp)
 2011adc:	10800003 	ldbu	r2,0(r2)
 2011ae0:	10803fcc 	andi	r2,r2,255
 2011ae4:	20800035 	stwio	r2,0(r4)
 2011ae8:	00000c06 	br	2011b1c <alt_avalon_spi_command+0x14c>
      else if (write_zeros > 0)
 2011aec:	e0bff517 	ldw	r2,-44(fp)
 2011af0:	10000826 	beq	r2,zero,2011b14 <alt_avalon_spi_command+0x144>
      {
        write_zeros--;
 2011af4:	e0bff517 	ldw	r2,-44(fp)
 2011af8:	10bfffc4 	addi	r2,r2,-1
 2011afc:	e0bff515 	stw	r2,-44(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
 2011b00:	e0bffc17 	ldw	r2,-16(fp)
 2011b04:	10800104 	addi	r2,r2,4
 2011b08:	0007883a 	mov	r3,zero
 2011b0c:	10c00035 	stwio	r3,0(r2)
 2011b10:	00000206 	br	2011b1c <alt_avalon_spi_command+0x14c>
      }
      else
        credits = -1024;
 2011b14:	00bf0004 	movi	r2,-1024
 2011b18:	e0bff715 	stw	r2,-36(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
 2011b1c:	e0bffa17 	ldw	r2,-24(fp)
 2011b20:	1080200c 	andi	r2,r2,128
 2011b24:	103fd026 	beq	r2,zero,2011a68 <__reset+0xfe010a68>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
 2011b28:	e0bffc17 	ldw	r2,-16(fp)
 2011b2c:	10800037 	ldwio	r2,0(r2)
 2011b30:	e0bffb15 	stw	r2,-20(fp)

      if (read_ignore > 0)
 2011b34:	e0bff617 	ldw	r2,-40(fp)
 2011b38:	10000426 	beq	r2,zero,2011b4c <alt_avalon_spi_command+0x17c>
        read_ignore--;
 2011b3c:	e0bff617 	ldw	r2,-40(fp)
 2011b40:	10bfffc4 	addi	r2,r2,-1
 2011b44:	e0bff615 	stw	r2,-40(fp)
 2011b48:	00000506 	br	2011b60 <alt_avalon_spi_command+0x190>
      else
        *read_data++ = (alt_u8)rxdata;
 2011b4c:	e0800217 	ldw	r2,8(fp)
 2011b50:	10c00044 	addi	r3,r2,1
 2011b54:	e0c00215 	stw	r3,8(fp)
 2011b58:	e0fffb17 	ldw	r3,-20(fp)
 2011b5c:	10c00005 	stb	r3,0(r2)
      credits++;
 2011b60:	e0bff717 	ldw	r2,-36(fp)
 2011b64:	10800044 	addi	r2,r2,1
 2011b68:	e0bff715 	stw	r2,-36(fp)

      if (read_ignore == 0 && read_data == read_end)
 2011b6c:	e0bff617 	ldw	r2,-40(fp)
 2011b70:	103fbd1e 	bne	r2,zero,2011a68 <__reset+0xfe010a68>
 2011b74:	e0c00217 	ldw	r3,8(fp)
 2011b78:	e0bff917 	ldw	r2,-28(fp)
 2011b7c:	18bfba1e 	bne	r3,r2,2011a68 <__reset+0xfe010a68>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 2011b80:	e0bffc17 	ldw	r2,-16(fp)
 2011b84:	10800204 	addi	r2,r2,8
 2011b88:	10800037 	ldwio	r2,0(r2)
 2011b8c:	e0bffa15 	stw	r2,-24(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
 2011b90:	e0bffa17 	ldw	r2,-24(fp)
 2011b94:	1080080c 	andi	r2,r2,32
 2011b98:	103ff926 	beq	r2,zero,2011b80 <__reset+0xfe010b80>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
 2011b9c:	e0800317 	ldw	r2,12(fp)
 2011ba0:	1080004c 	andi	r2,r2,1
 2011ba4:	1000041e 	bne	r2,zero,2011bb8 <alt_avalon_spi_command+0x1e8>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
 2011ba8:	e0bffc17 	ldw	r2,-16(fp)
 2011bac:	10800304 	addi	r2,r2,12
 2011bb0:	0007883a 	mov	r3,zero
 2011bb4:	10c00035 	stwio	r3,0(r2)

  return read_length;
 2011bb8:	e0800117 	ldw	r2,4(fp)
}
 2011bbc:	e037883a 	mov	sp,fp
 2011bc0:	df000017 	ldw	fp,0(sp)
 2011bc4:	dec00104 	addi	sp,sp,4
 2011bc8:	f800283a 	ret

02011bcc <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 2011bcc:	defffa04 	addi	sp,sp,-24
 2011bd0:	dfc00515 	stw	ra,20(sp)
 2011bd4:	df000415 	stw	fp,16(sp)
 2011bd8:	df000404 	addi	fp,sp,16
 2011bdc:	e13ffe15 	stw	r4,-8(fp)
 2011be0:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 2011be4:	e0bfff17 	ldw	r2,-4(fp)
 2011be8:	10800017 	ldw	r2,0(r2)
 2011bec:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 2011bf0:	e13ffe17 	ldw	r4,-8(fp)
 2011bf4:	200b3900 	call	200b390 <strlen>
 2011bf8:	10800044 	addi	r2,r2,1
 2011bfc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 2011c00:	00000d06 	br	2011c38 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 2011c04:	e0bffc17 	ldw	r2,-16(fp)
 2011c08:	10800217 	ldw	r2,8(r2)
 2011c0c:	e0fffd17 	ldw	r3,-12(fp)
 2011c10:	180d883a 	mov	r6,r3
 2011c14:	e17ffe17 	ldw	r5,-8(fp)
 2011c18:	1009883a 	mov	r4,r2
 2011c1c:	2011e740 	call	2011e74 <memcmp>
 2011c20:	1000021e 	bne	r2,zero,2011c2c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 2011c24:	e0bffc17 	ldw	r2,-16(fp)
 2011c28:	00000706 	br	2011c48 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 2011c2c:	e0bffc17 	ldw	r2,-16(fp)
 2011c30:	10800017 	ldw	r2,0(r2)
 2011c34:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 2011c38:	e0fffc17 	ldw	r3,-16(fp)
 2011c3c:	e0bfff17 	ldw	r2,-4(fp)
 2011c40:	18bff01e 	bne	r3,r2,2011c04 <__reset+0xfe010c04>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 2011c44:	0005883a 	mov	r2,zero
}
 2011c48:	e037883a 	mov	sp,fp
 2011c4c:	dfc00117 	ldw	ra,4(sp)
 2011c50:	df000017 	ldw	fp,0(sp)
 2011c54:	dec00204 	addi	sp,sp,8
 2011c58:	f800283a 	ret

02011c5c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 2011c5c:	defffb04 	addi	sp,sp,-20
 2011c60:	dfc00415 	stw	ra,16(sp)
 2011c64:	df000315 	stw	fp,12(sp)
 2011c68:	df000304 	addi	fp,sp,12
 2011c6c:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 2011c70:	d0a01517 	ldw	r2,-32684(gp)
 2011c74:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 2011c78:	00003106 	br	2011d40 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 2011c7c:	e0bffd17 	ldw	r2,-12(fp)
 2011c80:	10800217 	ldw	r2,8(r2)
 2011c84:	1009883a 	mov	r4,r2
 2011c88:	200b3900 	call	200b390 <strlen>
 2011c8c:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 2011c90:	e0bffd17 	ldw	r2,-12(fp)
 2011c94:	10c00217 	ldw	r3,8(r2)
 2011c98:	e0bffe17 	ldw	r2,-8(fp)
 2011c9c:	10bfffc4 	addi	r2,r2,-1
 2011ca0:	1885883a 	add	r2,r3,r2
 2011ca4:	10800003 	ldbu	r2,0(r2)
 2011ca8:	10803fcc 	andi	r2,r2,255
 2011cac:	1080201c 	xori	r2,r2,128
 2011cb0:	10bfe004 	addi	r2,r2,-128
 2011cb4:	10800bd8 	cmpnei	r2,r2,47
 2011cb8:	1000031e 	bne	r2,zero,2011cc8 <alt_find_file+0x6c>
    {
      len -= 1;
 2011cbc:	e0bffe17 	ldw	r2,-8(fp)
 2011cc0:	10bfffc4 	addi	r2,r2,-1
 2011cc4:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 2011cc8:	e0bffe17 	ldw	r2,-8(fp)
 2011ccc:	e0ffff17 	ldw	r3,-4(fp)
 2011cd0:	1885883a 	add	r2,r3,r2
 2011cd4:	10800003 	ldbu	r2,0(r2)
 2011cd8:	10803fcc 	andi	r2,r2,255
 2011cdc:	1080201c 	xori	r2,r2,128
 2011ce0:	10bfe004 	addi	r2,r2,-128
 2011ce4:	10800be0 	cmpeqi	r2,r2,47
 2011ce8:	1000081e 	bne	r2,zero,2011d0c <alt_find_file+0xb0>
 2011cec:	e0bffe17 	ldw	r2,-8(fp)
 2011cf0:	e0ffff17 	ldw	r3,-4(fp)
 2011cf4:	1885883a 	add	r2,r3,r2
 2011cf8:	10800003 	ldbu	r2,0(r2)
 2011cfc:	10803fcc 	andi	r2,r2,255
 2011d00:	1080201c 	xori	r2,r2,128
 2011d04:	10bfe004 	addi	r2,r2,-128
 2011d08:	10000a1e 	bne	r2,zero,2011d34 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 2011d0c:	e0bffd17 	ldw	r2,-12(fp)
 2011d10:	10800217 	ldw	r2,8(r2)
 2011d14:	e0fffe17 	ldw	r3,-8(fp)
 2011d18:	180d883a 	mov	r6,r3
 2011d1c:	e17fff17 	ldw	r5,-4(fp)
 2011d20:	1009883a 	mov	r4,r2
 2011d24:	2011e740 	call	2011e74 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 2011d28:	1000021e 	bne	r2,zero,2011d34 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 2011d2c:	e0bffd17 	ldw	r2,-12(fp)
 2011d30:	00000706 	br	2011d50 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 2011d34:	e0bffd17 	ldw	r2,-12(fp)
 2011d38:	10800017 	ldw	r2,0(r2)
 2011d3c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 2011d40:	e0fffd17 	ldw	r3,-12(fp)
 2011d44:	d0a01504 	addi	r2,gp,-32684
 2011d48:	18bfcc1e 	bne	r3,r2,2011c7c <__reset+0xfe010c7c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 2011d4c:	0005883a 	mov	r2,zero
}
 2011d50:	e037883a 	mov	sp,fp
 2011d54:	dfc00117 	ldw	ra,4(sp)
 2011d58:	df000017 	ldw	fp,0(sp)
 2011d5c:	dec00204 	addi	sp,sp,8
 2011d60:	f800283a 	ret

02011d64 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 2011d64:	defffa04 	addi	sp,sp,-24
 2011d68:	dfc00515 	stw	ra,20(sp)
 2011d6c:	df000415 	stw	fp,16(sp)
 2011d70:	dc000315 	stw	r16,12(sp)
 2011d74:	df000404 	addi	fp,sp,16
 2011d78:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
 2011d7c:	00bffa04 	movi	r2,-24
 2011d80:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 2011d84:	e03ffc15 	stw	zero,-16(fp)
 2011d88:	00001d06 	br	2011e00 <alt_get_fd+0x9c>
  {
    if (!alt_fd_list[i].dev)
 2011d8c:	04008074 	movhi	r16,513
 2011d90:	840b5804 	addi	r16,r16,11616
 2011d94:	e0bffc17 	ldw	r2,-16(fp)
 2011d98:	01400304 	movi	r5,12
 2011d9c:	1009883a 	mov	r4,r2
 2011da0:	2009bcc0 	call	2009bcc <__mulsi3>
 2011da4:	8085883a 	add	r2,r16,r2
 2011da8:	10800017 	ldw	r2,0(r2)
 2011dac:	1000111e 	bne	r2,zero,2011df4 <alt_get_fd+0x90>
    {
      alt_fd_list[i].dev = dev;
 2011db0:	04008074 	movhi	r16,513
 2011db4:	840b5804 	addi	r16,r16,11616
 2011db8:	e0bffc17 	ldw	r2,-16(fp)
 2011dbc:	01400304 	movi	r5,12
 2011dc0:	1009883a 	mov	r4,r2
 2011dc4:	2009bcc0 	call	2009bcc <__mulsi3>
 2011dc8:	8085883a 	add	r2,r16,r2
 2011dcc:	e0fffe17 	ldw	r3,-8(fp)
 2011dd0:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 2011dd4:	d0e01917 	ldw	r3,-32668(gp)
 2011dd8:	e0bffc17 	ldw	r2,-16(fp)
 2011ddc:	1880020e 	bge	r3,r2,2011de8 <alt_get_fd+0x84>
      {
        alt_max_fd = i;
 2011de0:	e0bffc17 	ldw	r2,-16(fp)
 2011de4:	d0a01915 	stw	r2,-32668(gp)
      }
      rc = i;
 2011de8:	e0bffc17 	ldw	r2,-16(fp)
 2011dec:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
 2011df0:	00000606 	br	2011e0c <alt_get_fd+0xa8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 2011df4:	e0bffc17 	ldw	r2,-16(fp)
 2011df8:	10800044 	addi	r2,r2,1
 2011dfc:	e0bffc15 	stw	r2,-16(fp)
 2011e00:	e0bffc17 	ldw	r2,-16(fp)
 2011e04:	10800810 	cmplti	r2,r2,32
 2011e08:	103fe01e 	bne	r2,zero,2011d8c <__reset+0xfe010d8c>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 2011e0c:	e0bffd17 	ldw	r2,-12(fp)
}
 2011e10:	e6ffff04 	addi	sp,fp,-4
 2011e14:	dfc00217 	ldw	ra,8(sp)
 2011e18:	df000117 	ldw	fp,4(sp)
 2011e1c:	dc000017 	ldw	r16,0(sp)
 2011e20:	dec00304 	addi	sp,sp,12
 2011e24:	f800283a 	ret

02011e28 <atexit>:
 2011e28:	200b883a 	mov	r5,r4
 2011e2c:	000f883a 	mov	r7,zero
 2011e30:	000d883a 	mov	r6,zero
 2011e34:	0009883a 	mov	r4,zero
 2011e38:	2011ef01 	jmpi	2011ef0 <__register_exitproc>

02011e3c <exit>:
 2011e3c:	defffe04 	addi	sp,sp,-8
 2011e40:	000b883a 	mov	r5,zero
 2011e44:	dc000015 	stw	r16,0(sp)
 2011e48:	dfc00115 	stw	ra,4(sp)
 2011e4c:	2021883a 	mov	r16,r4
 2011e50:	20120080 	call	2012008 <__call_exitprocs>
 2011e54:	00808074 	movhi	r2,513
 2011e58:	1090b804 	addi	r2,r2,17120
 2011e5c:	11000017 	ldw	r4,0(r2)
 2011e60:	20800f17 	ldw	r2,60(r4)
 2011e64:	10000126 	beq	r2,zero,2011e6c <exit+0x30>
 2011e68:	103ee83a 	callr	r2
 2011e6c:	8009883a 	mov	r4,r16
 2011e70:	20121880 	call	2012188 <_exit>

02011e74 <memcmp>:
 2011e74:	01c000c4 	movi	r7,3
 2011e78:	3980192e 	bgeu	r7,r6,2011ee0 <memcmp+0x6c>
 2011e7c:	2144b03a 	or	r2,r4,r5
 2011e80:	11c4703a 	and	r2,r2,r7
 2011e84:	10000f26 	beq	r2,zero,2011ec4 <memcmp+0x50>
 2011e88:	20800003 	ldbu	r2,0(r4)
 2011e8c:	28c00003 	ldbu	r3,0(r5)
 2011e90:	10c0151e 	bne	r2,r3,2011ee8 <memcmp+0x74>
 2011e94:	31bfff84 	addi	r6,r6,-2
 2011e98:	01ffffc4 	movi	r7,-1
 2011e9c:	00000406 	br	2011eb0 <memcmp+0x3c>
 2011ea0:	20800003 	ldbu	r2,0(r4)
 2011ea4:	28c00003 	ldbu	r3,0(r5)
 2011ea8:	31bfffc4 	addi	r6,r6,-1
 2011eac:	10c00e1e 	bne	r2,r3,2011ee8 <memcmp+0x74>
 2011eb0:	21000044 	addi	r4,r4,1
 2011eb4:	29400044 	addi	r5,r5,1
 2011eb8:	31fff91e 	bne	r6,r7,2011ea0 <__reset+0xfe010ea0>
 2011ebc:	0005883a 	mov	r2,zero
 2011ec0:	f800283a 	ret
 2011ec4:	20c00017 	ldw	r3,0(r4)
 2011ec8:	28800017 	ldw	r2,0(r5)
 2011ecc:	18bfee1e 	bne	r3,r2,2011e88 <__reset+0xfe010e88>
 2011ed0:	31bfff04 	addi	r6,r6,-4
 2011ed4:	21000104 	addi	r4,r4,4
 2011ed8:	29400104 	addi	r5,r5,4
 2011edc:	39bff936 	bltu	r7,r6,2011ec4 <__reset+0xfe010ec4>
 2011ee0:	303fe91e 	bne	r6,zero,2011e88 <__reset+0xfe010e88>
 2011ee4:	003ff506 	br	2011ebc <__reset+0xfe010ebc>
 2011ee8:	10c5c83a 	sub	r2,r2,r3
 2011eec:	f800283a 	ret

02011ef0 <__register_exitproc>:
 2011ef0:	defffa04 	addi	sp,sp,-24
 2011ef4:	dc000315 	stw	r16,12(sp)
 2011ef8:	04008074 	movhi	r16,513
 2011efc:	8410b804 	addi	r16,r16,17120
 2011f00:	80c00017 	ldw	r3,0(r16)
 2011f04:	dc400415 	stw	r17,16(sp)
 2011f08:	dfc00515 	stw	ra,20(sp)
 2011f0c:	18805217 	ldw	r2,328(r3)
 2011f10:	2023883a 	mov	r17,r4
 2011f14:	10003726 	beq	r2,zero,2011ff4 <__register_exitproc+0x104>
 2011f18:	10c00117 	ldw	r3,4(r2)
 2011f1c:	010007c4 	movi	r4,31
 2011f20:	20c00e16 	blt	r4,r3,2011f5c <__register_exitproc+0x6c>
 2011f24:	1a000044 	addi	r8,r3,1
 2011f28:	8800221e 	bne	r17,zero,2011fb4 <__register_exitproc+0xc4>
 2011f2c:	18c00084 	addi	r3,r3,2
 2011f30:	18c7883a 	add	r3,r3,r3
 2011f34:	18c7883a 	add	r3,r3,r3
 2011f38:	12000115 	stw	r8,4(r2)
 2011f3c:	10c7883a 	add	r3,r2,r3
 2011f40:	19400015 	stw	r5,0(r3)
 2011f44:	0005883a 	mov	r2,zero
 2011f48:	dfc00517 	ldw	ra,20(sp)
 2011f4c:	dc400417 	ldw	r17,16(sp)
 2011f50:	dc000317 	ldw	r16,12(sp)
 2011f54:	dec00604 	addi	sp,sp,24
 2011f58:	f800283a 	ret
 2011f5c:	00800034 	movhi	r2,0
 2011f60:	10800004 	addi	r2,r2,0
 2011f64:	10002626 	beq	r2,zero,2012000 <__register_exitproc+0x110>
 2011f68:	01006404 	movi	r4,400
 2011f6c:	d9400015 	stw	r5,0(sp)
 2011f70:	d9800115 	stw	r6,4(sp)
 2011f74:	d9c00215 	stw	r7,8(sp)
 2011f78:	00000000 	call	0 <__alt_mem_sdram-0x2000000>
 2011f7c:	d9400017 	ldw	r5,0(sp)
 2011f80:	d9800117 	ldw	r6,4(sp)
 2011f84:	d9c00217 	ldw	r7,8(sp)
 2011f88:	10001d26 	beq	r2,zero,2012000 <__register_exitproc+0x110>
 2011f8c:	81000017 	ldw	r4,0(r16)
 2011f90:	10000115 	stw	zero,4(r2)
 2011f94:	02000044 	movi	r8,1
 2011f98:	22405217 	ldw	r9,328(r4)
 2011f9c:	0007883a 	mov	r3,zero
 2011fa0:	12400015 	stw	r9,0(r2)
 2011fa4:	20805215 	stw	r2,328(r4)
 2011fa8:	10006215 	stw	zero,392(r2)
 2011fac:	10006315 	stw	zero,396(r2)
 2011fb0:	883fde26 	beq	r17,zero,2011f2c <__reset+0xfe010f2c>
 2011fb4:	18c9883a 	add	r4,r3,r3
 2011fb8:	2109883a 	add	r4,r4,r4
 2011fbc:	1109883a 	add	r4,r2,r4
 2011fc0:	21802215 	stw	r6,136(r4)
 2011fc4:	01800044 	movi	r6,1
 2011fc8:	12406217 	ldw	r9,392(r2)
 2011fcc:	30cc983a 	sll	r6,r6,r3
 2011fd0:	4992b03a 	or	r9,r9,r6
 2011fd4:	12406215 	stw	r9,392(r2)
 2011fd8:	21c04215 	stw	r7,264(r4)
 2011fdc:	01000084 	movi	r4,2
 2011fe0:	893fd21e 	bne	r17,r4,2011f2c <__reset+0xfe010f2c>
 2011fe4:	11006317 	ldw	r4,396(r2)
 2011fe8:	218cb03a 	or	r6,r4,r6
 2011fec:	11806315 	stw	r6,396(r2)
 2011ff0:	003fce06 	br	2011f2c <__reset+0xfe010f2c>
 2011ff4:	18805304 	addi	r2,r3,332
 2011ff8:	18805215 	stw	r2,328(r3)
 2011ffc:	003fc606 	br	2011f18 <__reset+0xfe010f18>
 2012000:	00bfffc4 	movi	r2,-1
 2012004:	003fd006 	br	2011f48 <__reset+0xfe010f48>

02012008 <__call_exitprocs>:
 2012008:	defff504 	addi	sp,sp,-44
 201200c:	df000915 	stw	fp,36(sp)
 2012010:	dd400615 	stw	r21,24(sp)
 2012014:	dc800315 	stw	r18,12(sp)
 2012018:	dfc00a15 	stw	ra,40(sp)
 201201c:	ddc00815 	stw	r23,32(sp)
 2012020:	dd800715 	stw	r22,28(sp)
 2012024:	dd000515 	stw	r20,20(sp)
 2012028:	dcc00415 	stw	r19,16(sp)
 201202c:	dc400215 	stw	r17,8(sp)
 2012030:	dc000115 	stw	r16,4(sp)
 2012034:	d9000015 	stw	r4,0(sp)
 2012038:	2839883a 	mov	fp,r5
 201203c:	04800044 	movi	r18,1
 2012040:	057fffc4 	movi	r21,-1
 2012044:	00808074 	movhi	r2,513
 2012048:	1090b804 	addi	r2,r2,17120
 201204c:	12000017 	ldw	r8,0(r2)
 2012050:	45005217 	ldw	r20,328(r8)
 2012054:	44c05204 	addi	r19,r8,328
 2012058:	a0001c26 	beq	r20,zero,20120cc <__call_exitprocs+0xc4>
 201205c:	a0800117 	ldw	r2,4(r20)
 2012060:	15ffffc4 	addi	r23,r2,-1
 2012064:	b8000d16 	blt	r23,zero,201209c <__call_exitprocs+0x94>
 2012068:	14000044 	addi	r16,r2,1
 201206c:	8421883a 	add	r16,r16,r16
 2012070:	8421883a 	add	r16,r16,r16
 2012074:	84402004 	addi	r17,r16,128
 2012078:	a463883a 	add	r17,r20,r17
 201207c:	a421883a 	add	r16,r20,r16
 2012080:	e0001e26 	beq	fp,zero,20120fc <__call_exitprocs+0xf4>
 2012084:	80804017 	ldw	r2,256(r16)
 2012088:	e0801c26 	beq	fp,r2,20120fc <__call_exitprocs+0xf4>
 201208c:	bdffffc4 	addi	r23,r23,-1
 2012090:	843fff04 	addi	r16,r16,-4
 2012094:	8c7fff04 	addi	r17,r17,-4
 2012098:	bd7ff91e 	bne	r23,r21,2012080 <__reset+0xfe011080>
 201209c:	00800034 	movhi	r2,0
 20120a0:	10800004 	addi	r2,r2,0
 20120a4:	10000926 	beq	r2,zero,20120cc <__call_exitprocs+0xc4>
 20120a8:	a0800117 	ldw	r2,4(r20)
 20120ac:	1000301e 	bne	r2,zero,2012170 <__call_exitprocs+0x168>
 20120b0:	a0800017 	ldw	r2,0(r20)
 20120b4:	10003226 	beq	r2,zero,2012180 <__call_exitprocs+0x178>
 20120b8:	a009883a 	mov	r4,r20
 20120bc:	98800015 	stw	r2,0(r19)
 20120c0:	00000000 	call	0 <__alt_mem_sdram-0x2000000>
 20120c4:	9d000017 	ldw	r20,0(r19)
 20120c8:	a03fe41e 	bne	r20,zero,201205c <__reset+0xfe01105c>
 20120cc:	dfc00a17 	ldw	ra,40(sp)
 20120d0:	df000917 	ldw	fp,36(sp)
 20120d4:	ddc00817 	ldw	r23,32(sp)
 20120d8:	dd800717 	ldw	r22,28(sp)
 20120dc:	dd400617 	ldw	r21,24(sp)
 20120e0:	dd000517 	ldw	r20,20(sp)
 20120e4:	dcc00417 	ldw	r19,16(sp)
 20120e8:	dc800317 	ldw	r18,12(sp)
 20120ec:	dc400217 	ldw	r17,8(sp)
 20120f0:	dc000117 	ldw	r16,4(sp)
 20120f4:	dec00b04 	addi	sp,sp,44
 20120f8:	f800283a 	ret
 20120fc:	a0800117 	ldw	r2,4(r20)
 2012100:	80c00017 	ldw	r3,0(r16)
 2012104:	10bfffc4 	addi	r2,r2,-1
 2012108:	15c01426 	beq	r2,r23,201215c <__call_exitprocs+0x154>
 201210c:	80000015 	stw	zero,0(r16)
 2012110:	183fde26 	beq	r3,zero,201208c <__reset+0xfe01108c>
 2012114:	95c8983a 	sll	r4,r18,r23
 2012118:	a0806217 	ldw	r2,392(r20)
 201211c:	a5800117 	ldw	r22,4(r20)
 2012120:	2084703a 	and	r2,r4,r2
 2012124:	10000b26 	beq	r2,zero,2012154 <__call_exitprocs+0x14c>
 2012128:	a0806317 	ldw	r2,396(r20)
 201212c:	2088703a 	and	r4,r4,r2
 2012130:	20000c1e 	bne	r4,zero,2012164 <__call_exitprocs+0x15c>
 2012134:	89400017 	ldw	r5,0(r17)
 2012138:	d9000017 	ldw	r4,0(sp)
 201213c:	183ee83a 	callr	r3
 2012140:	a0800117 	ldw	r2,4(r20)
 2012144:	15bfbf1e 	bne	r2,r22,2012044 <__reset+0xfe011044>
 2012148:	98800017 	ldw	r2,0(r19)
 201214c:	153fcf26 	beq	r2,r20,201208c <__reset+0xfe01108c>
 2012150:	003fbc06 	br	2012044 <__reset+0xfe011044>
 2012154:	183ee83a 	callr	r3
 2012158:	003ff906 	br	2012140 <__reset+0xfe011140>
 201215c:	a5c00115 	stw	r23,4(r20)
 2012160:	003feb06 	br	2012110 <__reset+0xfe011110>
 2012164:	89000017 	ldw	r4,0(r17)
 2012168:	183ee83a 	callr	r3
 201216c:	003ff406 	br	2012140 <__reset+0xfe011140>
 2012170:	a0800017 	ldw	r2,0(r20)
 2012174:	a027883a 	mov	r19,r20
 2012178:	1029883a 	mov	r20,r2
 201217c:	003fb606 	br	2012058 <__reset+0xfe011058>
 2012180:	0005883a 	mov	r2,zero
 2012184:	003ffb06 	br	2012174 <__reset+0xfe011174>

02012188 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 2012188:	defffd04 	addi	sp,sp,-12
 201218c:	df000215 	stw	fp,8(sp)
 2012190:	df000204 	addi	fp,sp,8
 2012194:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 2012198:	0001883a 	nop
 201219c:	e0bfff17 	ldw	r2,-4(fp)
 20121a0:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 20121a4:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 20121a8:	10000226 	beq	r2,zero,20121b4 <_exit+0x2c>
    ALT_SIM_FAIL();
 20121ac:	002af070 	cmpltui	zero,zero,43969
 20121b0:	00000106 	br	20121b8 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 20121b4:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 20121b8:	003fff06 	br	20121b8 <__reset+0xfe0111b8>
